(set-option :print-success false)
(set-info :smt-lib-version 2.0)
(set-option :AUTO_CONFIG false)
(set-option :pp.bv_literals false)
(set-option :MODEL.V2 true)
(set-option :smt.PHASE_SELECTION 0)
(set-option :smt.RESTART_STRATEGY 0)
(set-option :smt.RESTART_FACTOR |1.5|)
(set-option :smt.ARITH.RANDOM_INITIAL_VALUE true)
(set-option :smt.CASE_SPLIT 3)
(set-option :smt.DELAY_UNITS true)
(set-option :NNF.SK_HACK true)
(set-option :smt.MBQI false)
(set-option :smt.QI.EAGER_THRESHOLD 100)
(set-option :TYPE_CHECK true)
(set-option :smt.BV.REFLECT true)
(set-option :TIMEOUT 0)
(set-info :category "industrial")
(declare-sort |T@U| 0)
(declare-sort |T@T| 0)
(declare-fun real_pow (Real Real) Real)
(declare-fun UOrdering2 (|T@U| |T@U|) Bool)
(declare-fun UOrdering3 (|T@T| |T@U| |T@U|) Bool)
(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-fun Ctor (T@T) Int)
(declare-fun intType () T@T)
(declare-fun realType () T@T)
(declare-fun boolType () T@T)
(declare-fun int_2_U (Int) T@U)
(declare-fun U_2_int (T@U) Int)
(declare-fun type (T@U) T@T)
(declare-fun real_2_U (Real) T@U)
(declare-fun U_2_real (T@U) Real)
(declare-fun bool_2_U (Bool) T@U)
(declare-fun U_2_bool (T@U) Bool)
(declare-fun TyType () T@T)
(declare-fun TBool () T@U)
(declare-fun TChar () T@U)
(declare-fun TInt () T@U)
(declare-fun TNat () T@U)
(declare-fun TReal () T@U)
(declare-fun TyTagType () T@T)
(declare-fun TagBool () T@U)
(declare-fun TagChar () T@U)
(declare-fun TagInt () T@U)
(declare-fun TagNat () T@U)
(declare-fun TagReal () T@U)
(declare-fun TagSet () T@U)
(declare-fun TagISet () T@U)
(declare-fun TagMultiSet () T@U)
(declare-fun TagSeq () T@U)
(declare-fun TagMap () T@U)
(declare-fun TagIMap () T@U)
(declare-fun TagClass () T@U)
(declare-fun ClassNameType () T@T)
(declare-fun NoTraitAtAll () T@U)
(declare-fun class._System.int () T@U)
(declare-fun class._System.bool () T@U)
(declare-fun class._System.set () T@U)
(declare-fun class._System.seq () T@U)
(declare-fun class._System.multiset () T@U)
(declare-fun FieldType (T@T) T@T)
(declare-fun FieldTypeInv0 (T@T) T@T)
(declare-fun alloc () T@U)
(declare-fun class._System.object () T@U)
(declare-fun Tagclass._System.object () T@U)
(declare-fun class._System.array () T@U)
(declare-fun Tagclass._System.array () T@U)
(declare-fun Tagclass._System.___hFunc0 () T@U)
(declare-fun Tagclass._System.___hFunc1 () T@U)
(declare-fun class._module.__default () T@U)
(declare-fun Tagclass._module.__default () T@U)
(declare-fun $$Language$Dafny () Bool)
(declare-fun TSet (T@U) T@U)
(declare-fun Inv0_TSet (T@U) T@U)
(declare-fun TISet (T@U) T@U)
(declare-fun Inv0_TISet (T@U) T@U)
(declare-fun TSeq (T@U) T@U)
(declare-fun Inv0_TSeq (T@U) T@U)
(declare-fun TMultiSet (T@U) T@U)
(declare-fun Inv0_TMultiSet (T@U) T@U)
(declare-fun TMap (T@U T@U) T@U)
(declare-fun Inv0_TMap (T@U) T@U)
(declare-fun Inv1_TMap (T@U) T@U)
(declare-fun TIMap (T@U T@U) T@U)
(declare-fun Inv0_TIMap (T@U) T@U)
(declare-fun Inv1_TIMap (T@U) T@U)
(declare-fun Tag (T@U) T@U)
(declare-fun LitInt (Int) Int)
(declare-fun BoxType () T@T)
(declare-fun $Box (T@U) T@U)
(declare-fun Lit (T@U) T@U)
(declare-fun LitReal (Real) Real)
(declare-fun charType () T@T)
(declare-fun |char#FromInt| (Int) T@U)
(declare-fun |char#ToInt| (T@U) Int)
(declare-fun $Unbox (T@T T@U) T@U)
(declare-fun $IsBox (T@U T@U) Bool)
(declare-fun $Is (T@U T@U) Bool)
(declare-fun MapType0Type (T@T T@T) T@T)
(declare-fun MapType0TypeInv0 (T@T) T@T)
(declare-fun MapType0TypeInv1 (T@T) T@T)
(declare-fun MapType0Select (T@U T@U) T@U)
(declare-fun MapType0Store (T@U T@U T@U) T@U)
(declare-fun SeqType (T@T) T@T)
(declare-fun SeqTypeInv0 (T@T) T@T)
(declare-fun MapType (T@T T@T) T@T)
(declare-fun MapTypeInv0 (T@T) T@T)
(declare-fun MapTypeInv1 (T@T) T@T)
(declare-fun IMapType (T@T T@T) T@T)
(declare-fun IMapTypeInv0 (T@T) T@T)
(declare-fun IMapTypeInv1 (T@T) T@T)
(declare-fun MapType1Type (T@T) T@T)
(declare-fun MapType1TypeInv0 (T@T) T@T)
(declare-fun MapType1Select (T@U T@U T@U) T@U)
(declare-fun MapType1Store (T@U T@U T@U T@U) T@U)
(declare-fun refType () T@T)
(declare-fun $IsAllocBox (T@U T@U T@U) Bool)
(declare-fun $IsAlloc (T@U T@U T@U) Bool)
(declare-fun $IsGoodMultiSet (T@U) Bool)
(declare-fun |Seq#Index| (T@U Int) T@U)
(declare-fun |Seq#Length| (T@U) Int)
(declare-fun |Map#Elements| (T@U) T@U)
(declare-fun |Map#Domain| (T@U) T@U)
(declare-fun |IMap#Elements| (T@U) T@U)
(declare-fun |IMap#Domain| (T@U) T@U)
(declare-fun TypeTuple (T@U T@U) T@U)
(declare-fun TypeTupleCar (T@U) T@U)
(declare-fun TypeTupleCdr (T@U) T@U)
(declare-fun SetRef_to_SetBox (T@U) T@U)
(declare-fun Tclass._System.object () T@U)
(declare-fun DatatypeTypeType () T@T)
(declare-fun BoxRank (T@U) Int)
(declare-fun DtRank (T@U) Int)
(declare-fun LayerTypeType () T@T)
(declare-fun AtLayer (T@U T@U) T@U)
(declare-fun $LS (T@U) T@U)
(declare-fun IndexField (Int) T@U)
(declare-fun FDim (T@U) Int)
(declare-fun IndexField_Inverse (T@U) Int)
(declare-fun MultiIndexField (T@U Int) T@U)
(declare-fun MultiIndexField_Inverse0 (T@U) T@U)
(declare-fun MultiIndexField_Inverse1 (T@U) Int)
(declare-fun NameFamilyType () T@T)
(declare-fun FieldOfDecl (T@T T@U T@U) T@U)
(declare-fun DeclType (T@U) T@U)
(declare-fun DeclName (T@U) T@U)
(declare-fun $HeapSucc (T@U T@U) Bool)
(declare-fun $IsGhostField (T@U) Bool)
(declare-fun _System.array.Length (T@U) Int)
(declare-fun q@Int (Real) Int)
(declare-fun q@Real (Int) Real)
(declare-fun $IsGoodHeap (T@U) Bool)
(declare-fun $HeapSuccGhost (T@U T@U) Bool)
(declare-fun |Set#Card| (T@U) Int)
(declare-fun |Set#Empty| (T@T) T@U)
(declare-fun |Set#Singleton| (T@U) T@U)
(declare-fun |Set#UnionOne| (T@U T@U) T@U)
(declare-fun |Set#Union| (T@U T@U) T@U)
(declare-fun |Set#Difference| (T@U T@U) T@U)
(declare-fun |Set#Disjoint| (T@U T@U) Bool)
(declare-fun |Set#Intersection| (T@U T@U) T@U)
(declare-fun |Set#Subset| (T@U T@U) Bool)
(declare-fun |Set#Equal| (T@U T@U) Bool)
(declare-fun |ISet#Empty| (T@T) T@U)
(declare-fun |ISet#UnionOne| (T@U T@U) T@U)
(declare-fun |ISet#Union| (T@U T@U) T@U)
(declare-fun |ISet#Difference| (T@U T@U) T@U)
(declare-fun |ISet#Disjoint| (T@U T@U) Bool)
(declare-fun |ISet#Intersection| (T@U T@U) T@U)
(declare-fun |ISet#Subset| (T@U T@U) Bool)
(declare-fun |ISet#Equal| (T@U T@U) Bool)
(declare-fun |Math#min| (Int Int) Int)
(declare-fun |Math#clip| (Int) Int)
(declare-fun |MultiSet#Card| (T@U) Int)
(declare-fun |MultiSet#Empty| (T@T) T@U)
(declare-fun |MultiSet#Singleton| (T@U) T@U)
(declare-fun |MultiSet#UnionOne| (T@U T@U) T@U)
(declare-fun |MultiSet#Union| (T@U T@U) T@U)
(declare-fun |MultiSet#Intersection| (T@U T@U) T@U)
(declare-fun |MultiSet#Difference| (T@U T@U) T@U)
(declare-fun |MultiSet#Subset| (T@U T@U) Bool)
(declare-fun |MultiSet#Equal| (T@U T@U) Bool)
(declare-fun |MultiSet#Disjoint| (T@U T@U) Bool)
(declare-fun |MultiSet#FromSet| (T@U) T@U)
(declare-fun |MultiSet#FromSeq| (T@U) T@U)
(declare-fun |Seq#Build| (T@U T@U) T@U)
(declare-fun |Seq#Empty| (T@T) T@U)
(declare-fun |Seq#Append| (T@U T@U) T@U)
(declare-fun |Seq#Update| (T@U Int T@U) T@U)
(declare-fun |Seq#Singleton| (T@U) T@U)
(declare-fun |Seq#Contains| (T@U T@U) Bool)
(declare-fun |Seq#Take| (T@U Int) T@U)
(declare-fun |Seq#Drop| (T@U Int) T@U)
(declare-fun |Seq#Equal| (T@U T@U) Bool)
(declare-fun |Seq#SameUntil| (T@U T@U Int) Bool)
(declare-fun |Seq#FromArray| (T@U T@U) T@U)
(declare-fun |Seq#Rank| (T@U) Int)
(declare-fun |Map#Card| (T@U) Int)
(declare-fun |Map#Empty| (T@T T@T) T@U)
(declare-fun |Map#Glue| (T@U T@U T@U) T@U)
(declare-fun |Map#Build| (T@U T@U T@U) T@U)
(declare-fun |Map#Equal| (T@U T@U) Bool)
(declare-fun |Map#Disjoint| (T@U T@U) Bool)
(declare-fun |IMap#Empty| (T@T T@T) T@U)
(declare-fun |IMap#Glue| (T@U T@U T@U) T@U)
(declare-fun |IMap#Build| (T@U T@U T@U) T@U)
(declare-fun |IMap#Equal| (T@U T@U) Bool)
(declare-fun INTERNAL_add_boogie (Int Int) Int)
(declare-fun INTERNAL_sub_boogie (Int Int) Int)
(declare-fun INTERNAL_mul_boogie (Int Int) Int)
(declare-fun INTERNAL_div_boogie (Int Int) Int)
(declare-fun INTERNAL_mod_boogie (Int Int) Int)
(declare-fun INTERNAL_lt_boogie (Int Int) Bool)
(declare-fun INTERNAL_le_boogie (Int Int) Bool)
(declare-fun INTERNAL_gt_boogie (Int Int) Bool)
(declare-fun INTERNAL_ge_boogie (Int Int) Bool)
(declare-fun null () T@U)
(declare-fun Tclass._System.array (T@U) T@U)
(declare-fun Tclass._System.array_0 (T@U) T@U)
(declare-fun dtype (T@U) T@U)
(declare-fun Tclass._System.___hFunc0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc0_0 (T@U) T@U)
(declare-fun HandleTypeType () T@T)
(declare-fun Apply0 (T@U T@U T@U) T@U)
(declare-fun Handle0 (T@U T@U T@U) T@U)
(declare-fun Requires0 (T@U T@U T@U) Bool)
(declare-fun Reads0 (T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hFunc1 (T@U T@U) T@U)
(declare-fun Tclass._System.___hFunc1_0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc1_1 (T@U) T@U)
(declare-fun MapType2Type (T@T T@T T@T) T@T)
(declare-fun MapType2TypeInv0 (T@T) T@T)
(declare-fun MapType2TypeInv1 (T@T) T@T)
(declare-fun MapType2TypeInv2 (T@T) T@T)
(declare-fun MapType2Select (T@U T@U T@U) T@U)
(declare-fun MapType2Store (T@U T@U T@U T@U) T@U)
(declare-fun Apply1 (T@U T@U T@U T@U T@U) T@U)
(declare-fun Handle1 (T@U T@U T@U) T@U)
(declare-fun Requires1 (T@U T@U T@U T@U T@U) Bool)
(declare-fun Reads1 (T@U T@U T@U T@U T@U) T@U)
(declare-fun Tclass._module.__default () T@U)
(declare-fun _module.__default.Factorial (T@U T@U Int) Int)
(declare-fun $IsHeapAnchor (T@U) Bool)
(declare-fun |_module.__default.Factorial#canCall| (T@U Int) Bool)
(declare-fun $ModuleContextHeight () Int)
(declare-fun $FunctionContextHeight () Int)
(declare-fun |_module.__default.Factorial#requires| (T@U T@U Int) Bool)
(declare-fun MapType3Type (T@T T@T) T@T)
(declare-fun MapType3TypeInv0 (T@T) T@T)
(declare-fun MapType3TypeInv1 (T@T) T@T)
(declare-fun MapType3Select (T@U T@U T@U) T@U)
(declare-fun MapType3Store (T@U T@U T@U T@U) T@U)
(declare-fun |lambda#0| (T@U T@U T@U) T@U)
(declare-fun |lambda#1| (T@U T@U T@U) T@U)
(declare-fun |lambda#2| (T@U T@U T@U) T@U)
(declare-fun |lambda#3| (T@U T@U T@U) T@U)
(declare-fun |lambda#4| (T@U T@U T@U T@U) T@U)
(declare-fun |lambda#5| (T@U T@U T@U T@U) T@U)
(declare-fun $LZ () T@U)
(declare-fun $Heap@@12 () T@U)
(declare-fun $_Frame@0 () T@U)
(declare-fun $_Frame@0@@0 () T@U)
(declare-fun %lbl%+13101 () Bool)
(declare-fun %lbl%@34767 () Bool)
(declare-fun |b$reqreads#0@1| () Bool)
(declare-fun %lbl%+13099 () Bool)
(declare-fun |n#0@@7| () Int)
(declare-fun %lbl%@34589 () Bool)
(declare-fun |##n#0@0| () Int)
(declare-fun |b$reqreads#0@0| () Bool)
(declare-fun %lbl%@34638 () Bool)
(declare-fun %lbl%@34651 () Bool)
(declare-fun %lbl%@34666 () Bool)
(declare-fun %lbl%+13097 () Bool)
(declare-fun %lbl%@34525 () Bool)
(declare-fun %lbl%+13095 () Bool)
(declare-fun %lbl%+13088 () Bool)
(declare-fun %lbl%+13084 () Bool)
(declare-fun %lbl%+34404 () Bool)
(assert (and (and (and (and (and (and (and (and (and (and (and (= (Ctor intType) 0) (= (Ctor realType) 1)) (= (Ctor boolType) 2)) (forall ((arg0 Int)) (! (= (U_2_int (int_2_U arg0)) arg0) :qid |typeInv:U_2_int| :pattern ((int_2_U arg0))))) (forall ((x T@U)) (! (=> (= (type x) intType) (= (int_2_U (U_2_int x)) x)) :qid |cast:U_2_int| :pattern ((U_2_int x))))) (forall ((arg0@@0 Int)) (! (= (type (int_2_U arg0@@0)) intType) :qid |funType:int_2_U| :pattern ((int_2_U arg0@@0))))) (forall ((arg0@@1 Real)) (! (= (U_2_real (real_2_U arg0@@1)) arg0@@1) :qid |typeInv:U_2_real| :pattern ((real_2_U arg0@@1))))) (forall ((x@@0 T@U)) (! (=> (= (type x@@0) realType) (= (real_2_U (U_2_real x@@0)) x@@0)) :qid |cast:U_2_real| :pattern ((U_2_real x@@0))))) (forall ((arg0@@2 Real)) (! (= (type (real_2_U arg0@@2)) realType) :qid |funType:real_2_U| :pattern ((real_2_U arg0@@2))))) (forall ((arg0@@3 Bool)) (! (= (U_2_bool (bool_2_U arg0@@3)) arg0@@3) :qid |typeInv:U_2_bool| :pattern ((bool_2_U arg0@@3))))) (forall ((x@@1 T@U)) (! (=> (= (type x@@1) boolType) (= (bool_2_U (U_2_bool x@@1)) x@@1)) :qid |cast:U_2_bool| :pattern ((U_2_bool x@@1))))) (forall ((arg0@@4 Bool)) (! (= (type (bool_2_U arg0@@4)) boolType) :qid |funType:bool_2_U| :pattern ((bool_2_U arg0@@4))))))
(assert (forall ((x@@2 T@U)) (! (UOrdering2 x@@2 x@@2) :qid |bg:subtype-refl| :no-pattern (U_2_int x@@2) :no-pattern (U_2_bool x@@2))))
(assert (forall ((x@@3 T@U) (y T@U) (z T@U)) (! (let ((alpha (type x@@3))) (=> (and (and (= (type y) alpha) (= (type z) alpha)) (and (UOrdering2 x@@3 y) (UOrdering2 y z))) (UOrdering2 x@@3 z))) :qid |bg:subtype-trans| :pattern ((UOrdering2 x@@3 y) (UOrdering2 y z)))))
(assert (forall ((x@@4 T@U) (y@@0 T@U)) (! (let ((alpha@@0 (type x@@4))) (=> (= (type y@@0) alpha@@0) (=> (and (UOrdering2 x@@4 y@@0) (UOrdering2 y@@0 x@@4)) (= x@@4 y@@0)))) :qid |bg:subtype-antisymm| :pattern ((UOrdering2 x@@4 y@@0) (UOrdering2 y@@0 x@@4)))))
(assert (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (= (Ctor TyType) 3) (= (type TBool) TyType)) (= (type TChar) TyType)) (= (type TInt) TyType)) (= (type TNat) TyType)) (= (type TReal) TyType)) (= (Ctor TyTagType) 4)) (= (type TagBool) TyTagType)) (= (type TagChar) TyTagType)) (= (type TagInt) TyTagType)) (= (type TagNat) TyTagType)) (= (type TagReal) TyTagType)) (= (type TagSet) TyTagType)) (= (type TagISet) TyTagType)) (= (type TagMultiSet) TyTagType)) (= (type TagSeq) TyTagType)) (= (type TagMap) TyTagType)) (= (type TagIMap) TyTagType)) (= (type TagClass) TyTagType)) (= (Ctor ClassNameType) 5)) (= (type NoTraitAtAll) ClassNameType)) (= (type class._System.int) ClassNameType)) (= (type class._System.bool) ClassNameType)) (= (type class._System.set) ClassNameType)) (= (type class._System.seq) ClassNameType)) (= (type class._System.multiset) ClassNameType)) (forall ((arg0@@5 T@T)) (! (= (Ctor (FieldType arg0@@5)) 6) :qid |ctor:FieldType|))) (forall ((arg0@@6 T@T)) (! (= (FieldTypeInv0 (FieldType arg0@@6)) arg0@@6) :qid |typeInv:FieldTypeInv0| :pattern ((FieldType arg0@@6))))) (= (type alloc) (FieldType boolType))) (= (type class._System.object) ClassNameType)) (= (type Tagclass._System.object) TyTagType)) (= (type class._System.array) ClassNameType)) (= (type Tagclass._System.array) TyTagType)) (= (type Tagclass._System.___hFunc0) TyTagType)) (= (type Tagclass._System.___hFunc1) TyTagType)) (= (type class._module.__default) ClassNameType)) (= (type Tagclass._module.__default) TyTagType)))
(assert (distinct TBool TChar TInt TNat TReal TagBool TagChar TagInt TagNat TagReal TagSet TagISet TagMultiSet TagSeq TagMap TagIMap TagClass NoTraitAtAll class._System.int class._System.bool class._System.set class._System.seq class._System.multiset alloc class._System.object Tagclass._System.object class._System.array Tagclass._System.array Tagclass._System.___hFunc0 Tagclass._System.___hFunc1 class._module.__default Tagclass._module.__default))
(assert $$Language$Dafny)
(assert (and (forall ((arg0@@7 T@U)) (! (= (type (TSet arg0@@7)) TyType) :qid |funType:TSet| :pattern ((TSet arg0@@7)))) (forall ((arg0@@8 T@U)) (! (= (type (Inv0_TSet arg0@@8)) TyType) :qid |funType:Inv0_TSet| :pattern ((Inv0_TSet arg0@@8))))))
(assert (forall ((t T@U)) (! (=> (= (type t) TyType) (= (Inv0_TSet (TSet t)) t)) :qid |DafnyPre.30:15| :skolemid |0| :pattern ((TSet t)))))
(assert (and (forall ((arg0@@9 T@U)) (! (= (type (TISet arg0@@9)) TyType) :qid |funType:TISet| :pattern ((TISet arg0@@9)))) (forall ((arg0@@10 T@U)) (! (= (type (Inv0_TISet arg0@@10)) TyType) :qid |funType:Inv0_TISet| :pattern ((Inv0_TISet arg0@@10))))))
(assert (forall ((t@@0 T@U)) (! (=> (= (type t@@0) TyType) (= (Inv0_TISet (TISet t@@0)) t@@0)) :qid |DafnyPre.32:15| :skolemid |1| :pattern ((TISet t@@0)))))
(assert (and (forall ((arg0@@11 T@U)) (! (= (type (TSeq arg0@@11)) TyType) :qid |funType:TSeq| :pattern ((TSeq arg0@@11)))) (forall ((arg0@@12 T@U)) (! (= (type (Inv0_TSeq arg0@@12)) TyType) :qid |funType:Inv0_TSeq| :pattern ((Inv0_TSeq arg0@@12))))))
(assert (forall ((t@@1 T@U)) (! (=> (= (type t@@1) TyType) (= (Inv0_TSeq (TSeq t@@1)) t@@1)) :qid |DafnyPre.34:15| :skolemid |2| :pattern ((TSeq t@@1)))))
(assert (and (forall ((arg0@@13 T@U)) (! (= (type (TMultiSet arg0@@13)) TyType) :qid |funType:TMultiSet| :pattern ((TMultiSet arg0@@13)))) (forall ((arg0@@14 T@U)) (! (= (type (Inv0_TMultiSet arg0@@14)) TyType) :qid |funType:Inv0_TMultiSet| :pattern ((Inv0_TMultiSet arg0@@14))))))
(assert (forall ((t@@2 T@U)) (! (=> (= (type t@@2) TyType) (= (Inv0_TMultiSet (TMultiSet t@@2)) t@@2)) :qid |DafnyPre.36:15| :skolemid |3| :pattern ((TMultiSet t@@2)))))
(assert (and (forall ((arg0@@15 T@U) (arg1 T@U)) (! (= (type (TMap arg0@@15 arg1)) TyType) :qid |funType:TMap| :pattern ((TMap arg0@@15 arg1)))) (forall ((arg0@@16 T@U)) (! (= (type (Inv0_TMap arg0@@16)) TyType) :qid |funType:Inv0_TMap| :pattern ((Inv0_TMap arg0@@16))))))
(assert (forall ((t@@3 T@U) (u T@U)) (! (=> (and (= (type t@@3) TyType) (= (type u) TyType)) (= (Inv0_TMap (TMap t@@3 u)) t@@3)) :qid |DafnyPre.39:15| :skolemid |4| :pattern ((TMap t@@3 u)))))
(assert (forall ((arg0@@17 T@U)) (! (= (type (Inv1_TMap arg0@@17)) TyType) :qid |funType:Inv1_TMap| :pattern ((Inv1_TMap arg0@@17)))))
(assert (forall ((t@@4 T@U) (u@@0 T@U)) (! (=> (and (= (type t@@4) TyType) (= (type u@@0) TyType)) (= (Inv1_TMap (TMap t@@4 u@@0)) u@@0)) :qid |DafnyPre.40:15| :skolemid |5| :pattern ((TMap t@@4 u@@0)))))
(assert (and (forall ((arg0@@18 T@U) (arg1@@0 T@U)) (! (= (type (TIMap arg0@@18 arg1@@0)) TyType) :qid |funType:TIMap| :pattern ((TIMap arg0@@18 arg1@@0)))) (forall ((arg0@@19 T@U)) (! (= (type (Inv0_TIMap arg0@@19)) TyType) :qid |funType:Inv0_TIMap| :pattern ((Inv0_TIMap arg0@@19))))))
(assert (forall ((t@@5 T@U) (u@@1 T@U)) (! (=> (and (= (type t@@5) TyType) (= (type u@@1) TyType)) (= (Inv0_TIMap (TIMap t@@5 u@@1)) t@@5)) :qid |DafnyPre.43:15| :skolemid |6| :pattern ((TIMap t@@5 u@@1)))))
(assert (forall ((arg0@@20 T@U)) (! (= (type (Inv1_TIMap arg0@@20)) TyType) :qid |funType:Inv1_TIMap| :pattern ((Inv1_TIMap arg0@@20)))))
(assert (forall ((t@@6 T@U) (u@@2 T@U)) (! (=> (and (= (type t@@6) TyType) (= (type u@@2) TyType)) (= (Inv1_TIMap (TIMap t@@6 u@@2)) u@@2)) :qid |DafnyPre.44:15| :skolemid |7| :pattern ((TIMap t@@6 u@@2)))))
(assert (forall ((arg0@@21 T@U)) (! (= (type (Tag arg0@@21)) TyTagType) :qid |funType:Tag| :pattern ((Tag arg0@@21)))))
(assert (= (Tag TBool) TagBool))
(assert (= (Tag TChar) TagChar))
(assert (= (Tag TInt) TagInt))
(assert (= (Tag TNat) TagNat))
(assert (= (Tag TReal) TagReal))
(assert (forall ((t@@7 T@U)) (! (=> (= (type t@@7) TyType) (= (Tag (TSet t@@7)) TagSet)) :qid |DafnyPre.70:15| :skolemid |8| :pattern ((TSet t@@7)))))
(assert (forall ((t@@8 T@U)) (! (=> (= (type t@@8) TyType) (= (Tag (TISet t@@8)) TagISet)) :qid |DafnyPre.71:15| :skolemid |9| :pattern ((TISet t@@8)))))
(assert (forall ((t@@9 T@U)) (! (=> (= (type t@@9) TyType) (= (Tag (TMultiSet t@@9)) TagMultiSet)) :qid |DafnyPre.72:15| :skolemid |10| :pattern ((TMultiSet t@@9)))))
(assert (forall ((t@@10 T@U)) (! (=> (= (type t@@10) TyType) (= (Tag (TSeq t@@10)) TagSeq)) :qid |DafnyPre.73:15| :skolemid |11| :pattern ((TSeq t@@10)))))
(assert (forall ((t@@11 T@U) (u@@3 T@U)) (! (=> (and (= (type t@@11) TyType) (= (type u@@3) TyType)) (= (Tag (TMap t@@11 u@@3)) TagMap)) :qid |DafnyPre.74:15| :skolemid |12| :pattern ((TMap t@@11 u@@3)))))
(assert (forall ((t@@12 T@U) (u@@4 T@U)) (! (=> (and (= (type t@@12) TyType) (= (type u@@4) TyType)) (= (Tag (TIMap t@@12 u@@4)) TagIMap)) :qid |DafnyPre.75:15| :skolemid |13| :pattern ((TIMap t@@12 u@@4)))))
(assert (forall ((x@@5 Int)) (! (= (LitInt x@@5) x@@5) :qid |DafnyPre.80:29| :skolemid |14| :pattern ((LitInt x@@5)))))
(assert (and (and (= (Ctor BoxType) 7) (forall ((arg0@@22 T@U)) (! (= (type ($Box arg0@@22)) BoxType) :qid |funType:$Box| :pattern (($Box arg0@@22))))) (forall ((arg0@@23 T@U)) (! (let ((T (type arg0@@23))) (= (type (Lit arg0@@23)) T)) :qid |funType:Lit| :pattern ((Lit arg0@@23))))))
(assert (forall ((x@@6 Int)) (! (= ($Box (int_2_U (LitInt x@@6))) (Lit ($Box (int_2_U x@@6)))) :qid |DafnyPre.81:15| :skolemid |15| :pattern (($Box (int_2_U (LitInt x@@6)))))))
(assert (forall ((x@@7 Real)) (! (= (LitReal x@@7) x@@7) :qid |DafnyPre.82:30| :skolemid |16| :pattern ((LitReal x@@7)))))
(assert (forall ((x@@8 Real)) (! (= ($Box (real_2_U (LitReal x@@8))) (Lit ($Box (real_2_U x@@8)))) :qid |DafnyPre.83:15| :skolemid |17| :pattern (($Box (real_2_U (LitReal x@@8)))))))
(assert (forall ((x@@9 T@U)) (! (= (Lit x@@9) x@@9) :qid |DafnyPre.84:29| :skolemid |18| :pattern ((Lit x@@9)))))
(assert (forall ((x@@10 T@U)) (! (= ($Box (Lit x@@10)) (Lit ($Box x@@10))) :qid |DafnyPre.85:18| :skolemid |19| :pattern (($Box (Lit x@@10))))))
(assert (and (= (Ctor charType) 8) (forall ((arg0@@24 Int)) (! (= (type (|char#FromInt| arg0@@24)) charType) :qid |funType:char#FromInt| :pattern ((|char#FromInt| arg0@@24))))))
(assert (forall ((ch T@U)) (! (=> (= (type ch) charType) (= (|char#FromInt| (|char#ToInt| ch)) ch)) :qid |DafnyPre.94:15| :skolemid |20| :pattern ((|char#ToInt| ch)))))
(assert (forall ((n Int)) (! (=> (and (<= 0 n) (< n 65536)) (= (|char#ToInt| (|char#FromInt| n)) n)) :qid |DafnyPre.97:15| :skolemid |21| :pattern ((|char#FromInt| n)))))
(assert (forall ((T@@0 T@T) (arg0@@25 T@U)) (! (= (type ($Unbox T@@0 arg0@@25)) T@@0) :qid |funType:$Unbox| :pattern (($Unbox T@@0 arg0@@25)))))
(assert (forall ((x@@11 T@U)) (! (let ((T@@1 (type x@@11))) (= ($Unbox T@@1 ($Box x@@11)) x@@11)) :qid |DafnyPre.125:18| :skolemid |22| :pattern (($Box x@@11)))))
(assert (forall ((bx T@U)) (! (=> (and (= (type bx) BoxType) ($IsBox bx TInt)) (and (= ($Box ($Unbox intType bx)) bx) ($Is ($Unbox intType bx) TInt))) :qid |DafnyPre.127:15| :skolemid |23| :pattern (($IsBox bx TInt)))))
(assert (forall ((bx@@0 T@U)) (! (=> (and (= (type bx@@0) BoxType) ($IsBox bx@@0 TNat)) (and (= ($Box ($Unbox intType bx@@0)) bx@@0) ($Is ($Unbox intType bx@@0) TNat))) :qid |DafnyPre.130:15| :skolemid |24| :pattern (($IsBox bx@@0 TNat)))))
(assert (forall ((bx@@1 T@U)) (! (=> (and (= (type bx@@1) BoxType) ($IsBox bx@@1 TReal)) (and (= ($Box ($Unbox realType bx@@1)) bx@@1) ($Is ($Unbox realType bx@@1) TReal))) :qid |DafnyPre.133:15| :skolemid |25| :pattern (($IsBox bx@@1 TReal)))))
(assert (forall ((bx@@2 T@U)) (! (=> (and (= (type bx@@2) BoxType) ($IsBox bx@@2 TBool)) (and (= ($Box ($Unbox boolType bx@@2)) bx@@2) ($Is ($Unbox boolType bx@@2) TBool))) :qid |DafnyPre.136:15| :skolemid |26| :pattern (($IsBox bx@@2 TBool)))))
(assert (forall ((bx@@3 T@U)) (! (=> (and (= (type bx@@3) BoxType) ($IsBox bx@@3 TChar)) (and (= ($Box ($Unbox charType bx@@3)) bx@@3) ($Is ($Unbox charType bx@@3) TChar))) :qid |DafnyPre.139:15| :skolemid |27| :pattern (($IsBox bx@@3 TChar)))))
(assert (and (and (and (and (and (and (forall ((arg0@@26 T@T) (arg1@@1 T@T)) (! (= (Ctor (MapType0Type arg0@@26 arg1@@1)) 9) :qid |ctor:MapType0Type|)) (forall ((arg0@@27 T@T) (arg1@@2 T@T)) (! (= (MapType0TypeInv0 (MapType0Type arg0@@27 arg1@@2)) arg0@@27) :qid |typeInv:MapType0TypeInv0| :pattern ((MapType0Type arg0@@27 arg1@@2))))) (forall ((arg0@@28 T@T) (arg1@@3 T@T)) (! (= (MapType0TypeInv1 (MapType0Type arg0@@28 arg1@@3)) arg1@@3) :qid |typeInv:MapType0TypeInv1| :pattern ((MapType0Type arg0@@28 arg1@@3))))) (forall ((arg0@@29 T@U) (arg1@@4 T@U)) (! (let ((aVar1 (MapType0TypeInv1 (type arg0@@29)))) (= (type (MapType0Select arg0@@29 arg1@@4)) aVar1)) :qid |funType:MapType0Select| :pattern ((MapType0Select arg0@@29 arg1@@4))))) (forall ((arg0@@30 T@U) (arg1@@5 T@U) (arg2 T@U)) (! (let ((aVar1@@0 (type arg2))) (let ((aVar0 (type arg1@@5))) (= (type (MapType0Store arg0@@30 arg1@@5 arg2)) (MapType0Type aVar0 aVar1@@0)))) :qid |funType:MapType0Store| :pattern ((MapType0Store arg0@@30 arg1@@5 arg2))))) (forall ((m T@U) (x0 T@U) (val T@U)) (! (let ((aVar1@@1 (MapType0TypeInv1 (type m)))) (=> (= (type val) aVar1@@1) (= (MapType0Select (MapType0Store m x0 val) x0) val))) :qid |mapAx0:MapType0Select| :weight 0))) (and (forall ((val@@0 T@U) (m@@0 T@U) (x0@@0 T@U) (y0 T@U)) (! (or (= x0@@0 y0) (= (MapType0Select (MapType0Store m@@0 x0@@0 val@@0) y0) (MapType0Select m@@0 y0))) :qid |mapAx1:MapType0Select:0| :weight 0)) (forall ((val@@1 T@U) (m@@1 T@U) (x0@@1 T@U) (y0@@0 T@U)) (! (or true (= (MapType0Select (MapType0Store m@@1 x0@@1 val@@1) y0@@0) (MapType0Select m@@1 y0@@0))) :qid |mapAx2:MapType0Select| :weight 0)))))
(assert (forall ((bx@@4 T@U) (t@@13 T@U)) (! (=> (and (and (= (type bx@@4) BoxType) (= (type t@@13) TyType)) ($IsBox bx@@4 (TSet t@@13))) (and (= ($Box ($Unbox (MapType0Type BoxType boolType) bx@@4)) bx@@4) ($Is ($Unbox (MapType0Type BoxType boolType) bx@@4) (TSet t@@13)))) :qid |DafnyPre.142:15| :skolemid |28| :pattern (($IsBox bx@@4 (TSet t@@13))))))
(assert (forall ((bx@@5 T@U) (t@@14 T@U)) (! (=> (and (and (= (type bx@@5) BoxType) (= (type t@@14) TyType)) ($IsBox bx@@5 (TISet t@@14))) (and (= ($Box ($Unbox (MapType0Type BoxType boolType) bx@@5)) bx@@5) ($Is ($Unbox (MapType0Type BoxType boolType) bx@@5) (TISet t@@14)))) :qid |DafnyPre.145:15| :skolemid |29| :pattern (($IsBox bx@@5 (TISet t@@14))))))
(assert (forall ((bx@@6 T@U) (t@@15 T@U)) (! (=> (and (and (= (type bx@@6) BoxType) (= (type t@@15) TyType)) ($IsBox bx@@6 (TMultiSet t@@15))) (and (= ($Box ($Unbox (MapType0Type BoxType intType) bx@@6)) bx@@6) ($Is ($Unbox (MapType0Type BoxType intType) bx@@6) (TMultiSet t@@15)))) :qid |DafnyPre.148:15| :skolemid |30| :pattern (($IsBox bx@@6 (TMultiSet t@@15))))))
(assert (and (forall ((arg0@@31 T@T)) (! (= (Ctor (SeqType arg0@@31)) 10) :qid |ctor:SeqType|)) (forall ((arg0@@32 T@T)) (! (= (SeqTypeInv0 (SeqType arg0@@32)) arg0@@32) :qid |typeInv:SeqTypeInv0| :pattern ((SeqType arg0@@32))))))
(assert (forall ((bx@@7 T@U) (t@@16 T@U)) (! (=> (and (and (= (type bx@@7) BoxType) (= (type t@@16) TyType)) ($IsBox bx@@7 (TSeq t@@16))) (and (= ($Box ($Unbox (SeqType BoxType) bx@@7)) bx@@7) ($Is ($Unbox (SeqType BoxType) bx@@7) (TSeq t@@16)))) :qid |DafnyPre.151:15| :skolemid |31| :pattern (($IsBox bx@@7 (TSeq t@@16))))))
(assert (and (and (forall ((arg0@@33 T@T) (arg1@@6 T@T)) (! (= (Ctor (MapType arg0@@33 arg1@@6)) 11) :qid |ctor:MapType|)) (forall ((arg0@@34 T@T) (arg1@@7 T@T)) (! (= (MapTypeInv0 (MapType arg0@@34 arg1@@7)) arg0@@34) :qid |typeInv:MapTypeInv0| :pattern ((MapType arg0@@34 arg1@@7))))) (forall ((arg0@@35 T@T) (arg1@@8 T@T)) (! (= (MapTypeInv1 (MapType arg0@@35 arg1@@8)) arg1@@8) :qid |typeInv:MapTypeInv1| :pattern ((MapType arg0@@35 arg1@@8))))))
(assert (forall ((bx@@8 T@U) (s T@U) (t@@17 T@U)) (! (=> (and (and (and (= (type bx@@8) BoxType) (= (type s) TyType)) (= (type t@@17) TyType)) ($IsBox bx@@8 (TMap s t@@17))) (and (= ($Box ($Unbox (MapType BoxType BoxType) bx@@8)) bx@@8) ($Is ($Unbox (MapType BoxType BoxType) bx@@8) (TMap s t@@17)))) :qid |DafnyPre.154:15| :skolemid |32| :pattern (($IsBox bx@@8 (TMap s t@@17))))))
(assert (and (and (forall ((arg0@@36 T@T) (arg1@@9 T@T)) (! (= (Ctor (IMapType arg0@@36 arg1@@9)) 12) :qid |ctor:IMapType|)) (forall ((arg0@@37 T@T) (arg1@@10 T@T)) (! (= (IMapTypeInv0 (IMapType arg0@@37 arg1@@10)) arg0@@37) :qid |typeInv:IMapTypeInv0| :pattern ((IMapType arg0@@37 arg1@@10))))) (forall ((arg0@@38 T@T) (arg1@@11 T@T)) (! (= (IMapTypeInv1 (IMapType arg0@@38 arg1@@11)) arg1@@11) :qid |typeInv:IMapTypeInv1| :pattern ((IMapType arg0@@38 arg1@@11))))))
(assert (forall ((bx@@9 T@U) (s@@0 T@U) (t@@18 T@U)) (! (=> (and (and (and (= (type bx@@9) BoxType) (= (type s@@0) TyType)) (= (type t@@18) TyType)) ($IsBox bx@@9 (TIMap s@@0 t@@18))) (and (= ($Box ($Unbox (IMapType BoxType BoxType) bx@@9)) bx@@9) ($Is ($Unbox (IMapType BoxType BoxType) bx@@9) (TIMap s@@0 t@@18)))) :qid |DafnyPre.157:15| :skolemid |33| :pattern (($IsBox bx@@9 (TIMap s@@0 t@@18))))))
(assert (forall ((v T@U) (t@@19 T@U)) (! (=> (= (type t@@19) TyType) (and (=> ($IsBox ($Box v) t@@19) ($Is v t@@19)) (=> ($Is v t@@19) ($IsBox ($Box v) t@@19)))) :qid |DafnyPre.161:18| :skolemid |34| :pattern (($IsBox ($Box v) t@@19)))))
(assert (and (and (and (and (and (and (forall ((arg0@@39 T@T)) (! (= (Ctor (MapType1Type arg0@@39)) 13) :qid |ctor:MapType1Type|)) (forall ((arg0@@40 T@T)) (! (= (MapType1TypeInv0 (MapType1Type arg0@@40)) arg0@@40) :qid |typeInv:MapType1TypeInv0| :pattern ((MapType1Type arg0@@40))))) (forall ((arg0@@41 T@U) (arg1@@12 T@U) (arg2@@0 T@U)) (! (let ((alpha@@1 (FieldTypeInv0 (type arg2@@0)))) (= (type (MapType1Select arg0@@41 arg1@@12 arg2@@0)) alpha@@1)) :qid |funType:MapType1Select| :pattern ((MapType1Select arg0@@41 arg1@@12 arg2@@0))))) (forall ((arg0@@42 T@U) (arg1@@13 T@U) (arg2@@1 T@U) (arg3 T@U)) (! (let ((aVar0@@0 (type arg1@@13))) (= (type (MapType1Store arg0@@42 arg1@@13 arg2@@1 arg3)) (MapType1Type aVar0@@0))) :qid |funType:MapType1Store| :pattern ((MapType1Store arg0@@42 arg1@@13 arg2@@1 arg3))))) (forall ((m@@2 T@U) (x0@@2 T@U) (x1 T@U) (val@@2 T@U)) (! (let ((alpha@@2 (FieldTypeInv0 (type x1)))) (=> (= (type val@@2) alpha@@2) (= (MapType1Select (MapType1Store m@@2 x0@@2 x1 val@@2) x0@@2 x1) val@@2))) :qid |mapAx0:MapType1Select| :weight 0))) (and (and (forall ((val@@3 T@U) (m@@3 T@U) (x0@@3 T@U) (x1@@0 T@U) (y0@@1 T@U) (y1 T@U)) (! (or (= x0@@3 y0@@1) (= (MapType1Select (MapType1Store m@@3 x0@@3 x1@@0 val@@3) y0@@1 y1) (MapType1Select m@@3 y0@@1 y1))) :qid |mapAx1:MapType1Select:0| :weight 0)) (forall ((val@@4 T@U) (m@@4 T@U) (x0@@4 T@U) (x1@@1 T@U) (y0@@2 T@U) (y1@@0 T@U)) (! (or (= x1@@1 y1@@0) (= (MapType1Select (MapType1Store m@@4 x0@@4 x1@@1 val@@4) y0@@2 y1@@0) (MapType1Select m@@4 y0@@2 y1@@0))) :qid |mapAx1:MapType1Select:1| :weight 0))) (forall ((val@@5 T@U) (m@@5 T@U) (x0@@5 T@U) (x1@@2 T@U) (y0@@3 T@U) (y1@@1 T@U)) (! (or true (= (MapType1Select (MapType1Store m@@5 x0@@5 x1@@2 val@@5) y0@@3 y1@@1) (MapType1Select m@@5 y0@@3 y1@@1))) :qid |mapAx2:MapType1Select| :weight 0)))) (= (Ctor refType) 14)))
(assert (forall ((v@@0 T@U) (t@@20 T@U) (h T@U)) (! (=> (and (= (type t@@20) TyType) (= (type h) (MapType1Type refType))) (and (=> ($IsAllocBox ($Box v@@0) t@@20 h) ($IsAlloc v@@0 t@@20 h)) (=> ($IsAlloc v@@0 t@@20 h) ($IsAllocBox ($Box v@@0) t@@20 h)))) :qid |DafnyPre.164:18| :skolemid |35| :pattern (($IsAllocBox ($Box v@@0) t@@20 h)))))
(assert (forall ((v@@1 T@U)) (! (=> (= (type v@@1) intType) ($Is v@@1 TInt)) :qid |DafnyPre.182:14| :skolemid |36| :pattern (($Is v@@1 TInt)))))
(assert (forall ((v@@2 T@U)) (! (=> (= (type v@@2) intType) (and (=> ($Is v@@2 TNat) (>= (U_2_int v@@2) 0)) (=> (>= (U_2_int v@@2) 0) ($Is v@@2 TNat)))) :qid |DafnyPre.183:14| :skolemid |37| :pattern (($Is v@@2 TNat)))))
(assert (forall ((v@@3 T@U)) (! (=> (= (type v@@3) realType) ($Is v@@3 TReal)) :qid |DafnyPre.184:14| :skolemid |38| :pattern (($Is v@@3 TReal)))))
(assert (forall ((v@@4 T@U)) (! (=> (= (type v@@4) boolType) ($Is v@@4 TBool)) :qid |DafnyPre.185:14| :skolemid |39| :pattern (($Is v@@4 TBool)))))
(assert (forall ((v@@5 T@U)) (! (=> (= (type v@@5) charType) ($Is v@@5 TChar)) :qid |DafnyPre.186:14| :skolemid |40| :pattern (($Is v@@5 TChar)))))
(assert (forall ((h@@0 T@U) (v@@6 T@U)) (! (=> (and (= (type h@@0) (MapType1Type refType)) (= (type v@@6) intType)) ($IsAlloc v@@6 TInt h@@0)) :qid |DafnyPre.188:14| :skolemid |41| :pattern (($IsAlloc v@@6 TInt h@@0)))))
(assert (forall ((h@@1 T@U) (v@@7 T@U)) (! (=> (and (= (type h@@1) (MapType1Type refType)) (= (type v@@7) intType)) ($IsAlloc v@@7 TNat h@@1)) :qid |DafnyPre.189:14| :skolemid |42| :pattern (($IsAlloc v@@7 TNat h@@1)))))
(assert (forall ((h@@2 T@U) (v@@8 T@U)) (! (=> (and (= (type h@@2) (MapType1Type refType)) (= (type v@@8) realType)) ($IsAlloc v@@8 TReal h@@2)) :qid |DafnyPre.190:14| :skolemid |43| :pattern (($IsAlloc v@@8 TReal h@@2)))))
(assert (forall ((h@@3 T@U) (v@@9 T@U)) (! (=> (and (= (type h@@3) (MapType1Type refType)) (= (type v@@9) boolType)) ($IsAlloc v@@9 TBool h@@3)) :qid |DafnyPre.191:14| :skolemid |44| :pattern (($IsAlloc v@@9 TBool h@@3)))))
(assert (forall ((h@@4 T@U) (v@@10 T@U)) (! (=> (and (= (type h@@4) (MapType1Type refType)) (= (type v@@10) charType)) ($IsAlloc v@@10 TChar h@@4)) :qid |DafnyPre.192:14| :skolemid |45| :pattern (($IsAlloc v@@10 TChar h@@4)))))
(assert (forall ((v@@11 T@U) (t0 T@U)) (! (=> (and (= (type v@@11) (MapType0Type BoxType boolType)) (= (type t0) TyType)) (and (=> ($Is v@@11 (TSet t0)) (forall ((bx@@10 T@U)) (! (=> (and (= (type bx@@10) BoxType) (U_2_bool (MapType0Select v@@11 bx@@10))) ($IsBox bx@@10 t0)) :qid |DafnyPre.196:11| :skolemid |46| :pattern ((MapType0Select v@@11 bx@@10))))) (=> (forall ((bx@@11 T@U)) (! (=> (and (= (type bx@@11) BoxType) (U_2_bool (MapType0Select v@@11 bx@@11))) ($IsBox bx@@11 t0)) :qid |DafnyPre.196:11| :skolemid |46| :pattern ((MapType0Select v@@11 bx@@11)))) ($Is v@@11 (TSet t0))))) :qid |DafnyPre.194:15| :skolemid |47| :pattern (($Is v@@11 (TSet t0))))))
(assert (forall ((v@@12 T@U) (t0@@0 T@U)) (! (=> (and (= (type v@@12) (MapType0Type BoxType boolType)) (= (type t0@@0) TyType)) (and (=> ($Is v@@12 (TISet t0@@0)) (forall ((bx@@12 T@U)) (! (=> (and (= (type bx@@12) BoxType) (U_2_bool (MapType0Select v@@12 bx@@12))) ($IsBox bx@@12 t0@@0)) :qid |DafnyPre.200:11| :skolemid |48| :pattern ((MapType0Select v@@12 bx@@12))))) (=> (forall ((bx@@13 T@U)) (! (=> (and (= (type bx@@13) BoxType) (U_2_bool (MapType0Select v@@12 bx@@13))) ($IsBox bx@@13 t0@@0)) :qid |DafnyPre.200:11| :skolemid |48| :pattern ((MapType0Select v@@12 bx@@13)))) ($Is v@@12 (TISet t0@@0))))) :qid |DafnyPre.198:15| :skolemid |49| :pattern (($Is v@@12 (TISet t0@@0))))))
(assert (forall ((v@@13 T@U) (t0@@1 T@U)) (! (=> (and (= (type v@@13) (MapType0Type BoxType intType)) (= (type t0@@1) TyType)) (and (=> ($Is v@@13 (TMultiSet t0@@1)) (forall ((bx@@14 T@U)) (! (=> (and (= (type bx@@14) BoxType) (< 0 (U_2_int (MapType0Select v@@13 bx@@14)))) ($IsBox bx@@14 t0@@1)) :qid |DafnyPre.204:11| :skolemid |50| :pattern ((MapType0Select v@@13 bx@@14))))) (=> (forall ((bx@@15 T@U)) (! (=> (and (= (type bx@@15) BoxType) (< 0 (U_2_int (MapType0Select v@@13 bx@@15)))) ($IsBox bx@@15 t0@@1)) :qid |DafnyPre.204:11| :skolemid |50| :pattern ((MapType0Select v@@13 bx@@15)))) ($Is v@@13 (TMultiSet t0@@1))))) :qid |DafnyPre.202:15| :skolemid |51| :pattern (($Is v@@13 (TMultiSet t0@@1))))))
(assert (forall ((v@@14 T@U) (t0@@2 T@U)) (! (=> (and (and (= (type v@@14) (MapType0Type BoxType intType)) (= (type t0@@2) TyType)) ($Is v@@14 (TMultiSet t0@@2))) ($IsGoodMultiSet v@@14)) :qid |DafnyPre.206:15| :skolemid |52| :pattern (($Is v@@14 (TMultiSet t0@@2))))))
(assert (forall ((arg0@@43 T@U) (arg1@@14 Int)) (! (let ((T@@2 (SeqTypeInv0 (type arg0@@43)))) (= (type (|Seq#Index| arg0@@43 arg1@@14)) T@@2)) :qid |funType:Seq#Index| :pattern ((|Seq#Index| arg0@@43 arg1@@14)))))
(assert (forall ((v@@15 T@U) (t0@@3 T@U)) (! (=> (and (= (type v@@15) (SeqType BoxType)) (= (type t0@@3) TyType)) (and (=> ($Is v@@15 (TSeq t0@@3)) (forall ((i Int)) (! (=> (and (<= 0 i) (< i (|Seq#Length| v@@15))) ($IsBox (|Seq#Index| v@@15 i) t0@@3)) :qid |DafnyPre.210:11| :skolemid |53| :pattern ((|Seq#Index| v@@15 i))))) (=> (forall ((i@@0 Int)) (! (=> (and (<= 0 i@@0) (< i@@0 (|Seq#Length| v@@15))) ($IsBox (|Seq#Index| v@@15 i@@0) t0@@3)) :qid |DafnyPre.210:11| :skolemid |53| :pattern ((|Seq#Index| v@@15 i@@0)))) ($Is v@@15 (TSeq t0@@3))))) :qid |DafnyPre.208:15| :skolemid |54| :pattern (($Is v@@15 (TSeq t0@@3))))))
(assert (forall ((v@@16 T@U) (t0@@4 T@U) (h@@5 T@U)) (! (=> (and (and (= (type v@@16) (MapType0Type BoxType boolType)) (= (type t0@@4) TyType)) (= (type h@@5) (MapType1Type refType))) (and (=> ($IsAlloc v@@16 (TSet t0@@4) h@@5) (forall ((bx@@16 T@U)) (! (=> (and (= (type bx@@16) BoxType) (U_2_bool (MapType0Select v@@16 bx@@16))) ($IsAllocBox bx@@16 t0@@4 h@@5)) :qid |DafnyPre.215:11| :skolemid |55| :pattern ((MapType0Select v@@16 bx@@16))))) (=> (forall ((bx@@17 T@U)) (! (=> (and (= (type bx@@17) BoxType) (U_2_bool (MapType0Select v@@16 bx@@17))) ($IsAllocBox bx@@17 t0@@4 h@@5)) :qid |DafnyPre.215:11| :skolemid |55| :pattern ((MapType0Select v@@16 bx@@17)))) ($IsAlloc v@@16 (TSet t0@@4) h@@5)))) :qid |DafnyPre.213:15| :skolemid |56| :pattern (($IsAlloc v@@16 (TSet t0@@4) h@@5)))))
(assert (forall ((v@@17 T@U) (t0@@5 T@U) (h@@6 T@U)) (! (=> (and (and (= (type v@@17) (MapType0Type BoxType boolType)) (= (type t0@@5) TyType)) (= (type h@@6) (MapType1Type refType))) (and (=> ($IsAlloc v@@17 (TISet t0@@5) h@@6) (forall ((bx@@18 T@U)) (! (=> (and (= (type bx@@18) BoxType) (U_2_bool (MapType0Select v@@17 bx@@18))) ($IsAllocBox bx@@18 t0@@5 h@@6)) :qid |DafnyPre.219:11| :skolemid |57| :pattern ((MapType0Select v@@17 bx@@18))))) (=> (forall ((bx@@19 T@U)) (! (=> (and (= (type bx@@19) BoxType) (U_2_bool (MapType0Select v@@17 bx@@19))) ($IsAllocBox bx@@19 t0@@5 h@@6)) :qid |DafnyPre.219:11| :skolemid |57| :pattern ((MapType0Select v@@17 bx@@19)))) ($IsAlloc v@@17 (TISet t0@@5) h@@6)))) :qid |DafnyPre.217:15| :skolemid |58| :pattern (($IsAlloc v@@17 (TISet t0@@5) h@@6)))))
(assert (forall ((v@@18 T@U) (t0@@6 T@U) (h@@7 T@U)) (! (=> (and (and (= (type v@@18) (MapType0Type BoxType intType)) (= (type t0@@6) TyType)) (= (type h@@7) (MapType1Type refType))) (and (=> ($IsAlloc v@@18 (TMultiSet t0@@6) h@@7) (forall ((bx@@20 T@U)) (! (=> (and (= (type bx@@20) BoxType) (< 0 (U_2_int (MapType0Select v@@18 bx@@20)))) ($IsAllocBox bx@@20 t0@@6 h@@7)) :qid |DafnyPre.223:11| :skolemid |59| :pattern ((MapType0Select v@@18 bx@@20))))) (=> (forall ((bx@@21 T@U)) (! (=> (and (= (type bx@@21) BoxType) (< 0 (U_2_int (MapType0Select v@@18 bx@@21)))) ($IsAllocBox bx@@21 t0@@6 h@@7)) :qid |DafnyPre.223:11| :skolemid |59| :pattern ((MapType0Select v@@18 bx@@21)))) ($IsAlloc v@@18 (TMultiSet t0@@6) h@@7)))) :qid |DafnyPre.221:15| :skolemid |60| :pattern (($IsAlloc v@@18 (TMultiSet t0@@6) h@@7)))))
(assert (forall ((v@@19 T@U) (t0@@7 T@U) (h@@8 T@U)) (! (=> (and (and (= (type v@@19) (SeqType BoxType)) (= (type t0@@7) TyType)) (= (type h@@8) (MapType1Type refType))) (and (=> ($IsAlloc v@@19 (TSeq t0@@7) h@@8) (forall ((i@@1 Int)) (! (=> (and (<= 0 i@@1) (< i@@1 (|Seq#Length| v@@19))) ($IsAllocBox (|Seq#Index| v@@19 i@@1) t0@@7 h@@8)) :qid |DafnyPre.227:11| :skolemid |61| :pattern ((|Seq#Index| v@@19 i@@1))))) (=> (forall ((i@@2 Int)) (! (=> (and (<= 0 i@@2) (< i@@2 (|Seq#Length| v@@19))) ($IsAllocBox (|Seq#Index| v@@19 i@@2) t0@@7 h@@8)) :qid |DafnyPre.227:11| :skolemid |61| :pattern ((|Seq#Index| v@@19 i@@2)))) ($IsAlloc v@@19 (TSeq t0@@7) h@@8)))) :qid |DafnyPre.225:15| :skolemid |62| :pattern (($IsAlloc v@@19 (TSeq t0@@7) h@@8)))))
(assert (and (forall ((arg0@@44 T@U)) (! (let ((V (MapTypeInv1 (type arg0@@44)))) (let ((U (MapTypeInv0 (type arg0@@44)))) (= (type (|Map#Elements| arg0@@44)) (MapType0Type U V)))) :qid |funType:Map#Elements| :pattern ((|Map#Elements| arg0@@44)))) (forall ((arg0@@45 T@U)) (! (let ((U@@0 (MapTypeInv0 (type arg0@@45)))) (= (type (|Map#Domain| arg0@@45)) (MapType0Type U@@0 boolType))) :qid |funType:Map#Domain| :pattern ((|Map#Domain| arg0@@45))))))
(assert (forall ((v@@20 T@U) (t0@@8 T@U) (t1 T@U)) (! (=> (and (and (= (type v@@20) (MapType BoxType BoxType)) (= (type t0@@8) TyType)) (= (type t1) TyType)) (and (=> ($Is v@@20 (TMap t0@@8 t1)) (forall ((bx@@22 T@U)) (! (=> (and (= (type bx@@22) BoxType) (U_2_bool (MapType0Select (|Map#Domain| v@@20) bx@@22))) (and ($IsBox (MapType0Select (|Map#Elements| v@@20) bx@@22) t1) ($IsBox bx@@22 t0@@8))) :qid |DafnyPre.234:19| :skolemid |63| :pattern ((MapType0Select (|Map#Elements| v@@20) bx@@22)) :pattern ((MapType0Select (|Map#Domain| v@@20) bx@@22))))) (=> (forall ((bx@@23 T@U)) (! (=> (and (= (type bx@@23) BoxType) (U_2_bool (MapType0Select (|Map#Domain| v@@20) bx@@23))) (and ($IsBox (MapType0Select (|Map#Elements| v@@20) bx@@23) t1) ($IsBox bx@@23 t0@@8))) :qid |DafnyPre.234:19| :skolemid |63| :pattern ((MapType0Select (|Map#Elements| v@@20) bx@@23)) :pattern ((MapType0Select (|Map#Domain| v@@20) bx@@23)))) ($Is v@@20 (TMap t0@@8 t1))))) :qid |DafnyPre.231:15| :skolemid |64| :pattern (($Is v@@20 (TMap t0@@8 t1))))))
(assert (forall ((v@@21 T@U) (t0@@9 T@U) (t1@@0 T@U) (h@@9 T@U)) (! (=> (and (and (and (= (type v@@21) (MapType BoxType BoxType)) (= (type t0@@9) TyType)) (= (type t1@@0) TyType)) (= (type h@@9) (MapType1Type refType))) (and (=> ($IsAlloc v@@21 (TMap t0@@9 t1@@0) h@@9) (forall ((bx@@24 T@U)) (! (=> (and (= (type bx@@24) BoxType) (U_2_bool (MapType0Select (|Map#Domain| v@@21) bx@@24))) (and ($IsAllocBox (MapType0Select (|Map#Elements| v@@21) bx@@24) t1@@0 h@@9) ($IsAllocBox bx@@24 t0@@9 h@@9))) :qid |DafnyPre.242:19| :skolemid |65| :pattern ((MapType0Select (|Map#Elements| v@@21) bx@@24)) :pattern ((MapType0Select (|Map#Domain| v@@21) bx@@24))))) (=> (forall ((bx@@25 T@U)) (! (=> (and (= (type bx@@25) BoxType) (U_2_bool (MapType0Select (|Map#Domain| v@@21) bx@@25))) (and ($IsAllocBox (MapType0Select (|Map#Elements| v@@21) bx@@25) t1@@0 h@@9) ($IsAllocBox bx@@25 t0@@9 h@@9))) :qid |DafnyPre.242:19| :skolemid |65| :pattern ((MapType0Select (|Map#Elements| v@@21) bx@@25)) :pattern ((MapType0Select (|Map#Domain| v@@21) bx@@25)))) ($IsAlloc v@@21 (TMap t0@@9 t1@@0) h@@9)))) :qid |DafnyPre.239:15| :skolemid |66| :pattern (($IsAlloc v@@21 (TMap t0@@9 t1@@0) h@@9)))))
(assert (and (forall ((arg0@@46 T@U)) (! (let ((V@@0 (IMapTypeInv1 (type arg0@@46)))) (let ((U@@1 (IMapTypeInv0 (type arg0@@46)))) (= (type (|IMap#Elements| arg0@@46)) (MapType0Type U@@1 V@@0)))) :qid |funType:IMap#Elements| :pattern ((|IMap#Elements| arg0@@46)))) (forall ((arg0@@47 T@U)) (! (let ((U@@2 (IMapTypeInv0 (type arg0@@47)))) (= (type (|IMap#Domain| arg0@@47)) (MapType0Type U@@2 boolType))) :qid |funType:IMap#Domain| :pattern ((|IMap#Domain| arg0@@47))))))
(assert (forall ((v@@22 T@U) (t0@@10 T@U) (t1@@1 T@U)) (! (=> (and (and (= (type v@@22) (IMapType BoxType BoxType)) (= (type t0@@10) TyType)) (= (type t1@@1) TyType)) (and (=> ($Is v@@22 (TIMap t0@@10 t1@@1)) (forall ((bx@@26 T@U)) (! (=> (and (= (type bx@@26) BoxType) (U_2_bool (MapType0Select (|IMap#Domain| v@@22) bx@@26))) (and ($IsBox (MapType0Select (|IMap#Elements| v@@22) bx@@26) t1@@1) ($IsBox bx@@26 t0@@10))) :qid |DafnyPre.251:19| :skolemid |67| :pattern ((MapType0Select (|IMap#Elements| v@@22) bx@@26)) :pattern ((MapType0Select (|IMap#Domain| v@@22) bx@@26))))) (=> (forall ((bx@@27 T@U)) (! (=> (and (= (type bx@@27) BoxType) (U_2_bool (MapType0Select (|IMap#Domain| v@@22) bx@@27))) (and ($IsBox (MapType0Select (|IMap#Elements| v@@22) bx@@27) t1@@1) ($IsBox bx@@27 t0@@10))) :qid |DafnyPre.251:19| :skolemid |67| :pattern ((MapType0Select (|IMap#Elements| v@@22) bx@@27)) :pattern ((MapType0Select (|IMap#Domain| v@@22) bx@@27)))) ($Is v@@22 (TIMap t0@@10 t1@@1))))) :qid |DafnyPre.248:15| :skolemid |68| :pattern (($Is v@@22 (TIMap t0@@10 t1@@1))))))
(assert (forall ((v@@23 T@U) (t0@@11 T@U) (t1@@2 T@U) (h@@10 T@U)) (! (=> (and (and (and (= (type v@@23) (IMapType BoxType BoxType)) (= (type t0@@11) TyType)) (= (type t1@@2) TyType)) (= (type h@@10) (MapType1Type refType))) (and (=> ($IsAlloc v@@23 (TIMap t0@@11 t1@@2) h@@10) (forall ((bx@@28 T@U)) (! (=> (and (= (type bx@@28) BoxType) (U_2_bool (MapType0Select (|IMap#Domain| v@@23) bx@@28))) (and ($IsAllocBox (MapType0Select (|IMap#Elements| v@@23) bx@@28) t1@@2 h@@10) ($IsAllocBox bx@@28 t0@@11 h@@10))) :qid |DafnyPre.259:19| :skolemid |69| :pattern ((MapType0Select (|IMap#Elements| v@@23) bx@@28)) :pattern ((MapType0Select (|IMap#Domain| v@@23) bx@@28))))) (=> (forall ((bx@@29 T@U)) (! (=> (and (= (type bx@@29) BoxType) (U_2_bool (MapType0Select (|IMap#Domain| v@@23) bx@@29))) (and ($IsAllocBox (MapType0Select (|IMap#Elements| v@@23) bx@@29) t1@@2 h@@10) ($IsAllocBox bx@@29 t0@@11 h@@10))) :qid |DafnyPre.259:19| :skolemid |69| :pattern ((MapType0Select (|IMap#Elements| v@@23) bx@@29)) :pattern ((MapType0Select (|IMap#Domain| v@@23) bx@@29)))) ($IsAlloc v@@23 (TIMap t0@@11 t1@@2) h@@10)))) :qid |DafnyPre.256:15| :skolemid |70| :pattern (($IsAlloc v@@23 (TIMap t0@@11 t1@@2) h@@10)))))
(assert (and (and (forall ((arg0@@48 T@U) (arg1@@15 T@U)) (! (= (type (TypeTuple arg0@@48 arg1@@15)) ClassNameType) :qid |funType:TypeTuple| :pattern ((TypeTuple arg0@@48 arg1@@15)))) (forall ((arg0@@49 T@U)) (! (= (type (TypeTupleCar arg0@@49)) ClassNameType) :qid |funType:TypeTupleCar| :pattern ((TypeTupleCar arg0@@49))))) (forall ((arg0@@50 T@U)) (! (= (type (TypeTupleCdr arg0@@50)) ClassNameType) :qid |funType:TypeTupleCdr| :pattern ((TypeTupleCdr arg0@@50))))))
(assert (forall ((a T@U) (b T@U)) (! (=> (and (= (type a) ClassNameType) (= (type b) ClassNameType)) (and (= (TypeTupleCar (TypeTuple a b)) a) (= (TypeTupleCdr (TypeTuple a b)) b))) :qid |DafnyPre.284:15| :skolemid |71| :pattern ((TypeTuple a b)))))
(assert (forall ((arg0@@51 T@U)) (! (= (type (SetRef_to_SetBox arg0@@51)) (MapType0Type BoxType boolType)) :qid |funType:SetRef_to_SetBox| :pattern ((SetRef_to_SetBox arg0@@51)))))
(assert (forall ((s@@1 T@U) (bx@@30 T@U)) (! (=> (and (= (type s@@1) (MapType0Type refType boolType)) (= (type bx@@30) BoxType)) (and (=> (U_2_bool (MapType0Select (SetRef_to_SetBox s@@1) bx@@30)) (U_2_bool (MapType0Select s@@1 ($Unbox refType bx@@30)))) (=> (U_2_bool (MapType0Select s@@1 ($Unbox refType bx@@30))) (U_2_bool (MapType0Select (SetRef_to_SetBox s@@1) bx@@30))))) :qid |DafnyPre.293:15| :skolemid |72| :pattern ((MapType0Select (SetRef_to_SetBox s@@1) bx@@30)))))
(assert (= (type Tclass._System.object) TyType))
(assert (forall ((s@@2 T@U)) (! (=> (= (type s@@2) (MapType0Type refType boolType)) ($Is (SetRef_to_SetBox s@@2) (TSet Tclass._System.object))) :qid |DafnyPre.295:15| :skolemid |73| :pattern ((SetRef_to_SetBox s@@2)))))
(assert (= (Ctor DatatypeTypeType) 15))
(assert (forall ((d T@U)) (! (=> (= (type d) DatatypeTypeType) (= (BoxRank ($Box d)) (DtRank d))) :qid |DafnyPre.310:15| :skolemid |74| :pattern ((BoxRank ($Box d))))))
(assert (and (= (Ctor LayerTypeType) 16) (forall ((arg0@@52 T@U) (arg1@@16 T@U)) (! (let ((A (MapType0TypeInv1 (type arg0@@52)))) (= (type (AtLayer arg0@@52 arg1@@16)) A)) :qid |funType:AtLayer| :pattern ((AtLayer arg0@@52 arg1@@16))))))
(assert (forall ((f T@U) (ly T@U)) (! (let ((A@@0 (MapType0TypeInv1 (type f)))) (=> (and (= (type f) (MapType0Type LayerTypeType A@@0)) (= (type ly) LayerTypeType)) (= (AtLayer f ly) (MapType0Select f ly)))) :qid |DafnyPre.329:18| :skolemid |75| :pattern ((AtLayer f ly)))))
(assert (forall ((arg0@@53 T@U)) (! (= (type ($LS arg0@@53)) LayerTypeType) :qid |funType:$LS| :pattern (($LS arg0@@53)))))
(assert (forall ((f@@0 T@U) (ly@@0 T@U)) (! (let ((A@@1 (MapType0TypeInv1 (type f@@0)))) (=> (and (= (type f@@0) (MapType0Type LayerTypeType A@@1)) (= (type ly@@0) LayerTypeType)) (= (AtLayer f@@0 ($LS ly@@0)) (AtLayer f@@0 ly@@0)))) :qid |DafnyPre.330:18| :skolemid |76| :pattern ((AtLayer f@@0 ($LS ly@@0))))))
(assert (forall ((arg0@@54 Int)) (! (= (type (IndexField arg0@@54)) (FieldType BoxType)) :qid |funType:IndexField| :pattern ((IndexField arg0@@54)))))
(assert (forall ((i@@3 Int)) (! (= (FDim (IndexField i@@3)) 1) :qid |DafnyPre.341:15| :skolemid |77| :pattern ((IndexField i@@3)))))
(assert (forall ((i@@4 Int)) (! (= (IndexField_Inverse (IndexField i@@4)) i@@4) :qid |DafnyPre.343:15| :skolemid |78| :pattern ((IndexField i@@4)))))
(assert (forall ((arg0@@55 T@U) (arg1@@17 Int)) (! (= (type (MultiIndexField arg0@@55 arg1@@17)) (FieldType BoxType)) :qid |funType:MultiIndexField| :pattern ((MultiIndexField arg0@@55 arg1@@17)))))
(assert (forall ((f@@1 T@U) (i@@5 Int)) (! (=> (= (type f@@1) (FieldType BoxType)) (= (FDim (MultiIndexField f@@1 i@@5)) (+ (FDim f@@1) 1))) :qid |DafnyPre.346:15| :skolemid |79| :pattern ((MultiIndexField f@@1 i@@5)))))
(assert (forall ((arg0@@56 T@U)) (! (let ((T@@3 (FieldTypeInv0 (type arg0@@56)))) (= (type (MultiIndexField_Inverse0 arg0@@56)) (FieldType T@@3))) :qid |funType:MultiIndexField_Inverse0| :pattern ((MultiIndexField_Inverse0 arg0@@56)))))
(assert (forall ((f@@2 T@U) (i@@6 Int)) (! (=> (= (type f@@2) (FieldType BoxType)) (and (= (MultiIndexField_Inverse0 (MultiIndexField f@@2 i@@6)) f@@2) (= (MultiIndexField_Inverse1 (MultiIndexField f@@2 i@@6)) i@@6))) :qid |DafnyPre.349:15| :skolemid |80| :pattern ((MultiIndexField f@@2 i@@6)))))
(assert (and (and (and (= (Ctor NameFamilyType) 17) (forall ((alpha@@3 T@T) (arg0@@57 T@U) (arg1@@18 T@U)) (! (= (type (FieldOfDecl alpha@@3 arg0@@57 arg1@@18)) (FieldType alpha@@3)) :qid |funType:FieldOfDecl| :pattern ((FieldOfDecl alpha@@3 arg0@@57 arg1@@18))))) (forall ((arg0@@58 T@U)) (! (= (type (DeclType arg0@@58)) ClassNameType) :qid |funType:DeclType| :pattern ((DeclType arg0@@58))))) (forall ((arg0@@59 T@U)) (! (= (type (DeclName arg0@@59)) NameFamilyType) :qid |funType:DeclName| :pattern ((DeclName arg0@@59))))))
(assert (forall ((cl T@U) (nm T@U) (T@@4 T@T)) (! (=> (and (= (type cl) ClassNameType) (= (type nm) NameFamilyType)) (and (= (DeclType (FieldOfDecl T@@4 cl nm)) cl) (= (DeclName (FieldOfDecl T@@4 cl nm)) nm))) :qid |DafnyPre.358:18| :skolemid |81| :pattern ((FieldOfDecl T@@4 cl nm)))))
(assert (forall ((h@@11 T@U) (k T@U) (v@@24 T@U) (t@@21 T@U)) (! (=> (and (and (and (and (= (type h@@11) (MapType1Type refType)) (= (type k) (MapType1Type refType))) (= (type t@@21) TyType)) ($HeapSucc h@@11 k)) ($IsAlloc v@@24 t@@21 h@@11)) ($IsAlloc v@@24 t@@21 k)) :qid |DafnyPre.371:17| :skolemid |82| :pattern (($HeapSucc h@@11 k) ($IsAlloc v@@24 t@@21 h@@11)))))
(assert (forall ((h@@12 T@U) (k@@0 T@U) (bx@@31 T@U) (t@@22 T@U)) (! (=> (and (and (and (and (and (= (type h@@12) (MapType1Type refType)) (= (type k@@0) (MapType1Type refType))) (= (type bx@@31) BoxType)) (= (type t@@22) TyType)) ($HeapSucc h@@12 k@@0)) ($IsAllocBox bx@@31 t@@22 h@@12)) ($IsAllocBox bx@@31 t@@22 k@@0)) :qid |DafnyPre.374:14| :skolemid |83| :pattern (($HeapSucc h@@12 k@@0) ($IsAllocBox bx@@31 t@@22 h@@12)))))
(assert (= (FDim alloc) 0))
(assert (not ($IsGhostField alloc)))
(assert (forall ((o T@U)) (! (=> (= (type o) refType) (<= 0 (_System.array.Length o))) :qid |DafnyPre.388:15| :skolemid |84| :no-pattern (type o) :no-pattern (U_2_int o) :no-pattern (U_2_bool o))))
(assert (forall ((x@@12 Real)) (! (= (q@Int x@@12) (to_int x@@12)) :qid |DafnyPre.394:14| :skolemid |85| :pattern ((q@Int x@@12)))))
(assert (forall ((x@@13 Int)) (! (= (q@Real x@@13) (to_real x@@13)) :qid |DafnyPre.395:15| :skolemid |86| :pattern ((q@Real x@@13)))))
(assert (forall ((i@@7 Int)) (! (= (q@Int (q@Real i@@7)) i@@7) :qid |DafnyPre.396:15| :skolemid |87| :pattern ((q@Int (q@Real i@@7))))))
(assert (forall ((h@@13 T@U) (r T@U) (f@@3 T@U) (x@@14 T@U)) (! (let ((alpha@@4 (type x@@14))) (=> (and (and (and (= (type h@@13) (MapType1Type refType)) (= (type r) refType)) (= (type f@@3) (FieldType alpha@@4))) ($IsGoodHeap (MapType1Store h@@13 r f@@3 x@@14))) ($HeapSucc h@@13 (MapType1Store h@@13 r f@@3 x@@14)))) :qid |DafnyPre.413:22| :skolemid |88| :pattern ((MapType1Store h@@13 r f@@3 x@@14)))))
(assert (forall ((a@@0 T@U) (b@@0 T@U) (c T@U)) (! (=> (and (and (and (= (type a@@0) (MapType1Type refType)) (= (type b@@0) (MapType1Type refType))) (= (type c) (MapType1Type refType))) (and ($HeapSucc a@@0 b@@0) ($HeapSucc b@@0 c))) ($HeapSucc a@@0 c)) :qid |DafnyPre.416:15| :skolemid |89| :pattern (($HeapSucc a@@0 b@@0) ($HeapSucc b@@0 c)))))
(assert (forall ((h@@14 T@U) (k@@1 T@U)) (! (=> (and (and (= (type h@@14) (MapType1Type refType)) (= (type k@@1) (MapType1Type refType))) ($HeapSucc h@@14 k@@1)) (forall ((o@@0 T@U)) (! (=> (and (= (type o@@0) refType) (U_2_bool (MapType1Select h@@14 o@@0 alloc))) (U_2_bool (MapType1Select k@@1 o@@0 alloc))) :qid |DafnyPre.419:30| :skolemid |90| :pattern ((MapType1Select k@@1 o@@0 alloc))))) :qid |DafnyPre.418:15| :skolemid |91| :pattern (($HeapSucc h@@14 k@@1)))))
(assert (forall ((h@@15 T@U) (k@@2 T@U)) (! (=> (and (and (= (type h@@15) (MapType1Type refType)) (= (type k@@2) (MapType1Type refType))) ($HeapSuccGhost h@@15 k@@2)) (and ($HeapSucc h@@15 k@@2) (forall ((o@@1 T@U) (f@@4 T@U)) (! (let ((alpha@@5 (FieldTypeInv0 (type f@@4)))) (=> (and (and (= (type o@@1) refType) (= (type f@@4) (FieldType alpha@@5))) (not ($IsGhostField f@@4))) (= (MapType1Select h@@15 o@@1 f@@4) (MapType1Select k@@2 o@@1 f@@4)))) :qid |DafnyPre.425:20| :skolemid |92| :pattern ((MapType1Select k@@2 o@@1 f@@4)))))) :qid |DafnyPre.422:15| :skolemid |93| :pattern (($HeapSuccGhost h@@15 k@@2)))))
(assert (forall ((s@@3 T@U)) (! (let ((T@@5 (MapType0TypeInv0 (type s@@3)))) (=> (= (type s@@3) (MapType0Type T@@5 boolType)) (<= 0 (|Set#Card| s@@3)))) :qid |DafnyPre.483:18| :skolemid |98| :pattern ((|Set#Card| s@@3)))))
(assert (forall ((T@@6 T@T)) (! (= (type (|Set#Empty| T@@6)) (MapType0Type T@@6 boolType)) :qid |funType:Set#Empty| :pattern ((|Set#Empty| T@@6)))))
(assert (forall ((o@@2 T@U)) (! (let ((T@@7 (type o@@2))) (not (U_2_bool (MapType0Select (|Set#Empty| T@@7) o@@2)))) :qid |DafnyPre.486:18| :skolemid |99| :pattern ((let ((T@@7 (type o@@2))) (MapType0Select (|Set#Empty| T@@7) o@@2))))))
(assert (forall ((s@@4 T@U)) (! (let ((T@@8 (MapType0TypeInv0 (type s@@4)))) (=> (= (type s@@4) (MapType0Type T@@8 boolType)) (and (and (=> (= (|Set#Card| s@@4) 0) (= s@@4 (|Set#Empty| T@@8))) (=> (= s@@4 (|Set#Empty| T@@8)) (= (|Set#Card| s@@4) 0))) (=> (not (= (|Set#Card| s@@4) 0)) (exists ((x@@15 T@U)) (! (and (= (type x@@15) T@@8) (U_2_bool (MapType0Select s@@4 x@@15))) :qid |DafnyPre.489:33| :skolemid |100| :no-pattern (type x@@15) :no-pattern (U_2_int x@@15) :no-pattern (U_2_bool x@@15))))))) :qid |DafnyPre.487:18| :skolemid |101| :pattern ((|Set#Card| s@@4)))))
(assert (forall ((arg0@@60 T@U)) (! (let ((T@@9 (type arg0@@60))) (= (type (|Set#Singleton| arg0@@60)) (MapType0Type T@@9 boolType))) :qid |funType:Set#Singleton| :pattern ((|Set#Singleton| arg0@@60)))))
(assert (forall ((r@@0 T@U)) (! (U_2_bool (MapType0Select (|Set#Singleton| r@@0) r@@0)) :qid |DafnyPre.495:18| :skolemid |102| :pattern ((|Set#Singleton| r@@0)))))
(assert (forall ((r@@1 T@U) (o@@3 T@U)) (! (let ((T@@10 (type r@@1))) (=> (= (type o@@3) T@@10) (and (=> (U_2_bool (MapType0Select (|Set#Singleton| r@@1) o@@3)) (= r@@1 o@@3)) (=> (= r@@1 o@@3) (U_2_bool (MapType0Select (|Set#Singleton| r@@1) o@@3)))))) :qid |DafnyPre.496:18| :skolemid |103| :pattern ((MapType0Select (|Set#Singleton| r@@1) o@@3)))))
(assert (forall ((r@@2 T@U)) (! (= (|Set#Card| (|Set#Singleton| r@@2)) 1) :qid |DafnyPre.497:18| :skolemid |104| :pattern ((|Set#Card| (|Set#Singleton| r@@2))))))
(assert (forall ((arg0@@61 T@U) (arg1@@19 T@U)) (! (let ((T@@11 (type arg1@@19))) (= (type (|Set#UnionOne| arg0@@61 arg1@@19)) (MapType0Type T@@11 boolType))) :qid |funType:Set#UnionOne| :pattern ((|Set#UnionOne| arg0@@61 arg1@@19)))))
(assert (forall ((a@@1 T@U) (x@@16 T@U) (o@@4 T@U)) (! (let ((T@@12 (type x@@16))) (=> (and (= (type a@@1) (MapType0Type T@@12 boolType)) (= (type o@@4) T@@12)) (and (=> (U_2_bool (MapType0Select (|Set#UnionOne| a@@1 x@@16) o@@4)) (or (= o@@4 x@@16) (U_2_bool (MapType0Select a@@1 o@@4)))) (=> (or (= o@@4 x@@16) (U_2_bool (MapType0Select a@@1 o@@4))) (U_2_bool (MapType0Select (|Set#UnionOne| a@@1 x@@16) o@@4)))))) :qid |DafnyPre.500:18| :skolemid |105| :pattern ((MapType0Select (|Set#UnionOne| a@@1 x@@16) o@@4)))))
(assert (forall ((a@@2 T@U) (x@@17 T@U)) (! (let ((T@@13 (type x@@17))) (=> (= (type a@@2) (MapType0Type T@@13 boolType)) (U_2_bool (MapType0Select (|Set#UnionOne| a@@2 x@@17) x@@17)))) :qid |DafnyPre.502:18| :skolemid |106| :pattern ((|Set#UnionOne| a@@2 x@@17)))))
(assert (forall ((a@@3 T@U) (x@@18 T@U) (y@@1 T@U)) (! (let ((T@@14 (type x@@18))) (=> (and (and (= (type a@@3) (MapType0Type T@@14 boolType)) (= (type y@@1) T@@14)) (U_2_bool (MapType0Select a@@3 y@@1))) (U_2_bool (MapType0Select (|Set#UnionOne| a@@3 x@@18) y@@1)))) :qid |DafnyPre.504:18| :skolemid |107| :pattern ((|Set#UnionOne| a@@3 x@@18) (MapType0Select a@@3 y@@1)))))
(assert (forall ((a@@4 T@U) (x@@19 T@U)) (! (let ((T@@15 (type x@@19))) (=> (and (= (type a@@4) (MapType0Type T@@15 boolType)) (U_2_bool (MapType0Select a@@4 x@@19))) (= (|Set#Card| (|Set#UnionOne| a@@4 x@@19)) (|Set#Card| a@@4)))) :qid |DafnyPre.506:18| :skolemid |108| :pattern ((|Set#Card| (|Set#UnionOne| a@@4 x@@19))))))
(assert (forall ((a@@5 T@U) (x@@20 T@U)) (! (let ((T@@16 (type x@@20))) (=> (and (= (type a@@5) (MapType0Type T@@16 boolType)) (not (U_2_bool (MapType0Select a@@5 x@@20)))) (= (|Set#Card| (|Set#UnionOne| a@@5 x@@20)) (+ (|Set#Card| a@@5) 1)))) :qid |DafnyPre.508:18| :skolemid |109| :pattern ((|Set#Card| (|Set#UnionOne| a@@5 x@@20))))))
(assert (forall ((arg0@@62 T@U) (arg1@@20 T@U)) (! (let ((T@@17 (MapType0TypeInv0 (type arg0@@62)))) (= (type (|Set#Union| arg0@@62 arg1@@20)) (MapType0Type T@@17 boolType))) :qid |funType:Set#Union| :pattern ((|Set#Union| arg0@@62 arg1@@20)))))
(assert (forall ((a@@6 T@U) (b@@1 T@U) (o@@5 T@U)) (! (let ((T@@18 (type o@@5))) (=> (and (= (type a@@6) (MapType0Type T@@18 boolType)) (= (type b@@1) (MapType0Type T@@18 boolType))) (and (=> (U_2_bool (MapType0Select (|Set#Union| a@@6 b@@1) o@@5)) (or (U_2_bool (MapType0Select a@@6 o@@5)) (U_2_bool (MapType0Select b@@1 o@@5)))) (=> (or (U_2_bool (MapType0Select a@@6 o@@5)) (U_2_bool (MapType0Select b@@1 o@@5))) (U_2_bool (MapType0Select (|Set#Union| a@@6 b@@1) o@@5)))))) :qid |DafnyPre.512:18| :skolemid |110| :pattern ((MapType0Select (|Set#Union| a@@6 b@@1) o@@5)))))
(assert (forall ((a@@7 T@U) (b@@2 T@U) (y@@2 T@U)) (! (let ((T@@19 (type y@@2))) (=> (and (and (= (type a@@7) (MapType0Type T@@19 boolType)) (= (type b@@2) (MapType0Type T@@19 boolType))) (U_2_bool (MapType0Select a@@7 y@@2))) (U_2_bool (MapType0Select (|Set#Union| a@@7 b@@2) y@@2)))) :qid |DafnyPre.514:18| :skolemid |111| :pattern ((|Set#Union| a@@7 b@@2) (MapType0Select a@@7 y@@2)))))
(assert (forall ((a@@8 T@U) (b@@3 T@U) (y@@3 T@U)) (! (let ((T@@20 (type y@@3))) (=> (and (and (= (type a@@8) (MapType0Type T@@20 boolType)) (= (type b@@3) (MapType0Type T@@20 boolType))) (U_2_bool (MapType0Select b@@3 y@@3))) (U_2_bool (MapType0Select (|Set#Union| a@@8 b@@3) y@@3)))) :qid |DafnyPre.516:18| :skolemid |112| :pattern ((|Set#Union| a@@8 b@@3) (MapType0Select b@@3 y@@3)))))
(assert (forall ((arg0@@63 T@U) (arg1@@21 T@U)) (! (let ((T@@21 (MapType0TypeInv0 (type arg0@@63)))) (= (type (|Set#Difference| arg0@@63 arg1@@21)) (MapType0Type T@@21 boolType))) :qid |funType:Set#Difference| :pattern ((|Set#Difference| arg0@@63 arg1@@21)))))
(assert (forall ((a@@9 T@U) (b@@4 T@U)) (! (let ((T@@22 (MapType0TypeInv0 (type a@@9)))) (=> (and (and (= (type a@@9) (MapType0Type T@@22 boolType)) (= (type b@@4) (MapType0Type T@@22 boolType))) (|Set#Disjoint| a@@9 b@@4)) (and (= (|Set#Difference| (|Set#Union| a@@9 b@@4) a@@9) b@@4) (= (|Set#Difference| (|Set#Union| a@@9 b@@4) b@@4) a@@9)))) :qid |DafnyPre.518:18| :skolemid |113| :pattern ((|Set#Union| a@@9 b@@4)))))
(assert (forall ((arg0@@64 T@U) (arg1@@22 T@U)) (! (let ((T@@23 (MapType0TypeInv0 (type arg0@@64)))) (= (type (|Set#Intersection| arg0@@64 arg1@@22)) (MapType0Type T@@23 boolType))) :qid |funType:Set#Intersection| :pattern ((|Set#Intersection| arg0@@64 arg1@@22)))))
(assert (forall ((a@@10 T@U) (b@@5 T@U) (o@@6 T@U)) (! (let ((T@@24 (type o@@6))) (=> (and (= (type a@@10) (MapType0Type T@@24 boolType)) (= (type b@@5) (MapType0Type T@@24 boolType))) (and (=> (U_2_bool (MapType0Select (|Set#Intersection| a@@10 b@@5) o@@6)) (and (U_2_bool (MapType0Select a@@10 o@@6)) (U_2_bool (MapType0Select b@@5 o@@6)))) (=> (and (U_2_bool (MapType0Select a@@10 o@@6)) (U_2_bool (MapType0Select b@@5 o@@6))) (U_2_bool (MapType0Select (|Set#Intersection| a@@10 b@@5) o@@6)))))) :qid |DafnyPre.528:18| :skolemid |114| :pattern ((MapType0Select (|Set#Intersection| a@@10 b@@5) o@@6)))))
(assert (forall ((a@@11 T@U) (b@@6 T@U)) (! (let ((T@@25 (MapType0TypeInv0 (type a@@11)))) (=> (and (= (type a@@11) (MapType0Type T@@25 boolType)) (= (type b@@6) (MapType0Type T@@25 boolType))) (= (|Set#Union| (|Set#Union| a@@11 b@@6) b@@6) (|Set#Union| a@@11 b@@6)))) :qid |DafnyPre.531:18| :skolemid |115| :pattern ((|Set#Union| (|Set#Union| a@@11 b@@6) b@@6)))))
(assert (forall ((a@@12 T@U) (b@@7 T@U)) (! (let ((T@@26 (MapType0TypeInv0 (type a@@12)))) (=> (and (= (type a@@12) (MapType0Type T@@26 boolType)) (= (type b@@7) (MapType0Type T@@26 boolType))) (= (|Set#Union| a@@12 (|Set#Union| a@@12 b@@7)) (|Set#Union| a@@12 b@@7)))) :qid |DafnyPre.533:18| :skolemid |116| :pattern ((|Set#Union| a@@12 (|Set#Union| a@@12 b@@7))))))
(assert (forall ((a@@13 T@U) (b@@8 T@U)) (! (let ((T@@27 (MapType0TypeInv0 (type a@@13)))) (=> (and (= (type a@@13) (MapType0Type T@@27 boolType)) (= (type b@@8) (MapType0Type T@@27 boolType))) (= (|Set#Intersection| (|Set#Intersection| a@@13 b@@8) b@@8) (|Set#Intersection| a@@13 b@@8)))) :qid |DafnyPre.535:18| :skolemid |117| :pattern ((|Set#Intersection| (|Set#Intersection| a@@13 b@@8) b@@8)))))
(assert (forall ((a@@14 T@U) (b@@9 T@U)) (! (let ((T@@28 (MapType0TypeInv0 (type a@@14)))) (=> (and (= (type a@@14) (MapType0Type T@@28 boolType)) (= (type b@@9) (MapType0Type T@@28 boolType))) (= (|Set#Intersection| a@@14 (|Set#Intersection| a@@14 b@@9)) (|Set#Intersection| a@@14 b@@9)))) :qid |DafnyPre.537:18| :skolemid |118| :pattern ((|Set#Intersection| a@@14 (|Set#Intersection| a@@14 b@@9))))))
(assert (forall ((a@@15 T@U) (b@@10 T@U)) (! (let ((T@@29 (MapType0TypeInv0 (type a@@15)))) (=> (and (= (type a@@15) (MapType0Type T@@29 boolType)) (= (type b@@10) (MapType0Type T@@29 boolType))) (= (+ (|Set#Card| (|Set#Union| a@@15 b@@10)) (|Set#Card| (|Set#Intersection| a@@15 b@@10))) (+ (|Set#Card| a@@15) (|Set#Card| b@@10))))) :qid |DafnyPre.539:18| :skolemid |119| :pattern ((|Set#Card| (|Set#Union| a@@15 b@@10))) :pattern ((|Set#Card| (|Set#Intersection| a@@15 b@@10))))))
(assert (forall ((a@@16 T@U) (b@@11 T@U) (o@@7 T@U)) (! (let ((T@@30 (type o@@7))) (=> (and (= (type a@@16) (MapType0Type T@@30 boolType)) (= (type b@@11) (MapType0Type T@@30 boolType))) (and (=> (U_2_bool (MapType0Select (|Set#Difference| a@@16 b@@11) o@@7)) (and (U_2_bool (MapType0Select a@@16 o@@7)) (not (U_2_bool (MapType0Select b@@11 o@@7))))) (=> (and (U_2_bool (MapType0Select a@@16 o@@7)) (not (U_2_bool (MapType0Select b@@11 o@@7)))) (U_2_bool (MapType0Select (|Set#Difference| a@@16 b@@11) o@@7)))))) :qid |DafnyPre.543:18| :skolemid |120| :pattern ((MapType0Select (|Set#Difference| a@@16 b@@11) o@@7)))))
(assert (forall ((a@@17 T@U) (b@@12 T@U) (y@@4 T@U)) (! (let ((T@@31 (type y@@4))) (=> (and (and (= (type a@@17) (MapType0Type T@@31 boolType)) (= (type b@@12) (MapType0Type T@@31 boolType))) (U_2_bool (MapType0Select b@@12 y@@4))) (not (U_2_bool (MapType0Select (|Set#Difference| a@@17 b@@12) y@@4))))) :qid |DafnyPre.545:18| :skolemid |121| :pattern ((|Set#Difference| a@@17 b@@12) (MapType0Select b@@12 y@@4)))))
(assert (forall ((a@@18 T@U) (b@@13 T@U)) (! (let ((T@@32 (MapType0TypeInv0 (type a@@18)))) (=> (and (= (type a@@18) (MapType0Type T@@32 boolType)) (= (type b@@13) (MapType0Type T@@32 boolType))) (and (= (+ (+ (|Set#Card| (|Set#Difference| a@@18 b@@13)) (|Set#Card| (|Set#Difference| b@@13 a@@18))) (|Set#Card| (|Set#Intersection| a@@18 b@@13))) (|Set#Card| (|Set#Union| a@@18 b@@13))) (= (|Set#Card| (|Set#Difference| a@@18 b@@13)) (- (|Set#Card| a@@18) (|Set#Card| (|Set#Intersection| a@@18 b@@13))))))) :qid |DafnyPre.547:18| :skolemid |122| :pattern ((|Set#Card| (|Set#Difference| a@@18 b@@13))))))
(assert (forall ((a@@19 T@U) (b@@14 T@U)) (! (let ((T@@33 (MapType0TypeInv0 (type a@@19)))) (=> (and (= (type a@@19) (MapType0Type T@@33 boolType)) (= (type b@@14) (MapType0Type T@@33 boolType))) (and (=> (|Set#Subset| a@@19 b@@14) (forall ((o@@8 T@U)) (! (=> (and (= (type o@@8) T@@33) (U_2_bool (MapType0Select a@@19 o@@8))) (U_2_bool (MapType0Select b@@14 o@@8))) :qid |DafnyPre.556:32| :skolemid |123| :pattern ((MapType0Select a@@19 o@@8)) :pattern ((MapType0Select b@@14 o@@8))))) (=> (forall ((o@@9 T@U)) (! (=> (and (= (type o@@9) T@@33) (U_2_bool (MapType0Select a@@19 o@@9))) (U_2_bool (MapType0Select b@@14 o@@9))) :qid |DafnyPre.556:32| :skolemid |123| :pattern ((MapType0Select a@@19 o@@9)) :pattern ((MapType0Select b@@14 o@@9)))) (|Set#Subset| a@@19 b@@14))))) :qid |DafnyPre.555:17| :skolemid |124| :pattern ((|Set#Subset| a@@19 b@@14)))))
(assert (forall ((a@@20 T@U) (b@@15 T@U)) (! (let ((T@@34 (MapType0TypeInv0 (type a@@20)))) (=> (and (= (type a@@20) (MapType0Type T@@34 boolType)) (= (type b@@15) (MapType0Type T@@34 boolType))) (and (=> (|Set#Equal| a@@20 b@@15) (forall ((o@@10 T@U)) (! (=> (= (type o@@10) T@@34) (and (=> (U_2_bool (MapType0Select a@@20 o@@10)) (U_2_bool (MapType0Select b@@15 o@@10))) (=> (U_2_bool (MapType0Select b@@15 o@@10)) (U_2_bool (MapType0Select a@@20 o@@10))))) :qid |DafnyPre.564:31| :skolemid |125| :pattern ((MapType0Select a@@20 o@@10)) :pattern ((MapType0Select b@@15 o@@10))))) (=> (forall ((o@@11 T@U)) (! (=> (= (type o@@11) T@@34) (and (=> (U_2_bool (MapType0Select a@@20 o@@11)) (U_2_bool (MapType0Select b@@15 o@@11))) (=> (U_2_bool (MapType0Select b@@15 o@@11)) (U_2_bool (MapType0Select a@@20 o@@11))))) :qid |DafnyPre.564:31| :skolemid |125| :pattern ((MapType0Select a@@20 o@@11)) :pattern ((MapType0Select b@@15 o@@11)))) (|Set#Equal| a@@20 b@@15))))) :qid |DafnyPre.563:17| :skolemid |126| :pattern ((|Set#Equal| a@@20 b@@15)))))
(assert (forall ((a@@21 T@U) (b@@16 T@U)) (! (let ((T@@35 (MapType0TypeInv0 (type a@@21)))) (=> (and (and (= (type a@@21) (MapType0Type T@@35 boolType)) (= (type b@@16) (MapType0Type T@@35 boolType))) (|Set#Equal| a@@21 b@@16)) (= a@@21 b@@16))) :qid |DafnyPre.565:17| :skolemid |127| :pattern ((|Set#Equal| a@@21 b@@16)))))
(assert (forall ((a@@22 T@U) (b@@17 T@U)) (! (let ((T@@36 (MapType0TypeInv0 (type a@@22)))) (=> (and (= (type a@@22) (MapType0Type T@@36 boolType)) (= (type b@@17) (MapType0Type T@@36 boolType))) (and (=> (|Set#Disjoint| a@@22 b@@17) (forall ((o@@12 T@U)) (! (=> (= (type o@@12) T@@36) (or (not (U_2_bool (MapType0Select a@@22 o@@12))) (not (U_2_bool (MapType0Select b@@17 o@@12))))) :qid |DafnyPre.570:34| :skolemid |128| :pattern ((MapType0Select a@@22 o@@12)) :pattern ((MapType0Select b@@17 o@@12))))) (=> (forall ((o@@13 T@U)) (! (=> (= (type o@@13) T@@36) (or (not (U_2_bool (MapType0Select a@@22 o@@13))) (not (U_2_bool (MapType0Select b@@17 o@@13))))) :qid |DafnyPre.570:34| :skolemid |128| :pattern ((MapType0Select a@@22 o@@13)) :pattern ((MapType0Select b@@17 o@@13)))) (|Set#Disjoint| a@@22 b@@17))))) :qid |DafnyPre.569:18| :skolemid |129| :pattern ((|Set#Disjoint| a@@22 b@@17)))))
(assert (forall ((T@@37 T@T)) (! (= (type (|ISet#Empty| T@@37)) (MapType0Type T@@37 boolType)) :qid |funType:ISet#Empty| :pattern ((|ISet#Empty| T@@37)))))
(assert (forall ((o@@14 T@U)) (! (let ((T@@38 (type o@@14))) (not (U_2_bool (MapType0Select (|ISet#Empty| T@@38) o@@14)))) :qid |DafnyPre.579:18| :skolemid |130| :pattern ((let ((T@@38 (type o@@14))) (MapType0Select (|ISet#Empty| T@@38) o@@14))))))
(assert (forall ((arg0@@65 T@U) (arg1@@23 T@U)) (! (let ((T@@39 (type arg1@@23))) (= (type (|ISet#UnionOne| arg0@@65 arg1@@23)) (MapType0Type T@@39 boolType))) :qid |funType:ISet#UnionOne| :pattern ((|ISet#UnionOne| arg0@@65 arg1@@23)))))
(assert (forall ((a@@23 T@U) (x@@21 T@U) (o@@15 T@U)) (! (let ((T@@40 (type x@@21))) (=> (and (= (type a@@23) (MapType0Type T@@40 boolType)) (= (type o@@15) T@@40)) (and (=> (U_2_bool (MapType0Select (|ISet#UnionOne| a@@23 x@@21) o@@15)) (or (= o@@15 x@@21) (U_2_bool (MapType0Select a@@23 o@@15)))) (=> (or (= o@@15 x@@21) (U_2_bool (MapType0Select a@@23 o@@15))) (U_2_bool (MapType0Select (|ISet#UnionOne| a@@23 x@@21) o@@15)))))) :qid |DafnyPre.586:18| :skolemid |131| :pattern ((MapType0Select (|ISet#UnionOne| a@@23 x@@21) o@@15)))))
(assert (forall ((a@@24 T@U) (x@@22 T@U)) (! (let ((T@@41 (type x@@22))) (=> (= (type a@@24) (MapType0Type T@@41 boolType)) (U_2_bool (MapType0Select (|ISet#UnionOne| a@@24 x@@22) x@@22)))) :qid |DafnyPre.588:18| :skolemid |132| :pattern ((|ISet#UnionOne| a@@24 x@@22)))))
(assert (forall ((a@@25 T@U) (x@@23 T@U) (y@@5 T@U)) (! (let ((T@@42 (type x@@23))) (=> (and (and (= (type a@@25) (MapType0Type T@@42 boolType)) (= (type y@@5) T@@42)) (U_2_bool (MapType0Select a@@25 y@@5))) (U_2_bool (MapType0Select (|ISet#UnionOne| a@@25 x@@23) y@@5)))) :qid |DafnyPre.590:18| :skolemid |133| :pattern ((|ISet#UnionOne| a@@25 x@@23) (MapType0Select a@@25 y@@5)))))
(assert (forall ((arg0@@66 T@U) (arg1@@24 T@U)) (! (let ((T@@43 (MapType0TypeInv0 (type arg0@@66)))) (= (type (|ISet#Union| arg0@@66 arg1@@24)) (MapType0Type T@@43 boolType))) :qid |funType:ISet#Union| :pattern ((|ISet#Union| arg0@@66 arg1@@24)))))
(assert (forall ((a@@26 T@U) (b@@18 T@U) (o@@16 T@U)) (! (let ((T@@44 (type o@@16))) (=> (and (= (type a@@26) (MapType0Type T@@44 boolType)) (= (type b@@18) (MapType0Type T@@44 boolType))) (and (=> (U_2_bool (MapType0Select (|ISet#Union| a@@26 b@@18) o@@16)) (or (U_2_bool (MapType0Select a@@26 o@@16)) (U_2_bool (MapType0Select b@@18 o@@16)))) (=> (or (U_2_bool (MapType0Select a@@26 o@@16)) (U_2_bool (MapType0Select b@@18 o@@16))) (U_2_bool (MapType0Select (|ISet#Union| a@@26 b@@18) o@@16)))))) :qid |DafnyPre.594:18| :skolemid |134| :pattern ((MapType0Select (|ISet#Union| a@@26 b@@18) o@@16)))))
(assert (forall ((a@@27 T@U) (b@@19 T@U) (y@@6 T@U)) (! (let ((T@@45 (type y@@6))) (=> (and (and (= (type a@@27) (MapType0Type T@@45 boolType)) (= (type b@@19) (MapType0Type T@@45 boolType))) (U_2_bool (MapType0Select a@@27 y@@6))) (U_2_bool (MapType0Select (|ISet#Union| a@@27 b@@19) y@@6)))) :qid |DafnyPre.596:18| :skolemid |135| :pattern ((|ISet#Union| a@@27 b@@19) (MapType0Select a@@27 y@@6)))))
(assert (forall ((a@@28 T@U) (b@@20 T@U) (y@@7 T@U)) (! (let ((T@@46 (type y@@7))) (=> (and (and (= (type a@@28) (MapType0Type T@@46 boolType)) (= (type b@@20) (MapType0Type T@@46 boolType))) (U_2_bool (MapType0Select b@@20 y@@7))) (U_2_bool (MapType0Select (|ISet#Union| a@@28 b@@20) y@@7)))) :qid |DafnyPre.598:18| :skolemid |136| :pattern ((|ISet#Union| a@@28 b@@20) (MapType0Select b@@20 y@@7)))))
(assert (forall ((arg0@@67 T@U) (arg1@@25 T@U)) (! (let ((T@@47 (MapType0TypeInv0 (type arg0@@67)))) (= (type (|ISet#Difference| arg0@@67 arg1@@25)) (MapType0Type T@@47 boolType))) :qid |funType:ISet#Difference| :pattern ((|ISet#Difference| arg0@@67 arg1@@25)))))
(assert (forall ((a@@29 T@U) (b@@21 T@U)) (! (let ((T@@48 (MapType0TypeInv0 (type a@@29)))) (=> (and (and (= (type a@@29) (MapType0Type T@@48 boolType)) (= (type b@@21) (MapType0Type T@@48 boolType))) (|ISet#Disjoint| a@@29 b@@21)) (and (= (|ISet#Difference| (|ISet#Union| a@@29 b@@21) a@@29) b@@21) (= (|ISet#Difference| (|ISet#Union| a@@29 b@@21) b@@21) a@@29)))) :qid |DafnyPre.600:18| :skolemid |137| :pattern ((|ISet#Union| a@@29 b@@21)))))
(assert (forall ((arg0@@68 T@U) (arg1@@26 T@U)) (! (let ((T@@49 (MapType0TypeInv0 (type arg0@@68)))) (= (type (|ISet#Intersection| arg0@@68 arg1@@26)) (MapType0Type T@@49 boolType))) :qid |funType:ISet#Intersection| :pattern ((|ISet#Intersection| arg0@@68 arg1@@26)))))
(assert (forall ((a@@30 T@U) (b@@22 T@U) (o@@17 T@U)) (! (let ((T@@50 (type o@@17))) (=> (and (= (type a@@30) (MapType0Type T@@50 boolType)) (= (type b@@22) (MapType0Type T@@50 boolType))) (and (=> (U_2_bool (MapType0Select (|ISet#Intersection| a@@30 b@@22) o@@17)) (and (U_2_bool (MapType0Select a@@30 o@@17)) (U_2_bool (MapType0Select b@@22 o@@17)))) (=> (and (U_2_bool (MapType0Select a@@30 o@@17)) (U_2_bool (MapType0Select b@@22 o@@17))) (U_2_bool (MapType0Select (|ISet#Intersection| a@@30 b@@22) o@@17)))))) :qid |DafnyPre.610:18| :skolemid |138| :pattern ((MapType0Select (|ISet#Intersection| a@@30 b@@22) o@@17)))))
(assert (forall ((a@@31 T@U) (b@@23 T@U)) (! (let ((T@@51 (MapType0TypeInv0 (type a@@31)))) (=> (and (= (type a@@31) (MapType0Type T@@51 boolType)) (= (type b@@23) (MapType0Type T@@51 boolType))) (= (|ISet#Union| (|ISet#Union| a@@31 b@@23) b@@23) (|ISet#Union| a@@31 b@@23)))) :qid |DafnyPre.613:18| :skolemid |139| :pattern ((|ISet#Union| (|ISet#Union| a@@31 b@@23) b@@23)))))
(assert (forall ((a@@32 T@U) (b@@24 T@U)) (! (let ((T@@52 (MapType0TypeInv0 (type a@@32)))) (=> (and (= (type a@@32) (MapType0Type T@@52 boolType)) (= (type b@@24) (MapType0Type T@@52 boolType))) (= (|ISet#Union| a@@32 (|ISet#Union| a@@32 b@@24)) (|ISet#Union| a@@32 b@@24)))) :qid |DafnyPre.615:18| :skolemid |140| :pattern ((|ISet#Union| a@@32 (|ISet#Union| a@@32 b@@24))))))
(assert (forall ((a@@33 T@U) (b@@25 T@U)) (! (let ((T@@53 (MapType0TypeInv0 (type a@@33)))) (=> (and (= (type a@@33) (MapType0Type T@@53 boolType)) (= (type b@@25) (MapType0Type T@@53 boolType))) (= (|ISet#Intersection| (|ISet#Intersection| a@@33 b@@25) b@@25) (|ISet#Intersection| a@@33 b@@25)))) :qid |DafnyPre.617:18| :skolemid |141| :pattern ((|ISet#Intersection| (|ISet#Intersection| a@@33 b@@25) b@@25)))))
(assert (forall ((a@@34 T@U) (b@@26 T@U)) (! (let ((T@@54 (MapType0TypeInv0 (type a@@34)))) (=> (and (= (type a@@34) (MapType0Type T@@54 boolType)) (= (type b@@26) (MapType0Type T@@54 boolType))) (= (|ISet#Intersection| a@@34 (|ISet#Intersection| a@@34 b@@26)) (|ISet#Intersection| a@@34 b@@26)))) :qid |DafnyPre.619:18| :skolemid |142| :pattern ((|ISet#Intersection| a@@34 (|ISet#Intersection| a@@34 b@@26))))))
(assert (forall ((a@@35 T@U) (b@@27 T@U) (o@@18 T@U)) (! (let ((T@@55 (type o@@18))) (=> (and (= (type a@@35) (MapType0Type T@@55 boolType)) (= (type b@@27) (MapType0Type T@@55 boolType))) (and (=> (U_2_bool (MapType0Select (|ISet#Difference| a@@35 b@@27) o@@18)) (and (U_2_bool (MapType0Select a@@35 o@@18)) (not (U_2_bool (MapType0Select b@@27 o@@18))))) (=> (and (U_2_bool (MapType0Select a@@35 o@@18)) (not (U_2_bool (MapType0Select b@@27 o@@18)))) (U_2_bool (MapType0Select (|ISet#Difference| a@@35 b@@27) o@@18)))))) :qid |DafnyPre.624:18| :skolemid |143| :pattern ((MapType0Select (|ISet#Difference| a@@35 b@@27) o@@18)))))
(assert (forall ((a@@36 T@U) (b@@28 T@U) (y@@8 T@U)) (! (let ((T@@56 (type y@@8))) (=> (and (and (= (type a@@36) (MapType0Type T@@56 boolType)) (= (type b@@28) (MapType0Type T@@56 boolType))) (U_2_bool (MapType0Select b@@28 y@@8))) (not (U_2_bool (MapType0Select (|ISet#Difference| a@@36 b@@28) y@@8))))) :qid |DafnyPre.626:18| :skolemid |144| :pattern ((|ISet#Difference| a@@36 b@@28) (MapType0Select b@@28 y@@8)))))
(assert (forall ((a@@37 T@U) (b@@29 T@U)) (! (let ((T@@57 (MapType0TypeInv0 (type a@@37)))) (=> (and (= (type a@@37) (MapType0Type T@@57 boolType)) (= (type b@@29) (MapType0Type T@@57 boolType))) (and (=> (|ISet#Subset| a@@37 b@@29) (forall ((o@@19 T@U)) (! (=> (and (= (type o@@19) T@@57) (U_2_bool (MapType0Select a@@37 o@@19))) (U_2_bool (MapType0Select b@@29 o@@19))) :qid |DafnyPre.631:33| :skolemid |145| :pattern ((MapType0Select a@@37 o@@19)) :pattern ((MapType0Select b@@29 o@@19))))) (=> (forall ((o@@20 T@U)) (! (=> (and (= (type o@@20) T@@57) (U_2_bool (MapType0Select a@@37 o@@20))) (U_2_bool (MapType0Select b@@29 o@@20))) :qid |DafnyPre.631:33| :skolemid |145| :pattern ((MapType0Select a@@37 o@@20)) :pattern ((MapType0Select b@@29 o@@20)))) (|ISet#Subset| a@@37 b@@29))))) :qid |DafnyPre.630:17| :skolemid |146| :pattern ((|ISet#Subset| a@@37 b@@29)))))
(assert (forall ((a@@38 T@U) (b@@30 T@U)) (! (let ((T@@58 (MapType0TypeInv0 (type a@@38)))) (=> (and (= (type a@@38) (MapType0Type T@@58 boolType)) (= (type b@@30) (MapType0Type T@@58 boolType))) (and (=> (|ISet#Equal| a@@38 b@@30) (forall ((o@@21 T@U)) (! (=> (= (type o@@21) T@@58) (and (=> (U_2_bool (MapType0Select a@@38 o@@21)) (U_2_bool (MapType0Select b@@30 o@@21))) (=> (U_2_bool (MapType0Select b@@30 o@@21)) (U_2_bool (MapType0Select a@@38 o@@21))))) :qid |DafnyPre.639:32| :skolemid |147| :pattern ((MapType0Select a@@38 o@@21)) :pattern ((MapType0Select b@@30 o@@21))))) (=> (forall ((o@@22 T@U)) (! (=> (= (type o@@22) T@@58) (and (=> (U_2_bool (MapType0Select a@@38 o@@22)) (U_2_bool (MapType0Select b@@30 o@@22))) (=> (U_2_bool (MapType0Select b@@30 o@@22)) (U_2_bool (MapType0Select a@@38 o@@22))))) :qid |DafnyPre.639:32| :skolemid |147| :pattern ((MapType0Select a@@38 o@@22)) :pattern ((MapType0Select b@@30 o@@22)))) (|ISet#Equal| a@@38 b@@30))))) :qid |DafnyPre.638:17| :skolemid |148| :pattern ((|ISet#Equal| a@@38 b@@30)))))
(assert (forall ((a@@39 T@U) (b@@31 T@U)) (! (let ((T@@59 (MapType0TypeInv0 (type a@@39)))) (=> (and (and (= (type a@@39) (MapType0Type T@@59 boolType)) (= (type b@@31) (MapType0Type T@@59 boolType))) (|ISet#Equal| a@@39 b@@31)) (= a@@39 b@@31))) :qid |DafnyPre.640:17| :skolemid |149| :pattern ((|ISet#Equal| a@@39 b@@31)))))
(assert (forall ((a@@40 T@U) (b@@32 T@U)) (! (let ((T@@60 (MapType0TypeInv0 (type a@@40)))) (=> (and (= (type a@@40) (MapType0Type T@@60 boolType)) (= (type b@@32) (MapType0Type T@@60 boolType))) (and (=> (|ISet#Disjoint| a@@40 b@@32) (forall ((o@@23 T@U)) (! (=> (= (type o@@23) T@@60) (or (not (U_2_bool (MapType0Select a@@40 o@@23))) (not (U_2_bool (MapType0Select b@@32 o@@23))))) :qid |DafnyPre.645:35| :skolemid |150| :pattern ((MapType0Select a@@40 o@@23)) :pattern ((MapType0Select b@@32 o@@23))))) (=> (forall ((o@@24 T@U)) (! (=> (= (type o@@24) T@@60) (or (not (U_2_bool (MapType0Select a@@40 o@@24))) (not (U_2_bool (MapType0Select b@@32 o@@24))))) :qid |DafnyPre.645:35| :skolemid |150| :pattern ((MapType0Select a@@40 o@@24)) :pattern ((MapType0Select b@@32 o@@24)))) (|ISet#Disjoint| a@@40 b@@32))))) :qid |DafnyPre.644:18| :skolemid |151| :pattern ((|ISet#Disjoint| a@@40 b@@32)))))
(assert (forall ((a@@41 Int) (b@@33 Int)) (! (and (=> (<= a@@41 b@@33) (= (|Math#min| a@@41 b@@33) a@@41)) (=> (= (|Math#min| a@@41 b@@33) a@@41) (<= a@@41 b@@33))) :qid |DafnyPre.652:15| :skolemid |152| :pattern ((|Math#min| a@@41 b@@33)))))
(assert (forall ((a@@42 Int) (b@@34 Int)) (! (and (=> (<= b@@34 a@@42) (= (|Math#min| a@@42 b@@34) b@@34)) (=> (= (|Math#min| a@@42 b@@34) b@@34) (<= b@@34 a@@42))) :qid |DafnyPre.653:15| :skolemid |153| :pattern ((|Math#min| a@@42 b@@34)))))
(assert (forall ((a@@43 Int) (b@@35 Int)) (! (or (= (|Math#min| a@@43 b@@35) a@@43) (= (|Math#min| a@@43 b@@35) b@@35)) :qid |DafnyPre.654:15| :skolemid |154| :pattern ((|Math#min| a@@43 b@@35)))))
(assert (forall ((a@@44 Int)) (! (=> (<= 0 a@@44) (= (|Math#clip| a@@44) a@@44)) :qid |DafnyPre.657:15| :skolemid |155| :pattern ((|Math#clip| a@@44)))))
(assert (forall ((a@@45 Int)) (! (=> (< a@@45 0) (= (|Math#clip| a@@45) 0)) :qid |DafnyPre.658:15| :skolemid |156| :pattern ((|Math#clip| a@@45)))))
(assert (forall ((ms T@U)) (! (let ((T@@61 (MapType0TypeInv0 (type ms)))) (=> (= (type ms) (MapType0Type T@@61 intType)) (and (=> ($IsGoodMultiSet ms) (forall ((bx@@32 T@U)) (! (=> (= (type bx@@32) T@@61) (and (<= 0 (U_2_int (MapType0Select ms bx@@32))) (<= (U_2_int (MapType0Select ms bx@@32)) (|MultiSet#Card| ms)))) :qid |DafnyPre.666:11| :skolemid |157| :pattern ((MapType0Select ms bx@@32))))) (=> (forall ((bx@@33 T@U)) (! (=> (= (type bx@@33) T@@61) (and (<= 0 (U_2_int (MapType0Select ms bx@@33))) (<= (U_2_int (MapType0Select ms bx@@33)) (|MultiSet#Card| ms)))) :qid |DafnyPre.666:11| :skolemid |157| :pattern ((MapType0Select ms bx@@33)))) ($IsGoodMultiSet ms))))) :qid |DafnyPre.664:18| :skolemid |158| :pattern (($IsGoodMultiSet ms)))))
(assert (forall ((s@@5 T@U)) (! (let ((T@@62 (MapType0TypeInv0 (type s@@5)))) (=> (= (type s@@5) (MapType0Type T@@62 intType)) (<= 0 (|MultiSet#Card| s@@5)))) :qid |DafnyPre.669:18| :skolemid |159| :pattern ((|MultiSet#Card| s@@5)))))
(assert (forall ((s@@6 T@U) (x@@24 T@U) (n@@0 T@U)) (! (let ((T@@63 (type x@@24))) (=> (and (and (= (type s@@6) (MapType0Type T@@63 intType)) (= (type n@@0) intType)) (<= 0 (U_2_int n@@0))) (= (|MultiSet#Card| (MapType0Store s@@6 x@@24 n@@0)) (+ (- (|MultiSet#Card| s@@6) (U_2_int (MapType0Select s@@6 x@@24))) (U_2_int n@@0))))) :qid |DafnyPre.670:18| :skolemid |160| :pattern ((|MultiSet#Card| (MapType0Store s@@6 x@@24 n@@0))))))
(assert (forall ((T@@64 T@T)) (! (= (type (|MultiSet#Empty| T@@64)) (MapType0Type T@@64 intType)) :qid |funType:MultiSet#Empty| :pattern ((|MultiSet#Empty| T@@64)))))
(assert (forall ((o@@25 T@U)) (! (let ((T@@65 (type o@@25))) (= (U_2_int (MapType0Select (|MultiSet#Empty| T@@65) o@@25)) 0)) :qid |DafnyPre.674:18| :skolemid |161| :pattern ((let ((T@@65 (type o@@25))) (MapType0Select (|MultiSet#Empty| T@@65) o@@25))))))
(assert (forall ((s@@7 T@U)) (! (let ((T@@66 (MapType0TypeInv0 (type s@@7)))) (=> (= (type s@@7) (MapType0Type T@@66 intType)) (and (and (=> (= (|MultiSet#Card| s@@7) 0) (= s@@7 (|MultiSet#Empty| T@@66))) (=> (= s@@7 (|MultiSet#Empty| T@@66)) (= (|MultiSet#Card| s@@7) 0))) (=> (not (= (|MultiSet#Card| s@@7) 0)) (exists ((x@@25 T@U)) (! (and (= (type x@@25) T@@66) (< 0 (U_2_int (MapType0Select s@@7 x@@25)))) :qid |DafnyPre.677:38| :skolemid |162| :no-pattern (type x@@25) :no-pattern (U_2_int x@@25) :no-pattern (U_2_bool x@@25))))))) :qid |DafnyPre.675:18| :skolemid |163| :pattern ((|MultiSet#Card| s@@7)))))
(assert (forall ((arg0@@69 T@U)) (! (let ((T@@67 (type arg0@@69))) (= (type (|MultiSet#Singleton| arg0@@69)) (MapType0Type T@@67 intType))) :qid |funType:MultiSet#Singleton| :pattern ((|MultiSet#Singleton| arg0@@69)))))
(assert (forall ((r@@3 T@U) (o@@26 T@U)) (! (let ((T@@68 (type r@@3))) (=> (= (type o@@26) T@@68) (and (and (=> (= (U_2_int (MapType0Select (|MultiSet#Singleton| r@@3) o@@26)) 1) (= r@@3 o@@26)) (=> (= r@@3 o@@26) (= (U_2_int (MapType0Select (|MultiSet#Singleton| r@@3) o@@26)) 1))) (and (=> (= (U_2_int (MapType0Select (|MultiSet#Singleton| r@@3) o@@26)) 0) (not (= r@@3 o@@26))) (=> (not (= r@@3 o@@26)) (= (U_2_int (MapType0Select (|MultiSet#Singleton| r@@3) o@@26)) 0)))))) :qid |DafnyPre.680:18| :skolemid |164| :pattern ((MapType0Select (|MultiSet#Singleton| r@@3) o@@26)))))
(assert (forall ((arg0@@70 T@U) (arg1@@27 T@U)) (! (let ((T@@69 (type arg1@@27))) (= (type (|MultiSet#UnionOne| arg0@@70 arg1@@27)) (MapType0Type T@@69 intType))) :qid |funType:MultiSet#UnionOne| :pattern ((|MultiSet#UnionOne| arg0@@70 arg1@@27)))))
(assert (forall ((r@@4 T@U)) (! (let ((T@@70 (type r@@4))) (= (|MultiSet#Singleton| r@@4) (|MultiSet#UnionOne| (|MultiSet#Empty| T@@70) r@@4))) :qid |DafnyPre.682:18| :skolemid |165| :pattern ((|MultiSet#Singleton| r@@4)))))
(assert (forall ((a@@46 T@U) (x@@26 T@U) (o@@27 T@U)) (! (let ((T@@71 (type x@@26))) (=> (and (= (type a@@46) (MapType0Type T@@71 intType)) (= (type o@@27) T@@71)) (and (=> (< 0 (U_2_int (MapType0Select (|MultiSet#UnionOne| a@@46 x@@26) o@@27))) (or (= o@@27 x@@26) (< 0 (U_2_int (MapType0Select a@@46 o@@27))))) (=> (or (= o@@27 x@@26) (< 0 (U_2_int (MapType0Select a@@46 o@@27)))) (< 0 (U_2_int (MapType0Select (|MultiSet#UnionOne| a@@46 x@@26) o@@27))))))) :qid |DafnyPre.686:18| :skolemid |166| :pattern ((MapType0Select (|MultiSet#UnionOne| a@@46 x@@26) o@@27)))))
(assert (forall ((a@@47 T@U) (x@@27 T@U)) (! (let ((T@@72 (type x@@27))) (=> (= (type a@@47) (MapType0Type T@@72 intType)) (= (U_2_int (MapType0Select (|MultiSet#UnionOne| a@@47 x@@27) x@@27)) (+ (U_2_int (MapType0Select a@@47 x@@27)) 1)))) :qid |DafnyPre.689:18| :skolemid |167| :pattern ((|MultiSet#UnionOne| a@@47 x@@27)))))
(assert (forall ((a@@48 T@U) (x@@28 T@U) (y@@9 T@U)) (! (let ((T@@73 (type x@@28))) (=> (and (and (= (type a@@48) (MapType0Type T@@73 intType)) (= (type y@@9) T@@73)) (< 0 (U_2_int (MapType0Select a@@48 y@@9)))) (< 0 (U_2_int (MapType0Select (|MultiSet#UnionOne| a@@48 x@@28) y@@9))))) :qid |DafnyPre.692:18| :skolemid |168| :pattern ((|MultiSet#UnionOne| a@@48 x@@28) (MapType0Select a@@48 y@@9)))))
(assert (forall ((a@@49 T@U) (x@@29 T@U) (y@@10 T@U)) (! (let ((T@@74 (type x@@29))) (=> (and (and (= (type a@@49) (MapType0Type T@@74 intType)) (= (type y@@10) T@@74)) (not (= x@@29 y@@10))) (= (U_2_int (MapType0Select a@@49 y@@10)) (U_2_int (MapType0Select (|MultiSet#UnionOne| a@@49 x@@29) y@@10))))) :qid |DafnyPre.695:18| :skolemid |169| :pattern ((|MultiSet#UnionOne| a@@49 x@@29) (MapType0Select a@@49 y@@10)))))
(assert (forall ((a@@50 T@U) (x@@30 T@U)) (! (let ((T@@75 (type x@@30))) (=> (= (type a@@50) (MapType0Type T@@75 intType)) (= (|MultiSet#Card| (|MultiSet#UnionOne| a@@50 x@@30)) (+ (|MultiSet#Card| a@@50) 1)))) :qid |DafnyPre.697:18| :skolemid |170| :pattern ((|MultiSet#Card| (|MultiSet#UnionOne| a@@50 x@@30))))))
(assert (forall ((arg0@@71 T@U) (arg1@@28 T@U)) (! (let ((T@@76 (MapType0TypeInv0 (type arg0@@71)))) (= (type (|MultiSet#Union| arg0@@71 arg1@@28)) (MapType0Type T@@76 intType))) :qid |funType:MultiSet#Union| :pattern ((|MultiSet#Union| arg0@@71 arg1@@28)))))
(assert (forall ((a@@51 T@U) (b@@36 T@U) (o@@28 T@U)) (! (let ((T@@77 (type o@@28))) (=> (and (= (type a@@51) (MapType0Type T@@77 intType)) (= (type b@@36) (MapType0Type T@@77 intType))) (= (U_2_int (MapType0Select (|MultiSet#Union| a@@51 b@@36) o@@28)) (+ (U_2_int (MapType0Select a@@51 o@@28)) (U_2_int (MapType0Select b@@36 o@@28)))))) :qid |DafnyPre.703:18| :skolemid |171| :pattern ((MapType0Select (|MultiSet#Union| a@@51 b@@36) o@@28)))))
(assert (forall ((a@@52 T@U) (b@@37 T@U)) (! (let ((T@@78 (MapType0TypeInv0 (type a@@52)))) (=> (and (= (type a@@52) (MapType0Type T@@78 intType)) (= (type b@@37) (MapType0Type T@@78 intType))) (= (|MultiSet#Card| (|MultiSet#Union| a@@52 b@@37)) (+ (|MultiSet#Card| a@@52) (|MultiSet#Card| b@@37))))) :qid |DafnyPre.705:18| :skolemid |172| :pattern ((|MultiSet#Card| (|MultiSet#Union| a@@52 b@@37))))))
(assert (forall ((arg0@@72 T@U) (arg1@@29 T@U)) (! (let ((T@@79 (MapType0TypeInv0 (type arg0@@72)))) (= (type (|MultiSet#Intersection| arg0@@72 arg1@@29)) (MapType0Type T@@79 intType))) :qid |funType:MultiSet#Intersection| :pattern ((|MultiSet#Intersection| arg0@@72 arg1@@29)))))
(assert (forall ((a@@53 T@U) (b@@38 T@U) (o@@29 T@U)) (! (let ((T@@80 (type o@@29))) (=> (and (= (type a@@53) (MapType0Type T@@80 intType)) (= (type b@@38) (MapType0Type T@@80 intType))) (= (U_2_int (MapType0Select (|MultiSet#Intersection| a@@53 b@@38) o@@29)) (|Math#min| (U_2_int (MapType0Select a@@53 o@@29)) (U_2_int (MapType0Select b@@38 o@@29)))))) :qid |DafnyPre.709:18| :skolemid |173| :pattern ((MapType0Select (|MultiSet#Intersection| a@@53 b@@38) o@@29)))))
(assert (forall ((a@@54 T@U) (b@@39 T@U)) (! (let ((T@@81 (MapType0TypeInv0 (type a@@54)))) (=> (and (= (type a@@54) (MapType0Type T@@81 intType)) (= (type b@@39) (MapType0Type T@@81 intType))) (= (|MultiSet#Intersection| (|MultiSet#Intersection| a@@54 b@@39) b@@39) (|MultiSet#Intersection| a@@54 b@@39)))) :qid |DafnyPre.713:18| :skolemid |174| :pattern ((|MultiSet#Intersection| (|MultiSet#Intersection| a@@54 b@@39) b@@39)))))
(assert (forall ((a@@55 T@U) (b@@40 T@U)) (! (let ((T@@82 (MapType0TypeInv0 (type a@@55)))) (=> (and (= (type a@@55) (MapType0Type T@@82 intType)) (= (type b@@40) (MapType0Type T@@82 intType))) (= (|MultiSet#Intersection| a@@55 (|MultiSet#Intersection| a@@55 b@@40)) (|MultiSet#Intersection| a@@55 b@@40)))) :qid |DafnyPre.715:18| :skolemid |175| :pattern ((|MultiSet#Intersection| a@@55 (|MultiSet#Intersection| a@@55 b@@40))))))
(assert (forall ((arg0@@73 T@U) (arg1@@30 T@U)) (! (let ((T@@83 (MapType0TypeInv0 (type arg0@@73)))) (= (type (|MultiSet#Difference| arg0@@73 arg1@@30)) (MapType0Type T@@83 intType))) :qid |funType:MultiSet#Difference| :pattern ((|MultiSet#Difference| arg0@@73 arg1@@30)))))
(assert (forall ((a@@56 T@U) (b@@41 T@U) (o@@30 T@U)) (! (let ((T@@84 (type o@@30))) (=> (and (= (type a@@56) (MapType0Type T@@84 intType)) (= (type b@@41) (MapType0Type T@@84 intType))) (= (U_2_int (MapType0Select (|MultiSet#Difference| a@@56 b@@41) o@@30)) (|Math#clip| (- (U_2_int (MapType0Select a@@56 o@@30)) (U_2_int (MapType0Select b@@41 o@@30))))))) :qid |DafnyPre.720:18| :skolemid |176| :pattern ((MapType0Select (|MultiSet#Difference| a@@56 b@@41) o@@30)))))
(assert (forall ((a@@57 T@U) (b@@42 T@U) (y@@11 T@U)) (! (let ((T@@85 (type y@@11))) (=> (and (and (= (type a@@57) (MapType0Type T@@85 intType)) (= (type b@@42) (MapType0Type T@@85 intType))) (<= (U_2_int (MapType0Select a@@57 y@@11)) (U_2_int (MapType0Select b@@42 y@@11)))) (= (U_2_int (MapType0Select (|MultiSet#Difference| a@@57 b@@42) y@@11)) 0))) :qid |DafnyPre.722:18| :skolemid |177| :pattern ((|MultiSet#Difference| a@@57 b@@42) (MapType0Select b@@42 y@@11) (MapType0Select a@@57 y@@11)))))
(assert (forall ((a@@58 T@U) (b@@43 T@U)) (! (let ((T@@86 (MapType0TypeInv0 (type a@@58)))) (=> (and (= (type a@@58) (MapType0Type T@@86 intType)) (= (type b@@43) (MapType0Type T@@86 intType))) (and (= (+ (+ (|MultiSet#Card| (|MultiSet#Difference| a@@58 b@@43)) (|MultiSet#Card| (|MultiSet#Difference| b@@43 a@@58))) (* 2 (|MultiSet#Card| (|MultiSet#Intersection| a@@58 b@@43)))) (|MultiSet#Card| (|MultiSet#Union| a@@58 b@@43))) (= (|MultiSet#Card| (|MultiSet#Difference| a@@58 b@@43)) (- (|MultiSet#Card| a@@58) (|MultiSet#Card| (|MultiSet#Intersection| a@@58 b@@43))))))) :qid |DafnyPre.724:18| :skolemid |178| :pattern ((|MultiSet#Card| (|MultiSet#Difference| a@@58 b@@43))))))
(assert (forall ((a@@59 T@U) (b@@44 T@U)) (! (let ((T@@87 (MapType0TypeInv0 (type a@@59)))) (=> (and (= (type a@@59) (MapType0Type T@@87 intType)) (= (type b@@44) (MapType0Type T@@87 intType))) (and (=> (|MultiSet#Subset| a@@59 b@@44) (forall ((o@@31 T@U)) (! (=> (= (type o@@31) T@@87) (<= (U_2_int (MapType0Select a@@59 o@@31)) (U_2_int (MapType0Select b@@44 o@@31)))) :qid |DafnyPre.734:37| :skolemid |179| :pattern ((MapType0Select a@@59 o@@31)) :pattern ((MapType0Select b@@44 o@@31))))) (=> (forall ((o@@32 T@U)) (! (=> (= (type o@@32) T@@87) (<= (U_2_int (MapType0Select a@@59 o@@32)) (U_2_int (MapType0Select b@@44 o@@32)))) :qid |DafnyPre.734:37| :skolemid |179| :pattern ((MapType0Select a@@59 o@@32)) :pattern ((MapType0Select b@@44 o@@32)))) (|MultiSet#Subset| a@@59 b@@44))))) :qid |DafnyPre.733:17| :skolemid |180| :pattern ((|MultiSet#Subset| a@@59 b@@44)))))
(assert (forall ((a@@60 T@U) (b@@45 T@U)) (! (let ((T@@88 (MapType0TypeInv0 (type a@@60)))) (=> (and (= (type a@@60) (MapType0Type T@@88 intType)) (= (type b@@45) (MapType0Type T@@88 intType))) (and (=> (|MultiSet#Equal| a@@60 b@@45) (forall ((o@@33 T@U)) (! (=> (= (type o@@33) T@@88) (= (U_2_int (MapType0Select a@@60 o@@33)) (U_2_int (MapType0Select b@@45 o@@33)))) :qid |DafnyPre.738:36| :skolemid |181| :pattern ((MapType0Select a@@60 o@@33)) :pattern ((MapType0Select b@@45 o@@33))))) (=> (forall ((o@@34 T@U)) (! (=> (= (type o@@34) T@@88) (= (U_2_int (MapType0Select a@@60 o@@34)) (U_2_int (MapType0Select b@@45 o@@34)))) :qid |DafnyPre.738:36| :skolemid |181| :pattern ((MapType0Select a@@60 o@@34)) :pattern ((MapType0Select b@@45 o@@34)))) (|MultiSet#Equal| a@@60 b@@45))))) :qid |DafnyPre.737:17| :skolemid |182| :pattern ((|MultiSet#Equal| a@@60 b@@45)))))
(assert (forall ((a@@61 T@U) (b@@46 T@U)) (! (let ((T@@89 (MapType0TypeInv0 (type a@@61)))) (=> (and (and (= (type a@@61) (MapType0Type T@@89 intType)) (= (type b@@46) (MapType0Type T@@89 intType))) (|MultiSet#Equal| a@@61 b@@46)) (= a@@61 b@@46))) :qid |DafnyPre.740:17| :skolemid |183| :pattern ((|MultiSet#Equal| a@@61 b@@46)))))
(assert (forall ((a@@62 T@U) (b@@47 T@U)) (! (let ((T@@90 (MapType0TypeInv0 (type a@@62)))) (=> (and (= (type a@@62) (MapType0Type T@@90 intType)) (= (type b@@47) (MapType0Type T@@90 intType))) (and (=> (|MultiSet#Disjoint| a@@62 b@@47) (forall ((o@@35 T@U)) (! (=> (= (type o@@35) T@@90) (or (= (U_2_int (MapType0Select a@@62 o@@35)) 0) (= (U_2_int (MapType0Select b@@47 o@@35)) 0))) :qid |DafnyPre.745:39| :skolemid |184| :pattern ((MapType0Select a@@62 o@@35)) :pattern ((MapType0Select b@@47 o@@35))))) (=> (forall ((o@@36 T@U)) (! (=> (= (type o@@36) T@@90) (or (= (U_2_int (MapType0Select a@@62 o@@36)) 0) (= (U_2_int (MapType0Select b@@47 o@@36)) 0))) :qid |DafnyPre.745:39| :skolemid |184| :pattern ((MapType0Select a@@62 o@@36)) :pattern ((MapType0Select b@@47 o@@36)))) (|MultiSet#Disjoint| a@@62 b@@47))))) :qid |DafnyPre.744:18| :skolemid |185| :pattern ((|MultiSet#Disjoint| a@@62 b@@47)))))
(assert (forall ((arg0@@74 T@U)) (! (let ((T@@91 (MapType0TypeInv0 (type arg0@@74)))) (= (type (|MultiSet#FromSet| arg0@@74)) (MapType0Type T@@91 intType))) :qid |funType:MultiSet#FromSet| :pattern ((|MultiSet#FromSet| arg0@@74)))))
(assert (forall ((s@@8 T@U) (a@@63 T@U)) (! (let ((T@@92 (type a@@63))) (=> (= (type s@@8) (MapType0Type T@@92 boolType)) (and (and (=> (= (U_2_int (MapType0Select (|MultiSet#FromSet| s@@8) a@@63)) 0) (not (U_2_bool (MapType0Select s@@8 a@@63)))) (=> (not (U_2_bool (MapType0Select s@@8 a@@63))) (= (U_2_int (MapType0Select (|MultiSet#FromSet| s@@8) a@@63)) 0))) (and (=> (= (U_2_int (MapType0Select (|MultiSet#FromSet| s@@8) a@@63)) 1) (U_2_bool (MapType0Select s@@8 a@@63))) (=> (U_2_bool (MapType0Select s@@8 a@@63)) (= (U_2_int (MapType0Select (|MultiSet#FromSet| s@@8) a@@63)) 1)))))) :qid |DafnyPre.749:18| :skolemid |186| :pattern ((MapType0Select (|MultiSet#FromSet| s@@8) a@@63)))))
(assert (forall ((s@@9 T@U)) (! (let ((T@@93 (MapType0TypeInv0 (type s@@9)))) (=> (= (type s@@9) (MapType0Type T@@93 boolType)) (= (|MultiSet#Card| (|MultiSet#FromSet| s@@9)) (|Set#Card| s@@9)))) :qid |DafnyPre.752:18| :skolemid |187| :pattern ((|MultiSet#Card| (|MultiSet#FromSet| s@@9))))))
(assert (forall ((arg0@@75 T@U)) (! (let ((T@@94 (SeqTypeInv0 (type arg0@@75)))) (= (type (|MultiSet#FromSeq| arg0@@75)) (MapType0Type T@@94 intType))) :qid |funType:MultiSet#FromSeq| :pattern ((|MultiSet#FromSeq| arg0@@75)))))
(assert (forall ((s@@10 T@U)) (! (let ((T@@95 (SeqTypeInv0 (type s@@10)))) (=> (= (type s@@10) (SeqType T@@95)) ($IsGoodMultiSet (|MultiSet#FromSeq| s@@10)))) :qid |DafnyPre.758:18| :skolemid |188| :pattern ((|MultiSet#FromSeq| s@@10)))))
(assert (forall ((s@@11 T@U)) (! (let ((T@@96 (SeqTypeInv0 (type s@@11)))) (=> (= (type s@@11) (SeqType T@@96)) (= (|MultiSet#Card| (|MultiSet#FromSeq| s@@11)) (|Seq#Length| s@@11)))) :qid |DafnyPre.760:18| :skolemid |189| :pattern ((|MultiSet#Card| (|MultiSet#FromSeq| s@@11))))))
(assert (forall ((arg0@@76 T@U) (arg1@@31 T@U)) (! (let ((T@@97 (type arg1@@31))) (= (type (|Seq#Build| arg0@@76 arg1@@31)) (SeqType T@@97))) :qid |funType:Seq#Build| :pattern ((|Seq#Build| arg0@@76 arg1@@31)))))
(assert (forall ((s@@12 T@U) (v@@25 T@U)) (! (let ((T@@98 (type v@@25))) (=> (= (type s@@12) (SeqType T@@98)) (= (|MultiSet#FromSeq| (|Seq#Build| s@@12 v@@25)) (|MultiSet#UnionOne| (|MultiSet#FromSeq| s@@12) v@@25)))) :qid |DafnyPre.764:18| :skolemid |190| :pattern ((|MultiSet#FromSeq| (|Seq#Build| s@@12 v@@25))))))
(assert (forall ((T@@99 T@T)) (! (= (type (|Seq#Empty| T@@99)) (SeqType T@@99)) :qid |funType:Seq#Empty| :pattern ((|Seq#Empty| T@@99)))))
(assert (forall ((T@@100 T@T)) (! (= (|MultiSet#FromSeq| (|Seq#Empty| T@@100)) (|MultiSet#Empty| T@@100)) :skolemid |191|)))
(assert (forall ((arg0@@77 T@U) (arg1@@32 T@U)) (! (let ((T@@101 (SeqTypeInv0 (type arg0@@77)))) (= (type (|Seq#Append| arg0@@77 arg1@@32)) (SeqType T@@101))) :qid |funType:Seq#Append| :pattern ((|Seq#Append| arg0@@77 arg1@@32)))))
(assert (forall ((a@@64 T@U) (b@@48 T@U)) (! (let ((T@@102 (SeqTypeInv0 (type a@@64)))) (=> (and (= (type a@@64) (SeqType T@@102)) (= (type b@@48) (SeqType T@@102))) (= (|MultiSet#FromSeq| (|Seq#Append| a@@64 b@@48)) (|MultiSet#Union| (|MultiSet#FromSeq| a@@64) (|MultiSet#FromSeq| b@@48))))) :qid |DafnyPre.771:18| :skolemid |192| :pattern ((|MultiSet#FromSeq| (|Seq#Append| a@@64 b@@48))))))
(assert (forall ((arg0@@78 T@U) (arg1@@33 Int) (arg2@@2 T@U)) (! (let ((T@@103 (type arg2@@2))) (= (type (|Seq#Update| arg0@@78 arg1@@33 arg2@@2)) (SeqType T@@103))) :qid |funType:Seq#Update| :pattern ((|Seq#Update| arg0@@78 arg1@@33 arg2@@2)))))
(assert (forall ((s@@13 T@U) (i@@8 Int) (v@@26 T@U) (x@@31 T@U)) (! (let ((T@@104 (type v@@26))) (=> (and (and (= (type s@@13) (SeqType T@@104)) (= (type x@@31) T@@104)) (and (<= 0 i@@8) (< i@@8 (|Seq#Length| s@@13)))) (= (U_2_int (MapType0Select (|MultiSet#FromSeq| (|Seq#Update| s@@13 i@@8 v@@26)) x@@31)) (U_2_int (MapType0Select (|MultiSet#Union| (|MultiSet#Difference| (|MultiSet#FromSeq| s@@13) (|MultiSet#Singleton| (|Seq#Index| s@@13 i@@8))) (|MultiSet#Singleton| v@@26)) x@@31))))) :qid |DafnyPre.776:18| :skolemid |193| :pattern ((MapType0Select (|MultiSet#FromSeq| (|Seq#Update| s@@13 i@@8 v@@26)) x@@31)))))
(assert (forall ((s@@14 T@U) (x@@32 T@U)) (! (let ((T@@105 (type x@@32))) (=> (= (type s@@14) (SeqType T@@105)) (and (=> (exists ((i@@9 Int)) (! (and (and (<= 0 i@@9) (< i@@9 (|Seq#Length| s@@14))) (= x@@32 (|Seq#Index| s@@14 i@@9))) :qid |DafnyPre.783:11| :skolemid |194| :pattern ((|Seq#Index| s@@14 i@@9)))) (< 0 (U_2_int (MapType0Select (|MultiSet#FromSeq| s@@14) x@@32)))) (=> (< 0 (U_2_int (MapType0Select (|MultiSet#FromSeq| s@@14) x@@32))) (exists ((i@@10 Int)) (! (and (and (<= 0 i@@10) (< i@@10 (|Seq#Length| s@@14))) (= x@@32 (|Seq#Index| s@@14 i@@10))) :qid |DafnyPre.783:11| :skolemid |194| :pattern ((|Seq#Index| s@@14 i@@10)))))))) :qid |DafnyPre.782:18| :skolemid |195| :pattern ((MapType0Select (|MultiSet#FromSeq| s@@14) x@@32)))))
(assert (forall ((s@@15 T@U)) (! (let ((T@@106 (SeqTypeInv0 (type s@@15)))) (=> (= (type s@@15) (SeqType T@@106)) (<= 0 (|Seq#Length| s@@15)))) :qid |DafnyPre.792:18| :skolemid |196| :pattern ((|Seq#Length| s@@15)))))
(assert (forall ((T@@107 T@T)) (! (= (|Seq#Length| (|Seq#Empty| T@@107)) 0) :skolemid |197|)))
(assert (forall ((s@@16 T@U)) (! (let ((T@@108 (SeqTypeInv0 (type s@@16)))) (=> (and (= (type s@@16) (SeqType T@@108)) (= (|Seq#Length| s@@16) 0)) (= s@@16 (|Seq#Empty| T@@108)))) :qid |DafnyPre.796:18| :skolemid |198| :pattern ((|Seq#Length| s@@16)))))
(assert (forall ((t@@23 T@U) (T@@109 T@T)) (! (=> (= (type t@@23) TyType) ($Is (|Seq#Empty| T@@109) t@@23)) :qid |DafnyPre.806:18| :skolemid |199| :pattern (($Is (|Seq#Empty| T@@109) t@@23)))))
(assert (forall ((arg0@@79 T@U)) (! (let ((T@@110 (type arg0@@79))) (= (type (|Seq#Singleton| arg0@@79)) (SeqType T@@110))) :qid |funType:Seq#Singleton| :pattern ((|Seq#Singleton| arg0@@79)))))
(assert (forall ((t@@24 T@U)) (! (= (|Seq#Length| (|Seq#Singleton| t@@24)) 1) :qid |DafnyPre.809:18| :skolemid |200| :pattern ((|Seq#Length| (|Seq#Singleton| t@@24))))))
(assert (forall ((s@@17 T@U) (v@@27 T@U)) (! (let ((T@@111 (type v@@27))) (=> (= (type s@@17) (SeqType T@@111)) (= (|Seq#Length| (|Seq#Build| s@@17 v@@27)) (+ 1 (|Seq#Length| s@@17))))) :qid |DafnyPre.812:18| :skolemid |201| :pattern ((|Seq#Length| (|Seq#Build| s@@17 v@@27))))))
(assert (forall ((s@@18 T@U) (i@@11 Int) (v@@28 T@U)) (! (let ((T@@112 (type v@@28))) (=> (= (type s@@18) (SeqType T@@112)) (and (=> (= i@@11 (|Seq#Length| s@@18)) (= (|Seq#Index| (|Seq#Build| s@@18 v@@28) i@@11) v@@28)) (=> (not (= i@@11 (|Seq#Length| s@@18))) (= (|Seq#Index| (|Seq#Build| s@@18 v@@28) i@@11) (|Seq#Index| s@@18 i@@11)))))) :qid |DafnyPre.814:18| :skolemid |202| :pattern ((|Seq#Index| (|Seq#Build| s@@18 v@@28) i@@11)))))
(assert (forall ((s@@19 T@U) (bx@@34 T@U) (t@@25 T@U)) (! (=> (and (and (and (= (type s@@19) (SeqType BoxType)) (= (type bx@@34) BoxType)) (= (type t@@25) TyType)) (and ($Is s@@19 (TSeq t@@25)) ($IsBox bx@@34 t@@25))) ($Is (|Seq#Build| s@@19 bx@@34) (TSeq t@@25))) :qid |DafnyPre.819:15| :skolemid |203| :pattern (($Is (|Seq#Build| s@@19 bx@@34) (TSeq t@@25))))))
(assert (forall ((s0 T@U) (s1 T@U)) (! (let ((T@@113 (SeqTypeInv0 (type s0)))) (=> (and (= (type s0) (SeqType T@@113)) (= (type s1) (SeqType T@@113))) (= (|Seq#Length| (|Seq#Append| s0 s1)) (+ (|Seq#Length| s0) (|Seq#Length| s1))))) :qid |DafnyPre.823:18| :skolemid |204| :pattern ((|Seq#Length| (|Seq#Append| s0 s1))))))
(assert (forall ((s0@@0 T@U) (s1@@0 T@U) (t@@26 T@U)) (! (=> (and (and (and (= (type s0@@0) (SeqType BoxType)) (= (type s1@@0) (SeqType BoxType))) (= (type t@@26) TyType)) (and ($Is s0@@0 t@@26) ($Is s1@@0 t@@26))) ($Is (|Seq#Append| s0@@0 s1@@0) t@@26)) :qid |DafnyPre.827:15| :skolemid |205| :pattern (($Is (|Seq#Append| s0@@0 s1@@0) t@@26)))))
(assert (forall ((t@@27 T@U)) (! (= (|Seq#Index| (|Seq#Singleton| t@@27) 0) t@@27) :qid |DafnyPre.831:18| :skolemid |206| :pattern ((|Seq#Index| (|Seq#Singleton| t@@27) 0)))))
(assert (forall ((s0@@1 T@U) (s1@@1 T@U) (n@@1 Int)) (! (let ((T@@114 (SeqTypeInv0 (type s0@@1)))) (=> (and (= (type s0@@1) (SeqType T@@114)) (= (type s1@@1) (SeqType T@@114))) (and (=> (< n@@1 (|Seq#Length| s0@@1)) (= (|Seq#Index| (|Seq#Append| s0@@1 s1@@1) n@@1) (|Seq#Index| s0@@1 n@@1))) (=> (<= (|Seq#Length| s0@@1) n@@1) (= (|Seq#Index| (|Seq#Append| s0@@1 s1@@1) n@@1) (|Seq#Index| s1@@1 (- n@@1 (|Seq#Length| s0@@1)))))))) :qid |DafnyPre.832:18| :skolemid |207| :pattern ((|Seq#Index| (|Seq#Append| s0@@1 s1@@1) n@@1)))))
(assert (forall ((s@@20 T@U) (i@@12 Int) (v@@29 T@U)) (! (let ((T@@115 (type v@@29))) (=> (= (type s@@20) (SeqType T@@115)) (=> (and (<= 0 i@@12) (< i@@12 (|Seq#Length| s@@20))) (= (|Seq#Length| (|Seq#Update| s@@20 i@@12 v@@29)) (|Seq#Length| s@@20))))) :qid |DafnyPre.837:18| :skolemid |208| :pattern ((|Seq#Length| (|Seq#Update| s@@20 i@@12 v@@29))))))
(assert (forall ((s@@21 T@U) (i@@13 Int) (v@@30 T@U) (n@@2 Int)) (! (let ((T@@116 (type v@@30))) (=> (= (type s@@21) (SeqType T@@116)) (=> (and (<= 0 n@@2) (< n@@2 (|Seq#Length| s@@21))) (and (=> (= i@@13 n@@2) (= (|Seq#Index| (|Seq#Update| s@@21 i@@13 v@@30) n@@2) v@@30)) (=> (not (= i@@13 n@@2)) (= (|Seq#Index| (|Seq#Update| s@@21 i@@13 v@@30) n@@2) (|Seq#Index| s@@21 n@@2))))))) :qid |DafnyPre.839:18| :skolemid |209| :pattern ((|Seq#Index| (|Seq#Update| s@@21 i@@13 v@@30) n@@2)))))
(assert (forall ((s@@22 T@U) (x@@33 T@U)) (! (let ((T@@117 (type x@@33))) (=> (= (type s@@22) (SeqType T@@117)) (and (=> (|Seq#Contains| s@@22 x@@33) (exists ((i@@14 Int)) (! (and (and (<= 0 i@@14) (< i@@14 (|Seq#Length| s@@22))) (= (|Seq#Index| s@@22 i@@14) x@@33)) :qid |DafnyPre.847:13| :skolemid |210| :pattern ((|Seq#Index| s@@22 i@@14))))) (=> (exists ((i@@15 Int)) (! (and (and (<= 0 i@@15) (< i@@15 (|Seq#Length| s@@22))) (= (|Seq#Index| s@@22 i@@15) x@@33)) :qid |DafnyPre.847:13| :skolemid |210| :pattern ((|Seq#Index| s@@22 i@@15)))) (|Seq#Contains| s@@22 x@@33))))) :qid |DafnyPre.845:18| :skolemid |211| :pattern ((|Seq#Contains| s@@22 x@@33)))))
(assert (forall ((x@@34 T@U)) (! (let ((T@@118 (type x@@34))) (not (|Seq#Contains| (|Seq#Empty| T@@118) x@@34))) :qid |DafnyPre.848:18| :skolemid |212| :pattern ((let ((T@@118 (type x@@34))) (|Seq#Contains| (|Seq#Empty| T@@118) x@@34))))))
(assert (forall ((s0@@2 T@U) (s1@@2 T@U) (x@@35 T@U)) (! (let ((T@@119 (type x@@35))) (=> (and (= (type s0@@2) (SeqType T@@119)) (= (type s1@@2) (SeqType T@@119))) (and (=> (|Seq#Contains| (|Seq#Append| s0@@2 s1@@2) x@@35) (or (|Seq#Contains| s0@@2 x@@35) (|Seq#Contains| s1@@2 x@@35))) (=> (or (|Seq#Contains| s0@@2 x@@35) (|Seq#Contains| s1@@2 x@@35)) (|Seq#Contains| (|Seq#Append| s0@@2 s1@@2) x@@35))))) :qid |DafnyPre.852:18| :skolemid |213| :pattern ((|Seq#Contains| (|Seq#Append| s0@@2 s1@@2) x@@35)))))
(assert (forall ((s@@23 T@U) (v@@31 T@U) (x@@36 T@U)) (! (let ((T@@120 (type v@@31))) (=> (and (= (type s@@23) (SeqType T@@120)) (= (type x@@36) T@@120)) (and (=> (|Seq#Contains| (|Seq#Build| s@@23 v@@31) x@@36) (or (= v@@31 x@@36) (|Seq#Contains| s@@23 x@@36))) (=> (or (= v@@31 x@@36) (|Seq#Contains| s@@23 x@@36)) (|Seq#Contains| (|Seq#Build| s@@23 v@@31) x@@36))))) :qid |DafnyPre.857:18| :skolemid |214| :pattern ((|Seq#Contains| (|Seq#Build| s@@23 v@@31) x@@36)))))
(assert (forall ((arg0@@80 T@U) (arg1@@34 Int)) (! (let ((T@@121 (SeqTypeInv0 (type arg0@@80)))) (= (type (|Seq#Take| arg0@@80 arg1@@34)) (SeqType T@@121))) :qid |funType:Seq#Take| :pattern ((|Seq#Take| arg0@@80 arg1@@34)))))
(assert (forall ((s@@24 T@U) (n@@3 Int) (x@@37 T@U)) (! (let ((T@@122 (type x@@37))) (=> (= (type s@@24) (SeqType T@@122)) (and (=> (|Seq#Contains| (|Seq#Take| s@@24 n@@3) x@@37) (exists ((i@@16 Int)) (! (and (and (and (<= 0 i@@16) (< i@@16 n@@3)) (< i@@16 (|Seq#Length| s@@24))) (= (|Seq#Index| s@@24 i@@16) x@@37)) :qid |DafnyPre.864:13| :skolemid |215| :pattern ((|Seq#Index| s@@24 i@@16))))) (=> (exists ((i@@17 Int)) (! (and (and (and (<= 0 i@@17) (< i@@17 n@@3)) (< i@@17 (|Seq#Length| s@@24))) (= (|Seq#Index| s@@24 i@@17) x@@37)) :qid |DafnyPre.864:13| :skolemid |215| :pattern ((|Seq#Index| s@@24 i@@17)))) (|Seq#Contains| (|Seq#Take| s@@24 n@@3) x@@37))))) :qid |DafnyPre.861:18| :skolemid |216| :pattern ((|Seq#Contains| (|Seq#Take| s@@24 n@@3) x@@37)))))
(assert (forall ((arg0@@81 T@U) (arg1@@35 Int)) (! (let ((T@@123 (SeqTypeInv0 (type arg0@@81)))) (= (type (|Seq#Drop| arg0@@81 arg1@@35)) (SeqType T@@123))) :qid |funType:Seq#Drop| :pattern ((|Seq#Drop| arg0@@81 arg1@@35)))))
(assert (forall ((s@@25 T@U) (n@@4 Int) (x@@38 T@U)) (! (let ((T@@124 (type x@@38))) (=> (= (type s@@25) (SeqType T@@124)) (and (=> (|Seq#Contains| (|Seq#Drop| s@@25 n@@4) x@@38) (exists ((i@@18 Int)) (! (and (and (and (<= 0 n@@4) (<= n@@4 i@@18)) (< i@@18 (|Seq#Length| s@@25))) (= (|Seq#Index| s@@25 i@@18) x@@38)) :qid |DafnyPre.869:13| :skolemid |217| :pattern ((|Seq#Index| s@@25 i@@18))))) (=> (exists ((i@@19 Int)) (! (and (and (and (<= 0 n@@4) (<= n@@4 i@@19)) (< i@@19 (|Seq#Length| s@@25))) (= (|Seq#Index| s@@25 i@@19) x@@38)) :qid |DafnyPre.869:13| :skolemid |217| :pattern ((|Seq#Index| s@@25 i@@19)))) (|Seq#Contains| (|Seq#Drop| s@@25 n@@4) x@@38))))) :qid |DafnyPre.866:18| :skolemid |218| :pattern ((|Seq#Contains| (|Seq#Drop| s@@25 n@@4) x@@38)))))
(assert (forall ((s0@@3 T@U) (s1@@3 T@U)) (! (let ((T@@125 (SeqTypeInv0 (type s0@@3)))) (=> (and (= (type s0@@3) (SeqType T@@125)) (= (type s1@@3) (SeqType T@@125))) (and (=> (|Seq#Equal| s0@@3 s1@@3) (and (= (|Seq#Length| s0@@3) (|Seq#Length| s1@@3)) (forall ((j Int)) (! (=> (and (<= 0 j) (< j (|Seq#Length| s0@@3))) (= (|Seq#Index| s0@@3 j) (|Seq#Index| s1@@3 j))) :qid |DafnyPre.876:13| :skolemid |219| :pattern ((|Seq#Index| s0@@3 j)) :pattern ((|Seq#Index| s1@@3 j)))))) (=> (and (= (|Seq#Length| s0@@3) (|Seq#Length| s1@@3)) (forall ((j@@0 Int)) (! (=> (and (<= 0 j@@0) (< j@@0 (|Seq#Length| s0@@3))) (= (|Seq#Index| s0@@3 j@@0) (|Seq#Index| s1@@3 j@@0))) :qid |DafnyPre.876:13| :skolemid |219| :pattern ((|Seq#Index| s0@@3 j@@0)) :pattern ((|Seq#Index| s1@@3 j@@0))))) (|Seq#Equal| s0@@3 s1@@3))))) :qid |DafnyPre.873:18| :skolemid |220| :pattern ((|Seq#Equal| s0@@3 s1@@3)))))
(assert (forall ((a@@65 T@U) (b@@49 T@U)) (! (let ((T@@126 (SeqTypeInv0 (type a@@65)))) (=> (and (and (= (type a@@65) (SeqType T@@126)) (= (type b@@49) (SeqType T@@126))) (|Seq#Equal| a@@65 b@@49)) (= a@@65 b@@49))) :qid |DafnyPre.878:18| :skolemid |221| :pattern ((|Seq#Equal| a@@65 b@@49)))))
(assert (forall ((s0@@4 T@U) (s1@@4 T@U) (n@@5 Int)) (! (let ((T@@127 (SeqTypeInv0 (type s0@@4)))) (=> (and (= (type s0@@4) (SeqType T@@127)) (= (type s1@@4) (SeqType T@@127))) (and (=> (|Seq#SameUntil| s0@@4 s1@@4 n@@5) (forall ((j@@1 Int)) (! (=> (and (<= 0 j@@1) (< j@@1 n@@5)) (= (|Seq#Index| s0@@4 j@@1) (|Seq#Index| s1@@4 j@@1))) :qid |DafnyPre.884:13| :skolemid |222| :pattern ((|Seq#Index| s0@@4 j@@1)) :pattern ((|Seq#Index| s1@@4 j@@1))))) (=> (forall ((j@@2 Int)) (! (=> (and (<= 0 j@@2) (< j@@2 n@@5)) (= (|Seq#Index| s0@@4 j@@2) (|Seq#Index| s1@@4 j@@2))) :qid |DafnyPre.884:13| :skolemid |222| :pattern ((|Seq#Index| s0@@4 j@@2)) :pattern ((|Seq#Index| s1@@4 j@@2)))) (|Seq#SameUntil| s0@@4 s1@@4 n@@5))))) :qid |DafnyPre.882:18| :skolemid |223| :pattern ((|Seq#SameUntil| s0@@4 s1@@4 n@@5)))))
(assert (forall ((s@@26 T@U) (n@@6 Int)) (! (let ((T@@128 (SeqTypeInv0 (type s@@26)))) (=> (= (type s@@26) (SeqType T@@128)) (=> (and (<= 0 n@@6) (<= n@@6 (|Seq#Length| s@@26))) (= (|Seq#Length| (|Seq#Take| s@@26 n@@6)) n@@6)))) :qid |DafnyPre.888:18| :skolemid |224| :pattern ((|Seq#Length| (|Seq#Take| s@@26 n@@6))))))
(assert (forall ((s@@27 T@U) (n@@7 Int) (j@@3 Int)) (! (let ((T@@129 (SeqTypeInv0 (type s@@27)))) (=> (= (type s@@27) (SeqType T@@129)) (=> (and (and (<= 0 j@@3) (< j@@3 n@@7)) (< j@@3 (|Seq#Length| s@@27))) (= (|Seq#Index| (|Seq#Take| s@@27 n@@7) j@@3) (|Seq#Index| s@@27 j@@3))))) :qid |DafnyPre.890:18| :weight 25 :skolemid |225| :pattern ((|Seq#Index| (|Seq#Take| s@@27 n@@7) j@@3)) :pattern ((|Seq#Index| s@@27 j@@3) (|Seq#Take| s@@27 n@@7)))))
(assert (forall ((s@@28 T@U) (n@@8 Int)) (! (let ((T@@130 (SeqTypeInv0 (type s@@28)))) (=> (= (type s@@28) (SeqType T@@130)) (=> (and (<= 0 n@@8) (<= n@@8 (|Seq#Length| s@@28))) (= (|Seq#Length| (|Seq#Drop| s@@28 n@@8)) (- (|Seq#Length| s@@28) n@@8))))) :qid |DafnyPre.898:18| :skolemid |226| :pattern ((|Seq#Length| (|Seq#Drop| s@@28 n@@8))))))
(assert (forall ((s@@29 T@U) (n@@9 Int) (j@@4 Int)) (! (let ((T@@131 (SeqTypeInv0 (type s@@29)))) (=> (= (type s@@29) (SeqType T@@131)) (=> (and (and (<= 0 n@@9) (<= 0 j@@4)) (< j@@4 (- (|Seq#Length| s@@29) n@@9))) (= (|Seq#Index| (|Seq#Drop| s@@29 n@@9) j@@4) (|Seq#Index| s@@29 (+ j@@4 n@@9)))))) :qid |DafnyPre.900:18| :weight 25 :skolemid |227| :pattern ((|Seq#Index| (|Seq#Drop| s@@29 n@@9) j@@4)))))
(assert (forall ((s@@30 T@U) (n@@10 Int) (k@@3 Int)) (! (let ((T@@132 (SeqTypeInv0 (type s@@30)))) (=> (= (type s@@30) (SeqType T@@132)) (=> (and (and (<= 0 n@@10) (<= n@@10 k@@3)) (< k@@3 (|Seq#Length| s@@30))) (= (|Seq#Index| (|Seq#Drop| s@@30 n@@10) (- k@@3 n@@10)) (|Seq#Index| s@@30 k@@3))))) :qid |DafnyPre.905:18| :weight 25 :skolemid |228| :pattern ((|Seq#Index| s@@30 k@@3) (|Seq#Drop| s@@30 n@@10)))))
(assert (forall ((s@@31 T@U) (t@@28 T@U)) (! (let ((T@@133 (SeqTypeInv0 (type s@@31)))) (=> (and (= (type s@@31) (SeqType T@@133)) (= (type t@@28) (SeqType T@@133))) (and (= (|Seq#Take| (|Seq#Append| s@@31 t@@28) (|Seq#Length| s@@31)) s@@31) (= (|Seq#Drop| (|Seq#Append| s@@31 t@@28) (|Seq#Length| s@@31)) t@@28)))) :qid |DafnyPre.911:18| :skolemid |229| :pattern ((|Seq#Append| s@@31 t@@28)))))
(assert (forall ((arg0@@82 T@U) (arg1@@36 T@U)) (! (= (type (|Seq#FromArray| arg0@@82 arg1@@36)) (SeqType BoxType)) :qid |funType:Seq#FromArray| :pattern ((|Seq#FromArray| arg0@@82 arg1@@36)))))
(assert (forall ((h@@16 T@U) (a@@66 T@U)) (! (=> (and (= (type h@@16) (MapType1Type refType)) (= (type a@@66) refType)) (= (|Seq#Length| (|Seq#FromArray| h@@16 a@@66)) (_System.array.Length a@@66))) :qid |DafnyPre.917:15| :skolemid |230| :pattern ((|Seq#Length| (|Seq#FromArray| h@@16 a@@66))))))
(assert (forall ((h@@17 T@U) (a@@67 T@U)) (! (=> (and (= (type h@@17) (MapType1Type refType)) (= (type a@@67) refType)) (forall ((i@@20 Int)) (! (=> (and (<= 0 i@@20) (< i@@20 (|Seq#Length| (|Seq#FromArray| h@@17 a@@67)))) (= (|Seq#Index| (|Seq#FromArray| h@@17 a@@67) i@@20) (MapType1Select h@@17 a@@67 (IndexField i@@20)))) :qid |DafnyPre.922:11| :skolemid |231| :pattern ((MapType1Select h@@17 a@@67 (IndexField i@@20))) :pattern ((|Seq#Index| (|Seq#FromArray| h@@17 a@@67) i@@20))))) :qid |DafnyPre.920:15| :skolemid |232| :pattern ((|Seq#FromArray| h@@17 a@@67)))))
(assert (forall ((h0 T@U) (h1 T@U) (a@@68 T@U)) (! (=> (and (and (= (type h0) (MapType1Type refType)) (= (type h1) (MapType1Type refType))) (= (type a@@68) refType)) (=> (and (and (and ($IsGoodHeap h0) ($IsGoodHeap h1)) ($HeapSucc h0 h1)) (forall ((i@@21 Int)) (! (=> (and (<= 0 i@@21) (< i@@21 (_System.array.Length a@@68))) (= (MapType1Select h0 a@@68 (IndexField i@@21)) (MapType1Select h1 a@@68 (IndexField i@@21)))) :qid |DafnyPre.935:11| :skolemid |233|))) (= (|Seq#FromArray| h0 a@@68) (|Seq#FromArray| h1 a@@68)))) :qid |DafnyPre.932:15| :skolemid |234| :pattern ((|Seq#FromArray| h1 a@@68) ($HeapSucc h0 h1)))))
(assert (forall ((h@@18 T@U) (i@@22 Int) (v@@32 T@U) (a@@69 T@U)) (! (=> (and (and (and (= (type h@@18) (MapType1Type refType)) (= (type v@@32) BoxType)) (= (type a@@69) refType)) (and (<= 0 i@@22) (< i@@22 (_System.array.Length a@@69)))) (= (|Seq#FromArray| (MapType1Store h@@18 a@@69 (IndexField i@@22) v@@32) a@@69) (|Seq#Update| (|Seq#FromArray| h@@18 a@@69) i@@22 v@@32))) :qid |DafnyPre.939:15| :skolemid |235| :pattern ((|Seq#FromArray| (MapType1Store h@@18 a@@69 (IndexField i@@22) v@@32) a@@69)))))
(assert (forall ((s@@32 T@U) (i@@23 Int) (v@@33 T@U) (n@@11 Int)) (! (let ((T@@134 (type v@@33))) (=> (= (type s@@32) (SeqType T@@134)) (=> (and (and (<= 0 i@@23) (< i@@23 n@@11)) (<= n@@11 (|Seq#Length| s@@32))) (= (|Seq#Take| (|Seq#Update| s@@32 i@@23 v@@33) n@@11) (|Seq#Update| (|Seq#Take| s@@32 n@@11) i@@23 v@@33))))) :qid |DafnyPre.944:18| :skolemid |236| :pattern ((|Seq#Take| (|Seq#Update| s@@32 i@@23 v@@33) n@@11)))))
(assert (forall ((s@@33 T@U) (i@@24 Int) (v@@34 T@U) (n@@12 Int)) (! (let ((T@@135 (type v@@34))) (=> (= (type s@@33) (SeqType T@@135)) (=> (and (<= n@@12 i@@24) (< i@@24 (|Seq#Length| s@@33))) (= (|Seq#Take| (|Seq#Update| s@@33 i@@24 v@@34) n@@12) (|Seq#Take| s@@33 n@@12))))) :qid |DafnyPre.947:18| :skolemid |237| :pattern ((|Seq#Take| (|Seq#Update| s@@33 i@@24 v@@34) n@@12)))))
(assert (forall ((s@@34 T@U) (i@@25 Int) (v@@35 T@U) (n@@13 Int)) (! (let ((T@@136 (type v@@35))) (=> (= (type s@@34) (SeqType T@@136)) (=> (and (and (<= 0 n@@13) (<= n@@13 i@@25)) (< i@@25 (|Seq#Length| s@@34))) (= (|Seq#Drop| (|Seq#Update| s@@34 i@@25 v@@35) n@@13) (|Seq#Update| (|Seq#Drop| s@@34 n@@13) (- i@@25 n@@13) v@@35))))) :qid |DafnyPre.950:18| :skolemid |238| :pattern ((|Seq#Drop| (|Seq#Update| s@@34 i@@25 v@@35) n@@13)))))
(assert (forall ((s@@35 T@U) (i@@26 Int) (v@@36 T@U) (n@@14 Int)) (! (let ((T@@137 (type v@@36))) (=> (= (type s@@35) (SeqType T@@137)) (=> (and (and (<= 0 i@@26) (< i@@26 n@@14)) (< n@@14 (|Seq#Length| s@@35))) (= (|Seq#Drop| (|Seq#Update| s@@35 i@@26 v@@36) n@@14) (|Seq#Drop| s@@35 n@@14))))) :qid |DafnyPre.953:18| :skolemid |239| :pattern ((|Seq#Drop| (|Seq#Update| s@@35 i@@26 v@@36) n@@14)))))
(assert (forall ((h@@19 T@U) (a@@70 T@U) (n0 Int) (n1 Int)) (! (=> (and (= (type h@@19) (MapType1Type refType)) (= (type a@@70) refType)) (=> (and (and (= (+ n0 1) n1) (<= 0 n0)) (<= n1 (_System.array.Length a@@70))) (= (|Seq#Take| (|Seq#FromArray| h@@19 a@@70) n1) (|Seq#Build| (|Seq#Take| (|Seq#FromArray| h@@19 a@@70) n0) (MapType1Select h@@19 a@@70 (IndexField n0)))))) :qid |DafnyPre.957:15| :skolemid |240| :pattern ((|Seq#Take| (|Seq#FromArray| h@@19 a@@70) n0) (|Seq#Take| (|Seq#FromArray| h@@19 a@@70) n1)))))
(assert (forall ((s@@36 T@U) (v@@37 T@U) (n@@15 Int)) (! (let ((T@@138 (type v@@37))) (=> (= (type s@@36) (SeqType T@@138)) (=> (and (<= 0 n@@15) (<= n@@15 (|Seq#Length| s@@36))) (= (|Seq#Drop| (|Seq#Build| s@@36 v@@37) n@@15) (|Seq#Build| (|Seq#Drop| s@@36 n@@15) v@@37))))) :qid |DafnyPre.961:18| :skolemid |241| :pattern ((|Seq#Drop| (|Seq#Build| s@@36 v@@37) n@@15)))))
(assert (forall ((s@@37 T@U) (i@@27 Int)) (! (=> (= (type s@@37) (SeqType BoxType)) (=> (and (<= 0 i@@27) (< i@@27 (|Seq#Length| s@@37))) (< (DtRank ($Unbox DatatypeTypeType (|Seq#Index| s@@37 i@@27))) (|Seq#Rank| s@@37)))) :qid |DafnyPre.966:15| :skolemid |242| :pattern ((DtRank ($Unbox DatatypeTypeType (|Seq#Index| s@@37 i@@27)))))))
(assert (forall ((s@@38 T@U) (i@@28 Int)) (! (let ((T@@139 (SeqTypeInv0 (type s@@38)))) (=> (= (type s@@38) (SeqType T@@139)) (=> (and (< 0 i@@28) (<= i@@28 (|Seq#Length| s@@38))) (< (|Seq#Rank| (|Seq#Drop| s@@38 i@@28)) (|Seq#Rank| s@@38))))) :qid |DafnyPre.969:18| :skolemid |243| :pattern ((|Seq#Rank| (|Seq#Drop| s@@38 i@@28))))))
(assert (forall ((s@@39 T@U) (i@@29 Int)) (! (let ((T@@140 (SeqTypeInv0 (type s@@39)))) (=> (= (type s@@39) (SeqType T@@140)) (=> (and (<= 0 i@@29) (< i@@29 (|Seq#Length| s@@39))) (< (|Seq#Rank| (|Seq#Take| s@@39 i@@29)) (|Seq#Rank| s@@39))))) :qid |DafnyPre.972:18| :skolemid |244| :pattern ((|Seq#Rank| (|Seq#Take| s@@39 i@@29))))))
(assert (forall ((s@@40 T@U) (i@@30 Int) (j@@5 Int)) (! (let ((T@@141 (SeqTypeInv0 (type s@@40)))) (=> (= (type s@@40) (SeqType T@@141)) (=> (and (and (<= 0 i@@30) (< i@@30 j@@5)) (<= j@@5 (|Seq#Length| s@@40))) (< (|Seq#Rank| (|Seq#Append| (|Seq#Take| s@@40 i@@30) (|Seq#Drop| s@@40 j@@5))) (|Seq#Rank| s@@40))))) :qid |DafnyPre.975:18| :skolemid |245| :pattern ((|Seq#Rank| (|Seq#Append| (|Seq#Take| s@@40 i@@30) (|Seq#Drop| s@@40 j@@5)))))))
(assert (forall ((s@@41 T@U) (n@@16 Int)) (! (let ((T@@142 (SeqTypeInv0 (type s@@41)))) (=> (and (= (type s@@41) (SeqType T@@142)) (= n@@16 0)) (= (|Seq#Drop| s@@41 n@@16) s@@41))) :qid |DafnyPre.980:18| :skolemid |246| :pattern ((|Seq#Drop| s@@41 n@@16)))))
(assert (forall ((s@@42 T@U) (n@@17 Int)) (! (let ((T@@143 (SeqTypeInv0 (type s@@42)))) (=> (and (= (type s@@42) (SeqType T@@143)) (= n@@17 0)) (= (|Seq#Take| s@@42 n@@17) (|Seq#Empty| T@@143)))) :qid |DafnyPre.982:18| :skolemid |247| :pattern ((|Seq#Take| s@@42 n@@17)))))
(assert (forall ((s@@43 T@U) (m@@6 Int) (n@@18 Int)) (! (let ((T@@144 (SeqTypeInv0 (type s@@43)))) (=> (= (type s@@43) (SeqType T@@144)) (=> (and (and (<= 0 m@@6) (<= 0 n@@18)) (<= (+ m@@6 n@@18) (|Seq#Length| s@@43))) (= (|Seq#Drop| (|Seq#Drop| s@@43 m@@6) n@@18) (|Seq#Drop| s@@43 (+ m@@6 n@@18)))))) :qid |DafnyPre.984:18| :skolemid |248| :pattern ((|Seq#Drop| (|Seq#Drop| s@@43 m@@6) n@@18)))))
(assert (forall ((m@@7 T@U)) (! (let ((V@@1 (MapTypeInv1 (type m@@7)))) (let ((U@@3 (MapTypeInv0 (type m@@7)))) (=> (= (type m@@7) (MapType U@@3 V@@1)) (<= 0 (|Map#Card| m@@7))))) :qid |DafnyPre.998:21| :skolemid |249| :pattern ((|Map#Card| m@@7)))))
(assert (forall ((U@@4 T@T) (V@@2 T@T)) (! (= (type (|Map#Empty| U@@4 V@@2)) (MapType U@@4 V@@2)) :qid |funType:Map#Empty| :pattern ((|Map#Empty| U@@4 V@@2)))))
(assert (forall ((u@@5 T@U) (V@@3 T@T)) (! (let ((U@@5 (type u@@5))) (not (U_2_bool (MapType0Select (|Map#Domain| (|Map#Empty| U@@5 V@@3)) u@@5)))) :qid |DafnyPre.1001:21| :skolemid |250| :pattern ((let ((U@@5 (type u@@5))) (MapType0Select (|Map#Domain| (|Map#Empty| U@@5 V@@3)) u@@5))))))
(assert (forall ((m@@8 T@U)) (! (let ((V@@4 (MapTypeInv1 (type m@@8)))) (let ((U@@6 (MapTypeInv0 (type m@@8)))) (=> (= (type m@@8) (MapType U@@6 V@@4)) (and (and (=> (= (|Map#Card| m@@8) 0) (= m@@8 (|Map#Empty| U@@6 V@@4))) (=> (= m@@8 (|Map#Empty| U@@6 V@@4)) (= (|Map#Card| m@@8) 0))) (=> (not (= (|Map#Card| m@@8) 0)) (exists ((x@@39 T@U)) (! (and (= (type x@@39) U@@6) (U_2_bool (MapType0Select (|Map#Domain| m@@8) x@@39))) :qid |DafnyPre.1006:32| :skolemid |251| :no-pattern (type x@@39) :no-pattern (U_2_int x@@39) :no-pattern (U_2_bool x@@39)))))))) :qid |DafnyPre.1004:21| :skolemid |252| :pattern ((|Map#Card| m@@8)))))
(assert (forall ((arg0@@83 T@U) (arg1@@37 T@U) (arg2@@3 T@U)) (! (let ((V@@5 (MapType0TypeInv1 (type arg1@@37)))) (let ((U@@7 (MapType0TypeInv0 (type arg0@@83)))) (= (type (|Map#Glue| arg0@@83 arg1@@37 arg2@@3)) (MapType U@@7 V@@5)))) :qid |funType:Map#Glue| :pattern ((|Map#Glue| arg0@@83 arg1@@37 arg2@@3)))))
(assert (forall ((a@@71 T@U) (b@@50 T@U) (t@@29 T@U)) (! (let ((V@@6 (MapType0TypeInv1 (type b@@50)))) (let ((U@@8 (MapType0TypeInv0 (type a@@71)))) (=> (and (and (= (type a@@71) (MapType0Type U@@8 boolType)) (= (type b@@50) (MapType0Type U@@8 V@@6))) (= (type t@@29) TyType)) (= (|Map#Domain| (|Map#Glue| a@@71 b@@50 t@@29)) a@@71)))) :qid |DafnyPre.1009:21| :skolemid |253| :pattern ((|Map#Domain| (|Map#Glue| a@@71 b@@50 t@@29))))))
(assert (forall ((a@@72 T@U) (b@@51 T@U) (t@@30 T@U)) (! (let ((V@@7 (MapType0TypeInv1 (type b@@51)))) (let ((U@@9 (MapType0TypeInv0 (type a@@72)))) (=> (and (and (= (type a@@72) (MapType0Type U@@9 boolType)) (= (type b@@51) (MapType0Type U@@9 V@@7))) (= (type t@@30) TyType)) (= (|Map#Elements| (|Map#Glue| a@@72 b@@51 t@@30)) b@@51)))) :qid |DafnyPre.1012:21| :skolemid |254| :pattern ((|Map#Elements| (|Map#Glue| a@@72 b@@51 t@@30))))))
(assert (forall ((a@@73 T@U) (b@@52 T@U) (t@@31 T@U)) (! (let ((V@@8 (MapType0TypeInv1 (type b@@52)))) (let ((U@@10 (MapType0TypeInv0 (type a@@73)))) (=> (and (and (= (type a@@73) (MapType0Type U@@10 boolType)) (= (type b@@52) (MapType0Type U@@10 V@@8))) (= (type t@@31) TyType)) ($Is (|Map#Glue| a@@73 b@@52 t@@31) t@@31)))) :qid |DafnyPre.1015:21| :skolemid |255| :pattern (($Is (|Map#Glue| a@@73 b@@52 t@@31) t@@31)))))
(assert (forall ((arg0@@84 T@U) (arg1@@38 T@U) (arg2@@4 T@U)) (! (let ((V@@9 (type arg2@@4))) (let ((U@@11 (type arg1@@38))) (= (type (|Map#Build| arg0@@84 arg1@@38 arg2@@4)) (MapType U@@11 V@@9)))) :qid |funType:Map#Build| :pattern ((|Map#Build| arg0@@84 arg1@@38 arg2@@4)))))
(assert (forall ((m@@9 T@U) (u@@6 T@U) (|u'| T@U) (v@@38 T@U)) (! (let ((V@@10 (type v@@38))) (let ((U@@12 (type u@@6))) (=> (and (= (type m@@9) (MapType U@@12 V@@10)) (= (type |u'|) U@@12)) (and (=> (= |u'| u@@6) (and (U_2_bool (MapType0Select (|Map#Domain| (|Map#Build| m@@9 u@@6 v@@38)) |u'|)) (= (MapType0Select (|Map#Elements| (|Map#Build| m@@9 u@@6 v@@38)) |u'|) v@@38))) (=> (not (= |u'| u@@6)) (and (and (=> (U_2_bool (MapType0Select (|Map#Domain| (|Map#Build| m@@9 u@@6 v@@38)) |u'|)) (U_2_bool (MapType0Select (|Map#Domain| m@@9) |u'|))) (=> (U_2_bool (MapType0Select (|Map#Domain| m@@9) |u'|)) (U_2_bool (MapType0Select (|Map#Domain| (|Map#Build| m@@9 u@@6 v@@38)) |u'|)))) (= (MapType0Select (|Map#Elements| (|Map#Build| m@@9 u@@6 v@@38)) |u'|) (MapType0Select (|Map#Elements| m@@9) |u'|)))))))) :qid |DafnyPre.1026:21| :skolemid |256| :pattern ((MapType0Select (|Map#Domain| (|Map#Build| m@@9 u@@6 v@@38)) |u'|)) :pattern ((MapType0Select (|Map#Elements| (|Map#Build| m@@9 u@@6 v@@38)) |u'|)))))
(assert (forall ((m@@10 T@U) (u@@7 T@U) (v@@39 T@U)) (! (let ((V@@11 (type v@@39))) (let ((U@@13 (type u@@7))) (=> (and (= (type m@@10) (MapType U@@13 V@@11)) (U_2_bool (MapType0Select (|Map#Domain| m@@10) u@@7))) (= (|Map#Card| (|Map#Build| m@@10 u@@7 v@@39)) (|Map#Card| m@@10))))) :qid |DafnyPre.1032:21| :skolemid |257| :pattern ((|Map#Card| (|Map#Build| m@@10 u@@7 v@@39))))))
(assert (forall ((m@@11 T@U) (u@@8 T@U) (v@@40 T@U)) (! (let ((V@@12 (type v@@40))) (let ((U@@14 (type u@@8))) (=> (and (= (type m@@11) (MapType U@@14 V@@12)) (not (U_2_bool (MapType0Select (|Map#Domain| m@@11) u@@8)))) (= (|Map#Card| (|Map#Build| m@@11 u@@8 v@@40)) (+ (|Map#Card| m@@11) 1))))) :qid |DafnyPre.1034:21| :skolemid |258| :pattern ((|Map#Card| (|Map#Build| m@@11 u@@8 v@@40))))))
(assert (forall ((m@@12 T@U) (|m'| T@U)) (! (let ((V@@13 (MapTypeInv1 (type m@@12)))) (let ((U@@15 (MapTypeInv0 (type m@@12)))) (=> (and (= (type m@@12) (MapType U@@15 V@@13)) (= (type |m'|) (MapType U@@15 V@@13))) (and (=> (|Map#Equal| m@@12 |m'|) (and (forall ((u@@9 T@U)) (! (=> (= (type u@@9) U@@15) (and (=> (U_2_bool (MapType0Select (|Map#Domain| m@@12) u@@9)) (U_2_bool (MapType0Select (|Map#Domain| |m'|) u@@9))) (=> (U_2_bool (MapType0Select (|Map#Domain| |m'|) u@@9)) (U_2_bool (MapType0Select (|Map#Domain| m@@12) u@@9))))) :qid |DafnyPre.1042:35| :skolemid |259| :no-pattern (type u@@9) :no-pattern (U_2_int u@@9) :no-pattern (U_2_bool u@@9))) (forall ((u@@10 T@U)) (! (=> (and (= (type u@@10) U@@15) (U_2_bool (MapType0Select (|Map#Domain| m@@12) u@@10))) (= (MapType0Select (|Map#Elements| m@@12) u@@10) (MapType0Select (|Map#Elements| |m'|) u@@10))) :qid |DafnyPre.1043:35| :skolemid |260| :no-pattern (type u@@10) :no-pattern (U_2_int u@@10) :no-pattern (U_2_bool u@@10))))) (=> (and (forall ((u@@11 T@U)) (! (=> (= (type u@@11) U@@15) (and (=> (U_2_bool (MapType0Select (|Map#Domain| m@@12) u@@11)) (U_2_bool (MapType0Select (|Map#Domain| |m'|) u@@11))) (=> (U_2_bool (MapType0Select (|Map#Domain| |m'|) u@@11)) (U_2_bool (MapType0Select (|Map#Domain| m@@12) u@@11))))) :qid |DafnyPre.1042:35| :skolemid |259| :no-pattern (type u@@11) :no-pattern (U_2_int u@@11) :no-pattern (U_2_bool u@@11))) (forall ((u@@12 T@U)) (! (=> (and (= (type u@@12) U@@15) (U_2_bool (MapType0Select (|Map#Domain| m@@12) u@@12))) (= (MapType0Select (|Map#Elements| m@@12) u@@12) (MapType0Select (|Map#Elements| |m'|) u@@12))) :qid |DafnyPre.1043:35| :skolemid |260| :no-pattern (type u@@12) :no-pattern (U_2_int u@@12) :no-pattern (U_2_bool u@@12)))) (|Map#Equal| m@@12 |m'|)))))) :qid |DafnyPre.1040:21| :skolemid |261| :pattern ((|Map#Equal| m@@12 |m'|)))))
(assert (forall ((m@@13 T@U) (|m'@@0| T@U)) (! (let ((V@@14 (MapTypeInv1 (type m@@13)))) (let ((U@@16 (MapTypeInv0 (type m@@13)))) (=> (and (and (= (type m@@13) (MapType U@@16 V@@14)) (= (type |m'@@0|) (MapType U@@16 V@@14))) (|Map#Equal| m@@13 |m'@@0|)) (= m@@13 |m'@@0|)))) :qid |DafnyPre.1045:21| :skolemid |262| :pattern ((|Map#Equal| m@@13 |m'@@0|)))))
(assert (forall ((m@@14 T@U) (|m'@@1| T@U)) (! (let ((V@@15 (MapTypeInv1 (type m@@14)))) (let ((U@@17 (MapTypeInv0 (type m@@14)))) (=> (and (= (type m@@14) (MapType U@@17 V@@15)) (= (type |m'@@1|) (MapType U@@17 V@@15))) (and (=> (|Map#Disjoint| m@@14 |m'@@1|) (forall ((o@@37 T@U)) (! (=> (= (type o@@37) U@@17) (or (not (U_2_bool (MapType0Select (|Map#Domain| m@@14) o@@37))) (not (U_2_bool (MapType0Select (|Map#Domain| |m'@@1|) o@@37))))) :qid |DafnyPre.1052:38| :skolemid |263| :pattern ((MapType0Select (|Map#Domain| m@@14) o@@37)) :pattern ((MapType0Select (|Map#Domain| |m'@@1|) o@@37))))) (=> (forall ((o@@38 T@U)) (! (=> (= (type o@@38) U@@17) (or (not (U_2_bool (MapType0Select (|Map#Domain| m@@14) o@@38))) (not (U_2_bool (MapType0Select (|Map#Domain| |m'@@1|) o@@38))))) :qid |DafnyPre.1052:38| :skolemid |263| :pattern ((MapType0Select (|Map#Domain| m@@14) o@@38)) :pattern ((MapType0Select (|Map#Domain| |m'@@1|) o@@38)))) (|Map#Disjoint| m@@14 |m'@@1|)))))) :qid |DafnyPre.1050:21| :skolemid |264| :pattern ((|Map#Disjoint| m@@14 |m'@@1|)))))
(assert (forall ((U@@18 T@T) (V@@16 T@T)) (! (= (type (|IMap#Empty| U@@18 V@@16)) (IMapType U@@18 V@@16)) :qid |funType:IMap#Empty| :pattern ((|IMap#Empty| U@@18 V@@16)))))
(assert (forall ((u@@13 T@U) (V@@17 T@T)) (! (let ((U@@19 (type u@@13))) (not (U_2_bool (MapType0Select (|IMap#Domain| (|IMap#Empty| U@@19 V@@17)) u@@13)))) :qid |DafnyPre.1064:21| :skolemid |265| :pattern ((let ((U@@19 (type u@@13))) (MapType0Select (|IMap#Domain| (|IMap#Empty| U@@19 V@@17)) u@@13))))))
(assert (forall ((arg0@@85 T@U) (arg1@@39 T@U) (arg2@@5 T@U)) (! (let ((V@@18 (MapType0TypeInv1 (type arg1@@39)))) (let ((U@@20 (MapType0TypeInv0 (type arg0@@85)))) (= (type (|IMap#Glue| arg0@@85 arg1@@39 arg2@@5)) (IMapType U@@20 V@@18)))) :qid |funType:IMap#Glue| :pattern ((|IMap#Glue| arg0@@85 arg1@@39 arg2@@5)))))
(assert (forall ((a@@74 T@U) (b@@53 T@U) (t@@32 T@U)) (! (let ((V@@19 (MapType0TypeInv1 (type b@@53)))) (let ((U@@21 (MapType0TypeInv0 (type a@@74)))) (=> (and (and (= (type a@@74) (MapType0Type U@@21 boolType)) (= (type b@@53) (MapType0Type U@@21 V@@19))) (= (type t@@32) TyType)) (= (|IMap#Domain| (|IMap#Glue| a@@74 b@@53 t@@32)) a@@74)))) :qid |DafnyPre.1069:21| :skolemid |266| :pattern ((|IMap#Domain| (|IMap#Glue| a@@74 b@@53 t@@32))))))
(assert (forall ((a@@75 T@U) (b@@54 T@U) (t@@33 T@U)) (! (let ((V@@20 (MapType0TypeInv1 (type b@@54)))) (let ((U@@22 (MapType0TypeInv0 (type a@@75)))) (=> (and (and (= (type a@@75) (MapType0Type U@@22 boolType)) (= (type b@@54) (MapType0Type U@@22 V@@20))) (= (type t@@33) TyType)) (= (|IMap#Elements| (|IMap#Glue| a@@75 b@@54 t@@33)) b@@54)))) :qid |DafnyPre.1072:21| :skolemid |267| :pattern ((|IMap#Elements| (|IMap#Glue| a@@75 b@@54 t@@33))))))
(assert (forall ((a@@76 T@U) (b@@55 T@U) (t@@34 T@U)) (! (let ((V@@21 (MapType0TypeInv1 (type b@@55)))) (let ((U@@23 (MapType0TypeInv0 (type a@@76)))) (=> (and (and (= (type a@@76) (MapType0Type U@@23 boolType)) (= (type b@@55) (MapType0Type U@@23 V@@21))) (= (type t@@34) TyType)) ($Is (|IMap#Glue| a@@76 b@@55 t@@34) t@@34)))) :qid |DafnyPre.1075:21| :skolemid |268| :pattern (($Is (|IMap#Glue| a@@76 b@@55 t@@34) t@@34)))))
(assert (forall ((arg0@@86 T@U) (arg1@@40 T@U) (arg2@@6 T@U)) (! (let ((V@@22 (type arg2@@6))) (let ((U@@24 (type arg1@@40))) (= (type (|IMap#Build| arg0@@86 arg1@@40 arg2@@6)) (IMapType U@@24 V@@22)))) :qid |funType:IMap#Build| :pattern ((|IMap#Build| arg0@@86 arg1@@40 arg2@@6)))))
(assert (forall ((m@@15 T@U) (u@@14 T@U) (|u'@@0| T@U) (v@@41 T@U)) (! (let ((V@@23 (type v@@41))) (let ((U@@25 (type u@@14))) (=> (and (= (type m@@15) (IMapType U@@25 V@@23)) (= (type |u'@@0|) U@@25)) (and (=> (= |u'@@0| u@@14) (and (U_2_bool (MapType0Select (|IMap#Domain| (|IMap#Build| m@@15 u@@14 v@@41)) |u'@@0|)) (= (MapType0Select (|IMap#Elements| (|IMap#Build| m@@15 u@@14 v@@41)) |u'@@0|) v@@41))) (=> (not (= |u'@@0| u@@14)) (and (and (=> (U_2_bool (MapType0Select (|IMap#Domain| (|IMap#Build| m@@15 u@@14 v@@41)) |u'@@0|)) (U_2_bool (MapType0Select (|IMap#Domain| m@@15) |u'@@0|))) (=> (U_2_bool (MapType0Select (|IMap#Domain| m@@15) |u'@@0|)) (U_2_bool (MapType0Select (|IMap#Domain| (|IMap#Build| m@@15 u@@14 v@@41)) |u'@@0|)))) (= (MapType0Select (|IMap#Elements| (|IMap#Build| m@@15 u@@14 v@@41)) |u'@@0|) (MapType0Select (|IMap#Elements| m@@15) |u'@@0|)))))))) :qid |DafnyPre.1085:21| :skolemid |269| :pattern ((MapType0Select (|IMap#Domain| (|IMap#Build| m@@15 u@@14 v@@41)) |u'@@0|)) :pattern ((MapType0Select (|IMap#Elements| (|IMap#Build| m@@15 u@@14 v@@41)) |u'@@0|)))))
(assert (forall ((m@@16 T@U) (|m'@@2| T@U)) (! (let ((V@@24 (IMapTypeInv1 (type m@@16)))) (let ((U@@26 (IMapTypeInv0 (type m@@16)))) (=> (and (= (type m@@16) (IMapType U@@26 V@@24)) (= (type |m'@@2|) (IMapType U@@26 V@@24))) (and (=> (|IMap#Equal| m@@16 |m'@@2|) (and (forall ((u@@15 T@U)) (! (=> (= (type u@@15) U@@26) (and (=> (U_2_bool (MapType0Select (|IMap#Domain| m@@16) u@@15)) (U_2_bool (MapType0Select (|IMap#Domain| |m'@@2|) u@@15))) (=> (U_2_bool (MapType0Select (|IMap#Domain| |m'@@2|) u@@15)) (U_2_bool (MapType0Select (|IMap#Domain| m@@16) u@@15))))) :qid |DafnyPre.1096:36| :skolemid |270| :no-pattern (type u@@15) :no-pattern (U_2_int u@@15) :no-pattern (U_2_bool u@@15))) (forall ((u@@16 T@U)) (! (=> (and (= (type u@@16) U@@26) (U_2_bool (MapType0Select (|IMap#Domain| m@@16) u@@16))) (= (MapType0Select (|IMap#Elements| m@@16) u@@16) (MapType0Select (|IMap#Elements| |m'@@2|) u@@16))) :qid |DafnyPre.1097:35| :skolemid |271| :no-pattern (type u@@16) :no-pattern (U_2_int u@@16) :no-pattern (U_2_bool u@@16))))) (=> (and (forall ((u@@17 T@U)) (! (=> (= (type u@@17) U@@26) (and (=> (U_2_bool (MapType0Select (|IMap#Domain| m@@16) u@@17)) (U_2_bool (MapType0Select (|IMap#Domain| |m'@@2|) u@@17))) (=> (U_2_bool (MapType0Select (|IMap#Domain| |m'@@2|) u@@17)) (U_2_bool (MapType0Select (|IMap#Domain| m@@16) u@@17))))) :qid |DafnyPre.1096:36| :skolemid |270| :no-pattern (type u@@17) :no-pattern (U_2_int u@@17) :no-pattern (U_2_bool u@@17))) (forall ((u@@18 T@U)) (! (=> (and (= (type u@@18) U@@26) (U_2_bool (MapType0Select (|IMap#Domain| m@@16) u@@18))) (= (MapType0Select (|IMap#Elements| m@@16) u@@18) (MapType0Select (|IMap#Elements| |m'@@2|) u@@18))) :qid |DafnyPre.1097:35| :skolemid |271| :no-pattern (type u@@18) :no-pattern (U_2_int u@@18) :no-pattern (U_2_bool u@@18)))) (|IMap#Equal| m@@16 |m'@@2|)))))) :qid |DafnyPre.1094:21| :skolemid |272| :pattern ((|IMap#Equal| m@@16 |m'@@2|)))))
(assert (forall ((m@@17 T@U) (|m'@@3| T@U)) (! (let ((V@@25 (IMapTypeInv1 (type m@@17)))) (let ((U@@27 (IMapTypeInv0 (type m@@17)))) (=> (and (and (= (type m@@17) (IMapType U@@27 V@@25)) (= (type |m'@@3|) (IMapType U@@27 V@@25))) (|IMap#Equal| m@@17 |m'@@3|)) (= m@@17 |m'@@3|)))) :qid |DafnyPre.1099:21| :skolemid |273| :pattern ((|IMap#Equal| m@@17 |m'@@3|)))))
(assert (forall ((x@@40 Int) (y@@12 Int)) (! (= (INTERNAL_add_boogie x@@40 y@@12) (+ x@@40 y@@12)) :qid |DafnyPre.1107:30| :skolemid |274| :pattern ((INTERNAL_add_boogie x@@40 y@@12)))))
(assert (forall ((x@@41 Int) (y@@13 Int)) (! (= (INTERNAL_sub_boogie x@@41 y@@13) (- x@@41 y@@13)) :qid |DafnyPre.1108:30| :skolemid |275| :pattern ((INTERNAL_sub_boogie x@@41 y@@13)))))
(assert (forall ((x@@42 Int) (y@@14 Int)) (! (= (INTERNAL_mul_boogie x@@42 y@@14) (* x@@42 y@@14)) :qid |DafnyPre.1109:30| :skolemid |276| :pattern ((INTERNAL_mul_boogie x@@42 y@@14)))))
(assert (forall ((x@@43 Int) (y@@15 Int)) (! (= (INTERNAL_div_boogie x@@43 y@@15) (div x@@43 y@@15)) :qid |DafnyPre.1110:30| :skolemid |277| :pattern ((INTERNAL_div_boogie x@@43 y@@15)))))
(assert (forall ((x@@44 Int) (y@@16 Int)) (! (= (INTERNAL_mod_boogie x@@44 y@@16) (mod x@@44 y@@16)) :qid |DafnyPre.1111:30| :skolemid |278| :pattern ((INTERNAL_mod_boogie x@@44 y@@16)))))
(assert (forall ((x@@45 Int) (y@@17 Int)) (! (and (=> (INTERNAL_lt_boogie x@@45 y@@17) (< x@@45 y@@17)) (=> (< x@@45 y@@17) (INTERNAL_lt_boogie x@@45 y@@17))) :qid |DafnyPre.1112:51| :skolemid |279| :pattern ((INTERNAL_lt_boogie x@@45 y@@17)))))
(assert (forall ((x@@46 Int) (y@@18 Int)) (! (and (=> (INTERNAL_le_boogie x@@46 y@@18) (<= x@@46 y@@18)) (=> (<= x@@46 y@@18) (INTERNAL_le_boogie x@@46 y@@18))) :qid |DafnyPre.1113:51| :skolemid |280| :pattern ((INTERNAL_le_boogie x@@46 y@@18)))))
(assert (forall ((x@@47 Int) (y@@19 Int)) (! (and (=> (INTERNAL_gt_boogie x@@47 y@@19) (> x@@47 y@@19)) (=> (> x@@47 y@@19) (INTERNAL_gt_boogie x@@47 y@@19))) :qid |DafnyPre.1114:51| :skolemid |281| :pattern ((INTERNAL_gt_boogie x@@47 y@@19)))))
(assert (forall ((x@@48 Int) (y@@20 Int)) (! (and (=> (INTERNAL_ge_boogie x@@48 y@@20) (>= x@@48 y@@20)) (=> (>= x@@48 y@@20) (INTERNAL_ge_boogie x@@48 y@@20))) :qid |DafnyPre.1115:51| :skolemid |282| :pattern ((INTERNAL_ge_boogie x@@48 y@@20)))))
(assert (= (Tag Tclass._System.object) Tagclass._System.object))
(assert (forall ((bx@@35 T@U)) (! (=> (and (= (type bx@@35) BoxType) ($IsBox bx@@35 Tclass._System.object)) (and (= ($Box ($Unbox refType bx@@35)) bx@@35) ($Is ($Unbox refType bx@@35) Tclass._System.object))) :qid |unknown.0:0| :skolemid |283| :pattern (($IsBox bx@@35 Tclass._System.object)))))
(assert (forall (($o T@U)) (! (=> (= (type $o) refType) ($Is $o Tclass._System.object)) :qid |unknown.0:0| :skolemid |284| :pattern (($Is $o Tclass._System.object)))))
(assert (= (type null) refType))
(assert (forall (($o@@0 T@U) ($h T@U)) (! (=> (and (= (type $o@@0) refType) (= (type $h) (MapType1Type refType))) (and (=> ($IsAlloc $o@@0 Tclass._System.object $h) (or (= $o@@0 null) (U_2_bool (MapType1Select $h $o@@0 alloc)))) (=> (or (= $o@@0 null) (U_2_bool (MapType1Select $h $o@@0 alloc))) ($IsAlloc $o@@0 Tclass._System.object $h)))) :qid |unknown.0:0| :skolemid |285| :pattern (($IsAlloc $o@@0 Tclass._System.object $h)))))
(assert (forall ((arg0@@87 T@U)) (! (= (type (Tclass._System.array arg0@@87)) TyType) :qid |funType:Tclass._System.array| :pattern ((Tclass._System.array arg0@@87)))))
(assert (forall ((|#$arg| T@U)) (! (=> (= (type |#$arg|) TyType) (= (Tag (Tclass._System.array |#$arg|)) Tagclass._System.array)) :qid |unknown.0:0| :skolemid |286| :pattern ((Tclass._System.array |#$arg|)))))
(assert (forall ((arg0@@88 T@U)) (! (= (type (Tclass._System.array_0 arg0@@88)) TyType) :qid |funType:Tclass._System.array_0| :pattern ((Tclass._System.array_0 arg0@@88)))))
(assert (forall ((|#$arg@@0| T@U)) (! (=> (= (type |#$arg@@0|) TyType) (= (Tclass._System.array_0 (Tclass._System.array |#$arg@@0|)) |#$arg@@0|)) :qid |unknown.0:0| :skolemid |287| :pattern ((Tclass._System.array |#$arg@@0|)))))
(assert (forall ((|#$arg@@1| T@U) (bx@@36 T@U)) (! (=> (and (and (= (type |#$arg@@1|) TyType) (= (type bx@@36) BoxType)) ($IsBox bx@@36 (Tclass._System.array |#$arg@@1|))) (and (= ($Box ($Unbox refType bx@@36)) bx@@36) ($Is ($Unbox refType bx@@36) (Tclass._System.array |#$arg@@1|)))) :qid |unknown.0:0| :skolemid |288| :pattern (($IsBox bx@@36 (Tclass._System.array |#$arg@@1|))))))
(assert (forall ((arg0@@89 T@U)) (! (= (type (dtype arg0@@89)) TyType) :qid |funType:dtype| :pattern ((dtype arg0@@89)))))
(assert (forall ((|#$arg@@2| T@U) ($i0 Int) ($h@@0 T@U) ($o@@1 T@U)) (! (=> (and (and (= (type |#$arg@@2|) TyType) (= (type $h@@0) (MapType1Type refType))) (= (type $o@@1) refType)) (=> (and (and (and ($IsGoodHeap $h@@0) (not (= $o@@1 null))) (= (dtype $o@@1) (Tclass._System.array |#$arg@@2|))) (and (<= 0 $i0) (< $i0 (_System.array.Length $o@@1)))) (and ($IsBox (MapType1Select $h@@0 $o@@1 (IndexField $i0)) |#$arg@@2|) (=> (U_2_bool (MapType1Select $h@@0 $o@@1 alloc)) ($IsAllocBox (MapType1Select $h@@0 $o@@1 (IndexField $i0)) |#$arg@@2| $h@@0))))) :qid |unknown.0:0| :skolemid |289| :pattern ((MapType1Select $h@@0 $o@@1 (IndexField $i0)) (Tclass._System.array |#$arg@@2|)))))
(assert (forall ((|#$arg@@3| T@U) ($o@@2 T@U)) (! (=> (and (= (type |#$arg@@3|) TyType) (= (type $o@@2) refType)) (and (=> ($Is $o@@2 (Tclass._System.array |#$arg@@3|)) (or (= $o@@2 null) (= (dtype $o@@2) (Tclass._System.array |#$arg@@3|)))) (=> (or (= $o@@2 null) (= (dtype $o@@2) (Tclass._System.array |#$arg@@3|))) ($Is $o@@2 (Tclass._System.array |#$arg@@3|))))) :qid |unknown.0:0| :skolemid |290| :pattern (($Is $o@@2 (Tclass._System.array |#$arg@@3|))))))
(assert (forall ((|#$arg@@4| T@U) ($o@@3 T@U) ($h@@1 T@U)) (! (=> (and (and (= (type |#$arg@@4|) TyType) (= (type $o@@3) refType)) (= (type $h@@1) (MapType1Type refType))) (and (=> ($IsAlloc $o@@3 (Tclass._System.array |#$arg@@4|) $h@@1) (or (= $o@@3 null) (U_2_bool (MapType1Select $h@@1 $o@@3 alloc)))) (=> (or (= $o@@3 null) (U_2_bool (MapType1Select $h@@1 $o@@3 alloc))) ($IsAlloc $o@@3 (Tclass._System.array |#$arg@@4|) $h@@1)))) :qid |unknown.0:0| :skolemid |291| :pattern (($IsAlloc $o@@3 (Tclass._System.array |#$arg@@4|) $h@@1)))))
(assert (forall ((|#$arg@@5| T@U) ($h@@2 T@U) ($o@@4 T@U)) (! (=> (and (and (and (= (type |#$arg@@5|) TyType) (= (type $h@@2) (MapType1Type refType))) (= (type $o@@4) refType)) (and (and ($IsGoodHeap $h@@2) (not (= $o@@4 null))) (= (dtype $o@@4) (Tclass._System.array |#$arg@@5|)))) (and ($Is (int_2_U (_System.array.Length $o@@4)) TInt) (=> (U_2_bool (MapType1Select $h@@2 $o@@4 alloc)) ($IsAlloc (int_2_U (_System.array.Length $o@@4)) TInt $h@@2)))) :qid |unknown.0:0| :skolemid |292| :no-pattern (type |#$arg@@5|) :no-pattern (type $h@@2) :no-pattern (type $o@@4) :no-pattern (U_2_int |#$arg@@5|) :no-pattern (U_2_bool |#$arg@@5|) :no-pattern (U_2_int $h@@2) :no-pattern (U_2_bool $h@@2) :no-pattern (U_2_int $o@@4) :no-pattern (U_2_bool $o@@4))))
(assert (forall ((arg0@@90 T@U)) (! (= (type (Tclass._System.___hFunc0 arg0@@90)) TyType) :qid |funType:Tclass._System.___hFunc0| :pattern ((Tclass._System.___hFunc0 arg0@@90)))))
(assert (forall ((|#$T0| T@U)) (! (=> (= (type |#$T0|) TyType) (= (Tag (Tclass._System.___hFunc0 |#$T0|)) Tagclass._System.___hFunc0)) :qid |unknown.0:0| :skolemid |293| :pattern ((Tclass._System.___hFunc0 |#$T0|)))))
(assert (forall ((arg0@@91 T@U)) (! (= (type (Tclass._System.___hFunc0_0 arg0@@91)) TyType) :qid |funType:Tclass._System.___hFunc0_0| :pattern ((Tclass._System.___hFunc0_0 arg0@@91)))))
(assert (forall ((|#$T0@@0| T@U)) (! (=> (= (type |#$T0@@0|) TyType) (= (Tclass._System.___hFunc0_0 (Tclass._System.___hFunc0 |#$T0@@0|)) |#$T0@@0|)) :qid |unknown.0:0| :skolemid |294| :pattern ((Tclass._System.___hFunc0 |#$T0@@0|)))))
(assert (= (Ctor HandleTypeType) 18))
(assert (forall ((|#$T0@@1| T@U) (bx@@37 T@U)) (! (=> (and (and (= (type |#$T0@@1|) TyType) (= (type bx@@37) BoxType)) ($IsBox bx@@37 (Tclass._System.___hFunc0 |#$T0@@1|))) (and (= ($Box ($Unbox HandleTypeType bx@@37)) bx@@37) ($Is ($Unbox HandleTypeType bx@@37) (Tclass._System.___hFunc0 |#$T0@@1|)))) :qid |unknown.0:0| :skolemid |295| :pattern (($IsBox bx@@37 (Tclass._System.___hFunc0 |#$T0@@1|))))))
(assert (and (forall ((arg0@@92 T@U) (arg1@@41 T@U) (arg2@@7 T@U)) (! (= (type (Apply0 arg0@@92 arg1@@41 arg2@@7)) BoxType) :qid |funType:Apply0| :pattern ((Apply0 arg0@@92 arg1@@41 arg2@@7)))) (forall ((arg0@@93 T@U) (arg1@@42 T@U) (arg2@@8 T@U)) (! (= (type (Handle0 arg0@@93 arg1@@42 arg2@@8)) HandleTypeType) :qid |funType:Handle0| :pattern ((Handle0 arg0@@93 arg1@@42 arg2@@8))))))
(assert (forall ((t0@@12 T@U) (heap T@U) (h@@20 T@U) (r@@5 T@U) (rd T@U)) (! (=> (and (and (and (and (= (type t0@@12) TyType) (= (type heap) (MapType1Type refType))) (= (type h@@20) (MapType0Type (MapType1Type refType) BoxType))) (= (type r@@5) (MapType0Type (MapType1Type refType) boolType))) (= (type rd) (MapType0Type (MapType1Type refType) (MapType0Type BoxType boolType)))) (= (Apply0 t0@@12 (Handle0 h@@20 r@@5 rd) heap) (MapType0Select h@@20 heap))) :qid |unknown.0:0| :skolemid |296| :pattern ((Apply0 t0@@12 (Handle0 h@@20 r@@5 rd) heap)))))
(assert (forall ((t0@@13 T@U) (heap@@0 T@U) (h@@21 T@U) (r@@6 T@U) (rd@@0 T@U)) (! (=> (and (and (and (and (and (= (type t0@@13) TyType) (= (type heap@@0) (MapType1Type refType))) (= (type h@@21) (MapType0Type (MapType1Type refType) BoxType))) (= (type r@@6) (MapType0Type (MapType1Type refType) boolType))) (= (type rd@@0) (MapType0Type (MapType1Type refType) (MapType0Type BoxType boolType)))) (U_2_bool (MapType0Select r@@6 heap@@0))) (Requires0 t0@@13 (Handle0 h@@21 r@@6 rd@@0) heap@@0)) :qid |unknown.0:0| :skolemid |297| :pattern ((Requires0 t0@@13 (Handle0 h@@21 r@@6 rd@@0) heap@@0)))))
(assert (forall ((arg0@@94 T@U) (arg1@@43 T@U) (arg2@@9 T@U)) (! (= (type (Reads0 arg0@@94 arg1@@43 arg2@@9)) (MapType0Type BoxType boolType)) :qid |funType:Reads0| :pattern ((Reads0 arg0@@94 arg1@@43 arg2@@9)))))
(assert (forall ((t0@@14 T@U) (heap@@1 T@U) (h@@22 T@U) (r@@7 T@U) (rd@@1 T@U) (bx@@38 T@U)) (! (=> (and (and (and (and (and (= (type t0@@14) TyType) (= (type heap@@1) (MapType1Type refType))) (= (type h@@22) (MapType0Type (MapType1Type refType) BoxType))) (= (type r@@7) (MapType0Type (MapType1Type refType) boolType))) (= (type rd@@1) (MapType0Type (MapType1Type refType) (MapType0Type BoxType boolType)))) (= (type bx@@38) BoxType)) (and (=> (U_2_bool (MapType0Select (Reads0 t0@@14 (Handle0 h@@22 r@@7 rd@@1) heap@@1) bx@@38)) (U_2_bool (MapType0Select (MapType0Select rd@@1 heap@@1) bx@@38))) (=> (U_2_bool (MapType0Select (MapType0Select rd@@1 heap@@1) bx@@38)) (U_2_bool (MapType0Select (Reads0 t0@@14 (Handle0 h@@22 r@@7 rd@@1) heap@@1) bx@@38))))) :qid |unknown.0:0| :skolemid |298| :pattern ((MapType0Select (Reads0 t0@@14 (Handle0 h@@22 r@@7 rd@@1) heap@@1) bx@@38)))))
(assert (forall ((t0@@15 T@U) (h0@@0 T@U) (h1@@0 T@U) (f@@5 T@U)) (! (=> (and (and (and (and (= (type t0@@15) TyType) (= (type h0@@0) (MapType1Type refType))) (= (type h1@@0) (MapType1Type refType))) (= (type f@@5) HandleTypeType)) (and (and (and ($HeapSucc h0@@0 h1@@0) (and ($IsGoodHeap h0@@0) ($IsGoodHeap h1@@0))) (and ($Is f@@5 (Tclass._System.___hFunc0 t0@@15)) ($IsAlloc f@@5 (Tclass._System.___hFunc0 t0@@15) h0@@0))) (forall ((o@@39 T@U) (fld T@U)) (! (let ((a@@77 (FieldTypeInv0 (type fld)))) (=> (and (= (type o@@39) refType) (= (type fld) (FieldType a@@77))) (=> (and (and (and (not (= o@@39 null)) (U_2_bool (MapType1Select h0@@0 o@@39 alloc))) (U_2_bool (MapType1Select h1@@0 o@@39 alloc))) (U_2_bool (MapType0Select (Reads0 t0@@15 f@@5 h0@@0) ($Box o@@39)))) (= (MapType1Select h0@@0 o@@39 fld) (MapType1Select h1@@0 o@@39 fld))))) :qid |unknown.0:0| :skolemid |299| :no-pattern (type o@@39) :no-pattern (type fld) :no-pattern (U_2_int o@@39) :no-pattern (U_2_bool o@@39) :no-pattern (U_2_int fld) :no-pattern (U_2_bool fld))))) (= (Reads0 t0@@15 f@@5 h0@@0) (Reads0 t0@@15 f@@5 h1@@0))) :qid |unknown.0:0| :skolemid |300| :pattern (($HeapSucc h0@@0 h1@@0) (Reads0 t0@@15 f@@5 h1@@0)))))
(assert (forall ((t0@@16 T@U) (h0@@1 T@U) (h1@@1 T@U) (f@@6 T@U)) (! (=> (and (and (and (and (= (type t0@@16) TyType) (= (type h0@@1) (MapType1Type refType))) (= (type h1@@1) (MapType1Type refType))) (= (type f@@6) HandleTypeType)) (and (and (and ($HeapSucc h0@@1 h1@@1) (and ($IsGoodHeap h0@@1) ($IsGoodHeap h1@@1))) (and ($Is f@@6 (Tclass._System.___hFunc0 t0@@16)) ($IsAlloc f@@6 (Tclass._System.___hFunc0 t0@@16) h0@@1))) (forall ((o@@40 T@U) (fld@@0 T@U)) (! (let ((a@@78 (FieldTypeInv0 (type fld@@0)))) (=> (and (= (type o@@40) refType) (= (type fld@@0) (FieldType a@@78))) (=> (and (and (and (not (= o@@40 null)) (U_2_bool (MapType1Select h0@@1 o@@40 alloc))) (U_2_bool (MapType1Select h1@@1 o@@40 alloc))) (U_2_bool (MapType0Select (Reads0 t0@@16 f@@6 h1@@1) ($Box o@@40)))) (= (MapType1Select h0@@1 o@@40 fld@@0) (MapType1Select h1@@1 o@@40 fld@@0))))) :qid |unknown.0:0| :skolemid |301| :no-pattern (type o@@40) :no-pattern (type fld@@0) :no-pattern (U_2_int o@@40) :no-pattern (U_2_bool o@@40) :no-pattern (U_2_int fld@@0) :no-pattern (U_2_bool fld@@0))))) (= (Reads0 t0@@16 f@@6 h0@@1) (Reads0 t0@@16 f@@6 h1@@1))) :qid |unknown.0:0| :skolemid |302| :pattern (($HeapSucc h0@@1 h1@@1) (Reads0 t0@@16 f@@6 h1@@1)))))
(assert (forall ((t0@@17 T@U) (h0@@2 T@U) (h1@@2 T@U) (f@@7 T@U)) (! (=> (and (and (and (and (= (type t0@@17) TyType) (= (type h0@@2) (MapType1Type refType))) (= (type h1@@2) (MapType1Type refType))) (= (type f@@7) HandleTypeType)) (and (and (and ($HeapSucc h0@@2 h1@@2) (and ($IsGoodHeap h0@@2) ($IsGoodHeap h1@@2))) (and ($Is f@@7 (Tclass._System.___hFunc0 t0@@17)) ($IsAlloc f@@7 (Tclass._System.___hFunc0 t0@@17) h0@@2))) (forall ((o@@41 T@U) (fld@@1 T@U)) (! (let ((a@@79 (FieldTypeInv0 (type fld@@1)))) (=> (and (= (type o@@41) refType) (= (type fld@@1) (FieldType a@@79))) (=> (and (and (and (not (= o@@41 null)) (U_2_bool (MapType1Select h0@@2 o@@41 alloc))) (U_2_bool (MapType1Select h1@@2 o@@41 alloc))) (U_2_bool (MapType0Select (Reads0 t0@@17 f@@7 h0@@2) ($Box o@@41)))) (= (MapType1Select h0@@2 o@@41 fld@@1) (MapType1Select h1@@2 o@@41 fld@@1))))) :qid |unknown.0:0| :skolemid |303| :no-pattern (type o@@41) :no-pattern (type fld@@1) :no-pattern (U_2_int o@@41) :no-pattern (U_2_bool o@@41) :no-pattern (U_2_int fld@@1) :no-pattern (U_2_bool fld@@1))))) (and (=> (Requires0 t0@@17 f@@7 h0@@2) (Requires0 t0@@17 f@@7 h1@@2)) (=> (Requires0 t0@@17 f@@7 h1@@2) (Requires0 t0@@17 f@@7 h0@@2)))) :qid |unknown.0:0| :skolemid |304| :pattern (($HeapSucc h0@@2 h1@@2) (Requires0 t0@@17 f@@7 h1@@2)))))
(assert (forall ((t0@@18 T@U) (h0@@3 T@U) (h1@@3 T@U) (f@@8 T@U)) (! (=> (and (and (and (and (= (type t0@@18) TyType) (= (type h0@@3) (MapType1Type refType))) (= (type h1@@3) (MapType1Type refType))) (= (type f@@8) HandleTypeType)) (and (and (and ($HeapSucc h0@@3 h1@@3) (and ($IsGoodHeap h0@@3) ($IsGoodHeap h1@@3))) (and ($Is f@@8 (Tclass._System.___hFunc0 t0@@18)) ($IsAlloc f@@8 (Tclass._System.___hFunc0 t0@@18) h0@@3))) (forall ((o@@42 T@U) (fld@@2 T@U)) (! (let ((a@@80 (FieldTypeInv0 (type fld@@2)))) (=> (and (= (type o@@42) refType) (= (type fld@@2) (FieldType a@@80))) (=> (and (and (and (not (= o@@42 null)) (U_2_bool (MapType1Select h0@@3 o@@42 alloc))) (U_2_bool (MapType1Select h1@@3 o@@42 alloc))) (U_2_bool (MapType0Select (Reads0 t0@@18 f@@8 h1@@3) ($Box o@@42)))) (= (MapType1Select h0@@3 o@@42 fld@@2) (MapType1Select h1@@3 o@@42 fld@@2))))) :qid |unknown.0:0| :skolemid |305| :no-pattern (type o@@42) :no-pattern (type fld@@2) :no-pattern (U_2_int o@@42) :no-pattern (U_2_bool o@@42) :no-pattern (U_2_int fld@@2) :no-pattern (U_2_bool fld@@2))))) (and (=> (Requires0 t0@@18 f@@8 h0@@3) (Requires0 t0@@18 f@@8 h1@@3)) (=> (Requires0 t0@@18 f@@8 h1@@3) (Requires0 t0@@18 f@@8 h0@@3)))) :qid |unknown.0:0| :skolemid |306| :pattern (($HeapSucc h0@@3 h1@@3) (Requires0 t0@@18 f@@8 h1@@3)))))
(assert (forall ((t0@@19 T@U) (h0@@4 T@U) (h1@@4 T@U) (f@@9 T@U)) (! (=> (and (and (and (and (= (type t0@@19) TyType) (= (type h0@@4) (MapType1Type refType))) (= (type h1@@4) (MapType1Type refType))) (= (type f@@9) HandleTypeType)) (and (and (and ($HeapSucc h0@@4 h1@@4) (and ($IsGoodHeap h0@@4) ($IsGoodHeap h1@@4))) (and ($Is f@@9 (Tclass._System.___hFunc0 t0@@19)) ($IsAlloc f@@9 (Tclass._System.___hFunc0 t0@@19) h0@@4))) (forall ((o@@43 T@U) (fld@@3 T@U)) (! (let ((a@@81 (FieldTypeInv0 (type fld@@3)))) (=> (and (= (type o@@43) refType) (= (type fld@@3) (FieldType a@@81))) (=> (and (and (and (not (= o@@43 null)) (U_2_bool (MapType1Select h0@@4 o@@43 alloc))) (U_2_bool (MapType1Select h1@@4 o@@43 alloc))) (U_2_bool (MapType0Select (Reads0 t0@@19 f@@9 h0@@4) ($Box o@@43)))) (= (MapType1Select h0@@4 o@@43 fld@@3) (MapType1Select h1@@4 o@@43 fld@@3))))) :qid |unknown.0:0| :skolemid |307| :no-pattern (type o@@43) :no-pattern (type fld@@3) :no-pattern (U_2_int o@@43) :no-pattern (U_2_bool o@@43) :no-pattern (U_2_int fld@@3) :no-pattern (U_2_bool fld@@3))))) (= (Apply0 t0@@19 f@@9 h0@@4) (Apply0 t0@@19 f@@9 h1@@4))) :qid |unknown.0:0| :skolemid |308| :pattern (($HeapSucc h0@@4 h1@@4) (Apply0 t0@@19 f@@9 h1@@4)))))
(assert (forall ((t0@@20 T@U) (h0@@5 T@U) (h1@@5 T@U) (f@@10 T@U)) (! (=> (and (and (and (and (= (type t0@@20) TyType) (= (type h0@@5) (MapType1Type refType))) (= (type h1@@5) (MapType1Type refType))) (= (type f@@10) HandleTypeType)) (and (and (and ($HeapSucc h0@@5 h1@@5) (and ($IsGoodHeap h0@@5) ($IsGoodHeap h1@@5))) (and ($Is f@@10 (Tclass._System.___hFunc0 t0@@20)) ($IsAlloc f@@10 (Tclass._System.___hFunc0 t0@@20) h0@@5))) (forall ((o@@44 T@U) (fld@@4 T@U)) (! (let ((a@@82 (FieldTypeInv0 (type fld@@4)))) (=> (and (= (type o@@44) refType) (= (type fld@@4) (FieldType a@@82))) (=> (and (and (and (not (= o@@44 null)) (U_2_bool (MapType1Select h0@@5 o@@44 alloc))) (U_2_bool (MapType1Select h1@@5 o@@44 alloc))) (U_2_bool (MapType0Select (Reads0 t0@@20 f@@10 h1@@5) ($Box o@@44)))) (= (MapType1Select h0@@5 o@@44 fld@@4) (MapType1Select h1@@5 o@@44 fld@@4))))) :qid |unknown.0:0| :skolemid |309| :no-pattern (type o@@44) :no-pattern (type fld@@4) :no-pattern (U_2_int o@@44) :no-pattern (U_2_bool o@@44) :no-pattern (U_2_int fld@@4) :no-pattern (U_2_bool fld@@4))))) (= (Apply0 t0@@20 f@@10 h0@@5) (Apply0 t0@@20 f@@10 h1@@5))) :qid |unknown.0:0| :skolemid |310| :pattern (($HeapSucc h0@@5 h1@@5) (Apply0 t0@@20 f@@10 h1@@5)))))
(assert (forall ((t0@@21 T@U) (h@@23 T@U) (f@@11 T@U)) (! (=> (and (and (and (= (type t0@@21) TyType) (= (type h@@23) (MapType1Type refType))) (= (type f@@11) HandleTypeType)) (and ($IsGoodHeap h@@23) (and ($Is f@@11 (Tclass._System.___hFunc0 t0@@21)) ($IsAlloc f@@11 (Tclass._System.___hFunc0 t0@@21) h@@23)))) (and ($IsBox (Apply0 t0@@21 f@@11 h@@23) t0@@21) ($IsAllocBox (Apply0 t0@@21 f@@11 h@@23) t0@@21 h@@23))) :qid |unknown.0:0| :skolemid |311| :pattern ((Apply0 t0@@21 f@@11 h@@23)))))
(assert (forall ((arg0@@95 T@U) (arg1@@44 T@U)) (! (= (type (Tclass._System.___hFunc1 arg0@@95 arg1@@44)) TyType) :qid |funType:Tclass._System.___hFunc1| :pattern ((Tclass._System.___hFunc1 arg0@@95 arg1@@44)))))
(assert (forall ((|#$T0@@2| T@U) (|#$T1| T@U)) (! (=> (and (= (type |#$T0@@2|) TyType) (= (type |#$T1|) TyType)) (= (Tag (Tclass._System.___hFunc1 |#$T0@@2| |#$T1|)) Tagclass._System.___hFunc1)) :qid |unknown.0:0| :skolemid |312| :pattern ((Tclass._System.___hFunc1 |#$T0@@2| |#$T1|)))))
(assert (forall ((arg0@@96 T@U)) (! (= (type (Tclass._System.___hFunc1_0 arg0@@96)) TyType) :qid |funType:Tclass._System.___hFunc1_0| :pattern ((Tclass._System.___hFunc1_0 arg0@@96)))))
(assert (forall ((|#$T0@@3| T@U) (|#$T1@@0| T@U)) (! (=> (and (= (type |#$T0@@3|) TyType) (= (type |#$T1@@0|) TyType)) (= (Tclass._System.___hFunc1_0 (Tclass._System.___hFunc1 |#$T0@@3| |#$T1@@0|)) |#$T0@@3|)) :qid |unknown.0:0| :skolemid |313| :pattern ((Tclass._System.___hFunc1 |#$T0@@3| |#$T1@@0|)))))
(assert (forall ((arg0@@97 T@U)) (! (= (type (Tclass._System.___hFunc1_1 arg0@@97)) TyType) :qid |funType:Tclass._System.___hFunc1_1| :pattern ((Tclass._System.___hFunc1_1 arg0@@97)))))
(assert (forall ((|#$T0@@4| T@U) (|#$T1@@1| T@U)) (! (=> (and (= (type |#$T0@@4|) TyType) (= (type |#$T1@@1|) TyType)) (= (Tclass._System.___hFunc1_1 (Tclass._System.___hFunc1 |#$T0@@4| |#$T1@@1|)) |#$T1@@1|)) :qid |unknown.0:0| :skolemid |314| :pattern ((Tclass._System.___hFunc1 |#$T0@@4| |#$T1@@1|)))))
(assert (forall ((|#$T0@@5| T@U) (|#$T1@@2| T@U) (bx@@39 T@U)) (! (=> (and (and (and (= (type |#$T0@@5|) TyType) (= (type |#$T1@@2|) TyType)) (= (type bx@@39) BoxType)) ($IsBox bx@@39 (Tclass._System.___hFunc1 |#$T0@@5| |#$T1@@2|))) (and (= ($Box ($Unbox HandleTypeType bx@@39)) bx@@39) ($Is ($Unbox HandleTypeType bx@@39) (Tclass._System.___hFunc1 |#$T0@@5| |#$T1@@2|)))) :qid |unknown.0:0| :skolemid |315| :pattern (($IsBox bx@@39 (Tclass._System.___hFunc1 |#$T0@@5| |#$T1@@2|))))))
(assert (and (and (and (and (and (and (and (and (and (forall ((arg0@@98 T@T) (arg1@@45 T@T) (arg2@@10 T@T)) (! (= (Ctor (MapType2Type arg0@@98 arg1@@45 arg2@@10)) 19) :qid |ctor:MapType2Type|)) (forall ((arg0@@99 T@T) (arg1@@46 T@T) (arg2@@11 T@T)) (! (= (MapType2TypeInv0 (MapType2Type arg0@@99 arg1@@46 arg2@@11)) arg0@@99) :qid |typeInv:MapType2TypeInv0| :pattern ((MapType2Type arg0@@99 arg1@@46 arg2@@11))))) (forall ((arg0@@100 T@T) (arg1@@47 T@T) (arg2@@12 T@T)) (! (= (MapType2TypeInv1 (MapType2Type arg0@@100 arg1@@47 arg2@@12)) arg1@@47) :qid |typeInv:MapType2TypeInv1| :pattern ((MapType2Type arg0@@100 arg1@@47 arg2@@12))))) (forall ((arg0@@101 T@T) (arg1@@48 T@T) (arg2@@13 T@T)) (! (= (MapType2TypeInv2 (MapType2Type arg0@@101 arg1@@48 arg2@@13)) arg2@@13) :qid |typeInv:MapType2TypeInv2| :pattern ((MapType2Type arg0@@101 arg1@@48 arg2@@13))))) (forall ((arg0@@102 T@U) (arg1@@49 T@U) (arg2@@14 T@U)) (! (let ((aVar2 (MapType2TypeInv2 (type arg0@@102)))) (= (type (MapType2Select arg0@@102 arg1@@49 arg2@@14)) aVar2)) :qid |funType:MapType2Select| :pattern ((MapType2Select arg0@@102 arg1@@49 arg2@@14))))) (forall ((arg0@@103 T@U) (arg1@@50 T@U) (arg2@@15 T@U) (arg3@@0 T@U)) (! (let ((aVar2@@0 (type arg3@@0))) (let ((aVar1@@2 (type arg2@@15))) (let ((aVar0@@1 (type arg1@@50))) (= (type (MapType2Store arg0@@103 arg1@@50 arg2@@15 arg3@@0)) (MapType2Type aVar0@@1 aVar1@@2 aVar2@@0))))) :qid |funType:MapType2Store| :pattern ((MapType2Store arg0@@103 arg1@@50 arg2@@15 arg3@@0))))) (forall ((m@@18 T@U) (x0@@6 T@U) (x1@@3 T@U) (val@@6 T@U)) (! (let ((aVar2@@1 (MapType2TypeInv2 (type m@@18)))) (=> (= (type val@@6) aVar2@@1) (= (MapType2Select (MapType2Store m@@18 x0@@6 x1@@3 val@@6) x0@@6 x1@@3) val@@6))) :qid |mapAx0:MapType2Select| :weight 0))) (and (and (forall ((val@@7 T@U) (m@@19 T@U) (x0@@7 T@U) (x1@@4 T@U) (y0@@4 T@U) (y1@@2 T@U)) (! (or (= x0@@7 y0@@4) (= (MapType2Select (MapType2Store m@@19 x0@@7 x1@@4 val@@7) y0@@4 y1@@2) (MapType2Select m@@19 y0@@4 y1@@2))) :qid |mapAx1:MapType2Select:0| :weight 0)) (forall ((val@@8 T@U) (m@@20 T@U) (x0@@8 T@U) (x1@@5 T@U) (y0@@5 T@U) (y1@@3 T@U)) (! (or (= x1@@5 y1@@3) (= (MapType2Select (MapType2Store m@@20 x0@@8 x1@@5 val@@8) y0@@5 y1@@3) (MapType2Select m@@20 y0@@5 y1@@3))) :qid |mapAx1:MapType2Select:1| :weight 0))) (forall ((val@@9 T@U) (m@@21 T@U) (x0@@9 T@U) (x1@@6 T@U) (y0@@6 T@U) (y1@@4 T@U)) (! (or true (= (MapType2Select (MapType2Store m@@21 x0@@9 x1@@6 val@@9) y0@@6 y1@@4) (MapType2Select m@@21 y0@@6 y1@@4))) :qid |mapAx2:MapType2Select| :weight 0)))) (forall ((arg0@@104 T@U) (arg1@@51 T@U) (arg2@@16 T@U) (arg3@@1 T@U) (arg4 T@U)) (! (= (type (Apply1 arg0@@104 arg1@@51 arg2@@16 arg3@@1 arg4)) BoxType) :qid |funType:Apply1| :pattern ((Apply1 arg0@@104 arg1@@51 arg2@@16 arg3@@1 arg4))))) (forall ((arg0@@105 T@U) (arg1@@52 T@U) (arg2@@17 T@U)) (! (= (type (Handle1 arg0@@105 arg1@@52 arg2@@17)) HandleTypeType) :qid |funType:Handle1| :pattern ((Handle1 arg0@@105 arg1@@52 arg2@@17))))))
(assert (forall ((t0@@22 T@U) (t1@@3 T@U) (heap@@2 T@U) (h@@24 T@U) (r@@8 T@U) (rd@@2 T@U) (bx0 T@U)) (! (=> (and (and (and (and (and (and (= (type t0@@22) TyType) (= (type t1@@3) TyType)) (= (type heap@@2) (MapType1Type refType))) (= (type h@@24) (MapType2Type (MapType1Type refType) BoxType BoxType))) (= (type r@@8) (MapType2Type (MapType1Type refType) BoxType boolType))) (= (type rd@@2) (MapType2Type (MapType1Type refType) BoxType (MapType0Type BoxType boolType)))) (= (type bx0) BoxType)) (= (Apply1 t0@@22 t1@@3 (Handle1 h@@24 r@@8 rd@@2) heap@@2 bx0) (MapType2Select h@@24 heap@@2 bx0))) :qid |unknown.0:0| :skolemid |316| :pattern ((Apply1 t0@@22 t1@@3 (Handle1 h@@24 r@@8 rd@@2) heap@@2 bx0)))))
(assert (forall ((t0@@23 T@U) (t1@@4 T@U) (heap@@3 T@U) (h@@25 T@U) (r@@9 T@U) (rd@@3 T@U) (bx0@@0 T@U)) (! (=> (and (and (and (and (and (and (and (= (type t0@@23) TyType) (= (type t1@@4) TyType)) (= (type heap@@3) (MapType1Type refType))) (= (type h@@25) (MapType2Type (MapType1Type refType) BoxType BoxType))) (= (type r@@9) (MapType2Type (MapType1Type refType) BoxType boolType))) (= (type rd@@3) (MapType2Type (MapType1Type refType) BoxType (MapType0Type BoxType boolType)))) (= (type bx0@@0) BoxType)) (U_2_bool (MapType2Select r@@9 heap@@3 bx0@@0))) (Requires1 t0@@23 t1@@4 (Handle1 h@@25 r@@9 rd@@3) heap@@3 bx0@@0)) :qid |unknown.0:0| :skolemid |317| :pattern ((Requires1 t0@@23 t1@@4 (Handle1 h@@25 r@@9 rd@@3) heap@@3 bx0@@0)))))
(assert (forall ((arg0@@106 T@U) (arg1@@53 T@U) (arg2@@18 T@U) (arg3@@2 T@U) (arg4@@0 T@U)) (! (= (type (Reads1 arg0@@106 arg1@@53 arg2@@18 arg3@@2 arg4@@0)) (MapType0Type BoxType boolType)) :qid |funType:Reads1| :pattern ((Reads1 arg0@@106 arg1@@53 arg2@@18 arg3@@2 arg4@@0)))))
(assert (forall ((t0@@24 T@U) (t1@@5 T@U) (heap@@4 T@U) (h@@26 T@U) (r@@10 T@U) (rd@@4 T@U) (bx0@@1 T@U) (bx@@40 T@U)) (! (=> (and (and (and (and (and (and (and (= (type t0@@24) TyType) (= (type t1@@5) TyType)) (= (type heap@@4) (MapType1Type refType))) (= (type h@@26) (MapType2Type (MapType1Type refType) BoxType BoxType))) (= (type r@@10) (MapType2Type (MapType1Type refType) BoxType boolType))) (= (type rd@@4) (MapType2Type (MapType1Type refType) BoxType (MapType0Type BoxType boolType)))) (= (type bx0@@1) BoxType)) (= (type bx@@40) BoxType)) (and (=> (U_2_bool (MapType0Select (Reads1 t0@@24 t1@@5 (Handle1 h@@26 r@@10 rd@@4) heap@@4 bx0@@1) bx@@40)) (U_2_bool (MapType0Select (MapType2Select rd@@4 heap@@4 bx0@@1) bx@@40))) (=> (U_2_bool (MapType0Select (MapType2Select rd@@4 heap@@4 bx0@@1) bx@@40)) (U_2_bool (MapType0Select (Reads1 t0@@24 t1@@5 (Handle1 h@@26 r@@10 rd@@4) heap@@4 bx0@@1) bx@@40))))) :qid |unknown.0:0| :skolemid |318| :pattern ((MapType0Select (Reads1 t0@@24 t1@@5 (Handle1 h@@26 r@@10 rd@@4) heap@@4 bx0@@1) bx@@40)))))
(assert (forall ((t0@@25 T@U) (t1@@6 T@U) (h0@@6 T@U) (h1@@6 T@U) (f@@12 T@U) (bx0@@2 T@U)) (! (=> (and (and (and (and (and (and (= (type t0@@25) TyType) (= (type t1@@6) TyType)) (= (type h0@@6) (MapType1Type refType))) (= (type h1@@6) (MapType1Type refType))) (= (type f@@12) HandleTypeType)) (= (type bx0@@2) BoxType)) (and (and (and ($HeapSucc h0@@6 h1@@6) (and ($IsGoodHeap h0@@6) ($IsGoodHeap h1@@6))) (and (and ($IsBox bx0@@2 t0@@25) ($IsAllocBox bx0@@2 t0@@25 h0@@6)) (and ($Is f@@12 (Tclass._System.___hFunc1 t0@@25 t1@@6)) ($IsAlloc f@@12 (Tclass._System.___hFunc1 t0@@25 t1@@6) h0@@6)))) (forall ((o@@45 T@U) (fld@@5 T@U)) (! (let ((a@@83 (FieldTypeInv0 (type fld@@5)))) (=> (and (= (type o@@45) refType) (= (type fld@@5) (FieldType a@@83))) (=> (and (and (and (not (= o@@45 null)) (U_2_bool (MapType1Select h0@@6 o@@45 alloc))) (U_2_bool (MapType1Select h1@@6 o@@45 alloc))) (U_2_bool (MapType0Select (Reads1 t0@@25 t1@@6 f@@12 h0@@6 bx0@@2) ($Box o@@45)))) (= (MapType1Select h0@@6 o@@45 fld@@5) (MapType1Select h1@@6 o@@45 fld@@5))))) :qid |unknown.0:0| :skolemid |319| :no-pattern (type o@@45) :no-pattern (type fld@@5) :no-pattern (U_2_int o@@45) :no-pattern (U_2_bool o@@45) :no-pattern (U_2_int fld@@5) :no-pattern (U_2_bool fld@@5))))) (= (Reads1 t0@@25 t1@@6 f@@12 h0@@6 bx0@@2) (Reads1 t0@@25 t1@@6 f@@12 h1@@6 bx0@@2))) :qid |unknown.0:0| :skolemid |320| :pattern (($HeapSucc h0@@6 h1@@6) (Reads1 t0@@25 t1@@6 f@@12 h1@@6 bx0@@2)))))
(assert (forall ((t0@@26 T@U) (t1@@7 T@U) (h0@@7 T@U) (h1@@7 T@U) (f@@13 T@U) (bx0@@3 T@U)) (! (=> (and (and (and (and (and (and (= (type t0@@26) TyType) (= (type t1@@7) TyType)) (= (type h0@@7) (MapType1Type refType))) (= (type h1@@7) (MapType1Type refType))) (= (type f@@13) HandleTypeType)) (= (type bx0@@3) BoxType)) (and (and (and ($HeapSucc h0@@7 h1@@7) (and ($IsGoodHeap h0@@7) ($IsGoodHeap h1@@7))) (and (and ($IsBox bx0@@3 t0@@26) ($IsAllocBox bx0@@3 t0@@26 h0@@7)) (and ($Is f@@13 (Tclass._System.___hFunc1 t0@@26 t1@@7)) ($IsAlloc f@@13 (Tclass._System.___hFunc1 t0@@26 t1@@7) h0@@7)))) (forall ((o@@46 T@U) (fld@@6 T@U)) (! (let ((a@@84 (FieldTypeInv0 (type fld@@6)))) (=> (and (= (type o@@46) refType) (= (type fld@@6) (FieldType a@@84))) (=> (and (and (and (not (= o@@46 null)) (U_2_bool (MapType1Select h0@@7 o@@46 alloc))) (U_2_bool (MapType1Select h1@@7 o@@46 alloc))) (U_2_bool (MapType0Select (Reads1 t0@@26 t1@@7 f@@13 h1@@7 bx0@@3) ($Box o@@46)))) (= (MapType1Select h0@@7 o@@46 fld@@6) (MapType1Select h1@@7 o@@46 fld@@6))))) :qid |unknown.0:0| :skolemid |321| :no-pattern (type o@@46) :no-pattern (type fld@@6) :no-pattern (U_2_int o@@46) :no-pattern (U_2_bool o@@46) :no-pattern (U_2_int fld@@6) :no-pattern (U_2_bool fld@@6))))) (= (Reads1 t0@@26 t1@@7 f@@13 h0@@7 bx0@@3) (Reads1 t0@@26 t1@@7 f@@13 h1@@7 bx0@@3))) :qid |unknown.0:0| :skolemid |322| :pattern (($HeapSucc h0@@7 h1@@7) (Reads1 t0@@26 t1@@7 f@@13 h1@@7 bx0@@3)))))
(assert (forall ((t0@@27 T@U) (t1@@8 T@U) (h0@@8 T@U) (h1@@8 T@U) (f@@14 T@U) (bx0@@4 T@U)) (! (=> (and (and (and (and (and (and (= (type t0@@27) TyType) (= (type t1@@8) TyType)) (= (type h0@@8) (MapType1Type refType))) (= (type h1@@8) (MapType1Type refType))) (= (type f@@14) HandleTypeType)) (= (type bx0@@4) BoxType)) (and (and (and ($HeapSucc h0@@8 h1@@8) (and ($IsGoodHeap h0@@8) ($IsGoodHeap h1@@8))) (and (and ($IsBox bx0@@4 t0@@27) ($IsAllocBox bx0@@4 t0@@27 h0@@8)) (and ($Is f@@14 (Tclass._System.___hFunc1 t0@@27 t1@@8)) ($IsAlloc f@@14 (Tclass._System.___hFunc1 t0@@27 t1@@8) h0@@8)))) (forall ((o@@47 T@U) (fld@@7 T@U)) (! (let ((a@@85 (FieldTypeInv0 (type fld@@7)))) (=> (and (= (type o@@47) refType) (= (type fld@@7) (FieldType a@@85))) (=> (and (and (and (not (= o@@47 null)) (U_2_bool (MapType1Select h0@@8 o@@47 alloc))) (U_2_bool (MapType1Select h1@@8 o@@47 alloc))) (U_2_bool (MapType0Select (Reads1 t0@@27 t1@@8 f@@14 h0@@8 bx0@@4) ($Box o@@47)))) (= (MapType1Select h0@@8 o@@47 fld@@7) (MapType1Select h1@@8 o@@47 fld@@7))))) :qid |unknown.0:0| :skolemid |323| :no-pattern (type o@@47) :no-pattern (type fld@@7) :no-pattern (U_2_int o@@47) :no-pattern (U_2_bool o@@47) :no-pattern (U_2_int fld@@7) :no-pattern (U_2_bool fld@@7))))) (and (=> (Requires1 t0@@27 t1@@8 f@@14 h0@@8 bx0@@4) (Requires1 t0@@27 t1@@8 f@@14 h1@@8 bx0@@4)) (=> (Requires1 t0@@27 t1@@8 f@@14 h1@@8 bx0@@4) (Requires1 t0@@27 t1@@8 f@@14 h0@@8 bx0@@4)))) :qid |unknown.0:0| :skolemid |324| :pattern (($HeapSucc h0@@8 h1@@8) (Requires1 t0@@27 t1@@8 f@@14 h1@@8 bx0@@4)))))
(assert (forall ((t0@@28 T@U) (t1@@9 T@U) (h0@@9 T@U) (h1@@9 T@U) (f@@15 T@U) (bx0@@5 T@U)) (! (=> (and (and (and (and (and (and (= (type t0@@28) TyType) (= (type t1@@9) TyType)) (= (type h0@@9) (MapType1Type refType))) (= (type h1@@9) (MapType1Type refType))) (= (type f@@15) HandleTypeType)) (= (type bx0@@5) BoxType)) (and (and (and ($HeapSucc h0@@9 h1@@9) (and ($IsGoodHeap h0@@9) ($IsGoodHeap h1@@9))) (and (and ($IsBox bx0@@5 t0@@28) ($IsAllocBox bx0@@5 t0@@28 h0@@9)) (and ($Is f@@15 (Tclass._System.___hFunc1 t0@@28 t1@@9)) ($IsAlloc f@@15 (Tclass._System.___hFunc1 t0@@28 t1@@9) h0@@9)))) (forall ((o@@48 T@U) (fld@@8 T@U)) (! (let ((a@@86 (FieldTypeInv0 (type fld@@8)))) (=> (and (= (type o@@48) refType) (= (type fld@@8) (FieldType a@@86))) (=> (and (and (and (not (= o@@48 null)) (U_2_bool (MapType1Select h0@@9 o@@48 alloc))) (U_2_bool (MapType1Select h1@@9 o@@48 alloc))) (U_2_bool (MapType0Select (Reads1 t0@@28 t1@@9 f@@15 h1@@9 bx0@@5) ($Box o@@48)))) (= (MapType1Select h0@@9 o@@48 fld@@8) (MapType1Select h1@@9 o@@48 fld@@8))))) :qid |unknown.0:0| :skolemid |325| :no-pattern (type o@@48) :no-pattern (type fld@@8) :no-pattern (U_2_int o@@48) :no-pattern (U_2_bool o@@48) :no-pattern (U_2_int fld@@8) :no-pattern (U_2_bool fld@@8))))) (and (=> (Requires1 t0@@28 t1@@9 f@@15 h0@@9 bx0@@5) (Requires1 t0@@28 t1@@9 f@@15 h1@@9 bx0@@5)) (=> (Requires1 t0@@28 t1@@9 f@@15 h1@@9 bx0@@5) (Requires1 t0@@28 t1@@9 f@@15 h0@@9 bx0@@5)))) :qid |unknown.0:0| :skolemid |326| :pattern (($HeapSucc h0@@9 h1@@9) (Requires1 t0@@28 t1@@9 f@@15 h1@@9 bx0@@5)))))
(assert (forall ((t0@@29 T@U) (t1@@10 T@U) (h0@@10 T@U) (h1@@10 T@U) (f@@16 T@U) (bx0@@6 T@U)) (! (=> (and (and (and (and (and (and (= (type t0@@29) TyType) (= (type t1@@10) TyType)) (= (type h0@@10) (MapType1Type refType))) (= (type h1@@10) (MapType1Type refType))) (= (type f@@16) HandleTypeType)) (= (type bx0@@6) BoxType)) (and (and (and ($HeapSucc h0@@10 h1@@10) (and ($IsGoodHeap h0@@10) ($IsGoodHeap h1@@10))) (and (and ($IsBox bx0@@6 t0@@29) ($IsAllocBox bx0@@6 t0@@29 h0@@10)) (and ($Is f@@16 (Tclass._System.___hFunc1 t0@@29 t1@@10)) ($IsAlloc f@@16 (Tclass._System.___hFunc1 t0@@29 t1@@10) h0@@10)))) (forall ((o@@49 T@U) (fld@@9 T@U)) (! (let ((a@@87 (FieldTypeInv0 (type fld@@9)))) (=> (and (= (type o@@49) refType) (= (type fld@@9) (FieldType a@@87))) (=> (and (and (and (not (= o@@49 null)) (U_2_bool (MapType1Select h0@@10 o@@49 alloc))) (U_2_bool (MapType1Select h1@@10 o@@49 alloc))) (U_2_bool (MapType0Select (Reads1 t0@@29 t1@@10 f@@16 h0@@10 bx0@@6) ($Box o@@49)))) (= (MapType1Select h0@@10 o@@49 fld@@9) (MapType1Select h1@@10 o@@49 fld@@9))))) :qid |unknown.0:0| :skolemid |327| :no-pattern (type o@@49) :no-pattern (type fld@@9) :no-pattern (U_2_int o@@49) :no-pattern (U_2_bool o@@49) :no-pattern (U_2_int fld@@9) :no-pattern (U_2_bool fld@@9))))) (= (Apply1 t0@@29 t1@@10 f@@16 h0@@10 bx0@@6) (Apply1 t0@@29 t1@@10 f@@16 h1@@10 bx0@@6))) :qid |unknown.0:0| :skolemid |328| :pattern (($HeapSucc h0@@10 h1@@10) (Apply1 t0@@29 t1@@10 f@@16 h1@@10 bx0@@6)))))
(assert (forall ((t0@@30 T@U) (t1@@11 T@U) (h0@@11 T@U) (h1@@11 T@U) (f@@17 T@U) (bx0@@7 T@U)) (! (=> (and (and (and (and (and (and (= (type t0@@30) TyType) (= (type t1@@11) TyType)) (= (type h0@@11) (MapType1Type refType))) (= (type h1@@11) (MapType1Type refType))) (= (type f@@17) HandleTypeType)) (= (type bx0@@7) BoxType)) (and (and (and ($HeapSucc h0@@11 h1@@11) (and ($IsGoodHeap h0@@11) ($IsGoodHeap h1@@11))) (and (and ($IsBox bx0@@7 t0@@30) ($IsAllocBox bx0@@7 t0@@30 h0@@11)) (and ($Is f@@17 (Tclass._System.___hFunc1 t0@@30 t1@@11)) ($IsAlloc f@@17 (Tclass._System.___hFunc1 t0@@30 t1@@11) h0@@11)))) (forall ((o@@50 T@U) (fld@@10 T@U)) (! (let ((a@@88 (FieldTypeInv0 (type fld@@10)))) (=> (and (= (type o@@50) refType) (= (type fld@@10) (FieldType a@@88))) (=> (and (and (and (not (= o@@50 null)) (U_2_bool (MapType1Select h0@@11 o@@50 alloc))) (U_2_bool (MapType1Select h1@@11 o@@50 alloc))) (U_2_bool (MapType0Select (Reads1 t0@@30 t1@@11 f@@17 h1@@11 bx0@@7) ($Box o@@50)))) (= (MapType1Select h0@@11 o@@50 fld@@10) (MapType1Select h1@@11 o@@50 fld@@10))))) :qid |unknown.0:0| :skolemid |329| :no-pattern (type o@@50) :no-pattern (type fld@@10) :no-pattern (U_2_int o@@50) :no-pattern (U_2_bool o@@50) :no-pattern (U_2_int fld@@10) :no-pattern (U_2_bool fld@@10))))) (= (Apply1 t0@@30 t1@@11 f@@17 h0@@11 bx0@@7) (Apply1 t0@@30 t1@@11 f@@17 h1@@11 bx0@@7))) :qid |unknown.0:0| :skolemid |330| :pattern (($HeapSucc h0@@11 h1@@11) (Apply1 t0@@30 t1@@11 f@@17 h1@@11 bx0@@7)))))
(assert (forall ((t0@@31 T@U) (t1@@12 T@U) (h@@27 T@U) (f@@18 T@U) (bx0@@8 T@U)) (! (=> (and (and (and (and (and (= (type t0@@31) TyType) (= (type t1@@12) TyType)) (= (type h@@27) (MapType1Type refType))) (= (type f@@18) HandleTypeType)) (= (type bx0@@8) BoxType)) (and ($IsGoodHeap h@@27) (and (and ($IsBox bx0@@8 t0@@31) ($IsAllocBox bx0@@8 t0@@31 h@@27)) (and ($Is f@@18 (Tclass._System.___hFunc1 t0@@31 t1@@12)) ($IsAlloc f@@18 (Tclass._System.___hFunc1 t0@@31 t1@@12) h@@27))))) (and ($IsBox (Apply1 t0@@31 t1@@12 f@@18 h@@27 bx0@@8) t1@@12) ($IsAllocBox (Apply1 t0@@31 t1@@12 f@@18 h@@27 bx0@@8) t1@@12 h@@27))) :qid |unknown.0:0| :skolemid |331| :pattern ((Apply1 t0@@31 t1@@12 f@@18 h@@27 bx0@@8)))))
(assert (= (type Tclass._module.__default) TyType))
(assert (= (Tag Tclass._module.__default) Tagclass._module.__default))
(assert (forall ((bx@@41 T@U)) (! (=> (and (= (type bx@@41) BoxType) ($IsBox bx@@41 Tclass._module.__default)) (and (= ($Box ($Unbox refType bx@@41)) bx@@41) ($Is ($Unbox refType bx@@41) Tclass._module.__default))) :qid |unknown.0:0| :skolemid |332| :pattern (($IsBox bx@@41 Tclass._module.__default)))))
(assert (forall (($o@@5 T@U)) (! (=> (= (type $o@@5) refType) (and (=> ($Is $o@@5 Tclass._module.__default) (or (= $o@@5 null) (= (dtype $o@@5) Tclass._module.__default))) (=> (or (= $o@@5 null) (= (dtype $o@@5) Tclass._module.__default)) ($Is $o@@5 Tclass._module.__default)))) :qid |unknown.0:0| :skolemid |333| :pattern (($Is $o@@5 Tclass._module.__default)))))
(assert (forall (($o@@6 T@U) ($h@@3 T@U)) (! (=> (and (= (type $o@@6) refType) (= (type $h@@3) (MapType1Type refType))) (and (=> ($IsAlloc $o@@6 Tclass._module.__default $h@@3) (or (= $o@@6 null) (U_2_bool (MapType1Select $h@@3 $o@@6 alloc)))) (=> (or (= $o@@6 null) (U_2_bool (MapType1Select $h@@3 $o@@6 alloc))) ($IsAlloc $o@@6 Tclass._module.__default $h@@3)))) :qid |unknown.0:0| :skolemid |334| :pattern (($IsAlloc $o@@6 Tclass._module.__default $h@@3)))))
(assert (forall (($ly T@U) ($Heap T@U) (|n#0| Int)) (! (=> (and (= (type $ly) LayerTypeType) (= (type $Heap) (MapType1Type refType))) (= (_module.__default.Factorial ($LS $ly) $Heap |n#0|) (_module.__default.Factorial $ly $Heap |n#0|))) :qid |Classics.7:10| :skolemid |335| :pattern ((_module.__default.Factorial ($LS $ly) $Heap |n#0|)))))
(assert (forall (($ly@@0 T@U) ($h0 T@U) ($h1 T@U) (|n#0@@0| Int)) (! (=> (and (and (= (type $ly@@0) LayerTypeType) (= (type $h0) (MapType1Type refType))) (= (type $h1) (MapType1Type refType))) (=> (and (and (and ($IsGoodHeap $h0) ($IsGoodHeap $h1)) (and (or (|_module.__default.Factorial#canCall| $h0 |n#0@@0|) (<= 0 |n#0@@0|)) (or (|_module.__default.Factorial#canCall| $h1 |n#0@@0|) (<= 0 |n#0@@0|)))) (and ($IsHeapAnchor $h0) ($HeapSucc $h0 $h1))) (=> (forall (($o@@7 T@U) ($f T@U)) (! (let ((alpha@@6 (FieldTypeInv0 (type $f)))) (=> (and (and (= (type $o@@7) refType) (= (type $f) (FieldType alpha@@6))) false) (= (MapType1Select $h0 $o@@7 $f) (MapType1Select $h1 $o@@7 $f)))) :qid |unknown.0:0| :skolemid |336| :no-pattern (type $o@@7) :no-pattern (type $f) :no-pattern (U_2_int $o@@7) :no-pattern (U_2_bool $o@@7) :no-pattern (U_2_int $f) :no-pattern (U_2_bool $f))) (= (_module.__default.Factorial $ly@@0 $h0 |n#0@@0|) (_module.__default.Factorial $ly@@0 $h1 |n#0@@0|))))) :qid |unknown.0:0| :skolemid |337| :pattern (($IsHeapAnchor $h0) ($HeapSucc $h0 $h1) (_module.__default.Factorial $ly@@0 $h1 |n#0@@0|)))))
(assert (=> (or (< 0 $ModuleContextHeight) (and (= 0 $ModuleContextHeight) (<= 0 $FunctionContextHeight))) (forall (($ly@@1 T@U) ($Heap@@0 T@U) (|n#0@@1| Int)) (! (=> (and (and (= (type $ly@@1) LayerTypeType) (= (type $Heap@@0) (MapType1Type refType))) (or (|_module.__default.Factorial#canCall| $Heap@@0 |n#0@@1|) (and (or (not (= 0 $ModuleContextHeight)) (not (= 0 $FunctionContextHeight))) (and ($IsGoodHeap $Heap@@0) (<= 0 |n#0@@1|))))) (<= 0 (_module.__default.Factorial ($LS $ly@@1) $Heap@@0 |n#0@@1|))) :qid |Classics.7:10| :skolemid |338| :pattern ((_module.__default.Factorial ($LS $ly@@1) $Heap@@0 |n#0@@1|))))))
(assert (forall (($ly@@2 T@U) ($Heap@@1 T@U) (|n#0@@2| Int)) (! (=> (and (and (= (type $ly@@2) LayerTypeType) (= (type $Heap@@1) (MapType1Type refType))) (and ($IsGoodHeap $Heap@@1) (<= 0 |n#0@@2|))) (and (=> (|_module.__default.Factorial#requires| $ly@@2 $Heap@@1 |n#0@@2|) true) (=> true (|_module.__default.Factorial#requires| $ly@@2 $Heap@@1 |n#0@@2|)))) :qid |Classics.7:10| :skolemid |339| :pattern ((|_module.__default.Factorial#requires| $ly@@2 $Heap@@1 |n#0@@2|)))))
(assert (=> (and (= 0 $ModuleContextHeight) (<= 0 $FunctionContextHeight)) (forall (($ly@@3 T@U) ($Heap@@2 T@U) (|n#0@@3| Int)) (! (=> (and (and (= (type $ly@@3) LayerTypeType) (= (type $Heap@@2) (MapType1Type refType))) (or (|_module.__default.Factorial#canCall| $Heap@@2 |n#0@@3|) (and (not (= 0 $FunctionContextHeight)) (and ($IsGoodHeap $Heap@@2) (<= 0 |n#0@@3|))))) (and (and (=> (= |n#0@@3| (LitInt 0)) true) (=> (not (= |n#0@@3| (LitInt 0))) (|_module.__default.Factorial#canCall| $Heap@@2 (- |n#0@@3| 1)))) (= (_module.__default.Factorial ($LS $ly@@3) $Heap@@2 |n#0@@3|) (ite (= |n#0@@3| (LitInt 0)) 1 (* |n#0@@3| (_module.__default.Factorial $ly@@3 $Heap@@2 (- |n#0@@3| 1))))))) :qid |Classics.7:10| :skolemid |340| :pattern ((_module.__default.Factorial ($LS $ly@@3) $Heap@@2 |n#0@@3|))))))
(assert (=> (and (= 0 $ModuleContextHeight) (<= 0 $FunctionContextHeight)) (forall (($ly@@4 T@U) ($Heap@@3 T@U) (|n#0@@4| Int)) (! (=> (and (and (= (type $ly@@4) LayerTypeType) (= (type $Heap@@3) (MapType1Type refType))) (or (|_module.__default.Factorial#canCall| $Heap@@3 (LitInt |n#0@@4|)) (and (not (= 0 $FunctionContextHeight)) (and ($IsGoodHeap $Heap@@3) (<= 0 |n#0@@4|))))) (and (and (=> (= (LitInt |n#0@@4|) (LitInt 0)) true) (=> (not (= (LitInt |n#0@@4|) (LitInt 0))) (|_module.__default.Factorial#canCall| $Heap@@3 (LitInt (- |n#0@@4| 1))))) (= (_module.__default.Factorial $ly@@4 $Heap@@3 (LitInt |n#0@@4|)) (ite (= (LitInt |n#0@@4|) (LitInt 0)) 1 (* |n#0@@4| (_module.__default.Factorial $ly@@4 $Heap@@3 (LitInt (- |n#0@@4| 1)))))))) :qid |Classics.7:10| :weight 3 :skolemid |341| :pattern ((_module.__default.Factorial $ly@@4 $Heap@@3 (LitInt |n#0@@4|)))))))
(assert (=> (< 0 $ModuleContextHeight) (forall (($ly@@5 T@U) ($Heap@@4 T@U) (|n#0@@5| Int)) (! (=> (and (and (= (type $ly@@5) LayerTypeType) (= (type $Heap@@4) (MapType1Type refType))) (or (|_module.__default.Factorial#canCall| $Heap@@4 |n#0@@5|) (and ($IsGoodHeap $Heap@@4) (<= 0 |n#0@@5|)))) (and (and (=> (= |n#0@@5| (LitInt 0)) true) (=> (not (= |n#0@@5| (LitInt 0))) (|_module.__default.Factorial#canCall| $Heap@@4 (- |n#0@@5| 1)))) (= (_module.__default.Factorial ($LS $ly@@5) $Heap@@4 |n#0@@5|) (ite (= |n#0@@5| (LitInt 0)) 1 (* |n#0@@5| (_module.__default.Factorial $ly@@5 $Heap@@4 (- |n#0@@5| 1))))))) :qid |Classics.7:10| :skolemid |342| :pattern ((_module.__default.Factorial ($LS $ly@@5) $Heap@@4 |n#0@@5|))))))
(assert (=> (< 0 $ModuleContextHeight) (forall (($ly@@6 T@U) ($Heap@@5 T@U) (|n#0@@6| Int)) (! (=> (and (and (= (type $ly@@6) LayerTypeType) (= (type $Heap@@5) (MapType1Type refType))) (or (|_module.__default.Factorial#canCall| $Heap@@5 (LitInt |n#0@@6|)) (and ($IsGoodHeap $Heap@@5) (<= 0 |n#0@@6|)))) (and (and (=> (= (LitInt |n#0@@6|) (LitInt 0)) true) (=> (not (= (LitInt |n#0@@6|) (LitInt 0))) (|_module.__default.Factorial#canCall| $Heap@@5 (LitInt (- |n#0@@6| 1))))) (= (_module.__default.Factorial $ly@@6 $Heap@@5 (LitInt |n#0@@6|)) (ite (= (LitInt |n#0@@6|) (LitInt 0)) 1 (* |n#0@@6| (_module.__default.Factorial $ly@@6 $Heap@@5 (LitInt (- |n#0@@6| 1)))))))) :qid |Classics.7:10| :weight 3 :skolemid |343| :pattern ((_module.__default.Factorial $ly@@6 $Heap@@5 (LitInt |n#0@@6|)))))))
(assert (and (and (and (and (and (and (and (forall ((arg0@@107 T@T) (arg1@@54 T@T)) (! (= (Ctor (MapType3Type arg0@@107 arg1@@54)) 20) :qid |ctor:MapType3Type|)) (forall ((arg0@@108 T@T) (arg1@@55 T@T)) (! (= (MapType3TypeInv0 (MapType3Type arg0@@108 arg1@@55)) arg0@@108) :qid |typeInv:MapType3TypeInv0| :pattern ((MapType3Type arg0@@108 arg1@@55))))) (forall ((arg0@@109 T@T) (arg1@@56 T@T)) (! (= (MapType3TypeInv1 (MapType3Type arg0@@109 arg1@@56)) arg1@@56) :qid |typeInv:MapType3TypeInv1| :pattern ((MapType3Type arg0@@109 arg1@@56))))) (forall ((arg0@@110 T@U) (arg1@@57 T@U) (arg2@@19 T@U)) (! (let ((aVar1@@3 (MapType3TypeInv1 (type arg0@@110)))) (= (type (MapType3Select arg0@@110 arg1@@57 arg2@@19)) aVar1@@3)) :qid |funType:MapType3Select| :pattern ((MapType3Select arg0@@110 arg1@@57 arg2@@19))))) (forall ((arg0@@111 T@U) (arg1@@58 T@U) (arg2@@20 T@U) (arg3@@3 T@U)) (! (let ((aVar1@@4 (type arg3@@3))) (let ((aVar0@@2 (type arg1@@58))) (= (type (MapType3Store arg0@@111 arg1@@58 arg2@@20 arg3@@3)) (MapType3Type aVar0@@2 aVar1@@4)))) :qid |funType:MapType3Store| :pattern ((MapType3Store arg0@@111 arg1@@58 arg2@@20 arg3@@3))))) (forall ((m@@22 T@U) (x0@@10 T@U) (x1@@7 T@U) (val@@10 T@U)) (! (let ((aVar1@@5 (MapType3TypeInv1 (type m@@22)))) (=> (= (type val@@10) aVar1@@5) (= (MapType3Select (MapType3Store m@@22 x0@@10 x1@@7 val@@10) x0@@10 x1@@7) val@@10))) :qid |mapAx0:MapType3Select| :weight 0))) (and (and (forall ((val@@11 T@U) (m@@23 T@U) (x0@@11 T@U) (x1@@8 T@U) (y0@@7 T@U) (y1@@5 T@U)) (! (or (= x0@@11 y0@@7) (= (MapType3Select (MapType3Store m@@23 x0@@11 x1@@8 val@@11) y0@@7 y1@@5) (MapType3Select m@@23 y0@@7 y1@@5))) :qid |mapAx1:MapType3Select:0| :weight 0)) (forall ((val@@12 T@U) (m@@24 T@U) (x0@@12 T@U) (x1@@9 T@U) (y0@@8 T@U) (y1@@6 T@U)) (! (or (= x1@@9 y1@@6) (= (MapType3Select (MapType3Store m@@24 x0@@12 x1@@9 val@@12) y0@@8 y1@@6) (MapType3Select m@@24 y0@@8 y1@@6))) :qid |mapAx1:MapType3Select:1| :weight 0))) (forall ((val@@13 T@U) (m@@25 T@U) (x0@@13 T@U) (x1@@10 T@U) (y0@@9 T@U) (y1@@7 T@U)) (! (or true (= (MapType3Select (MapType3Store m@@25 x0@@13 x1@@10 val@@13) y0@@9 y1@@7) (MapType3Select m@@25 y0@@9 y1@@7))) :qid |mapAx2:MapType3Select| :weight 0)))) (forall ((arg0@@112 T@U) (arg1@@59 T@U) (arg2@@21 T@U)) (! (= (type (|lambda#0| arg0@@112 arg1@@59 arg2@@21)) (MapType3Type refType boolType)) :qid |funType:lambda#0| :pattern ((|lambda#0| arg0@@112 arg1@@59 arg2@@21))))))
(assert (forall (($o@@8 T@U) ($f@@0 T@U) (alloc@@0 T@U) (null@@0 T@U) ($Heap@@6 T@U)) (! (let ((alpha@@7 (FieldTypeInv0 (type $f@@0)))) (=> (and (and (and (and (= (type $o@@8) refType) (= (type $f@@0) (FieldType alpha@@7))) (= (type alloc@@0) (FieldType boolType))) (= (type null@@0) refType)) (= (type $Heap@@6) (MapType1Type refType))) (= (U_2_bool (MapType3Select (|lambda#0| alloc@@0 null@@0 $Heap@@6) $o@@8 $f@@0)) (=> (and (not (= $o@@8 null@@0)) (U_2_bool (MapType1Select $Heap@@6 $o@@8 alloc@@0))) false)))) :qid |Classics.7:10| :skolemid |454| :pattern ((MapType3Select (|lambda#0| alloc@@0 null@@0 $Heap@@6) $o@@8 $f@@0)))))
(assert (forall ((arg0@@113 T@U) (arg1@@60 T@U) (arg2@@22 T@U)) (! (= (type (|lambda#1| arg0@@113 arg1@@60 arg2@@22)) (MapType3Type refType boolType)) :qid |funType:lambda#1| :pattern ((|lambda#1| arg0@@113 arg1@@60 arg2@@22)))))
(assert (forall (($o@@9 T@U) ($f@@1 T@U) (alloc@@1 T@U) (null@@1 T@U) ($Heap@@7 T@U)) (! (let ((alpha@@8 (FieldTypeInv0 (type $f@@1)))) (=> (and (and (and (and (= (type $o@@9) refType) (= (type $f@@1) (FieldType alpha@@8))) (= (type alloc@@1) (FieldType boolType))) (= (type null@@1) refType)) (= (type $Heap@@7) (MapType1Type refType))) (= (U_2_bool (MapType3Select (|lambda#1| alloc@@1 null@@1 $Heap@@7) $o@@9 $f@@1)) (=> (and (not (= $o@@9 null@@1)) (U_2_bool (MapType1Select $Heap@@7 $o@@9 alloc@@1))) false)))) :qid |Classics.7:10| :skolemid |455| :pattern ((MapType3Select (|lambda#1| alloc@@1 null@@1 $Heap@@7) $o@@9 $f@@1)))))
(assert (forall ((arg0@@114 T@U) (arg1@@61 T@U) (arg2@@23 T@U)) (! (= (type (|lambda#2| arg0@@114 arg1@@61 arg2@@23)) (MapType3Type refType boolType)) :qid |funType:lambda#2| :pattern ((|lambda#2| arg0@@114 arg1@@61 arg2@@23)))))
(assert (forall (($o@@10 T@U) ($f@@2 T@U) (alloc@@2 T@U) (null@@2 T@U) ($Heap@@8 T@U)) (! (let ((alpha@@9 (FieldTypeInv0 (type $f@@2)))) (=> (and (and (and (and (= (type $o@@10) refType) (= (type $f@@2) (FieldType alpha@@9))) (= (type alloc@@2) (FieldType boolType))) (= (type null@@2) refType)) (= (type $Heap@@8) (MapType1Type refType))) (= (U_2_bool (MapType3Select (|lambda#2| alloc@@2 null@@2 $Heap@@8) $o@@10 $f@@2)) (=> (and (not (= $o@@10 null@@2)) (U_2_bool (MapType1Select $Heap@@8 $o@@10 alloc@@2))) false)))) :qid |Classics.12:8| :skolemid |456| :pattern ((MapType3Select (|lambda#2| alloc@@2 null@@2 $Heap@@8) $o@@10 $f@@2)))))
(assert (forall ((arg0@@115 T@U) (arg1@@62 T@U) (arg2@@24 T@U)) (! (= (type (|lambda#3| arg0@@115 arg1@@62 arg2@@24)) (MapType3Type refType boolType)) :qid |funType:lambda#3| :pattern ((|lambda#3| arg0@@115 arg1@@62 arg2@@24)))))
(assert (forall (($o@@11 T@U) ($f@@3 T@U) (alloc@@3 T@U) (null@@3 T@U) ($Heap@@9 T@U)) (! (let ((alpha@@10 (FieldTypeInv0 (type $f@@3)))) (=> (and (and (and (and (= (type $o@@11) refType) (= (type $f@@3) (FieldType alpha@@10))) (= (type alloc@@3) (FieldType boolType))) (= (type null@@3) refType)) (= (type $Heap@@9) (MapType1Type refType))) (= (U_2_bool (MapType3Select (|lambda#3| alloc@@3 null@@3 $Heap@@9) $o@@11 $f@@3)) (=> (and (not (= $o@@11 null@@3)) (U_2_bool (MapType1Select $Heap@@9 $o@@11 alloc@@3))) false)))) :qid |Classics.12:8| :skolemid |457| :pattern ((MapType3Select (|lambda#3| alloc@@3 null@@3 $Heap@@9) $o@@11 $f@@3)))))
(assert (forall ((arg0@@116 T@U) (arg1@@63 T@U) (arg2@@25 T@U) (arg3@@4 T@U)) (! (= (type (|lambda#4| arg0@@116 arg1@@63 arg2@@25 arg3@@4)) (MapType3Type refType boolType)) :qid |funType:lambda#4| :pattern ((|lambda#4| arg0@@116 arg1@@63 arg2@@25 arg3@@4)))))
(assert (forall (($o@@12 T@U) ($f@@4 T@U) (|A#0| T@U) (null@@4 T@U) ($Heap@@10 T@U) (alloc@@4 T@U)) (! (let ((alpha@@11 (FieldTypeInv0 (type $f@@4)))) (=> (and (and (and (and (and (= (type $o@@12) refType) (= (type $f@@4) (FieldType alpha@@11))) (= (type |A#0|) refType)) (= (type null@@4) refType)) (= (type $Heap@@10) (MapType1Type refType))) (= (type alloc@@4) (FieldType boolType))) (= (U_2_bool (MapType3Select (|lambda#4| |A#0| null@@4 $Heap@@10 alloc@@4) $o@@12 $f@@4)) (=> (and (not (= $o@@12 null@@4)) (U_2_bool (MapType1Select $Heap@@10 $o@@12 alloc@@4))) (= $o@@12 |A#0|))))) :qid |Classics.47:8| :skolemid |458| :pattern ((MapType3Select (|lambda#4| |A#0| null@@4 $Heap@@10 alloc@@4) $o@@12 $f@@4)))))
(assert (forall ((arg0@@117 T@U) (arg1@@64 T@U) (arg2@@26 T@U) (arg3@@5 T@U)) (! (= (type (|lambda#5| arg0@@117 arg1@@64 arg2@@26 arg3@@5)) (MapType3Type refType boolType)) :qid |funType:lambda#5| :pattern ((|lambda#5| arg0@@117 arg1@@64 arg2@@26 arg3@@5)))))
(assert (forall (($o@@13 T@U) ($f@@5 T@U) (|A#0@@0| T@U) (null@@5 T@U) ($Heap@@11 T@U) (alloc@@5 T@U)) (! (let ((alpha@@12 (FieldTypeInv0 (type $f@@5)))) (=> (and (and (and (and (and (= (type $o@@13) refType) (= (type $f@@5) (FieldType alpha@@12))) (= (type |A#0@@0|) refType)) (= (type null@@5) refType)) (= (type $Heap@@11) (MapType1Type refType))) (= (type alloc@@5) (FieldType boolType))) (= (U_2_bool (MapType3Select (|lambda#5| |A#0@@0| null@@5 $Heap@@11 alloc@@5) $o@@13 $f@@5)) (=> (and (not (= $o@@13 null@@5)) (U_2_bool (MapType1Select $Heap@@11 $o@@13 alloc@@5))) (= $o@@13 |A#0@@0|))))) :qid |Classics.47:8| :skolemid |459| :pattern ((MapType3Select (|lambda#5| |A#0@@0| null@@5 $Heap@@11 alloc@@5) $o@@13 $f@@5)))))
(assert (and (and (and (= (type $LZ) LayerTypeType) (= (type $Heap@@12) (MapType1Type refType))) (= (type $_Frame@0) (MapType3Type refType boolType))) (= (type $_Frame@0@@0) (MapType3Type refType boolType))))
(push 1)
(set-info :boogie-vc-id CheckWellformed$$_module.__default.Factorial)
(assert (not (let ((anon6_correct (=> (! (and %lbl%+13101 true) :lblpos +13101) (! (or %lbl%@34767 |b$reqreads#0@1|) :lblneg @34767)))) (let ((anon8_Else_correct (=> (! (and %lbl%+13099 true) :lblpos +13099) (=> (not (= |n#0@@7| (LitInt 0))) (and (! (or %lbl%@34589 ($Is (int_2_U (- |n#0@@7| 1)) TNat)) :lblneg @34589) (=> ($Is (int_2_U (- |n#0@@7| 1)) TNat) (=> (and (and (= |##n#0@0| (- |n#0@@7| 1)) ($IsAlloc (int_2_U |##n#0@0|) TNat $Heap@@12)) (and (=> |b$reqreads#0@0| (forall (($o@@14 T@U) ($f@@6 T@U)) (! (let ((alpha@@13 (FieldTypeInv0 (type $f@@6)))) (=> (and (and (= (type $o@@14) refType) (= (type $f@@6) (FieldType alpha@@13))) false) (U_2_bool (MapType3Select $_Frame@0 $o@@14 $f@@6)))) :qid |Classics.9:29| :skolemid |344| :no-pattern (type $o@@14) :no-pattern (type $f@@6) :no-pattern (U_2_int $o@@14) :no-pattern (U_2_bool $o@@14) :no-pattern (U_2_int $f@@6) :no-pattern (U_2_bool $f@@6)))) (=> (forall (($o@@15 T@U) ($f@@7 T@U)) (! (let ((alpha@@14 (FieldTypeInv0 (type $f@@7)))) (=> (and (and (= (type $o@@15) refType) (= (type $f@@7) (FieldType alpha@@14))) false) (U_2_bool (MapType3Select $_Frame@0 $o@@15 $f@@7)))) :qid |Classics.9:29| :skolemid |344| :no-pattern (type $o@@15) :no-pattern (type $f@@7) :no-pattern (U_2_int $o@@15) :no-pattern (U_2_bool $o@@15) :no-pattern (U_2_int $f@@7) :no-pattern (U_2_bool $f@@7))) |b$reqreads#0@0|))) (and (! (or %lbl%@34638 (or (<= 0 |n#0@@7|) (= |##n#0@0| |n#0@@7|))) :lblneg @34638) (=> (or (<= 0 |n#0@@7|) (= |##n#0@0| |n#0@@7|)) (and (! (or %lbl%@34651 (< |##n#0@0| |n#0@@7|)) :lblneg @34651) (=> (< |##n#0@0| |n#0@@7|) (=> (|_module.__default.Factorial#canCall| $Heap@@12 (- |n#0@@7| 1)) (and (! (or %lbl%@34666 ($Is (int_2_U (* |n#0@@7| (_module.__default.Factorial ($LS $LZ) $Heap@@12 (- |n#0@@7| 1)))) TNat)) :lblneg @34666) (=> ($Is (int_2_U (* |n#0@@7| (_module.__default.Factorial ($LS $LZ) $Heap@@12 (- |n#0@@7| 1)))) TNat) (=> (and (= (_module.__default.Factorial ($LS $LZ) $Heap@@12 |n#0@@7|) (* |n#0@@7| (_module.__default.Factorial ($LS $LZ) $Heap@@12 (- |n#0@@7| 1)))) (|_module.__default.Factorial#canCall| $Heap@@12 (- |n#0@@7| 1))) (=> (and (and ($IsAlloc (int_2_U (_module.__default.Factorial ($LS $LZ) $Heap@@12 |n#0@@7|)) TNat $Heap@@12) ($Is (int_2_U (_module.__default.Factorial ($LS $LZ) $Heap@@12 |n#0@@7|)) TNat)) (and (=> |b$reqreads#0@1| |b$reqreads#0@0|) (=> |b$reqreads#0@0| |b$reqreads#0@1|))) anon6_correct)))))))))))))))) (let ((anon8_Then_correct (=> (! (and %lbl%+13097 true) :lblpos +13097) (=> (= |n#0@@7| (LitInt 0)) (and (! (or %lbl%@34525 ($Is (int_2_U (LitInt 1)) TNat)) :lblneg @34525) (=> ($Is (int_2_U (LitInt 1)) TNat) (=> (= (_module.__default.Factorial ($LS $LZ) $Heap@@12 |n#0@@7|) (LitInt 1)) (=> (and (and ($IsAlloc (int_2_U (_module.__default.Factorial ($LS $LZ) $Heap@@12 |n#0@@7|)) TNat $Heap@@12) ($Is (int_2_U (_module.__default.Factorial ($LS $LZ) $Heap@@12 |n#0@@7|)) TNat)) (and (=> |b$reqreads#0@1| true) (=> true |b$reqreads#0@1|))) anon6_correct)))))))) (let ((anon7_Else_correct (=> (! (and %lbl%+13095 true) :lblpos +13095) (=> (= $_Frame@0@@0 (|lambda#1| alloc null $Heap@@12)) (and anon8_Then_correct anon8_Else_correct))))) (let ((anon7_Then_correct (=> (! (and %lbl%+13088 true) :lblpos +13088) true))) (let ((anon0_correct (=> (! (and %lbl%+13084 true) :lblpos +13084) (=> (= $_Frame@0 (|lambda#0| alloc null $Heap@@12)) (and anon7_Then_correct anon7_Else_correct))))) (let ((PreconditionGeneratedEntry_correct (=> (! (and %lbl%+34404 true) :lblpos +34404) (=> (and (and (and ($IsGoodHeap $Heap@@12) ($IsHeapAnchor $Heap@@12)) (<= 0 |n#0@@7|)) (and (= 0 $ModuleContextHeight) (= 0 $FunctionContextHeight))) anon0_correct)))) PreconditionGeneratedEntry_correct)))))))))
(check-sat)
(pop 1)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.0)
(set-option :AUTO_CONFIG false)
(set-option :pp.bv_literals false)
(set-option :MODEL.V2 true)
(set-option :smt.PHASE_SELECTION 0)
(set-option :smt.RESTART_STRATEGY 0)
(set-option :smt.RESTART_FACTOR |1.5|)
(set-option :smt.ARITH.RANDOM_INITIAL_VALUE true)
(set-option :smt.CASE_SPLIT 3)
(set-option :smt.DELAY_UNITS true)
(set-option :NNF.SK_HACK true)
(set-option :smt.MBQI false)
(set-option :smt.QI.EAGER_THRESHOLD 100)
(set-option :TYPE_CHECK true)
(set-option :smt.BV.REFLECT true)
(set-option :TIMEOUT 0)
(set-info :category "industrial")
(declare-sort |T@U| 0)
(declare-sort |T@T| 0)
(declare-fun real_pow (Real Real) Real)
(declare-fun UOrdering2 (|T@U| |T@U|) Bool)
(declare-fun UOrdering3 (|T@T| |T@U| |T@U|) Bool)
(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-fun Ctor (T@T) Int)
(declare-fun intType () T@T)
(declare-fun realType () T@T)
(declare-fun boolType () T@T)
(declare-fun int_2_U (Int) T@U)
(declare-fun U_2_int (T@U) Int)
(declare-fun type (T@U) T@T)
(declare-fun real_2_U (Real) T@U)
(declare-fun U_2_real (T@U) Real)
(declare-fun bool_2_U (Bool) T@U)
(declare-fun U_2_bool (T@U) Bool)
(declare-fun TyType () T@T)
(declare-fun TBool () T@U)
(declare-fun TChar () T@U)
(declare-fun TInt () T@U)
(declare-fun TNat () T@U)
(declare-fun TReal () T@U)
(declare-fun TyTagType () T@T)
(declare-fun TagBool () T@U)
(declare-fun TagChar () T@U)
(declare-fun TagInt () T@U)
(declare-fun TagNat () T@U)
(declare-fun TagReal () T@U)
(declare-fun TagSet () T@U)
(declare-fun TagISet () T@U)
(declare-fun TagMultiSet () T@U)
(declare-fun TagSeq () T@U)
(declare-fun TagMap () T@U)
(declare-fun TagIMap () T@U)
(declare-fun TagClass () T@U)
(declare-fun ClassNameType () T@T)
(declare-fun NoTraitAtAll () T@U)
(declare-fun class._System.int () T@U)
(declare-fun class._System.bool () T@U)
(declare-fun class._System.set () T@U)
(declare-fun class._System.seq () T@U)
(declare-fun class._System.multiset () T@U)
(declare-fun FieldType (T@T) T@T)
(declare-fun FieldTypeInv0 (T@T) T@T)
(declare-fun alloc () T@U)
(declare-fun class._System.object () T@U)
(declare-fun Tagclass._System.object () T@U)
(declare-fun class._System.array () T@U)
(declare-fun Tagclass._System.array () T@U)
(declare-fun Tagclass._System.___hFunc0 () T@U)
(declare-fun Tagclass._System.___hFunc1 () T@U)
(declare-fun class._module.__default () T@U)
(declare-fun Tagclass._module.__default () T@U)
(declare-fun $$Language$Dafny () Bool)
(declare-fun TSet (T@U) T@U)
(declare-fun Inv0_TSet (T@U) T@U)
(declare-fun TISet (T@U) T@U)
(declare-fun Inv0_TISet (T@U) T@U)
(declare-fun TSeq (T@U) T@U)
(declare-fun Inv0_TSeq (T@U) T@U)
(declare-fun TMultiSet (T@U) T@U)
(declare-fun Inv0_TMultiSet (T@U) T@U)
(declare-fun TMap (T@U T@U) T@U)
(declare-fun Inv0_TMap (T@U) T@U)
(declare-fun Inv1_TMap (T@U) T@U)
(declare-fun TIMap (T@U T@U) T@U)
(declare-fun Inv0_TIMap (T@U) T@U)
(declare-fun Inv1_TIMap (T@U) T@U)
(declare-fun Tag (T@U) T@U)
(declare-fun LitInt (Int) Int)
(declare-fun BoxType () T@T)
(declare-fun $Box (T@U) T@U)
(declare-fun Lit (T@U) T@U)
(declare-fun LitReal (Real) Real)
(declare-fun charType () T@T)
(declare-fun |char#FromInt| (Int) T@U)
(declare-fun |char#ToInt| (T@U) Int)
(declare-fun $Unbox (T@T T@U) T@U)
(declare-fun $IsBox (T@U T@U) Bool)
(declare-fun $Is (T@U T@U) Bool)
(declare-fun MapType0Type (T@T T@T) T@T)
(declare-fun MapType0TypeInv0 (T@T) T@T)
(declare-fun MapType0TypeInv1 (T@T) T@T)
(declare-fun MapType0Select (T@U T@U) T@U)
(declare-fun MapType0Store (T@U T@U T@U) T@U)
(declare-fun SeqType (T@T) T@T)
(declare-fun SeqTypeInv0 (T@T) T@T)
(declare-fun MapType (T@T T@T) T@T)
(declare-fun MapTypeInv0 (T@T) T@T)
(declare-fun MapTypeInv1 (T@T) T@T)
(declare-fun IMapType (T@T T@T) T@T)
(declare-fun IMapTypeInv0 (T@T) T@T)
(declare-fun IMapTypeInv1 (T@T) T@T)
(declare-fun MapType1Type (T@T) T@T)
(declare-fun MapType1TypeInv0 (T@T) T@T)
(declare-fun MapType1Select (T@U T@U T@U) T@U)
(declare-fun MapType1Store (T@U T@U T@U T@U) T@U)
(declare-fun refType () T@T)
(declare-fun $IsAllocBox (T@U T@U T@U) Bool)
(declare-fun $IsAlloc (T@U T@U T@U) Bool)
(declare-fun $IsGoodMultiSet (T@U) Bool)
(declare-fun |Seq#Index| (T@U Int) T@U)
(declare-fun |Seq#Length| (T@U) Int)
(declare-fun |Map#Elements| (T@U) T@U)
(declare-fun |Map#Domain| (T@U) T@U)
(declare-fun |IMap#Elements| (T@U) T@U)
(declare-fun |IMap#Domain| (T@U) T@U)
(declare-fun TypeTuple (T@U T@U) T@U)
(declare-fun TypeTupleCar (T@U) T@U)
(declare-fun TypeTupleCdr (T@U) T@U)
(declare-fun SetRef_to_SetBox (T@U) T@U)
(declare-fun Tclass._System.object () T@U)
(declare-fun DatatypeTypeType () T@T)
(declare-fun BoxRank (T@U) Int)
(declare-fun DtRank (T@U) Int)
(declare-fun LayerTypeType () T@T)
(declare-fun AtLayer (T@U T@U) T@U)
(declare-fun $LS (T@U) T@U)
(declare-fun IndexField (Int) T@U)
(declare-fun FDim (T@U) Int)
(declare-fun IndexField_Inverse (T@U) Int)
(declare-fun MultiIndexField (T@U Int) T@U)
(declare-fun MultiIndexField_Inverse0 (T@U) T@U)
(declare-fun MultiIndexField_Inverse1 (T@U) Int)
(declare-fun NameFamilyType () T@T)
(declare-fun FieldOfDecl (T@T T@U T@U) T@U)
(declare-fun DeclType (T@U) T@U)
(declare-fun DeclName (T@U) T@U)
(declare-fun $HeapSucc (T@U T@U) Bool)
(declare-fun $IsGhostField (T@U) Bool)
(declare-fun _System.array.Length (T@U) Int)
(declare-fun q@Int (Real) Int)
(declare-fun q@Real (Int) Real)
(declare-fun $IsGoodHeap (T@U) Bool)
(declare-fun $HeapSuccGhost (T@U T@U) Bool)
(declare-fun |Set#Card| (T@U) Int)
(declare-fun |Set#Empty| (T@T) T@U)
(declare-fun |Set#Singleton| (T@U) T@U)
(declare-fun |Set#UnionOne| (T@U T@U) T@U)
(declare-fun |Set#Union| (T@U T@U) T@U)
(declare-fun |Set#Difference| (T@U T@U) T@U)
(declare-fun |Set#Disjoint| (T@U T@U) Bool)
(declare-fun |Set#Intersection| (T@U T@U) T@U)
(declare-fun |Set#Subset| (T@U T@U) Bool)
(declare-fun |Set#Equal| (T@U T@U) Bool)
(declare-fun |ISet#Empty| (T@T) T@U)
(declare-fun |ISet#UnionOne| (T@U T@U) T@U)
(declare-fun |ISet#Union| (T@U T@U) T@U)
(declare-fun |ISet#Difference| (T@U T@U) T@U)
(declare-fun |ISet#Disjoint| (T@U T@U) Bool)
(declare-fun |ISet#Intersection| (T@U T@U) T@U)
(declare-fun |ISet#Subset| (T@U T@U) Bool)
(declare-fun |ISet#Equal| (T@U T@U) Bool)
(declare-fun |Math#min| (Int Int) Int)
(declare-fun |Math#clip| (Int) Int)
(declare-fun |MultiSet#Card| (T@U) Int)
(declare-fun |MultiSet#Empty| (T@T) T@U)
(declare-fun |MultiSet#Singleton| (T@U) T@U)
(declare-fun |MultiSet#UnionOne| (T@U T@U) T@U)
(declare-fun |MultiSet#Union| (T@U T@U) T@U)
(declare-fun |MultiSet#Intersection| (T@U T@U) T@U)
(declare-fun |MultiSet#Difference| (T@U T@U) T@U)
(declare-fun |MultiSet#Subset| (T@U T@U) Bool)
(declare-fun |MultiSet#Equal| (T@U T@U) Bool)
(declare-fun |MultiSet#Disjoint| (T@U T@U) Bool)
(declare-fun |MultiSet#FromSet| (T@U) T@U)
(declare-fun |MultiSet#FromSeq| (T@U) T@U)
(declare-fun |Seq#Build| (T@U T@U) T@U)
(declare-fun |Seq#Empty| (T@T) T@U)
(declare-fun |Seq#Append| (T@U T@U) T@U)
(declare-fun |Seq#Update| (T@U Int T@U) T@U)
(declare-fun |Seq#Singleton| (T@U) T@U)
(declare-fun |Seq#Contains| (T@U T@U) Bool)
(declare-fun |Seq#Take| (T@U Int) T@U)
(declare-fun |Seq#Drop| (T@U Int) T@U)
(declare-fun |Seq#Equal| (T@U T@U) Bool)
(declare-fun |Seq#SameUntil| (T@U T@U Int) Bool)
(declare-fun |Seq#FromArray| (T@U T@U) T@U)
(declare-fun |Seq#Rank| (T@U) Int)
(declare-fun |Map#Card| (T@U) Int)
(declare-fun |Map#Empty| (T@T T@T) T@U)
(declare-fun |Map#Glue| (T@U T@U T@U) T@U)
(declare-fun |Map#Build| (T@U T@U T@U) T@U)
(declare-fun |Map#Equal| (T@U T@U) Bool)
(declare-fun |Map#Disjoint| (T@U T@U) Bool)
(declare-fun |IMap#Empty| (T@T T@T) T@U)
(declare-fun |IMap#Glue| (T@U T@U T@U) T@U)
(declare-fun |IMap#Build| (T@U T@U T@U) T@U)
(declare-fun |IMap#Equal| (T@U T@U) Bool)
(declare-fun INTERNAL_add_boogie (Int Int) Int)
(declare-fun INTERNAL_sub_boogie (Int Int) Int)
(declare-fun INTERNAL_mul_boogie (Int Int) Int)
(declare-fun INTERNAL_div_boogie (Int Int) Int)
(declare-fun INTERNAL_mod_boogie (Int Int) Int)
(declare-fun INTERNAL_lt_boogie (Int Int) Bool)
(declare-fun INTERNAL_le_boogie (Int Int) Bool)
(declare-fun INTERNAL_gt_boogie (Int Int) Bool)
(declare-fun INTERNAL_ge_boogie (Int Int) Bool)
(declare-fun null () T@U)
(declare-fun Tclass._System.array (T@U) T@U)
(declare-fun Tclass._System.array_0 (T@U) T@U)
(declare-fun dtype (T@U) T@U)
(declare-fun Tclass._System.___hFunc0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc0_0 (T@U) T@U)
(declare-fun HandleTypeType () T@T)
(declare-fun Apply0 (T@U T@U T@U) T@U)
(declare-fun Handle0 (T@U T@U T@U) T@U)
(declare-fun Requires0 (T@U T@U T@U) Bool)
(declare-fun Reads0 (T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hFunc1 (T@U T@U) T@U)
(declare-fun Tclass._System.___hFunc1_0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc1_1 (T@U) T@U)
(declare-fun MapType2Type (T@T T@T T@T) T@T)
(declare-fun MapType2TypeInv0 (T@T) T@T)
(declare-fun MapType2TypeInv1 (T@T) T@T)
(declare-fun MapType2TypeInv2 (T@T) T@T)
(declare-fun MapType2Select (T@U T@U T@U) T@U)
(declare-fun MapType2Store (T@U T@U T@U T@U) T@U)
(declare-fun Apply1 (T@U T@U T@U T@U T@U) T@U)
(declare-fun Handle1 (T@U T@U T@U) T@U)
(declare-fun Requires1 (T@U T@U T@U T@U T@U) Bool)
(declare-fun Reads1 (T@U T@U T@U T@U T@U) T@U)
(declare-fun Tclass._module.__default () T@U)
(declare-fun _module.__default.Factorial (T@U T@U Int) Int)
(declare-fun $IsHeapAnchor (T@U) Bool)
(declare-fun |_module.__default.Factorial#canCall| (T@U Int) Bool)
(declare-fun $ModuleContextHeight () Int)
(declare-fun $FunctionContextHeight () Int)
(declare-fun |_module.__default.Factorial#requires| (T@U T@U Int) Bool)
(declare-fun MapType3Type (T@T T@T) T@T)
(declare-fun MapType3TypeInv0 (T@T) T@T)
(declare-fun MapType3TypeInv1 (T@T) T@T)
(declare-fun MapType3Select (T@U T@U T@U) T@U)
(declare-fun MapType3Store (T@U T@U T@U T@U) T@U)
(declare-fun |lambda#0| (T@U T@U T@U) T@U)
(declare-fun |lambda#1| (T@U T@U T@U) T@U)
(declare-fun |lambda#2| (T@U T@U T@U) T@U)
(declare-fun |lambda#3| (T@U T@U T@U) T@U)
(declare-fun |lambda#4| (T@U T@U T@U T@U) T@U)
(declare-fun |lambda#5| (T@U T@U T@U T@U) T@U)
(declare-fun $LZ () T@U)
(declare-fun $Heap@@12 () T@U)
(declare-fun $_Frame@0 () T@U)
(declare-fun $_Frame@0@@0 () T@U)
(declare-fun %lbl%+13101 () Bool)
(declare-fun %lbl%@34767 () Bool)
(declare-fun |b$reqreads#0@1| () Bool)
(declare-fun %lbl%+13099 () Bool)
(declare-fun |n#0@@7| () Int)
(declare-fun %lbl%@34589 () Bool)
(declare-fun |##n#0@0| () Int)
(declare-fun |b$reqreads#0@0| () Bool)
(declare-fun %lbl%@34638 () Bool)
(declare-fun %lbl%@34651 () Bool)
(declare-fun %lbl%@34666 () Bool)
(declare-fun %lbl%+13097 () Bool)
(declare-fun %lbl%@34525 () Bool)
(declare-fun %lbl%+13095 () Bool)
(declare-fun %lbl%+13088 () Bool)
(declare-fun %lbl%+13084 () Bool)
(declare-fun %lbl%+34404 () Bool)
(assert (and (and (and (and (and (and (and (and (and (and (and (= (Ctor intType) 0) (= (Ctor realType) 1)) (= (Ctor boolType) 2)) (forall ((arg0 Int)) (! (= (U_2_int (int_2_U arg0)) arg0) :qid |typeInv:U_2_int| :pattern ((int_2_U arg0))))) (forall ((x T@U)) (! (=> (= (type x) intType) (= (int_2_U (U_2_int x)) x)) :qid |cast:U_2_int| :pattern ((U_2_int x))))) (forall ((arg0@@0 Int)) (! (= (type (int_2_U arg0@@0)) intType) :qid |funType:int_2_U| :pattern ((int_2_U arg0@@0))))) (forall ((arg0@@1 Real)) (! (= (U_2_real (real_2_U arg0@@1)) arg0@@1) :qid |typeInv:U_2_real| :pattern ((real_2_U arg0@@1))))) (forall ((x@@0 T@U)) (! (=> (= (type x@@0) realType) (= (real_2_U (U_2_real x@@0)) x@@0)) :qid |cast:U_2_real| :pattern ((U_2_real x@@0))))) (forall ((arg0@@2 Real)) (! (= (type (real_2_U arg0@@2)) realType) :qid |funType:real_2_U| :pattern ((real_2_U arg0@@2))))) (forall ((arg0@@3 Bool)) (! (= (U_2_bool (bool_2_U arg0@@3)) arg0@@3) :qid |typeInv:U_2_bool| :pattern ((bool_2_U arg0@@3))))) (forall ((x@@1 T@U)) (! (=> (= (type x@@1) boolType) (= (bool_2_U (U_2_bool x@@1)) x@@1)) :qid |cast:U_2_bool| :pattern ((U_2_bool x@@1))))) (forall ((arg0@@4 Bool)) (! (= (type (bool_2_U arg0@@4)) boolType) :qid |funType:bool_2_U| :pattern ((bool_2_U arg0@@4))))))
(assert (forall ((x@@2 T@U)) (! (UOrdering2 x@@2 x@@2) :qid |bg:subtype-refl| :no-pattern (U_2_int x@@2) :no-pattern (U_2_bool x@@2))))
(assert (forall ((x@@3 T@U) (y T@U) (z T@U)) (! (let ((alpha (type x@@3))) (=> (and (and (= (type y) alpha) (= (type z) alpha)) (and (UOrdering2 x@@3 y) (UOrdering2 y z))) (UOrdering2 x@@3 z))) :qid |bg:subtype-trans| :pattern ((UOrdering2 x@@3 y) (UOrdering2 y z)))))
(assert (forall ((x@@4 T@U) (y@@0 T@U)) (! (let ((alpha@@0 (type x@@4))) (=> (= (type y@@0) alpha@@0) (=> (and (UOrdering2 x@@4 y@@0) (UOrdering2 y@@0 x@@4)) (= x@@4 y@@0)))) :qid |bg:subtype-antisymm| :pattern ((UOrdering2 x@@4 y@@0) (UOrdering2 y@@0 x@@4)))))
(assert (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (= (Ctor TyType) 3) (= (type TBool) TyType)) (= (type TChar) TyType)) (= (type TInt) TyType)) (= (type TNat) TyType)) (= (type TReal) TyType)) (= (Ctor TyTagType) 4)) (= (type TagBool) TyTagType)) (= (type TagChar) TyTagType)) (= (type TagInt) TyTagType)) (= (type TagNat) TyTagType)) (= (type TagReal) TyTagType)) (= (type TagSet) TyTagType)) (= (type TagISet) TyTagType)) (= (type TagMultiSet) TyTagType)) (= (type TagSeq) TyTagType)) (= (type TagMap) TyTagType)) (= (type TagIMap) TyTagType)) (= (type TagClass) TyTagType)) (= (Ctor ClassNameType) 5)) (= (type NoTraitAtAll) ClassNameType)) (= (type class._System.int) ClassNameType)) (= (type class._System.bool) ClassNameType)) (= (type class._System.set) ClassNameType)) (= (type class._System.seq) ClassNameType)) (= (type class._System.multiset) ClassNameType)) (forall ((arg0@@5 T@T)) (! (= (Ctor (FieldType arg0@@5)) 6) :qid |ctor:FieldType|))) (forall ((arg0@@6 T@T)) (! (= (FieldTypeInv0 (FieldType arg0@@6)) arg0@@6) :qid |typeInv:FieldTypeInv0| :pattern ((FieldType arg0@@6))))) (= (type alloc) (FieldType boolType))) (= (type class._System.object) ClassNameType)) (= (type Tagclass._System.object) TyTagType)) (= (type class._System.array) ClassNameType)) (= (type Tagclass._System.array) TyTagType)) (= (type Tagclass._System.___hFunc0) TyTagType)) (= (type Tagclass._System.___hFunc1) TyTagType)) (= (type class._module.__default) ClassNameType)) (= (type Tagclass._module.__default) TyTagType)))
(assert (distinct TBool TChar TInt TNat TReal TagBool TagChar TagInt TagNat TagReal TagSet TagISet TagMultiSet TagSeq TagMap TagIMap TagClass NoTraitAtAll class._System.int class._System.bool class._System.set class._System.seq class._System.multiset alloc class._System.object Tagclass._System.object class._System.array Tagclass._System.array Tagclass._System.___hFunc0 Tagclass._System.___hFunc1 class._module.__default Tagclass._module.__default))
(assert $$Language$Dafny)
(assert (and (forall ((arg0@@7 T@U)) (! (= (type (TSet arg0@@7)) TyType) :qid |funType:TSet| :pattern ((TSet arg0@@7)))) (forall ((arg0@@8 T@U)) (! (= (type (Inv0_TSet arg0@@8)) TyType) :qid |funType:Inv0_TSet| :pattern ((Inv0_TSet arg0@@8))))))
(assert (forall ((t T@U)) (! (=> (= (type t) TyType) (= (Inv0_TSet (TSet t)) t)) :qid |DafnyPre.30:15| :skolemid |0| :pattern ((TSet t)))))
(assert (and (forall ((arg0@@9 T@U)) (! (= (type (TISet arg0@@9)) TyType) :qid |funType:TISet| :pattern ((TISet arg0@@9)))) (forall ((arg0@@10 T@U)) (! (= (type (Inv0_TISet arg0@@10)) TyType) :qid |funType:Inv0_TISet| :pattern ((Inv0_TISet arg0@@10))))))
(assert (forall ((t@@0 T@U)) (! (=> (= (type t@@0) TyType) (= (Inv0_TISet (TISet t@@0)) t@@0)) :qid |DafnyPre.32:15| :skolemid |1| :pattern ((TISet t@@0)))))
(assert (and (forall ((arg0@@11 T@U)) (! (= (type (TSeq arg0@@11)) TyType) :qid |funType:TSeq| :pattern ((TSeq arg0@@11)))) (forall ((arg0@@12 T@U)) (! (= (type (Inv0_TSeq arg0@@12)) TyType) :qid |funType:Inv0_TSeq| :pattern ((Inv0_TSeq arg0@@12))))))
(assert (forall ((t@@1 T@U)) (! (=> (= (type t@@1) TyType) (= (Inv0_TSeq (TSeq t@@1)) t@@1)) :qid |DafnyPre.34:15| :skolemid |2| :pattern ((TSeq t@@1)))))
(assert (and (forall ((arg0@@13 T@U)) (! (= (type (TMultiSet arg0@@13)) TyType) :qid |funType:TMultiSet| :pattern ((TMultiSet arg0@@13)))) (forall ((arg0@@14 T@U)) (! (= (type (Inv0_TMultiSet arg0@@14)) TyType) :qid |funType:Inv0_TMultiSet| :pattern ((Inv0_TMultiSet arg0@@14))))))
(assert (forall ((t@@2 T@U)) (! (=> (= (type t@@2) TyType) (= (Inv0_TMultiSet (TMultiSet t@@2)) t@@2)) :qid |DafnyPre.36:15| :skolemid |3| :pattern ((TMultiSet t@@2)))))
(assert (and (forall ((arg0@@15 T@U) (arg1 T@U)) (! (= (type (TMap arg0@@15 arg1)) TyType) :qid |funType:TMap| :pattern ((TMap arg0@@15 arg1)))) (forall ((arg0@@16 T@U)) (! (= (type (Inv0_TMap arg0@@16)) TyType) :qid |funType:Inv0_TMap| :pattern ((Inv0_TMap arg0@@16))))))
(assert (forall ((t@@3 T@U) (u T@U)) (! (=> (and (= (type t@@3) TyType) (= (type u) TyType)) (= (Inv0_TMap (TMap t@@3 u)) t@@3)) :qid |DafnyPre.39:15| :skolemid |4| :pattern ((TMap t@@3 u)))))
(assert (forall ((arg0@@17 T@U)) (! (= (type (Inv1_TMap arg0@@17)) TyType) :qid |funType:Inv1_TMap| :pattern ((Inv1_TMap arg0@@17)))))
(assert (forall ((t@@4 T@U) (u@@0 T@U)) (! (=> (and (= (type t@@4) TyType) (= (type u@@0) TyType)) (= (Inv1_TMap (TMap t@@4 u@@0)) u@@0)) :qid |DafnyPre.40:15| :skolemid |5| :pattern ((TMap t@@4 u@@0)))))
(assert (and (forall ((arg0@@18 T@U) (arg1@@0 T@U)) (! (= (type (TIMap arg0@@18 arg1@@0)) TyType) :qid |funType:TIMap| :pattern ((TIMap arg0@@18 arg1@@0)))) (forall ((arg0@@19 T@U)) (! (= (type (Inv0_TIMap arg0@@19)) TyType) :qid |funType:Inv0_TIMap| :pattern ((Inv0_TIMap arg0@@19))))))
(assert (forall ((t@@5 T@U) (u@@1 T@U)) (! (=> (and (= (type t@@5) TyType) (= (type u@@1) TyType)) (= (Inv0_TIMap (TIMap t@@5 u@@1)) t@@5)) :qid |DafnyPre.43:15| :skolemid |6| :pattern ((TIMap t@@5 u@@1)))))
(assert (forall ((arg0@@20 T@U)) (! (= (type (Inv1_TIMap arg0@@20)) TyType) :qid |funType:Inv1_TIMap| :pattern ((Inv1_TIMap arg0@@20)))))
(assert (forall ((t@@6 T@U) (u@@2 T@U)) (! (=> (and (= (type t@@6) TyType) (= (type u@@2) TyType)) (= (Inv1_TIMap (TIMap t@@6 u@@2)) u@@2)) :qid |DafnyPre.44:15| :skolemid |7| :pattern ((TIMap t@@6 u@@2)))))
(assert (forall ((arg0@@21 T@U)) (! (= (type (Tag arg0@@21)) TyTagType) :qid |funType:Tag| :pattern ((Tag arg0@@21)))))
(assert (= (Tag TBool) TagBool))
(assert (= (Tag TChar) TagChar))
(assert (= (Tag TInt) TagInt))
(assert (= (Tag TNat) TagNat))
(assert (= (Tag TReal) TagReal))
(assert (forall ((t@@7 T@U)) (! (=> (= (type t@@7) TyType) (= (Tag (TSet t@@7)) TagSet)) :qid |DafnyPre.70:15| :skolemid |8| :pattern ((TSet t@@7)))))
(assert (forall ((t@@8 T@U)) (! (=> (= (type t@@8) TyType) (= (Tag (TISet t@@8)) TagISet)) :qid |DafnyPre.71:15| :skolemid |9| :pattern ((TISet t@@8)))))
(assert (forall ((t@@9 T@U)) (! (=> (= (type t@@9) TyType) (= (Tag (TMultiSet t@@9)) TagMultiSet)) :qid |DafnyPre.72:15| :skolemid |10| :pattern ((TMultiSet t@@9)))))
(assert (forall ((t@@10 T@U)) (! (=> (= (type t@@10) TyType) (= (Tag (TSeq t@@10)) TagSeq)) :qid |DafnyPre.73:15| :skolemid |11| :pattern ((TSeq t@@10)))))
(assert (forall ((t@@11 T@U) (u@@3 T@U)) (! (=> (and (= (type t@@11) TyType) (= (type u@@3) TyType)) (= (Tag (TMap t@@11 u@@3)) TagMap)) :qid |DafnyPre.74:15| :skolemid |12| :pattern ((TMap t@@11 u@@3)))))
(assert (forall ((t@@12 T@U) (u@@4 T@U)) (! (=> (and (= (type t@@12) TyType) (= (type u@@4) TyType)) (= (Tag (TIMap t@@12 u@@4)) TagIMap)) :qid |DafnyPre.75:15| :skolemid |13| :pattern ((TIMap t@@12 u@@4)))))
(assert (forall ((x@@5 Int)) (! (= (LitInt x@@5) x@@5) :qid |DafnyPre.80:29| :skolemid |14| :pattern ((LitInt x@@5)))))
(assert (and (and (= (Ctor BoxType) 7) (forall ((arg0@@22 T@U)) (! (= (type ($Box arg0@@22)) BoxType) :qid |funType:$Box| :pattern (($Box arg0@@22))))) (forall ((arg0@@23 T@U)) (! (let ((T (type arg0@@23))) (= (type (Lit arg0@@23)) T)) :qid |funType:Lit| :pattern ((Lit arg0@@23))))))
(assert (forall ((x@@6 Int)) (! (= ($Box (int_2_U (LitInt x@@6))) (Lit ($Box (int_2_U x@@6)))) :qid |DafnyPre.81:15| :skolemid |15| :pattern (($Box (int_2_U (LitInt x@@6)))))))
(assert (forall ((x@@7 Real)) (! (= (LitReal x@@7) x@@7) :qid |DafnyPre.82:30| :skolemid |16| :pattern ((LitReal x@@7)))))
(assert (forall ((x@@8 Real)) (! (= ($Box (real_2_U (LitReal x@@8))) (Lit ($Box (real_2_U x@@8)))) :qid |DafnyPre.83:15| :skolemid |17| :pattern (($Box (real_2_U (LitReal x@@8)))))))
(assert (forall ((x@@9 T@U)) (! (= (Lit x@@9) x@@9) :qid |DafnyPre.84:29| :skolemid |18| :pattern ((Lit x@@9)))))
(assert (forall ((x@@10 T@U)) (! (= ($Box (Lit x@@10)) (Lit ($Box x@@10))) :qid |DafnyPre.85:18| :skolemid |19| :pattern (($Box (Lit x@@10))))))
(assert (and (= (Ctor charType) 8) (forall ((arg0@@24 Int)) (! (= (type (|char#FromInt| arg0@@24)) charType) :qid |funType:char#FromInt| :pattern ((|char#FromInt| arg0@@24))))))
(assert (forall ((ch T@U)) (! (=> (= (type ch) charType) (= (|char#FromInt| (|char#ToInt| ch)) ch)) :qid |DafnyPre.94:15| :skolemid |20| :pattern ((|char#ToInt| ch)))))
(assert (forall ((n Int)) (! (=> (and (<= 0 n) (< n 65536)) (= (|char#ToInt| (|char#FromInt| n)) n)) :qid |DafnyPre.97:15| :skolemid |21| :pattern ((|char#FromInt| n)))))
(assert (forall ((T@@0 T@T) (arg0@@25 T@U)) (! (= (type ($Unbox T@@0 arg0@@25)) T@@0) :qid |funType:$Unbox| :pattern (($Unbox T@@0 arg0@@25)))))
(assert (forall ((x@@11 T@U)) (! (let ((T@@1 (type x@@11))) (= ($Unbox T@@1 ($Box x@@11)) x@@11)) :qid |DafnyPre.125:18| :skolemid |22| :pattern (($Box x@@11)))))
(assert (forall ((bx T@U)) (! (=> (and (= (type bx) BoxType) ($IsBox bx TInt)) (and (= ($Box ($Unbox intType bx)) bx) ($Is ($Unbox intType bx) TInt))) :qid |DafnyPre.127:15| :skolemid |23| :pattern (($IsBox bx TInt)))))
(assert (forall ((bx@@0 T@U)) (! (=> (and (= (type bx@@0) BoxType) ($IsBox bx@@0 TNat)) (and (= ($Box ($Unbox intType bx@@0)) bx@@0) ($Is ($Unbox intType bx@@0) TNat))) :qid |DafnyPre.130:15| :skolemid |24| :pattern (($IsBox bx@@0 TNat)))))
(assert (forall ((bx@@1 T@U)) (! (=> (and (= (type bx@@1) BoxType) ($IsBox bx@@1 TReal)) (and (= ($Box ($Unbox realType bx@@1)) bx@@1) ($Is ($Unbox realType bx@@1) TReal))) :qid |DafnyPre.133:15| :skolemid |25| :pattern (($IsBox bx@@1 TReal)))))
(assert (forall ((bx@@2 T@U)) (! (=> (and (= (type bx@@2) BoxType) ($IsBox bx@@2 TBool)) (and (= ($Box ($Unbox boolType bx@@2)) bx@@2) ($Is ($Unbox boolType bx@@2) TBool))) :qid |DafnyPre.136:15| :skolemid |26| :pattern (($IsBox bx@@2 TBool)))))
(assert (forall ((bx@@3 T@U)) (! (=> (and (= (type bx@@3) BoxType) ($IsBox bx@@3 TChar)) (and (= ($Box ($Unbox charType bx@@3)) bx@@3) ($Is ($Unbox charType bx@@3) TChar))) :qid |DafnyPre.139:15| :skolemid |27| :pattern (($IsBox bx@@3 TChar)))))
(assert (and (and (and (and (and (and (forall ((arg0@@26 T@T) (arg1@@1 T@T)) (! (= (Ctor (MapType0Type arg0@@26 arg1@@1)) 9) :qid |ctor:MapType0Type|)) (forall ((arg0@@27 T@T) (arg1@@2 T@T)) (! (= (MapType0TypeInv0 (MapType0Type arg0@@27 arg1@@2)) arg0@@27) :qid |typeInv:MapType0TypeInv0| :pattern ((MapType0Type arg0@@27 arg1@@2))))) (forall ((arg0@@28 T@T) (arg1@@3 T@T)) (! (= (MapType0TypeInv1 (MapType0Type arg0@@28 arg1@@3)) arg1@@3) :qid |typeInv:MapType0TypeInv1| :pattern ((MapType0Type arg0@@28 arg1@@3))))) (forall ((arg0@@29 T@U) (arg1@@4 T@U)) (! (let ((aVar1 (MapType0TypeInv1 (type arg0@@29)))) (= (type (MapType0Select arg0@@29 arg1@@4)) aVar1)) :qid |funType:MapType0Select| :pattern ((MapType0Select arg0@@29 arg1@@4))))) (forall ((arg0@@30 T@U) (arg1@@5 T@U) (arg2 T@U)) (! (let ((aVar1@@0 (type arg2))) (let ((aVar0 (type arg1@@5))) (= (type (MapType0Store arg0@@30 arg1@@5 arg2)) (MapType0Type aVar0 aVar1@@0)))) :qid |funType:MapType0Store| :pattern ((MapType0Store arg0@@30 arg1@@5 arg2))))) (forall ((m T@U) (x0 T@U) (val T@U)) (! (let ((aVar1@@1 (MapType0TypeInv1 (type m)))) (=> (= (type val) aVar1@@1) (= (MapType0Select (MapType0Store m x0 val) x0) val))) :qid |mapAx0:MapType0Select| :weight 0))) (and (forall ((val@@0 T@U) (m@@0 T@U) (x0@@0 T@U) (y0 T@U)) (! (or (= x0@@0 y0) (= (MapType0Select (MapType0Store m@@0 x0@@0 val@@0) y0) (MapType0Select m@@0 y0))) :qid |mapAx1:MapType0Select:0| :weight 0)) (forall ((val@@1 T@U) (m@@1 T@U) (x0@@1 T@U) (y0@@0 T@U)) (! (or true (= (MapType0Select (MapType0Store m@@1 x0@@1 val@@1) y0@@0) (MapType0Select m@@1 y0@@0))) :qid |mapAx2:MapType0Select| :weight 0)))))
(assert (forall ((bx@@4 T@U) (t@@13 T@U)) (! (=> (and (and (= (type bx@@4) BoxType) (= (type t@@13) TyType)) ($IsBox bx@@4 (TSet t@@13))) (and (= ($Box ($Unbox (MapType0Type BoxType boolType) bx@@4)) bx@@4) ($Is ($Unbox (MapType0Type BoxType boolType) bx@@4) (TSet t@@13)))) :qid |DafnyPre.142:15| :skolemid |28| :pattern (($IsBox bx@@4 (TSet t@@13))))))
(assert (forall ((bx@@5 T@U) (t@@14 T@U)) (! (=> (and (and (= (type bx@@5) BoxType) (= (type t@@14) TyType)) ($IsBox bx@@5 (TISet t@@14))) (and (= ($Box ($Unbox (MapType0Type BoxType boolType) bx@@5)) bx@@5) ($Is ($Unbox (MapType0Type BoxType boolType) bx@@5) (TISet t@@14)))) :qid |DafnyPre.145:15| :skolemid |29| :pattern (($IsBox bx@@5 (TISet t@@14))))))
(assert (forall ((bx@@6 T@U) (t@@15 T@U)) (! (=> (and (and (= (type bx@@6) BoxType) (= (type t@@15) TyType)) ($IsBox bx@@6 (TMultiSet t@@15))) (and (= ($Box ($Unbox (MapType0Type BoxType intType) bx@@6)) bx@@6) ($Is ($Unbox (MapType0Type BoxType intType) bx@@6) (TMultiSet t@@15)))) :qid |DafnyPre.148:15| :skolemid |30| :pattern (($IsBox bx@@6 (TMultiSet t@@15))))))
(assert (and (forall ((arg0@@31 T@T)) (! (= (Ctor (SeqType arg0@@31)) 10) :qid |ctor:SeqType|)) (forall ((arg0@@32 T@T)) (! (= (SeqTypeInv0 (SeqType arg0@@32)) arg0@@32) :qid |typeInv:SeqTypeInv0| :pattern ((SeqType arg0@@32))))))
(assert (forall ((bx@@7 T@U) (t@@16 T@U)) (! (=> (and (and (= (type bx@@7) BoxType) (= (type t@@16) TyType)) ($IsBox bx@@7 (TSeq t@@16))) (and (= ($Box ($Unbox (SeqType BoxType) bx@@7)) bx@@7) ($Is ($Unbox (SeqType BoxType) bx@@7) (TSeq t@@16)))) :qid |DafnyPre.151:15| :skolemid |31| :pattern (($IsBox bx@@7 (TSeq t@@16))))))
(assert (and (and (forall ((arg0@@33 T@T) (arg1@@6 T@T)) (! (= (Ctor (MapType arg0@@33 arg1@@6)) 11) :qid |ctor:MapType|)) (forall ((arg0@@34 T@T) (arg1@@7 T@T)) (! (= (MapTypeInv0 (MapType arg0@@34 arg1@@7)) arg0@@34) :qid |typeInv:MapTypeInv0| :pattern ((MapType arg0@@34 arg1@@7))))) (forall ((arg0@@35 T@T) (arg1@@8 T@T)) (! (= (MapTypeInv1 (MapType arg0@@35 arg1@@8)) arg1@@8) :qid |typeInv:MapTypeInv1| :pattern ((MapType arg0@@35 arg1@@8))))))
(assert (forall ((bx@@8 T@U) (s T@U) (t@@17 T@U)) (! (=> (and (and (and (= (type bx@@8) BoxType) (= (type s) TyType)) (= (type t@@17) TyType)) ($IsBox bx@@8 (TMap s t@@17))) (and (= ($Box ($Unbox (MapType BoxType BoxType) bx@@8)) bx@@8) ($Is ($Unbox (MapType BoxType BoxType) bx@@8) (TMap s t@@17)))) :qid |DafnyPre.154:15| :skolemid |32| :pattern (($IsBox bx@@8 (TMap s t@@17))))))
(assert (and (and (forall ((arg0@@36 T@T) (arg1@@9 T@T)) (! (= (Ctor (IMapType arg0@@36 arg1@@9)) 12) :qid |ctor:IMapType|)) (forall ((arg0@@37 T@T) (arg1@@10 T@T)) (! (= (IMapTypeInv0 (IMapType arg0@@37 arg1@@10)) arg0@@37) :qid |typeInv:IMapTypeInv0| :pattern ((IMapType arg0@@37 arg1@@10))))) (forall ((arg0@@38 T@T) (arg1@@11 T@T)) (! (= (IMapTypeInv1 (IMapType arg0@@38 arg1@@11)) arg1@@11) :qid |typeInv:IMapTypeInv1| :pattern ((IMapType arg0@@38 arg1@@11))))))
(assert (forall ((bx@@9 T@U) (s@@0 T@U) (t@@18 T@U)) (! (=> (and (and (and (= (type bx@@9) BoxType) (= (type s@@0) TyType)) (= (type t@@18) TyType)) ($IsBox bx@@9 (TIMap s@@0 t@@18))) (and (= ($Box ($Unbox (IMapType BoxType BoxType) bx@@9)) bx@@9) ($Is ($Unbox (IMapType BoxType BoxType) bx@@9) (TIMap s@@0 t@@18)))) :qid |DafnyPre.157:15| :skolemid |33| :pattern (($IsBox bx@@9 (TIMap s@@0 t@@18))))))
(assert (forall ((v T@U) (t@@19 T@U)) (! (=> (= (type t@@19) TyType) (and (=> ($IsBox ($Box v) t@@19) ($Is v t@@19)) (=> ($Is v t@@19) ($IsBox ($Box v) t@@19)))) :qid |DafnyPre.161:18| :skolemid |34| :pattern (($IsBox ($Box v) t@@19)))))
(assert (and (and (and (and (and (and (forall ((arg0@@39 T@T)) (! (= (Ctor (MapType1Type arg0@@39)) 13) :qid |ctor:MapType1Type|)) (forall ((arg0@@40 T@T)) (! (= (MapType1TypeInv0 (MapType1Type arg0@@40)) arg0@@40) :qid |typeInv:MapType1TypeInv0| :pattern ((MapType1Type arg0@@40))))) (forall ((arg0@@41 T@U) (arg1@@12 T@U) (arg2@@0 T@U)) (! (let ((alpha@@1 (FieldTypeInv0 (type arg2@@0)))) (= (type (MapType1Select arg0@@41 arg1@@12 arg2@@0)) alpha@@1)) :qid |funType:MapType1Select| :pattern ((MapType1Select arg0@@41 arg1@@12 arg2@@0))))) (forall ((arg0@@42 T@U) (arg1@@13 T@U) (arg2@@1 T@U) (arg3 T@U)) (! (let ((aVar0@@0 (type arg1@@13))) (= (type (MapType1Store arg0@@42 arg1@@13 arg2@@1 arg3)) (MapType1Type aVar0@@0))) :qid |funType:MapType1Store| :pattern ((MapType1Store arg0@@42 arg1@@13 arg2@@1 arg3))))) (forall ((m@@2 T@U) (x0@@2 T@U) (x1 T@U) (val@@2 T@U)) (! (let ((alpha@@2 (FieldTypeInv0 (type x1)))) (=> (= (type val@@2) alpha@@2) (= (MapType1Select (MapType1Store m@@2 x0@@2 x1 val@@2) x0@@2 x1) val@@2))) :qid |mapAx0:MapType1Select| :weight 0))) (and (and (forall ((val@@3 T@U) (m@@3 T@U) (x0@@3 T@U) (x1@@0 T@U) (y0@@1 T@U) (y1 T@U)) (! (or (= x0@@3 y0@@1) (= (MapType1Select (MapType1Store m@@3 x0@@3 x1@@0 val@@3) y0@@1 y1) (MapType1Select m@@3 y0@@1 y1))) :qid |mapAx1:MapType1Select:0| :weight 0)) (forall ((val@@4 T@U) (m@@4 T@U) (x0@@4 T@U) (x1@@1 T@U) (y0@@2 T@U) (y1@@0 T@U)) (! (or (= x1@@1 y1@@0) (= (MapType1Select (MapType1Store m@@4 x0@@4 x1@@1 val@@4) y0@@2 y1@@0) (MapType1Select m@@4 y0@@2 y1@@0))) :qid |mapAx1:MapType1Select:1| :weight 0))) (forall ((val@@5 T@U) (m@@5 T@U) (x0@@5 T@U) (x1@@2 T@U) (y0@@3 T@U) (y1@@1 T@U)) (! (or true (= (MapType1Select (MapType1Store m@@5 x0@@5 x1@@2 val@@5) y0@@3 y1@@1) (MapType1Select m@@5 y0@@3 y1@@1))) :qid |mapAx2:MapType1Select| :weight 0)))) (= (Ctor refType) 14)))
(assert (forall ((v@@0 T@U) (t@@20 T@U) (h T@U)) (! (=> (and (= (type t@@20) TyType) (= (type h) (MapType1Type refType))) (and (=> ($IsAllocBox ($Box v@@0) t@@20 h) ($IsAlloc v@@0 t@@20 h)) (=> ($IsAlloc v@@0 t@@20 h) ($IsAllocBox ($Box v@@0) t@@20 h)))) :qid |DafnyPre.164:18| :skolemid |35| :pattern (($IsAllocBox ($Box v@@0) t@@20 h)))))
(assert (forall ((v@@1 T@U)) (! (=> (= (type v@@1) intType) ($Is v@@1 TInt)) :qid |DafnyPre.182:14| :skolemid |36| :pattern (($Is v@@1 TInt)))))
(assert (forall ((v@@2 T@U)) (! (=> (= (type v@@2) intType) (and (=> ($Is v@@2 TNat) (>= (U_2_int v@@2) 0)) (=> (>= (U_2_int v@@2) 0) ($Is v@@2 TNat)))) :qid |DafnyPre.183:14| :skolemid |37| :pattern (($Is v@@2 TNat)))))
(assert (forall ((v@@3 T@U)) (! (=> (= (type v@@3) realType) ($Is v@@3 TReal)) :qid |DafnyPre.184:14| :skolemid |38| :pattern (($Is v@@3 TReal)))))
(assert (forall ((v@@4 T@U)) (! (=> (= (type v@@4) boolType) ($Is v@@4 TBool)) :qid |DafnyPre.185:14| :skolemid |39| :pattern (($Is v@@4 TBool)))))
(assert (forall ((v@@5 T@U)) (! (=> (= (type v@@5) charType) ($Is v@@5 TChar)) :qid |DafnyPre.186:14| :skolemid |40| :pattern (($Is v@@5 TChar)))))
(assert (forall ((h@@0 T@U) (v@@6 T@U)) (! (=> (and (= (type h@@0) (MapType1Type refType)) (= (type v@@6) intType)) ($IsAlloc v@@6 TInt h@@0)) :qid |DafnyPre.188:14| :skolemid |41| :pattern (($IsAlloc v@@6 TInt h@@0)))))
(assert (forall ((h@@1 T@U) (v@@7 T@U)) (! (=> (and (= (type h@@1) (MapType1Type refType)) (= (type v@@7) intType)) ($IsAlloc v@@7 TNat h@@1)) :qid |DafnyPre.189:14| :skolemid |42| :pattern (($IsAlloc v@@7 TNat h@@1)))))
(assert (forall ((h@@2 T@U) (v@@8 T@U)) (! (=> (and (= (type h@@2) (MapType1Type refType)) (= (type v@@8) realType)) ($IsAlloc v@@8 TReal h@@2)) :qid |DafnyPre.190:14| :skolemid |43| :pattern (($IsAlloc v@@8 TReal h@@2)))))
(assert (forall ((h@@3 T@U) (v@@9 T@U)) (! (=> (and (= (type h@@3) (MapType1Type refType)) (= (type v@@9) boolType)) ($IsAlloc v@@9 TBool h@@3)) :qid |DafnyPre.191:14| :skolemid |44| :pattern (($IsAlloc v@@9 TBool h@@3)))))
(assert (forall ((h@@4 T@U) (v@@10 T@U)) (! (=> (and (= (type h@@4) (MapType1Type refType)) (= (type v@@10) charType)) ($IsAlloc v@@10 TChar h@@4)) :qid |DafnyPre.192:14| :skolemid |45| :pattern (($IsAlloc v@@10 TChar h@@4)))))
(assert (forall ((v@@11 T@U) (t0 T@U)) (! (=> (and (= (type v@@11) (MapType0Type BoxType boolType)) (= (type t0) TyType)) (and (=> ($Is v@@11 (TSet t0)) (forall ((bx@@10 T@U)) (! (=> (and (= (type bx@@10) BoxType) (U_2_bool (MapType0Select v@@11 bx@@10))) ($IsBox bx@@10 t0)) :qid |DafnyPre.196:11| :skolemid |46| :pattern ((MapType0Select v@@11 bx@@10))))) (=> (forall ((bx@@11 T@U)) (! (=> (and (= (type bx@@11) BoxType) (U_2_bool (MapType0Select v@@11 bx@@11))) ($IsBox bx@@11 t0)) :qid |DafnyPre.196:11| :skolemid |46| :pattern ((MapType0Select v@@11 bx@@11)))) ($Is v@@11 (TSet t0))))) :qid |DafnyPre.194:15| :skolemid |47| :pattern (($Is v@@11 (TSet t0))))))
(assert (forall ((v@@12 T@U) (t0@@0 T@U)) (! (=> (and (= (type v@@12) (MapType0Type BoxType boolType)) (= (type t0@@0) TyType)) (and (=> ($Is v@@12 (TISet t0@@0)) (forall ((bx@@12 T@U)) (! (=> (and (= (type bx@@12) BoxType) (U_2_bool (MapType0Select v@@12 bx@@12))) ($IsBox bx@@12 t0@@0)) :qid |DafnyPre.200:11| :skolemid |48| :pattern ((MapType0Select v@@12 bx@@12))))) (=> (forall ((bx@@13 T@U)) (! (=> (and (= (type bx@@13) BoxType) (U_2_bool (MapType0Select v@@12 bx@@13))) ($IsBox bx@@13 t0@@0)) :qid |DafnyPre.200:11| :skolemid |48| :pattern ((MapType0Select v@@12 bx@@13)))) ($Is v@@12 (TISet t0@@0))))) :qid |DafnyPre.198:15| :skolemid |49| :pattern (($Is v@@12 (TISet t0@@0))))))
(assert (forall ((v@@13 T@U) (t0@@1 T@U)) (! (=> (and (= (type v@@13) (MapType0Type BoxType intType)) (= (type t0@@1) TyType)) (and (=> ($Is v@@13 (TMultiSet t0@@1)) (forall ((bx@@14 T@U)) (! (=> (and (= (type bx@@14) BoxType) (< 0 (U_2_int (MapType0Select v@@13 bx@@14)))) ($IsBox bx@@14 t0@@1)) :qid |DafnyPre.204:11| :skolemid |50| :pattern ((MapType0Select v@@13 bx@@14))))) (=> (forall ((bx@@15 T@U)) (! (=> (and (= (type bx@@15) BoxType) (< 0 (U_2_int (MapType0Select v@@13 bx@@15)))) ($IsBox bx@@15 t0@@1)) :qid |DafnyPre.204:11| :skolemid |50| :pattern ((MapType0Select v@@13 bx@@15)))) ($Is v@@13 (TMultiSet t0@@1))))) :qid |DafnyPre.202:15| :skolemid |51| :pattern (($Is v@@13 (TMultiSet t0@@1))))))
(assert (forall ((v@@14 T@U) (t0@@2 T@U)) (! (=> (and (and (= (type v@@14) (MapType0Type BoxType intType)) (= (type t0@@2) TyType)) ($Is v@@14 (TMultiSet t0@@2))) ($IsGoodMultiSet v@@14)) :qid |DafnyPre.206:15| :skolemid |52| :pattern (($Is v@@14 (TMultiSet t0@@2))))))
(assert (forall ((arg0@@43 T@U) (arg1@@14 Int)) (! (let ((T@@2 (SeqTypeInv0 (type arg0@@43)))) (= (type (|Seq#Index| arg0@@43 arg1@@14)) T@@2)) :qid |funType:Seq#Index| :pattern ((|Seq#Index| arg0@@43 arg1@@14)))))
(assert (forall ((v@@15 T@U) (t0@@3 T@U)) (! (=> (and (= (type v@@15) (SeqType BoxType)) (= (type t0@@3) TyType)) (and (=> ($Is v@@15 (TSeq t0@@3)) (forall ((i Int)) (! (=> (and (<= 0 i) (< i (|Seq#Length| v@@15))) ($IsBox (|Seq#Index| v@@15 i) t0@@3)) :qid |DafnyPre.210:11| :skolemid |53| :pattern ((|Seq#Index| v@@15 i))))) (=> (forall ((i@@0 Int)) (! (=> (and (<= 0 i@@0) (< i@@0 (|Seq#Length| v@@15))) ($IsBox (|Seq#Index| v@@15 i@@0) t0@@3)) :qid |DafnyPre.210:11| :skolemid |53| :pattern ((|Seq#Index| v@@15 i@@0)))) ($Is v@@15 (TSeq t0@@3))))) :qid |DafnyPre.208:15| :skolemid |54| :pattern (($Is v@@15 (TSeq t0@@3))))))
(assert (forall ((v@@16 T@U) (t0@@4 T@U) (h@@5 T@U)) (! (=> (and (and (= (type v@@16) (MapType0Type BoxType boolType)) (= (type t0@@4) TyType)) (= (type h@@5) (MapType1Type refType))) (and (=> ($IsAlloc v@@16 (TSet t0@@4) h@@5) (forall ((bx@@16 T@U)) (! (=> (and (= (type bx@@16) BoxType) (U_2_bool (MapType0Select v@@16 bx@@16))) ($IsAllocBox bx@@16 t0@@4 h@@5)) :qid |DafnyPre.215:11| :skolemid |55| :pattern ((MapType0Select v@@16 bx@@16))))) (=> (forall ((bx@@17 T@U)) (! (=> (and (= (type bx@@17) BoxType) (U_2_bool (MapType0Select v@@16 bx@@17))) ($IsAllocBox bx@@17 t0@@4 h@@5)) :qid |DafnyPre.215:11| :skolemid |55| :pattern ((MapType0Select v@@16 bx@@17)))) ($IsAlloc v@@16 (TSet t0@@4) h@@5)))) :qid |DafnyPre.213:15| :skolemid |56| :pattern (($IsAlloc v@@16 (TSet t0@@4) h@@5)))))
(assert (forall ((v@@17 T@U) (t0@@5 T@U) (h@@6 T@U)) (! (=> (and (and (= (type v@@17) (MapType0Type BoxType boolType)) (= (type t0@@5) TyType)) (= (type h@@6) (MapType1Type refType))) (and (=> ($IsAlloc v@@17 (TISet t0@@5) h@@6) (forall ((bx@@18 T@U)) (! (=> (and (= (type bx@@18) BoxType) (U_2_bool (MapType0Select v@@17 bx@@18))) ($IsAllocBox bx@@18 t0@@5 h@@6)) :qid |DafnyPre.219:11| :skolemid |57| :pattern ((MapType0Select v@@17 bx@@18))))) (=> (forall ((bx@@19 T@U)) (! (=> (and (= (type bx@@19) BoxType) (U_2_bool (MapType0Select v@@17 bx@@19))) ($IsAllocBox bx@@19 t0@@5 h@@6)) :qid |DafnyPre.219:11| :skolemid |57| :pattern ((MapType0Select v@@17 bx@@19)))) ($IsAlloc v@@17 (TISet t0@@5) h@@6)))) :qid |DafnyPre.217:15| :skolemid |58| :pattern (($IsAlloc v@@17 (TISet t0@@5) h@@6)))))
(assert (forall ((v@@18 T@U) (t0@@6 T@U) (h@@7 T@U)) (! (=> (and (and (= (type v@@18) (MapType0Type BoxType intType)) (= (type t0@@6) TyType)) (= (type h@@7) (MapType1Type refType))) (and (=> ($IsAlloc v@@18 (TMultiSet t0@@6) h@@7) (forall ((bx@@20 T@U)) (! (=> (and (= (type bx@@20) BoxType) (< 0 (U_2_int (MapType0Select v@@18 bx@@20)))) ($IsAllocBox bx@@20 t0@@6 h@@7)) :qid |DafnyPre.223:11| :skolemid |59| :pattern ((MapType0Select v@@18 bx@@20))))) (=> (forall ((bx@@21 T@U)) (! (=> (and (= (type bx@@21) BoxType) (< 0 (U_2_int (MapType0Select v@@18 bx@@21)))) ($IsAllocBox bx@@21 t0@@6 h@@7)) :qid |DafnyPre.223:11| :skolemid |59| :pattern ((MapType0Select v@@18 bx@@21)))) ($IsAlloc v@@18 (TMultiSet t0@@6) h@@7)))) :qid |DafnyPre.221:15| :skolemid |60| :pattern (($IsAlloc v@@18 (TMultiSet t0@@6) h@@7)))))
(assert (forall ((v@@19 T@U) (t0@@7 T@U) (h@@8 T@U)) (! (=> (and (and (= (type v@@19) (SeqType BoxType)) (= (type t0@@7) TyType)) (= (type h@@8) (MapType1Type refType))) (and (=> ($IsAlloc v@@19 (TSeq t0@@7) h@@8) (forall ((i@@1 Int)) (! (=> (and (<= 0 i@@1) (< i@@1 (|Seq#Length| v@@19))) ($IsAllocBox (|Seq#Index| v@@19 i@@1) t0@@7 h@@8)) :qid |DafnyPre.227:11| :skolemid |61| :pattern ((|Seq#Index| v@@19 i@@1))))) (=> (forall ((i@@2 Int)) (! (=> (and (<= 0 i@@2) (< i@@2 (|Seq#Length| v@@19))) ($IsAllocBox (|Seq#Index| v@@19 i@@2) t0@@7 h@@8)) :qid |DafnyPre.227:11| :skolemid |61| :pattern ((|Seq#Index| v@@19 i@@2)))) ($IsAlloc v@@19 (TSeq t0@@7) h@@8)))) :qid |DafnyPre.225:15| :skolemid |62| :pattern (($IsAlloc v@@19 (TSeq t0@@7) h@@8)))))
(assert (and (forall ((arg0@@44 T@U)) (! (let ((V (MapTypeInv1 (type arg0@@44)))) (let ((U (MapTypeInv0 (type arg0@@44)))) (= (type (|Map#Elements| arg0@@44)) (MapType0Type U V)))) :qid |funType:Map#Elements| :pattern ((|Map#Elements| arg0@@44)))) (forall ((arg0@@45 T@U)) (! (let ((U@@0 (MapTypeInv0 (type arg0@@45)))) (= (type (|Map#Domain| arg0@@45)) (MapType0Type U@@0 boolType))) :qid |funType:Map#Domain| :pattern ((|Map#Domain| arg0@@45))))))
(assert (forall ((v@@20 T@U) (t0@@8 T@U) (t1 T@U)) (! (=> (and (and (= (type v@@20) (MapType BoxType BoxType)) (= (type t0@@8) TyType)) (= (type t1) TyType)) (and (=> ($Is v@@20 (TMap t0@@8 t1)) (forall ((bx@@22 T@U)) (! (=> (and (= (type bx@@22) BoxType) (U_2_bool (MapType0Select (|Map#Domain| v@@20) bx@@22))) (and ($IsBox (MapType0Select (|Map#Elements| v@@20) bx@@22) t1) ($IsBox bx@@22 t0@@8))) :qid |DafnyPre.234:19| :skolemid |63| :pattern ((MapType0Select (|Map#Elements| v@@20) bx@@22)) :pattern ((MapType0Select (|Map#Domain| v@@20) bx@@22))))) (=> (forall ((bx@@23 T@U)) (! (=> (and (= (type bx@@23) BoxType) (U_2_bool (MapType0Select (|Map#Domain| v@@20) bx@@23))) (and ($IsBox (MapType0Select (|Map#Elements| v@@20) bx@@23) t1) ($IsBox bx@@23 t0@@8))) :qid |DafnyPre.234:19| :skolemid |63| :pattern ((MapType0Select (|Map#Elements| v@@20) bx@@23)) :pattern ((MapType0Select (|Map#Domain| v@@20) bx@@23)))) ($Is v@@20 (TMap t0@@8 t1))))) :qid |DafnyPre.231:15| :skolemid |64| :pattern (($Is v@@20 (TMap t0@@8 t1))))))
(assert (forall ((v@@21 T@U) (t0@@9 T@U) (t1@@0 T@U) (h@@9 T@U)) (! (=> (and (and (and (= (type v@@21) (MapType BoxType BoxType)) (= (type t0@@9) TyType)) (= (type t1@@0) TyType)) (= (type h@@9) (MapType1Type refType))) (and (=> ($IsAlloc v@@21 (TMap t0@@9 t1@@0) h@@9) (forall ((bx@@24 T@U)) (! (=> (and (= (type bx@@24) BoxType) (U_2_bool (MapType0Select (|Map#Domain| v@@21) bx@@24))) (and ($IsAllocBox (MapType0Select (|Map#Elements| v@@21) bx@@24) t1@@0 h@@9) ($IsAllocBox bx@@24 t0@@9 h@@9))) :qid |DafnyPre.242:19| :skolemid |65| :pattern ((MapType0Select (|Map#Elements| v@@21) bx@@24)) :pattern ((MapType0Select (|Map#Domain| v@@21) bx@@24))))) (=> (forall ((bx@@25 T@U)) (! (=> (and (= (type bx@@25) BoxType) (U_2_bool (MapType0Select (|Map#Domain| v@@21) bx@@25))) (and ($IsAllocBox (MapType0Select (|Map#Elements| v@@21) bx@@25) t1@@0 h@@9) ($IsAllocBox bx@@25 t0@@9 h@@9))) :qid |DafnyPre.242:19| :skolemid |65| :pattern ((MapType0Select (|Map#Elements| v@@21) bx@@25)) :pattern ((MapType0Select (|Map#Domain| v@@21) bx@@25)))) ($IsAlloc v@@21 (TMap t0@@9 t1@@0) h@@9)))) :qid |DafnyPre.239:15| :skolemid |66| :pattern (($IsAlloc v@@21 (TMap t0@@9 t1@@0) h@@9)))))
(assert (and (forall ((arg0@@46 T@U)) (! (let ((V@@0 (IMapTypeInv1 (type arg0@@46)))) (let ((U@@1 (IMapTypeInv0 (type arg0@@46)))) (= (type (|IMap#Elements| arg0@@46)) (MapType0Type U@@1 V@@0)))) :qid |funType:IMap#Elements| :pattern ((|IMap#Elements| arg0@@46)))) (forall ((arg0@@47 T@U)) (! (let ((U@@2 (IMapTypeInv0 (type arg0@@47)))) (= (type (|IMap#Domain| arg0@@47)) (MapType0Type U@@2 boolType))) :qid |funType:IMap#Domain| :pattern ((|IMap#Domain| arg0@@47))))))
(assert (forall ((v@@22 T@U) (t0@@10 T@U) (t1@@1 T@U)) (! (=> (and (and (= (type v@@22) (IMapType BoxType BoxType)) (= (type t0@@10) TyType)) (= (type t1@@1) TyType)) (and (=> ($Is v@@22 (TIMap t0@@10 t1@@1)) (forall ((bx@@26 T@U)) (! (=> (and (= (type bx@@26) BoxType) (U_2_bool (MapType0Select (|IMap#Domain| v@@22) bx@@26))) (and ($IsBox (MapType0Select (|IMap#Elements| v@@22) bx@@26) t1@@1) ($IsBox bx@@26 t0@@10))) :qid |DafnyPre.251:19| :skolemid |67| :pattern ((MapType0Select (|IMap#Elements| v@@22) bx@@26)) :pattern ((MapType0Select (|IMap#Domain| v@@22) bx@@26))))) (=> (forall ((bx@@27 T@U)) (! (=> (and (= (type bx@@27) BoxType) (U_2_bool (MapType0Select (|IMap#Domain| v@@22) bx@@27))) (and ($IsBox (MapType0Select (|IMap#Elements| v@@22) bx@@27) t1@@1) ($IsBox bx@@27 t0@@10))) :qid |DafnyPre.251:19| :skolemid |67| :pattern ((MapType0Select (|IMap#Elements| v@@22) bx@@27)) :pattern ((MapType0Select (|IMap#Domain| v@@22) bx@@27)))) ($Is v@@22 (TIMap t0@@10 t1@@1))))) :qid |DafnyPre.248:15| :skolemid |68| :pattern (($Is v@@22 (TIMap t0@@10 t1@@1))))))
(assert (forall ((v@@23 T@U) (t0@@11 T@U) (t1@@2 T@U) (h@@10 T@U)) (! (=> (and (and (and (= (type v@@23) (IMapType BoxType BoxType)) (= (type t0@@11) TyType)) (= (type t1@@2) TyType)) (= (type h@@10) (MapType1Type refType))) (and (=> ($IsAlloc v@@23 (TIMap t0@@11 t1@@2) h@@10) (forall ((bx@@28 T@U)) (! (=> (and (= (type bx@@28) BoxType) (U_2_bool (MapType0Select (|IMap#Domain| v@@23) bx@@28))) (and ($IsAllocBox (MapType0Select (|IMap#Elements| v@@23) bx@@28) t1@@2 h@@10) ($IsAllocBox bx@@28 t0@@11 h@@10))) :qid |DafnyPre.259:19| :skolemid |69| :pattern ((MapType0Select (|IMap#Elements| v@@23) bx@@28)) :pattern ((MapType0Select (|IMap#Domain| v@@23) bx@@28))))) (=> (forall ((bx@@29 T@U)) (! (=> (and (= (type bx@@29) BoxType) (U_2_bool (MapType0Select (|IMap#Domain| v@@23) bx@@29))) (and ($IsAllocBox (MapType0Select (|IMap#Elements| v@@23) bx@@29) t1@@2 h@@10) ($IsAllocBox bx@@29 t0@@11 h@@10))) :qid |DafnyPre.259:19| :skolemid |69| :pattern ((MapType0Select (|IMap#Elements| v@@23) bx@@29)) :pattern ((MapType0Select (|IMap#Domain| v@@23) bx@@29)))) ($IsAlloc v@@23 (TIMap t0@@11 t1@@2) h@@10)))) :qid |DafnyPre.256:15| :skolemid |70| :pattern (($IsAlloc v@@23 (TIMap t0@@11 t1@@2) h@@10)))))
(assert (and (and (forall ((arg0@@48 T@U) (arg1@@15 T@U)) (! (= (type (TypeTuple arg0@@48 arg1@@15)) ClassNameType) :qid |funType:TypeTuple| :pattern ((TypeTuple arg0@@48 arg1@@15)))) (forall ((arg0@@49 T@U)) (! (= (type (TypeTupleCar arg0@@49)) ClassNameType) :qid |funType:TypeTupleCar| :pattern ((TypeTupleCar arg0@@49))))) (forall ((arg0@@50 T@U)) (! (= (type (TypeTupleCdr arg0@@50)) ClassNameType) :qid |funType:TypeTupleCdr| :pattern ((TypeTupleCdr arg0@@50))))))
(assert (forall ((a T@U) (b T@U)) (! (=> (and (= (type a) ClassNameType) (= (type b) ClassNameType)) (and (= (TypeTupleCar (TypeTuple a b)) a) (= (TypeTupleCdr (TypeTuple a b)) b))) :qid |DafnyPre.284:15| :skolemid |71| :pattern ((TypeTuple a b)))))
(assert (forall ((arg0@@51 T@U)) (! (= (type (SetRef_to_SetBox arg0@@51)) (MapType0Type BoxType boolType)) :qid |funType:SetRef_to_SetBox| :pattern ((SetRef_to_SetBox arg0@@51)))))
(assert (forall ((s@@1 T@U) (bx@@30 T@U)) (! (=> (and (= (type s@@1) (MapType0Type refType boolType)) (= (type bx@@30) BoxType)) (and (=> (U_2_bool (MapType0Select (SetRef_to_SetBox s@@1) bx@@30)) (U_2_bool (MapType0Select s@@1 ($Unbox refType bx@@30)))) (=> (U_2_bool (MapType0Select s@@1 ($Unbox refType bx@@30))) (U_2_bool (MapType0Select (SetRef_to_SetBox s@@1) bx@@30))))) :qid |DafnyPre.293:15| :skolemid |72| :pattern ((MapType0Select (SetRef_to_SetBox s@@1) bx@@30)))))
(assert (= (type Tclass._System.object) TyType))
(assert (forall ((s@@2 T@U)) (! (=> (= (type s@@2) (MapType0Type refType boolType)) ($Is (SetRef_to_SetBox s@@2) (TSet Tclass._System.object))) :qid |DafnyPre.295:15| :skolemid |73| :pattern ((SetRef_to_SetBox s@@2)))))
(assert (= (Ctor DatatypeTypeType) 15))
(assert (forall ((d T@U)) (! (=> (= (type d) DatatypeTypeType) (= (BoxRank ($Box d)) (DtRank d))) :qid |DafnyPre.310:15| :skolemid |74| :pattern ((BoxRank ($Box d))))))
(assert (and (= (Ctor LayerTypeType) 16) (forall ((arg0@@52 T@U) (arg1@@16 T@U)) (! (let ((A (MapType0TypeInv1 (type arg0@@52)))) (= (type (AtLayer arg0@@52 arg1@@16)) A)) :qid |funType:AtLayer| :pattern ((AtLayer arg0@@52 arg1@@16))))))
(assert (forall ((f T@U) (ly T@U)) (! (let ((A@@0 (MapType0TypeInv1 (type f)))) (=> (and (= (type f) (MapType0Type LayerTypeType A@@0)) (= (type ly) LayerTypeType)) (= (AtLayer f ly) (MapType0Select f ly)))) :qid |DafnyPre.329:18| :skolemid |75| :pattern ((AtLayer f ly)))))
(assert (forall ((arg0@@53 T@U)) (! (= (type ($LS arg0@@53)) LayerTypeType) :qid |funType:$LS| :pattern (($LS arg0@@53)))))
(assert (forall ((f@@0 T@U) (ly@@0 T@U)) (! (let ((A@@1 (MapType0TypeInv1 (type f@@0)))) (=> (and (= (type f@@0) (MapType0Type LayerTypeType A@@1)) (= (type ly@@0) LayerTypeType)) (= (AtLayer f@@0 ($LS ly@@0)) (AtLayer f@@0 ly@@0)))) :qid |DafnyPre.330:18| :skolemid |76| :pattern ((AtLayer f@@0 ($LS ly@@0))))))
(assert (forall ((arg0@@54 Int)) (! (= (type (IndexField arg0@@54)) (FieldType BoxType)) :qid |funType:IndexField| :pattern ((IndexField arg0@@54)))))
(assert (forall ((i@@3 Int)) (! (= (FDim (IndexField i@@3)) 1) :qid |DafnyPre.341:15| :skolemid |77| :pattern ((IndexField i@@3)))))
(assert (forall ((i@@4 Int)) (! (= (IndexField_Inverse (IndexField i@@4)) i@@4) :qid |DafnyPre.343:15| :skolemid |78| :pattern ((IndexField i@@4)))))
(assert (forall ((arg0@@55 T@U) (arg1@@17 Int)) (! (= (type (MultiIndexField arg0@@55 arg1@@17)) (FieldType BoxType)) :qid |funType:MultiIndexField| :pattern ((MultiIndexField arg0@@55 arg1@@17)))))
(assert (forall ((f@@1 T@U) (i@@5 Int)) (! (=> (= (type f@@1) (FieldType BoxType)) (= (FDim (MultiIndexField f@@1 i@@5)) (+ (FDim f@@1) 1))) :qid |DafnyPre.346:15| :skolemid |79| :pattern ((MultiIndexField f@@1 i@@5)))))
(assert (forall ((arg0@@56 T@U)) (! (let ((T@@3 (FieldTypeInv0 (type arg0@@56)))) (= (type (MultiIndexField_Inverse0 arg0@@56)) (FieldType T@@3))) :qid |funType:MultiIndexField_Inverse0| :pattern ((MultiIndexField_Inverse0 arg0@@56)))))
(assert (forall ((f@@2 T@U) (i@@6 Int)) (! (=> (= (type f@@2) (FieldType BoxType)) (and (= (MultiIndexField_Inverse0 (MultiIndexField f@@2 i@@6)) f@@2) (= (MultiIndexField_Inverse1 (MultiIndexField f@@2 i@@6)) i@@6))) :qid |DafnyPre.349:15| :skolemid |80| :pattern ((MultiIndexField f@@2 i@@6)))))
(assert (and (and (and (= (Ctor NameFamilyType) 17) (forall ((alpha@@3 T@T) (arg0@@57 T@U) (arg1@@18 T@U)) (! (= (type (FieldOfDecl alpha@@3 arg0@@57 arg1@@18)) (FieldType alpha@@3)) :qid |funType:FieldOfDecl| :pattern ((FieldOfDecl alpha@@3 arg0@@57 arg1@@18))))) (forall ((arg0@@58 T@U)) (! (= (type (DeclType arg0@@58)) ClassNameType) :qid |funType:DeclType| :pattern ((DeclType arg0@@58))))) (forall ((arg0@@59 T@U)) (! (= (type (DeclName arg0@@59)) NameFamilyType) :qid |funType:DeclName| :pattern ((DeclName arg0@@59))))))
(assert (forall ((cl T@U) (nm T@U) (T@@4 T@T)) (! (=> (and (= (type cl) ClassNameType) (= (type nm) NameFamilyType)) (and (= (DeclType (FieldOfDecl T@@4 cl nm)) cl) (= (DeclName (FieldOfDecl T@@4 cl nm)) nm))) :qid |DafnyPre.358:18| :skolemid |81| :pattern ((FieldOfDecl T@@4 cl nm)))))
(assert (forall ((h@@11 T@U) (k T@U) (v@@24 T@U) (t@@21 T@U)) (! (=> (and (and (and (and (= (type h@@11) (MapType1Type refType)) (= (type k) (MapType1Type refType))) (= (type t@@21) TyType)) ($HeapSucc h@@11 k)) ($IsAlloc v@@24 t@@21 h@@11)) ($IsAlloc v@@24 t@@21 k)) :qid |DafnyPre.371:17| :skolemid |82| :pattern (($HeapSucc h@@11 k) ($IsAlloc v@@24 t@@21 h@@11)))))
(assert (forall ((h@@12 T@U) (k@@0 T@U) (bx@@31 T@U) (t@@22 T@U)) (! (=> (and (and (and (and (and (= (type h@@12) (MapType1Type refType)) (= (type k@@0) (MapType1Type refType))) (= (type bx@@31) BoxType)) (= (type t@@22) TyType)) ($HeapSucc h@@12 k@@0)) ($IsAllocBox bx@@31 t@@22 h@@12)) ($IsAllocBox bx@@31 t@@22 k@@0)) :qid |DafnyPre.374:14| :skolemid |83| :pattern (($HeapSucc h@@12 k@@0) ($IsAllocBox bx@@31 t@@22 h@@12)))))
(assert (= (FDim alloc) 0))
(assert (not ($IsGhostField alloc)))
(assert (forall ((o T@U)) (! (=> (= (type o) refType) (<= 0 (_System.array.Length o))) :qid |DafnyPre.388:15| :skolemid |84| :no-pattern (type o) :no-pattern (U_2_int o) :no-pattern (U_2_bool o))))
(assert (forall ((x@@12 Real)) (! (= (q@Int x@@12) (to_int x@@12)) :qid |DafnyPre.394:14| :skolemid |85| :pattern ((q@Int x@@12)))))
(assert (forall ((x@@13 Int)) (! (= (q@Real x@@13) (to_real x@@13)) :qid |DafnyPre.395:15| :skolemid |86| :pattern ((q@Real x@@13)))))
(assert (forall ((i@@7 Int)) (! (= (q@Int (q@Real i@@7)) i@@7) :qid |DafnyPre.396:15| :skolemid |87| :pattern ((q@Int (q@Real i@@7))))))
(assert (forall ((h@@13 T@U) (r T@U) (f@@3 T@U) (x@@14 T@U)) (! (let ((alpha@@4 (type x@@14))) (=> (and (and (and (= (type h@@13) (MapType1Type refType)) (= (type r) refType)) (= (type f@@3) (FieldType alpha@@4))) ($IsGoodHeap (MapType1Store h@@13 r f@@3 x@@14))) ($HeapSucc h@@13 (MapType1Store h@@13 r f@@3 x@@14)))) :qid |DafnyPre.413:22| :skolemid |88| :pattern ((MapType1Store h@@13 r f@@3 x@@14)))))
(assert (forall ((a@@0 T@U) (b@@0 T@U) (c T@U)) (! (=> (and (and (and (= (type a@@0) (MapType1Type refType)) (= (type b@@0) (MapType1Type refType))) (= (type c) (MapType1Type refType))) (and ($HeapSucc a@@0 b@@0) ($HeapSucc b@@0 c))) ($HeapSucc a@@0 c)) :qid |DafnyPre.416:15| :skolemid |89| :pattern (($HeapSucc a@@0 b@@0) ($HeapSucc b@@0 c)))))
(assert (forall ((h@@14 T@U) (k@@1 T@U)) (! (=> (and (and (= (type h@@14) (MapType1Type refType)) (= (type k@@1) (MapType1Type refType))) ($HeapSucc h@@14 k@@1)) (forall ((o@@0 T@U)) (! (=> (and (= (type o@@0) refType) (U_2_bool (MapType1Select h@@14 o@@0 alloc))) (U_2_bool (MapType1Select k@@1 o@@0 alloc))) :qid |DafnyPre.419:30| :skolemid |90| :pattern ((MapType1Select k@@1 o@@0 alloc))))) :qid |DafnyPre.418:15| :skolemid |91| :pattern (($HeapSucc h@@14 k@@1)))))
(assert (forall ((h@@15 T@U) (k@@2 T@U)) (! (=> (and (and (= (type h@@15) (MapType1Type refType)) (= (type k@@2) (MapType1Type refType))) ($HeapSuccGhost h@@15 k@@2)) (and ($HeapSucc h@@15 k@@2) (forall ((o@@1 T@U) (f@@4 T@U)) (! (let ((alpha@@5 (FieldTypeInv0 (type f@@4)))) (=> (and (and (= (type o@@1) refType) (= (type f@@4) (FieldType alpha@@5))) (not ($IsGhostField f@@4))) (= (MapType1Select h@@15 o@@1 f@@4) (MapType1Select k@@2 o@@1 f@@4)))) :qid |DafnyPre.425:20| :skolemid |92| :pattern ((MapType1Select k@@2 o@@1 f@@4)))))) :qid |DafnyPre.422:15| :skolemid |93| :pattern (($HeapSuccGhost h@@15 k@@2)))))
(assert (forall ((s@@3 T@U)) (! (let ((T@@5 (MapType0TypeInv0 (type s@@3)))) (=> (= (type s@@3) (MapType0Type T@@5 boolType)) (<= 0 (|Set#Card| s@@3)))) :qid |DafnyPre.483:18| :skolemid |98| :pattern ((|Set#Card| s@@3)))))
(assert (forall ((T@@6 T@T)) (! (= (type (|Set#Empty| T@@6)) (MapType0Type T@@6 boolType)) :qid |funType:Set#Empty| :pattern ((|Set#Empty| T@@6)))))
(assert (forall ((o@@2 T@U)) (! (let ((T@@7 (type o@@2))) (not (U_2_bool (MapType0Select (|Set#Empty| T@@7) o@@2)))) :qid |DafnyPre.486:18| :skolemid |99| :pattern ((let ((T@@7 (type o@@2))) (MapType0Select (|Set#Empty| T@@7) o@@2))))))
(assert (forall ((s@@4 T@U)) (! (let ((T@@8 (MapType0TypeInv0 (type s@@4)))) (=> (= (type s@@4) (MapType0Type T@@8 boolType)) (and (and (=> (= (|Set#Card| s@@4) 0) (= s@@4 (|Set#Empty| T@@8))) (=> (= s@@4 (|Set#Empty| T@@8)) (= (|Set#Card| s@@4) 0))) (=> (not (= (|Set#Card| s@@4) 0)) (exists ((x@@15 T@U)) (! (and (= (type x@@15) T@@8) (U_2_bool (MapType0Select s@@4 x@@15))) :qid |DafnyPre.489:33| :skolemid |100| :no-pattern (type x@@15) :no-pattern (U_2_int x@@15) :no-pattern (U_2_bool x@@15))))))) :qid |DafnyPre.487:18| :skolemid |101| :pattern ((|Set#Card| s@@4)))))
(assert (forall ((arg0@@60 T@U)) (! (let ((T@@9 (type arg0@@60))) (= (type (|Set#Singleton| arg0@@60)) (MapType0Type T@@9 boolType))) :qid |funType:Set#Singleton| :pattern ((|Set#Singleton| arg0@@60)))))
(assert (forall ((r@@0 T@U)) (! (U_2_bool (MapType0Select (|Set#Singleton| r@@0) r@@0)) :qid |DafnyPre.495:18| :skolemid |102| :pattern ((|Set#Singleton| r@@0)))))
(assert (forall ((r@@1 T@U) (o@@3 T@U)) (! (let ((T@@10 (type r@@1))) (=> (= (type o@@3) T@@10) (and (=> (U_2_bool (MapType0Select (|Set#Singleton| r@@1) o@@3)) (= r@@1 o@@3)) (=> (= r@@1 o@@3) (U_2_bool (MapType0Select (|Set#Singleton| r@@1) o@@3)))))) :qid |DafnyPre.496:18| :skolemid |103| :pattern ((MapType0Select (|Set#Singleton| r@@1) o@@3)))))
(assert (forall ((r@@2 T@U)) (! (= (|Set#Card| (|Set#Singleton| r@@2)) 1) :qid |DafnyPre.497:18| :skolemid |104| :pattern ((|Set#Card| (|Set#Singleton| r@@2))))))
(assert (forall ((arg0@@61 T@U) (arg1@@19 T@U)) (! (let ((T@@11 (type arg1@@19))) (= (type (|Set#UnionOne| arg0@@61 arg1@@19)) (MapType0Type T@@11 boolType))) :qid |funType:Set#UnionOne| :pattern ((|Set#UnionOne| arg0@@61 arg1@@19)))))
(assert (forall ((a@@1 T@U) (x@@16 T@U) (o@@4 T@U)) (! (let ((T@@12 (type x@@16))) (=> (and (= (type a@@1) (MapType0Type T@@12 boolType)) (= (type o@@4) T@@12)) (and (=> (U_2_bool (MapType0Select (|Set#UnionOne| a@@1 x@@16) o@@4)) (or (= o@@4 x@@16) (U_2_bool (MapType0Select a@@1 o@@4)))) (=> (or (= o@@4 x@@16) (U_2_bool (MapType0Select a@@1 o@@4))) (U_2_bool (MapType0Select (|Set#UnionOne| a@@1 x@@16) o@@4)))))) :qid |DafnyPre.500:18| :skolemid |105| :pattern ((MapType0Select (|Set#UnionOne| a@@1 x@@16) o@@4)))))
(assert (forall ((a@@2 T@U) (x@@17 T@U)) (! (let ((T@@13 (type x@@17))) (=> (= (type a@@2) (MapType0Type T@@13 boolType)) (U_2_bool (MapType0Select (|Set#UnionOne| a@@2 x@@17) x@@17)))) :qid |DafnyPre.502:18| :skolemid |106| :pattern ((|Set#UnionOne| a@@2 x@@17)))))
(assert (forall ((a@@3 T@U) (x@@18 T@U) (y@@1 T@U)) (! (let ((T@@14 (type x@@18))) (=> (and (and (= (type a@@3) (MapType0Type T@@14 boolType)) (= (type y@@1) T@@14)) (U_2_bool (MapType0Select a@@3 y@@1))) (U_2_bool (MapType0Select (|Set#UnionOne| a@@3 x@@18) y@@1)))) :qid |DafnyPre.504:18| :skolemid |107| :pattern ((|Set#UnionOne| a@@3 x@@18) (MapType0Select a@@3 y@@1)))))
(assert (forall ((a@@4 T@U) (x@@19 T@U)) (! (let ((T@@15 (type x@@19))) (=> (and (= (type a@@4) (MapType0Type T@@15 boolType)) (U_2_bool (MapType0Select a@@4 x@@19))) (= (|Set#Card| (|Set#UnionOne| a@@4 x@@19)) (|Set#Card| a@@4)))) :qid |DafnyPre.506:18| :skolemid |108| :pattern ((|Set#Card| (|Set#UnionOne| a@@4 x@@19))))))
(assert (forall ((a@@5 T@U) (x@@20 T@U)) (! (let ((T@@16 (type x@@20))) (=> (and (= (type a@@5) (MapType0Type T@@16 boolType)) (not (U_2_bool (MapType0Select a@@5 x@@20)))) (= (|Set#Card| (|Set#UnionOne| a@@5 x@@20)) (+ (|Set#Card| a@@5) 1)))) :qid |DafnyPre.508:18| :skolemid |109| :pattern ((|Set#Card| (|Set#UnionOne| a@@5 x@@20))))))
(assert (forall ((arg0@@62 T@U) (arg1@@20 T@U)) (! (let ((T@@17 (MapType0TypeInv0 (type arg0@@62)))) (= (type (|Set#Union| arg0@@62 arg1@@20)) (MapType0Type T@@17 boolType))) :qid |funType:Set#Union| :pattern ((|Set#Union| arg0@@62 arg1@@20)))))
(assert (forall ((a@@6 T@U) (b@@1 T@U) (o@@5 T@U)) (! (let ((T@@18 (type o@@5))) (=> (and (= (type a@@6) (MapType0Type T@@18 boolType)) (= (type b@@1) (MapType0Type T@@18 boolType))) (and (=> (U_2_bool (MapType0Select (|Set#Union| a@@6 b@@1) o@@5)) (or (U_2_bool (MapType0Select a@@6 o@@5)) (U_2_bool (MapType0Select b@@1 o@@5)))) (=> (or (U_2_bool (MapType0Select a@@6 o@@5)) (U_2_bool (MapType0Select b@@1 o@@5))) (U_2_bool (MapType0Select (|Set#Union| a@@6 b@@1) o@@5)))))) :qid |DafnyPre.512:18| :skolemid |110| :pattern ((MapType0Select (|Set#Union| a@@6 b@@1) o@@5)))))
(assert (forall ((a@@7 T@U) (b@@2 T@U) (y@@2 T@U)) (! (let ((T@@19 (type y@@2))) (=> (and (and (= (type a@@7) (MapType0Type T@@19 boolType)) (= (type b@@2) (MapType0Type T@@19 boolType))) (U_2_bool (MapType0Select a@@7 y@@2))) (U_2_bool (MapType0Select (|Set#Union| a@@7 b@@2) y@@2)))) :qid |DafnyPre.514:18| :skolemid |111| :pattern ((|Set#Union| a@@7 b@@2) (MapType0Select a@@7 y@@2)))))
(assert (forall ((a@@8 T@U) (b@@3 T@U) (y@@3 T@U)) (! (let ((T@@20 (type y@@3))) (=> (and (and (= (type a@@8) (MapType0Type T@@20 boolType)) (= (type b@@3) (MapType0Type T@@20 boolType))) (U_2_bool (MapType0Select b@@3 y@@3))) (U_2_bool (MapType0Select (|Set#Union| a@@8 b@@3) y@@3)))) :qid |DafnyPre.516:18| :skolemid |112| :pattern ((|Set#Union| a@@8 b@@3) (MapType0Select b@@3 y@@3)))))
(assert (forall ((arg0@@63 T@U) (arg1@@21 T@U)) (! (let ((T@@21 (MapType0TypeInv0 (type arg0@@63)))) (= (type (|Set#Difference| arg0@@63 arg1@@21)) (MapType0Type T@@21 boolType))) :qid |funType:Set#Difference| :pattern ((|Set#Difference| arg0@@63 arg1@@21)))))
(assert (forall ((a@@9 T@U) (b@@4 T@U)) (! (let ((T@@22 (MapType0TypeInv0 (type a@@9)))) (=> (and (and (= (type a@@9) (MapType0Type T@@22 boolType)) (= (type b@@4) (MapType0Type T@@22 boolType))) (|Set#Disjoint| a@@9 b@@4)) (and (= (|Set#Difference| (|Set#Union| a@@9 b@@4) a@@9) b@@4) (= (|Set#Difference| (|Set#Union| a@@9 b@@4) b@@4) a@@9)))) :qid |DafnyPre.518:18| :skolemid |113| :pattern ((|Set#Union| a@@9 b@@4)))))
(assert (forall ((arg0@@64 T@U) (arg1@@22 T@U)) (! (let ((T@@23 (MapType0TypeInv0 (type arg0@@64)))) (= (type (|Set#Intersection| arg0@@64 arg1@@22)) (MapType0Type T@@23 boolType))) :qid |funType:Set#Intersection| :pattern ((|Set#Intersection| arg0@@64 arg1@@22)))))
(assert (forall ((a@@10 T@U) (b@@5 T@U) (o@@6 T@U)) (! (let ((T@@24 (type o@@6))) (=> (and (= (type a@@10) (MapType0Type T@@24 boolType)) (= (type b@@5) (MapType0Type T@@24 boolType))) (and (=> (U_2_bool (MapType0Select (|Set#Intersection| a@@10 b@@5) o@@6)) (and (U_2_bool (MapType0Select a@@10 o@@6)) (U_2_bool (MapType0Select b@@5 o@@6)))) (=> (and (U_2_bool (MapType0Select a@@10 o@@6)) (U_2_bool (MapType0Select b@@5 o@@6))) (U_2_bool (MapType0Select (|Set#Intersection| a@@10 b@@5) o@@6)))))) :qid |DafnyPre.528:18| :skolemid |114| :pattern ((MapType0Select (|Set#Intersection| a@@10 b@@5) o@@6)))))
(assert (forall ((a@@11 T@U) (b@@6 T@U)) (! (let ((T@@25 (MapType0TypeInv0 (type a@@11)))) (=> (and (= (type a@@11) (MapType0Type T@@25 boolType)) (= (type b@@6) (MapType0Type T@@25 boolType))) (= (|Set#Union| (|Set#Union| a@@11 b@@6) b@@6) (|Set#Union| a@@11 b@@6)))) :qid |DafnyPre.531:18| :skolemid |115| :pattern ((|Set#Union| (|Set#Union| a@@11 b@@6) b@@6)))))
(assert (forall ((a@@12 T@U) (b@@7 T@U)) (! (let ((T@@26 (MapType0TypeInv0 (type a@@12)))) (=> (and (= (type a@@12) (MapType0Type T@@26 boolType)) (= (type b@@7) (MapType0Type T@@26 boolType))) (= (|Set#Union| a@@12 (|Set#Union| a@@12 b@@7)) (|Set#Union| a@@12 b@@7)))) :qid |DafnyPre.533:18| :skolemid |116| :pattern ((|Set#Union| a@@12 (|Set#Union| a@@12 b@@7))))))
(assert (forall ((a@@13 T@U) (b@@8 T@U)) (! (let ((T@@27 (MapType0TypeInv0 (type a@@13)))) (=> (and (= (type a@@13) (MapType0Type T@@27 boolType)) (= (type b@@8) (MapType0Type T@@27 boolType))) (= (|Set#Intersection| (|Set#Intersection| a@@13 b@@8) b@@8) (|Set#Intersection| a@@13 b@@8)))) :qid |DafnyPre.535:18| :skolemid |117| :pattern ((|Set#Intersection| (|Set#Intersection| a@@13 b@@8) b@@8)))))
(assert (forall ((a@@14 T@U) (b@@9 T@U)) (! (let ((T@@28 (MapType0TypeInv0 (type a@@14)))) (=> (and (= (type a@@14) (MapType0Type T@@28 boolType)) (= (type b@@9) (MapType0Type T@@28 boolType))) (= (|Set#Intersection| a@@14 (|Set#Intersection| a@@14 b@@9)) (|Set#Intersection| a@@14 b@@9)))) :qid |DafnyPre.537:18| :skolemid |118| :pattern ((|Set#Intersection| a@@14 (|Set#Intersection| a@@14 b@@9))))))
(assert (forall ((a@@15 T@U) (b@@10 T@U)) (! (let ((T@@29 (MapType0TypeInv0 (type a@@15)))) (=> (and (= (type a@@15) (MapType0Type T@@29 boolType)) (= (type b@@10) (MapType0Type T@@29 boolType))) (= (+ (|Set#Card| (|Set#Union| a@@15 b@@10)) (|Set#Card| (|Set#Intersection| a@@15 b@@10))) (+ (|Set#Card| a@@15) (|Set#Card| b@@10))))) :qid |DafnyPre.539:18| :skolemid |119| :pattern ((|Set#Card| (|Set#Union| a@@15 b@@10))) :pattern ((|Set#Card| (|Set#Intersection| a@@15 b@@10))))))
(assert (forall ((a@@16 T@U) (b@@11 T@U) (o@@7 T@U)) (! (let ((T@@30 (type o@@7))) (=> (and (= (type a@@16) (MapType0Type T@@30 boolType)) (= (type b@@11) (MapType0Type T@@30 boolType))) (and (=> (U_2_bool (MapType0Select (|Set#Difference| a@@16 b@@11) o@@7)) (and (U_2_bool (MapType0Select a@@16 o@@7)) (not (U_2_bool (MapType0Select b@@11 o@@7))))) (=> (and (U_2_bool (MapType0Select a@@16 o@@7)) (not (U_2_bool (MapType0Select b@@11 o@@7)))) (U_2_bool (MapType0Select (|Set#Difference| a@@16 b@@11) o@@7)))))) :qid |DafnyPre.543:18| :skolemid |120| :pattern ((MapType0Select (|Set#Difference| a@@16 b@@11) o@@7)))))
(assert (forall ((a@@17 T@U) (b@@12 T@U) (y@@4 T@U)) (! (let ((T@@31 (type y@@4))) (=> (and (and (= (type a@@17) (MapType0Type T@@31 boolType)) (= (type b@@12) (MapType0Type T@@31 boolType))) (U_2_bool (MapType0Select b@@12 y@@4))) (not (U_2_bool (MapType0Select (|Set#Difference| a@@17 b@@12) y@@4))))) :qid |DafnyPre.545:18| :skolemid |121| :pattern ((|Set#Difference| a@@17 b@@12) (MapType0Select b@@12 y@@4)))))
(assert (forall ((a@@18 T@U) (b@@13 T@U)) (! (let ((T@@32 (MapType0TypeInv0 (type a@@18)))) (=> (and (= (type a@@18) (MapType0Type T@@32 boolType)) (= (type b@@13) (MapType0Type T@@32 boolType))) (and (= (+ (+ (|Set#Card| (|Set#Difference| a@@18 b@@13)) (|Set#Card| (|Set#Difference| b@@13 a@@18))) (|Set#Card| (|Set#Intersection| a@@18 b@@13))) (|Set#Card| (|Set#Union| a@@18 b@@13))) (= (|Set#Card| (|Set#Difference| a@@18 b@@13)) (- (|Set#Card| a@@18) (|Set#Card| (|Set#Intersection| a@@18 b@@13))))))) :qid |DafnyPre.547:18| :skolemid |122| :pattern ((|Set#Card| (|Set#Difference| a@@18 b@@13))))))
(assert (forall ((a@@19 T@U) (b@@14 T@U)) (! (let ((T@@33 (MapType0TypeInv0 (type a@@19)))) (=> (and (= (type a@@19) (MapType0Type T@@33 boolType)) (= (type b@@14) (MapType0Type T@@33 boolType))) (and (=> (|Set#Subset| a@@19 b@@14) (forall ((o@@8 T@U)) (! (=> (and (= (type o@@8) T@@33) (U_2_bool (MapType0Select a@@19 o@@8))) (U_2_bool (MapType0Select b@@14 o@@8))) :qid |DafnyPre.556:32| :skolemid |123| :pattern ((MapType0Select a@@19 o@@8)) :pattern ((MapType0Select b@@14 o@@8))))) (=> (forall ((o@@9 T@U)) (! (=> (and (= (type o@@9) T@@33) (U_2_bool (MapType0Select a@@19 o@@9))) (U_2_bool (MapType0Select b@@14 o@@9))) :qid |DafnyPre.556:32| :skolemid |123| :pattern ((MapType0Select a@@19 o@@9)) :pattern ((MapType0Select b@@14 o@@9)))) (|Set#Subset| a@@19 b@@14))))) :qid |DafnyPre.555:17| :skolemid |124| :pattern ((|Set#Subset| a@@19 b@@14)))))
(assert (forall ((a@@20 T@U) (b@@15 T@U)) (! (let ((T@@34 (MapType0TypeInv0 (type a@@20)))) (=> (and (= (type a@@20) (MapType0Type T@@34 boolType)) (= (type b@@15) (MapType0Type T@@34 boolType))) (and (=> (|Set#Equal| a@@20 b@@15) (forall ((o@@10 T@U)) (! (=> (= (type o@@10) T@@34) (and (=> (U_2_bool (MapType0Select a@@20 o@@10)) (U_2_bool (MapType0Select b@@15 o@@10))) (=> (U_2_bool (MapType0Select b@@15 o@@10)) (U_2_bool (MapType0Select a@@20 o@@10))))) :qid |DafnyPre.564:31| :skolemid |125| :pattern ((MapType0Select a@@20 o@@10)) :pattern ((MapType0Select b@@15 o@@10))))) (=> (forall ((o@@11 T@U)) (! (=> (= (type o@@11) T@@34) (and (=> (U_2_bool (MapType0Select a@@20 o@@11)) (U_2_bool (MapType0Select b@@15 o@@11))) (=> (U_2_bool (MapType0Select b@@15 o@@11)) (U_2_bool (MapType0Select a@@20 o@@11))))) :qid |DafnyPre.564:31| :skolemid |125| :pattern ((MapType0Select a@@20 o@@11)) :pattern ((MapType0Select b@@15 o@@11)))) (|Set#Equal| a@@20 b@@15))))) :qid |DafnyPre.563:17| :skolemid |126| :pattern ((|Set#Equal| a@@20 b@@15)))))
(assert (forall ((a@@21 T@U) (b@@16 T@U)) (! (let ((T@@35 (MapType0TypeInv0 (type a@@21)))) (=> (and (and (= (type a@@21) (MapType0Type T@@35 boolType)) (= (type b@@16) (MapType0Type T@@35 boolType))) (|Set#Equal| a@@21 b@@16)) (= a@@21 b@@16))) :qid |DafnyPre.565:17| :skolemid |127| :pattern ((|Set#Equal| a@@21 b@@16)))))
(assert (forall ((a@@22 T@U) (b@@17 T@U)) (! (let ((T@@36 (MapType0TypeInv0 (type a@@22)))) (=> (and (= (type a@@22) (MapType0Type T@@36 boolType)) (= (type b@@17) (MapType0Type T@@36 boolType))) (and (=> (|Set#Disjoint| a@@22 b@@17) (forall ((o@@12 T@U)) (! (=> (= (type o@@12) T@@36) (or (not (U_2_bool (MapType0Select a@@22 o@@12))) (not (U_2_bool (MapType0Select b@@17 o@@12))))) :qid |DafnyPre.570:34| :skolemid |128| :pattern ((MapType0Select a@@22 o@@12)) :pattern ((MapType0Select b@@17 o@@12))))) (=> (forall ((o@@13 T@U)) (! (=> (= (type o@@13) T@@36) (or (not (U_2_bool (MapType0Select a@@22 o@@13))) (not (U_2_bool (MapType0Select b@@17 o@@13))))) :qid |DafnyPre.570:34| :skolemid |128| :pattern ((MapType0Select a@@22 o@@13)) :pattern ((MapType0Select b@@17 o@@13)))) (|Set#Disjoint| a@@22 b@@17))))) :qid |DafnyPre.569:18| :skolemid |129| :pattern ((|Set#Disjoint| a@@22 b@@17)))))
(assert (forall ((T@@37 T@T)) (! (= (type (|ISet#Empty| T@@37)) (MapType0Type T@@37 boolType)) :qid |funType:ISet#Empty| :pattern ((|ISet#Empty| T@@37)))))
(assert (forall ((o@@14 T@U)) (! (let ((T@@38 (type o@@14))) (not (U_2_bool (MapType0Select (|ISet#Empty| T@@38) o@@14)))) :qid |DafnyPre.579:18| :skolemid |130| :pattern ((let ((T@@38 (type o@@14))) (MapType0Select (|ISet#Empty| T@@38) o@@14))))))
(assert (forall ((arg0@@65 T@U) (arg1@@23 T@U)) (! (let ((T@@39 (type arg1@@23))) (= (type (|ISet#UnionOne| arg0@@65 arg1@@23)) (MapType0Type T@@39 boolType))) :qid |funType:ISet#UnionOne| :pattern ((|ISet#UnionOne| arg0@@65 arg1@@23)))))
(assert (forall ((a@@23 T@U) (x@@21 T@U) (o@@15 T@U)) (! (let ((T@@40 (type x@@21))) (=> (and (= (type a@@23) (MapType0Type T@@40 boolType)) (= (type o@@15) T@@40)) (and (=> (U_2_bool (MapType0Select (|ISet#UnionOne| a@@23 x@@21) o@@15)) (or (= o@@15 x@@21) (U_2_bool (MapType0Select a@@23 o@@15)))) (=> (or (= o@@15 x@@21) (U_2_bool (MapType0Select a@@23 o@@15))) (U_2_bool (MapType0Select (|ISet#UnionOne| a@@23 x@@21) o@@15)))))) :qid |DafnyPre.586:18| :skolemid |131| :pattern ((MapType0Select (|ISet#UnionOne| a@@23 x@@21) o@@15)))))
(assert (forall ((a@@24 T@U) (x@@22 T@U)) (! (let ((T@@41 (type x@@22))) (=> (= (type a@@24) (MapType0Type T@@41 boolType)) (U_2_bool (MapType0Select (|ISet#UnionOne| a@@24 x@@22) x@@22)))) :qid |DafnyPre.588:18| :skolemid |132| :pattern ((|ISet#UnionOne| a@@24 x@@22)))))
(assert (forall ((a@@25 T@U) (x@@23 T@U) (y@@5 T@U)) (! (let ((T@@42 (type x@@23))) (=> (and (and (= (type a@@25) (MapType0Type T@@42 boolType)) (= (type y@@5) T@@42)) (U_2_bool (MapType0Select a@@25 y@@5))) (U_2_bool (MapType0Select (|ISet#UnionOne| a@@25 x@@23) y@@5)))) :qid |DafnyPre.590:18| :skolemid |133| :pattern ((|ISet#UnionOne| a@@25 x@@23) (MapType0Select a@@25 y@@5)))))
(assert (forall ((arg0@@66 T@U) (arg1@@24 T@U)) (! (let ((T@@43 (MapType0TypeInv0 (type arg0@@66)))) (= (type (|ISet#Union| arg0@@66 arg1@@24)) (MapType0Type T@@43 boolType))) :qid |funType:ISet#Union| :pattern ((|ISet#Union| arg0@@66 arg1@@24)))))
(assert (forall ((a@@26 T@U) (b@@18 T@U) (o@@16 T@U)) (! (let ((T@@44 (type o@@16))) (=> (and (= (type a@@26) (MapType0Type T@@44 boolType)) (= (type b@@18) (MapType0Type T@@44 boolType))) (and (=> (U_2_bool (MapType0Select (|ISet#Union| a@@26 b@@18) o@@16)) (or (U_2_bool (MapType0Select a@@26 o@@16)) (U_2_bool (MapType0Select b@@18 o@@16)))) (=> (or (U_2_bool (MapType0Select a@@26 o@@16)) (U_2_bool (MapType0Select b@@18 o@@16))) (U_2_bool (MapType0Select (|ISet#Union| a@@26 b@@18) o@@16)))))) :qid |DafnyPre.594:18| :skolemid |134| :pattern ((MapType0Select (|ISet#Union| a@@26 b@@18) o@@16)))))
(assert (forall ((a@@27 T@U) (b@@19 T@U) (y@@6 T@U)) (! (let ((T@@45 (type y@@6))) (=> (and (and (= (type a@@27) (MapType0Type T@@45 boolType)) (= (type b@@19) (MapType0Type T@@45 boolType))) (U_2_bool (MapType0Select a@@27 y@@6))) (U_2_bool (MapType0Select (|ISet#Union| a@@27 b@@19) y@@6)))) :qid |DafnyPre.596:18| :skolemid |135| :pattern ((|ISet#Union| a@@27 b@@19) (MapType0Select a@@27 y@@6)))))
(assert (forall ((a@@28 T@U) (b@@20 T@U) (y@@7 T@U)) (! (let ((T@@46 (type y@@7))) (=> (and (and (= (type a@@28) (MapType0Type T@@46 boolType)) (= (type b@@20) (MapType0Type T@@46 boolType))) (U_2_bool (MapType0Select b@@20 y@@7))) (U_2_bool (MapType0Select (|ISet#Union| a@@28 b@@20) y@@7)))) :qid |DafnyPre.598:18| :skolemid |136| :pattern ((|ISet#Union| a@@28 b@@20) (MapType0Select b@@20 y@@7)))))
(assert (forall ((arg0@@67 T@U) (arg1@@25 T@U)) (! (let ((T@@47 (MapType0TypeInv0 (type arg0@@67)))) (= (type (|ISet#Difference| arg0@@67 arg1@@25)) (MapType0Type T@@47 boolType))) :qid |funType:ISet#Difference| :pattern ((|ISet#Difference| arg0@@67 arg1@@25)))))
(assert (forall ((a@@29 T@U) (b@@21 T@U)) (! (let ((T@@48 (MapType0TypeInv0 (type a@@29)))) (=> (and (and (= (type a@@29) (MapType0Type T@@48 boolType)) (= (type b@@21) (MapType0Type T@@48 boolType))) (|ISet#Disjoint| a@@29 b@@21)) (and (= (|ISet#Difference| (|ISet#Union| a@@29 b@@21) a@@29) b@@21) (= (|ISet#Difference| (|ISet#Union| a@@29 b@@21) b@@21) a@@29)))) :qid |DafnyPre.600:18| :skolemid |137| :pattern ((|ISet#Union| a@@29 b@@21)))))
(assert (forall ((arg0@@68 T@U) (arg1@@26 T@U)) (! (let ((T@@49 (MapType0TypeInv0 (type arg0@@68)))) (= (type (|ISet#Intersection| arg0@@68 arg1@@26)) (MapType0Type T@@49 boolType))) :qid |funType:ISet#Intersection| :pattern ((|ISet#Intersection| arg0@@68 arg1@@26)))))
(assert (forall ((a@@30 T@U) (b@@22 T@U) (o@@17 T@U)) (! (let ((T@@50 (type o@@17))) (=> (and (= (type a@@30) (MapType0Type T@@50 boolType)) (= (type b@@22) (MapType0Type T@@50 boolType))) (and (=> (U_2_bool (MapType0Select (|ISet#Intersection| a@@30 b@@22) o@@17)) (and (U_2_bool (MapType0Select a@@30 o@@17)) (U_2_bool (MapType0Select b@@22 o@@17)))) (=> (and (U_2_bool (MapType0Select a@@30 o@@17)) (U_2_bool (MapType0Select b@@22 o@@17))) (U_2_bool (MapType0Select (|ISet#Intersection| a@@30 b@@22) o@@17)))))) :qid |DafnyPre.610:18| :skolemid |138| :pattern ((MapType0Select (|ISet#Intersection| a@@30 b@@22) o@@17)))))
(assert (forall ((a@@31 T@U) (b@@23 T@U)) (! (let ((T@@51 (MapType0TypeInv0 (type a@@31)))) (=> (and (= (type a@@31) (MapType0Type T@@51 boolType)) (= (type b@@23) (MapType0Type T@@51 boolType))) (= (|ISet#Union| (|ISet#Union| a@@31 b@@23) b@@23) (|ISet#Union| a@@31 b@@23)))) :qid |DafnyPre.613:18| :skolemid |139| :pattern ((|ISet#Union| (|ISet#Union| a@@31 b@@23) b@@23)))))
(assert (forall ((a@@32 T@U) (b@@24 T@U)) (! (let ((T@@52 (MapType0TypeInv0 (type a@@32)))) (=> (and (= (type a@@32) (MapType0Type T@@52 boolType)) (= (type b@@24) (MapType0Type T@@52 boolType))) (= (|ISet#Union| a@@32 (|ISet#Union| a@@32 b@@24)) (|ISet#Union| a@@32 b@@24)))) :qid |DafnyPre.615:18| :skolemid |140| :pattern ((|ISet#Union| a@@32 (|ISet#Union| a@@32 b@@24))))))
(assert (forall ((a@@33 T@U) (b@@25 T@U)) (! (let ((T@@53 (MapType0TypeInv0 (type a@@33)))) (=> (and (= (type a@@33) (MapType0Type T@@53 boolType)) (= (type b@@25) (MapType0Type T@@53 boolType))) (= (|ISet#Intersection| (|ISet#Intersection| a@@33 b@@25) b@@25) (|ISet#Intersection| a@@33 b@@25)))) :qid |DafnyPre.617:18| :skolemid |141| :pattern ((|ISet#Intersection| (|ISet#Intersection| a@@33 b@@25) b@@25)))))
(assert (forall ((a@@34 T@U) (b@@26 T@U)) (! (let ((T@@54 (MapType0TypeInv0 (type a@@34)))) (=> (and (= (type a@@34) (MapType0Type T@@54 boolType)) (= (type b@@26) (MapType0Type T@@54 boolType))) (= (|ISet#Intersection| a@@34 (|ISet#Intersection| a@@34 b@@26)) (|ISet#Intersection| a@@34 b@@26)))) :qid |DafnyPre.619:18| :skolemid |142| :pattern ((|ISet#Intersection| a@@34 (|ISet#Intersection| a@@34 b@@26))))))
(assert (forall ((a@@35 T@U) (b@@27 T@U) (o@@18 T@U)) (! (let ((T@@55 (type o@@18))) (=> (and (= (type a@@35) (MapType0Type T@@55 boolType)) (= (type b@@27) (MapType0Type T@@55 boolType))) (and (=> (U_2_bool (MapType0Select (|ISet#Difference| a@@35 b@@27) o@@18)) (and (U_2_bool (MapType0Select a@@35 o@@18)) (not (U_2_bool (MapType0Select b@@27 o@@18))))) (=> (and (U_2_bool (MapType0Select a@@35 o@@18)) (not (U_2_bool (MapType0Select b@@27 o@@18)))) (U_2_bool (MapType0Select (|ISet#Difference| a@@35 b@@27) o@@18)))))) :qid |DafnyPre.624:18| :skolemid |143| :pattern ((MapType0Select (|ISet#Difference| a@@35 b@@27) o@@18)))))
(assert (forall ((a@@36 T@U) (b@@28 T@U) (y@@8 T@U)) (! (let ((T@@56 (type y@@8))) (=> (and (and (= (type a@@36) (MapType0Type T@@56 boolType)) (= (type b@@28) (MapType0Type T@@56 boolType))) (U_2_bool (MapType0Select b@@28 y@@8))) (not (U_2_bool (MapType0Select (|ISet#Difference| a@@36 b@@28) y@@8))))) :qid |DafnyPre.626:18| :skolemid |144| :pattern ((|ISet#Difference| a@@36 b@@28) (MapType0Select b@@28 y@@8)))))
(assert (forall ((a@@37 T@U) (b@@29 T@U)) (! (let ((T@@57 (MapType0TypeInv0 (type a@@37)))) (=> (and (= (type a@@37) (MapType0Type T@@57 boolType)) (= (type b@@29) (MapType0Type T@@57 boolType))) (and (=> (|ISet#Subset| a@@37 b@@29) (forall ((o@@19 T@U)) (! (=> (and (= (type o@@19) T@@57) (U_2_bool (MapType0Select a@@37 o@@19))) (U_2_bool (MapType0Select b@@29 o@@19))) :qid |DafnyPre.631:33| :skolemid |145| :pattern ((MapType0Select a@@37 o@@19)) :pattern ((MapType0Select b@@29 o@@19))))) (=> (forall ((o@@20 T@U)) (! (=> (and (= (type o@@20) T@@57) (U_2_bool (MapType0Select a@@37 o@@20))) (U_2_bool (MapType0Select b@@29 o@@20))) :qid |DafnyPre.631:33| :skolemid |145| :pattern ((MapType0Select a@@37 o@@20)) :pattern ((MapType0Select b@@29 o@@20)))) (|ISet#Subset| a@@37 b@@29))))) :qid |DafnyPre.630:17| :skolemid |146| :pattern ((|ISet#Subset| a@@37 b@@29)))))
(assert (forall ((a@@38 T@U) (b@@30 T@U)) (! (let ((T@@58 (MapType0TypeInv0 (type a@@38)))) (=> (and (= (type a@@38) (MapType0Type T@@58 boolType)) (= (type b@@30) (MapType0Type T@@58 boolType))) (and (=> (|ISet#Equal| a@@38 b@@30) (forall ((o@@21 T@U)) (! (=> (= (type o@@21) T@@58) (and (=> (U_2_bool (MapType0Select a@@38 o@@21)) (U_2_bool (MapType0Select b@@30 o@@21))) (=> (U_2_bool (MapType0Select b@@30 o@@21)) (U_2_bool (MapType0Select a@@38 o@@21))))) :qid |DafnyPre.639:32| :skolemid |147| :pattern ((MapType0Select a@@38 o@@21)) :pattern ((MapType0Select b@@30 o@@21))))) (=> (forall ((o@@22 T@U)) (! (=> (= (type o@@22) T@@58) (and (=> (U_2_bool (MapType0Select a@@38 o@@22)) (U_2_bool (MapType0Select b@@30 o@@22))) (=> (U_2_bool (MapType0Select b@@30 o@@22)) (U_2_bool (MapType0Select a@@38 o@@22))))) :qid |DafnyPre.639:32| :skolemid |147| :pattern ((MapType0Select a@@38 o@@22)) :pattern ((MapType0Select b@@30 o@@22)))) (|ISet#Equal| a@@38 b@@30))))) :qid |DafnyPre.638:17| :skolemid |148| :pattern ((|ISet#Equal| a@@38 b@@30)))))
(assert (forall ((a@@39 T@U) (b@@31 T@U)) (! (let ((T@@59 (MapType0TypeInv0 (type a@@39)))) (=> (and (and (= (type a@@39) (MapType0Type T@@59 boolType)) (= (type b@@31) (MapType0Type T@@59 boolType))) (|ISet#Equal| a@@39 b@@31)) (= a@@39 b@@31))) :qid |DafnyPre.640:17| :skolemid |149| :pattern ((|ISet#Equal| a@@39 b@@31)))))
(assert (forall ((a@@40 T@U) (b@@32 T@U)) (! (let ((T@@60 (MapType0TypeInv0 (type a@@40)))) (=> (and (= (type a@@40) (MapType0Type T@@60 boolType)) (= (type b@@32) (MapType0Type T@@60 boolType))) (and (=> (|ISet#Disjoint| a@@40 b@@32) (forall ((o@@23 T@U)) (! (=> (= (type o@@23) T@@60) (or (not (U_2_bool (MapType0Select a@@40 o@@23))) (not (U_2_bool (MapType0Select b@@32 o@@23))))) :qid |DafnyPre.645:35| :skolemid |150| :pattern ((MapType0Select a@@40 o@@23)) :pattern ((MapType0Select b@@32 o@@23))))) (=> (forall ((o@@24 T@U)) (! (=> (= (type o@@24) T@@60) (or (not (U_2_bool (MapType0Select a@@40 o@@24))) (not (U_2_bool (MapType0Select b@@32 o@@24))))) :qid |DafnyPre.645:35| :skolemid |150| :pattern ((MapType0Select a@@40 o@@24)) :pattern ((MapType0Select b@@32 o@@24)))) (|ISet#Disjoint| a@@40 b@@32))))) :qid |DafnyPre.644:18| :skolemid |151| :pattern ((|ISet#Disjoint| a@@40 b@@32)))))
(assert (forall ((a@@41 Int) (b@@33 Int)) (! (and (=> (<= a@@41 b@@33) (= (|Math#min| a@@41 b@@33) a@@41)) (=> (= (|Math#min| a@@41 b@@33) a@@41) (<= a@@41 b@@33))) :qid |DafnyPre.652:15| :skolemid |152| :pattern ((|Math#min| a@@41 b@@33)))))
(assert (forall ((a@@42 Int) (b@@34 Int)) (! (and (=> (<= b@@34 a@@42) (= (|Math#min| a@@42 b@@34) b@@34)) (=> (= (|Math#min| a@@42 b@@34) b@@34) (<= b@@34 a@@42))) :qid |DafnyPre.653:15| :skolemid |153| :pattern ((|Math#min| a@@42 b@@34)))))
(assert (forall ((a@@43 Int) (b@@35 Int)) (! (or (= (|Math#min| a@@43 b@@35) a@@43) (= (|Math#min| a@@43 b@@35) b@@35)) :qid |DafnyPre.654:15| :skolemid |154| :pattern ((|Math#min| a@@43 b@@35)))))
(assert (forall ((a@@44 Int)) (! (=> (<= 0 a@@44) (= (|Math#clip| a@@44) a@@44)) :qid |DafnyPre.657:15| :skolemid |155| :pattern ((|Math#clip| a@@44)))))
(assert (forall ((a@@45 Int)) (! (=> (< a@@45 0) (= (|Math#clip| a@@45) 0)) :qid |DafnyPre.658:15| :skolemid |156| :pattern ((|Math#clip| a@@45)))))
(assert (forall ((ms T@U)) (! (let ((T@@61 (MapType0TypeInv0 (type ms)))) (=> (= (type ms) (MapType0Type T@@61 intType)) (and (=> ($IsGoodMultiSet ms) (forall ((bx@@32 T@U)) (! (=> (= (type bx@@32) T@@61) (and (<= 0 (U_2_int (MapType0Select ms bx@@32))) (<= (U_2_int (MapType0Select ms bx@@32)) (|MultiSet#Card| ms)))) :qid |DafnyPre.666:11| :skolemid |157| :pattern ((MapType0Select ms bx@@32))))) (=> (forall ((bx@@33 T@U)) (! (=> (= (type bx@@33) T@@61) (and (<= 0 (U_2_int (MapType0Select ms bx@@33))) (<= (U_2_int (MapType0Select ms bx@@33)) (|MultiSet#Card| ms)))) :qid |DafnyPre.666:11| :skolemid |157| :pattern ((MapType0Select ms bx@@33)))) ($IsGoodMultiSet ms))))) :qid |DafnyPre.664:18| :skolemid |158| :pattern (($IsGoodMultiSet ms)))))
(assert (forall ((s@@5 T@U)) (! (let ((T@@62 (MapType0TypeInv0 (type s@@5)))) (=> (= (type s@@5) (MapType0Type T@@62 intType)) (<= 0 (|MultiSet#Card| s@@5)))) :qid |DafnyPre.669:18| :skolemid |159| :pattern ((|MultiSet#Card| s@@5)))))
(assert (forall ((s@@6 T@U) (x@@24 T@U) (n@@0 T@U)) (! (let ((T@@63 (type x@@24))) (=> (and (and (= (type s@@6) (MapType0Type T@@63 intType)) (= (type n@@0) intType)) (<= 0 (U_2_int n@@0))) (= (|MultiSet#Card| (MapType0Store s@@6 x@@24 n@@0)) (+ (- (|MultiSet#Card| s@@6) (U_2_int (MapType0Select s@@6 x@@24))) (U_2_int n@@0))))) :qid |DafnyPre.670:18| :skolemid |160| :pattern ((|MultiSet#Card| (MapType0Store s@@6 x@@24 n@@0))))))
(assert (forall ((T@@64 T@T)) (! (= (type (|MultiSet#Empty| T@@64)) (MapType0Type T@@64 intType)) :qid |funType:MultiSet#Empty| :pattern ((|MultiSet#Empty| T@@64)))))
(assert (forall ((o@@25 T@U)) (! (let ((T@@65 (type o@@25))) (= (U_2_int (MapType0Select (|MultiSet#Empty| T@@65) o@@25)) 0)) :qid |DafnyPre.674:18| :skolemid |161| :pattern ((let ((T@@65 (type o@@25))) (MapType0Select (|MultiSet#Empty| T@@65) o@@25))))))
(assert (forall ((s@@7 T@U)) (! (let ((T@@66 (MapType0TypeInv0 (type s@@7)))) (=> (= (type s@@7) (MapType0Type T@@66 intType)) (and (and (=> (= (|MultiSet#Card| s@@7) 0) (= s@@7 (|MultiSet#Empty| T@@66))) (=> (= s@@7 (|MultiSet#Empty| T@@66)) (= (|MultiSet#Card| s@@7) 0))) (=> (not (= (|MultiSet#Card| s@@7) 0)) (exists ((x@@25 T@U)) (! (and (= (type x@@25) T@@66) (< 0 (U_2_int (MapType0Select s@@7 x@@25)))) :qid |DafnyPre.677:38| :skolemid |162| :no-pattern (type x@@25) :no-pattern (U_2_int x@@25) :no-pattern (U_2_bool x@@25))))))) :qid |DafnyPre.675:18| :skolemid |163| :pattern ((|MultiSet#Card| s@@7)))))
(assert (forall ((arg0@@69 T@U)) (! (let ((T@@67 (type arg0@@69))) (= (type (|MultiSet#Singleton| arg0@@69)) (MapType0Type T@@67 intType))) :qid |funType:MultiSet#Singleton| :pattern ((|MultiSet#Singleton| arg0@@69)))))
(assert (forall ((r@@3 T@U) (o@@26 T@U)) (! (let ((T@@68 (type r@@3))) (=> (= (type o@@26) T@@68) (and (and (=> (= (U_2_int (MapType0Select (|MultiSet#Singleton| r@@3) o@@26)) 1) (= r@@3 o@@26)) (=> (= r@@3 o@@26) (= (U_2_int (MapType0Select (|MultiSet#Singleton| r@@3) o@@26)) 1))) (and (=> (= (U_2_int (MapType0Select (|MultiSet#Singleton| r@@3) o@@26)) 0) (not (= r@@3 o@@26))) (=> (not (= r@@3 o@@26)) (= (U_2_int (MapType0Select (|MultiSet#Singleton| r@@3) o@@26)) 0)))))) :qid |DafnyPre.680:18| :skolemid |164| :pattern ((MapType0Select (|MultiSet#Singleton| r@@3) o@@26)))))
(assert (forall ((arg0@@70 T@U) (arg1@@27 T@U)) (! (let ((T@@69 (type arg1@@27))) (= (type (|MultiSet#UnionOne| arg0@@70 arg1@@27)) (MapType0Type T@@69 intType))) :qid |funType:MultiSet#UnionOne| :pattern ((|MultiSet#UnionOne| arg0@@70 arg1@@27)))))
(assert (forall ((r@@4 T@U)) (! (let ((T@@70 (type r@@4))) (= (|MultiSet#Singleton| r@@4) (|MultiSet#UnionOne| (|MultiSet#Empty| T@@70) r@@4))) :qid |DafnyPre.682:18| :skolemid |165| :pattern ((|MultiSet#Singleton| r@@4)))))
(assert (forall ((a@@46 T@U) (x@@26 T@U) (o@@27 T@U)) (! (let ((T@@71 (type x@@26))) (=> (and (= (type a@@46) (MapType0Type T@@71 intType)) (= (type o@@27) T@@71)) (and (=> (< 0 (U_2_int (MapType0Select (|MultiSet#UnionOne| a@@46 x@@26) o@@27))) (or (= o@@27 x@@26) (< 0 (U_2_int (MapType0Select a@@46 o@@27))))) (=> (or (= o@@27 x@@26) (< 0 (U_2_int (MapType0Select a@@46 o@@27)))) (< 0 (U_2_int (MapType0Select (|MultiSet#UnionOne| a@@46 x@@26) o@@27))))))) :qid |DafnyPre.686:18| :skolemid |166| :pattern ((MapType0Select (|MultiSet#UnionOne| a@@46 x@@26) o@@27)))))
(assert (forall ((a@@47 T@U) (x@@27 T@U)) (! (let ((T@@72 (type x@@27))) (=> (= (type a@@47) (MapType0Type T@@72 intType)) (= (U_2_int (MapType0Select (|MultiSet#UnionOne| a@@47 x@@27) x@@27)) (+ (U_2_int (MapType0Select a@@47 x@@27)) 1)))) :qid |DafnyPre.689:18| :skolemid |167| :pattern ((|MultiSet#UnionOne| a@@47 x@@27)))))
(assert (forall ((a@@48 T@U) (x@@28 T@U) (y@@9 T@U)) (! (let ((T@@73 (type x@@28))) (=> (and (and (= (type a@@48) (MapType0Type T@@73 intType)) (= (type y@@9) T@@73)) (< 0 (U_2_int (MapType0Select a@@48 y@@9)))) (< 0 (U_2_int (MapType0Select (|MultiSet#UnionOne| a@@48 x@@28) y@@9))))) :qid |DafnyPre.692:18| :skolemid |168| :pattern ((|MultiSet#UnionOne| a@@48 x@@28) (MapType0Select a@@48 y@@9)))))
(assert (forall ((a@@49 T@U) (x@@29 T@U) (y@@10 T@U)) (! (let ((T@@74 (type x@@29))) (=> (and (and (= (type a@@49) (MapType0Type T@@74 intType)) (= (type y@@10) T@@74)) (not (= x@@29 y@@10))) (= (U_2_int (MapType0Select a@@49 y@@10)) (U_2_int (MapType0Select (|MultiSet#UnionOne| a@@49 x@@29) y@@10))))) :qid |DafnyPre.695:18| :skolemid |169| :pattern ((|MultiSet#UnionOne| a@@49 x@@29) (MapType0Select a@@49 y@@10)))))
(assert (forall ((a@@50 T@U) (x@@30 T@U)) (! (let ((T@@75 (type x@@30))) (=> (= (type a@@50) (MapType0Type T@@75 intType)) (= (|MultiSet#Card| (|MultiSet#UnionOne| a@@50 x@@30)) (+ (|MultiSet#Card| a@@50) 1)))) :qid |DafnyPre.697:18| :skolemid |170| :pattern ((|MultiSet#Card| (|MultiSet#UnionOne| a@@50 x@@30))))))
(assert (forall ((arg0@@71 T@U) (arg1@@28 T@U)) (! (let ((T@@76 (MapType0TypeInv0 (type arg0@@71)))) (= (type (|MultiSet#Union| arg0@@71 arg1@@28)) (MapType0Type T@@76 intType))) :qid |funType:MultiSet#Union| :pattern ((|MultiSet#Union| arg0@@71 arg1@@28)))))
(assert (forall ((a@@51 T@U) (b@@36 T@U) (o@@28 T@U)) (! (let ((T@@77 (type o@@28))) (=> (and (= (type a@@51) (MapType0Type T@@77 intType)) (= (type b@@36) (MapType0Type T@@77 intType))) (= (U_2_int (MapType0Select (|MultiSet#Union| a@@51 b@@36) o@@28)) (+ (U_2_int (MapType0Select a@@51 o@@28)) (U_2_int (MapType0Select b@@36 o@@28)))))) :qid |DafnyPre.703:18| :skolemid |171| :pattern ((MapType0Select (|MultiSet#Union| a@@51 b@@36) o@@28)))))
(assert (forall ((a@@52 T@U) (b@@37 T@U)) (! (let ((T@@78 (MapType0TypeInv0 (type a@@52)))) (=> (and (= (type a@@52) (MapType0Type T@@78 intType)) (= (type b@@37) (MapType0Type T@@78 intType))) (= (|MultiSet#Card| (|MultiSet#Union| a@@52 b@@37)) (+ (|MultiSet#Card| a@@52) (|MultiSet#Card| b@@37))))) :qid |DafnyPre.705:18| :skolemid |172| :pattern ((|MultiSet#Card| (|MultiSet#Union| a@@52 b@@37))))))
(assert (forall ((arg0@@72 T@U) (arg1@@29 T@U)) (! (let ((T@@79 (MapType0TypeInv0 (type arg0@@72)))) (= (type (|MultiSet#Intersection| arg0@@72 arg1@@29)) (MapType0Type T@@79 intType))) :qid |funType:MultiSet#Intersection| :pattern ((|MultiSet#Intersection| arg0@@72 arg1@@29)))))
(assert (forall ((a@@53 T@U) (b@@38 T@U) (o@@29 T@U)) (! (let ((T@@80 (type o@@29))) (=> (and (= (type a@@53) (MapType0Type T@@80 intType)) (= (type b@@38) (MapType0Type T@@80 intType))) (= (U_2_int (MapType0Select (|MultiSet#Intersection| a@@53 b@@38) o@@29)) (|Math#min| (U_2_int (MapType0Select a@@53 o@@29)) (U_2_int (MapType0Select b@@38 o@@29)))))) :qid |DafnyPre.709:18| :skolemid |173| :pattern ((MapType0Select (|MultiSet#Intersection| a@@53 b@@38) o@@29)))))
(assert (forall ((a@@54 T@U) (b@@39 T@U)) (! (let ((T@@81 (MapType0TypeInv0 (type a@@54)))) (=> (and (= (type a@@54) (MapType0Type T@@81 intType)) (= (type b@@39) (MapType0Type T@@81 intType))) (= (|MultiSet#Intersection| (|MultiSet#Intersection| a@@54 b@@39) b@@39) (|MultiSet#Intersection| a@@54 b@@39)))) :qid |DafnyPre.713:18| :skolemid |174| :pattern ((|MultiSet#Intersection| (|MultiSet#Intersection| a@@54 b@@39) b@@39)))))
(assert (forall ((a@@55 T@U) (b@@40 T@U)) (! (let ((T@@82 (MapType0TypeInv0 (type a@@55)))) (=> (and (= (type a@@55) (MapType0Type T@@82 intType)) (= (type b@@40) (MapType0Type T@@82 intType))) (= (|MultiSet#Intersection| a@@55 (|MultiSet#Intersection| a@@55 b@@40)) (|MultiSet#Intersection| a@@55 b@@40)))) :qid |DafnyPre.715:18| :skolemid |175| :pattern ((|MultiSet#Intersection| a@@55 (|MultiSet#Intersection| a@@55 b@@40))))))
(assert (forall ((arg0@@73 T@U) (arg1@@30 T@U)) (! (let ((T@@83 (MapType0TypeInv0 (type arg0@@73)))) (= (type (|MultiSet#Difference| arg0@@73 arg1@@30)) (MapType0Type T@@83 intType))) :qid |funType:MultiSet#Difference| :pattern ((|MultiSet#Difference| arg0@@73 arg1@@30)))))
(assert (forall ((a@@56 T@U) (b@@41 T@U) (o@@30 T@U)) (! (let ((T@@84 (type o@@30))) (=> (and (= (type a@@56) (MapType0Type T@@84 intType)) (= (type b@@41) (MapType0Type T@@84 intType))) (= (U_2_int (MapType0Select (|MultiSet#Difference| a@@56 b@@41) o@@30)) (|Math#clip| (- (U_2_int (MapType0Select a@@56 o@@30)) (U_2_int (MapType0Select b@@41 o@@30))))))) :qid |DafnyPre.720:18| :skolemid |176| :pattern ((MapType0Select (|MultiSet#Difference| a@@56 b@@41) o@@30)))))
(assert (forall ((a@@57 T@U) (b@@42 T@U) (y@@11 T@U)) (! (let ((T@@85 (type y@@11))) (=> (and (and (= (type a@@57) (MapType0Type T@@85 intType)) (= (type b@@42) (MapType0Type T@@85 intType))) (<= (U_2_int (MapType0Select a@@57 y@@11)) (U_2_int (MapType0Select b@@42 y@@11)))) (= (U_2_int (MapType0Select (|MultiSet#Difference| a@@57 b@@42) y@@11)) 0))) :qid |DafnyPre.722:18| :skolemid |177| :pattern ((|MultiSet#Difference| a@@57 b@@42) (MapType0Select b@@42 y@@11) (MapType0Select a@@57 y@@11)))))
(assert (forall ((a@@58 T@U) (b@@43 T@U)) (! (let ((T@@86 (MapType0TypeInv0 (type a@@58)))) (=> (and (= (type a@@58) (MapType0Type T@@86 intType)) (= (type b@@43) (MapType0Type T@@86 intType))) (and (= (+ (+ (|MultiSet#Card| (|MultiSet#Difference| a@@58 b@@43)) (|MultiSet#Card| (|MultiSet#Difference| b@@43 a@@58))) (* 2 (|MultiSet#Card| (|MultiSet#Intersection| a@@58 b@@43)))) (|MultiSet#Card| (|MultiSet#Union| a@@58 b@@43))) (= (|MultiSet#Card| (|MultiSet#Difference| a@@58 b@@43)) (- (|MultiSet#Card| a@@58) (|MultiSet#Card| (|MultiSet#Intersection| a@@58 b@@43))))))) :qid |DafnyPre.724:18| :skolemid |178| :pattern ((|MultiSet#Card| (|MultiSet#Difference| a@@58 b@@43))))))
(assert (forall ((a@@59 T@U) (b@@44 T@U)) (! (let ((T@@87 (MapType0TypeInv0 (type a@@59)))) (=> (and (= (type a@@59) (MapType0Type T@@87 intType)) (= (type b@@44) (MapType0Type T@@87 intType))) (and (=> (|MultiSet#Subset| a@@59 b@@44) (forall ((o@@31 T@U)) (! (=> (= (type o@@31) T@@87) (<= (U_2_int (MapType0Select a@@59 o@@31)) (U_2_int (MapType0Select b@@44 o@@31)))) :qid |DafnyPre.734:37| :skolemid |179| :pattern ((MapType0Select a@@59 o@@31)) :pattern ((MapType0Select b@@44 o@@31))))) (=> (forall ((o@@32 T@U)) (! (=> (= (type o@@32) T@@87) (<= (U_2_int (MapType0Select a@@59 o@@32)) (U_2_int (MapType0Select b@@44 o@@32)))) :qid |DafnyPre.734:37| :skolemid |179| :pattern ((MapType0Select a@@59 o@@32)) :pattern ((MapType0Select b@@44 o@@32)))) (|MultiSet#Subset| a@@59 b@@44))))) :qid |DafnyPre.733:17| :skolemid |180| :pattern ((|MultiSet#Subset| a@@59 b@@44)))))
(assert (forall ((a@@60 T@U) (b@@45 T@U)) (! (let ((T@@88 (MapType0TypeInv0 (type a@@60)))) (=> (and (= (type a@@60) (MapType0Type T@@88 intType)) (= (type b@@45) (MapType0Type T@@88 intType))) (and (=> (|MultiSet#Equal| a@@60 b@@45) (forall ((o@@33 T@U)) (! (=> (= (type o@@33) T@@88) (= (U_2_int (MapType0Select a@@60 o@@33)) (U_2_int (MapType0Select b@@45 o@@33)))) :qid |DafnyPre.738:36| :skolemid |181| :pattern ((MapType0Select a@@60 o@@33)) :pattern ((MapType0Select b@@45 o@@33))))) (=> (forall ((o@@34 T@U)) (! (=> (= (type o@@34) T@@88) (= (U_2_int (MapType0Select a@@60 o@@34)) (U_2_int (MapType0Select b@@45 o@@34)))) :qid |DafnyPre.738:36| :skolemid |181| :pattern ((MapType0Select a@@60 o@@34)) :pattern ((MapType0Select b@@45 o@@34)))) (|MultiSet#Equal| a@@60 b@@45))))) :qid |DafnyPre.737:17| :skolemid |182| :pattern ((|MultiSet#Equal| a@@60 b@@45)))))
(assert (forall ((a@@61 T@U) (b@@46 T@U)) (! (let ((T@@89 (MapType0TypeInv0 (type a@@61)))) (=> (and (and (= (type a@@61) (MapType0Type T@@89 intType)) (= (type b@@46) (MapType0Type T@@89 intType))) (|MultiSet#Equal| a@@61 b@@46)) (= a@@61 b@@46))) :qid |DafnyPre.740:17| :skolemid |183| :pattern ((|MultiSet#Equal| a@@61 b@@46)))))
(assert (forall ((a@@62 T@U) (b@@47 T@U)) (! (let ((T@@90 (MapType0TypeInv0 (type a@@62)))) (=> (and (= (type a@@62) (MapType0Type T@@90 intType)) (= (type b@@47) (MapType0Type T@@90 intType))) (and (=> (|MultiSet#Disjoint| a@@62 b@@47) (forall ((o@@35 T@U)) (! (=> (= (type o@@35) T@@90) (or (= (U_2_int (MapType0Select a@@62 o@@35)) 0) (= (U_2_int (MapType0Select b@@47 o@@35)) 0))) :qid |DafnyPre.745:39| :skolemid |184| :pattern ((MapType0Select a@@62 o@@35)) :pattern ((MapType0Select b@@47 o@@35))))) (=> (forall ((o@@36 T@U)) (! (=> (= (type o@@36) T@@90) (or (= (U_2_int (MapType0Select a@@62 o@@36)) 0) (= (U_2_int (MapType0Select b@@47 o@@36)) 0))) :qid |DafnyPre.745:39| :skolemid |184| :pattern ((MapType0Select a@@62 o@@36)) :pattern ((MapType0Select b@@47 o@@36)))) (|MultiSet#Disjoint| a@@62 b@@47))))) :qid |DafnyPre.744:18| :skolemid |185| :pattern ((|MultiSet#Disjoint| a@@62 b@@47)))))
(assert (forall ((arg0@@74 T@U)) (! (let ((T@@91 (MapType0TypeInv0 (type arg0@@74)))) (= (type (|MultiSet#FromSet| arg0@@74)) (MapType0Type T@@91 intType))) :qid |funType:MultiSet#FromSet| :pattern ((|MultiSet#FromSet| arg0@@74)))))
(assert (forall ((s@@8 T@U) (a@@63 T@U)) (! (let ((T@@92 (type a@@63))) (=> (= (type s@@8) (MapType0Type T@@92 boolType)) (and (and (=> (= (U_2_int (MapType0Select (|MultiSet#FromSet| s@@8) a@@63)) 0) (not (U_2_bool (MapType0Select s@@8 a@@63)))) (=> (not (U_2_bool (MapType0Select s@@8 a@@63))) (= (U_2_int (MapType0Select (|MultiSet#FromSet| s@@8) a@@63)) 0))) (and (=> (= (U_2_int (MapType0Select (|MultiSet#FromSet| s@@8) a@@63)) 1) (U_2_bool (MapType0Select s@@8 a@@63))) (=> (U_2_bool (MapType0Select s@@8 a@@63)) (= (U_2_int (MapType0Select (|MultiSet#FromSet| s@@8) a@@63)) 1)))))) :qid |DafnyPre.749:18| :skolemid |186| :pattern ((MapType0Select (|MultiSet#FromSet| s@@8) a@@63)))))
(assert (forall ((s@@9 T@U)) (! (let ((T@@93 (MapType0TypeInv0 (type s@@9)))) (=> (= (type s@@9) (MapType0Type T@@93 boolType)) (= (|MultiSet#Card| (|MultiSet#FromSet| s@@9)) (|Set#Card| s@@9)))) :qid |DafnyPre.752:18| :skolemid |187| :pattern ((|MultiSet#Card| (|MultiSet#FromSet| s@@9))))))
(assert (forall ((arg0@@75 T@U)) (! (let ((T@@94 (SeqTypeInv0 (type arg0@@75)))) (= (type (|MultiSet#FromSeq| arg0@@75)) (MapType0Type T@@94 intType))) :qid |funType:MultiSet#FromSeq| :pattern ((|MultiSet#FromSeq| arg0@@75)))))
(assert (forall ((s@@10 T@U)) (! (let ((T@@95 (SeqTypeInv0 (type s@@10)))) (=> (= (type s@@10) (SeqType T@@95)) ($IsGoodMultiSet (|MultiSet#FromSeq| s@@10)))) :qid |DafnyPre.758:18| :skolemid |188| :pattern ((|MultiSet#FromSeq| s@@10)))))
(assert (forall ((s@@11 T@U)) (! (let ((T@@96 (SeqTypeInv0 (type s@@11)))) (=> (= (type s@@11) (SeqType T@@96)) (= (|MultiSet#Card| (|MultiSet#FromSeq| s@@11)) (|Seq#Length| s@@11)))) :qid |DafnyPre.760:18| :skolemid |189| :pattern ((|MultiSet#Card| (|MultiSet#FromSeq| s@@11))))))
(assert (forall ((arg0@@76 T@U) (arg1@@31 T@U)) (! (let ((T@@97 (type arg1@@31))) (= (type (|Seq#Build| arg0@@76 arg1@@31)) (SeqType T@@97))) :qid |funType:Seq#Build| :pattern ((|Seq#Build| arg0@@76 arg1@@31)))))
(assert (forall ((s@@12 T@U) (v@@25 T@U)) (! (let ((T@@98 (type v@@25))) (=> (= (type s@@12) (SeqType T@@98)) (= (|MultiSet#FromSeq| (|Seq#Build| s@@12 v@@25)) (|MultiSet#UnionOne| (|MultiSet#FromSeq| s@@12) v@@25)))) :qid |DafnyPre.764:18| :skolemid |190| :pattern ((|MultiSet#FromSeq| (|Seq#Build| s@@12 v@@25))))))
(assert (forall ((T@@99 T@T)) (! (= (type (|Seq#Empty| T@@99)) (SeqType T@@99)) :qid |funType:Seq#Empty| :pattern ((|Seq#Empty| T@@99)))))
(assert (forall ((T@@100 T@T)) (! (= (|MultiSet#FromSeq| (|Seq#Empty| T@@100)) (|MultiSet#Empty| T@@100)) :skolemid |191|)))
(assert (forall ((arg0@@77 T@U) (arg1@@32 T@U)) (! (let ((T@@101 (SeqTypeInv0 (type arg0@@77)))) (= (type (|Seq#Append| arg0@@77 arg1@@32)) (SeqType T@@101))) :qid |funType:Seq#Append| :pattern ((|Seq#Append| arg0@@77 arg1@@32)))))
(assert (forall ((a@@64 T@U) (b@@48 T@U)) (! (let ((T@@102 (SeqTypeInv0 (type a@@64)))) (=> (and (= (type a@@64) (SeqType T@@102)) (= (type b@@48) (SeqType T@@102))) (= (|MultiSet#FromSeq| (|Seq#Append| a@@64 b@@48)) (|MultiSet#Union| (|MultiSet#FromSeq| a@@64) (|MultiSet#FromSeq| b@@48))))) :qid |DafnyPre.771:18| :skolemid |192| :pattern ((|MultiSet#FromSeq| (|Seq#Append| a@@64 b@@48))))))
(assert (forall ((arg0@@78 T@U) (arg1@@33 Int) (arg2@@2 T@U)) (! (let ((T@@103 (type arg2@@2))) (= (type (|Seq#Update| arg0@@78 arg1@@33 arg2@@2)) (SeqType T@@103))) :qid |funType:Seq#Update| :pattern ((|Seq#Update| arg0@@78 arg1@@33 arg2@@2)))))
(assert (forall ((s@@13 T@U) (i@@8 Int) (v@@26 T@U) (x@@31 T@U)) (! (let ((T@@104 (type v@@26))) (=> (and (and (= (type s@@13) (SeqType T@@104)) (= (type x@@31) T@@104)) (and (<= 0 i@@8) (< i@@8 (|Seq#Length| s@@13)))) (= (U_2_int (MapType0Select (|MultiSet#FromSeq| (|Seq#Update| s@@13 i@@8 v@@26)) x@@31)) (U_2_int (MapType0Select (|MultiSet#Union| (|MultiSet#Difference| (|MultiSet#FromSeq| s@@13) (|MultiSet#Singleton| (|Seq#Index| s@@13 i@@8))) (|MultiSet#Singleton| v@@26)) x@@31))))) :qid |DafnyPre.776:18| :skolemid |193| :pattern ((MapType0Select (|MultiSet#FromSeq| (|Seq#Update| s@@13 i@@8 v@@26)) x@@31)))))
(assert (forall ((s@@14 T@U) (x@@32 T@U)) (! (let ((T@@105 (type x@@32))) (=> (= (type s@@14) (SeqType T@@105)) (and (=> (exists ((i@@9 Int)) (! (and (and (<= 0 i@@9) (< i@@9 (|Seq#Length| s@@14))) (= x@@32 (|Seq#Index| s@@14 i@@9))) :qid |DafnyPre.783:11| :skolemid |194| :pattern ((|Seq#Index| s@@14 i@@9)))) (< 0 (U_2_int (MapType0Select (|MultiSet#FromSeq| s@@14) x@@32)))) (=> (< 0 (U_2_int (MapType0Select (|MultiSet#FromSeq| s@@14) x@@32))) (exists ((i@@10 Int)) (! (and (and (<= 0 i@@10) (< i@@10 (|Seq#Length| s@@14))) (= x@@32 (|Seq#Index| s@@14 i@@10))) :qid |DafnyPre.783:11| :skolemid |194| :pattern ((|Seq#Index| s@@14 i@@10)))))))) :qid |DafnyPre.782:18| :skolemid |195| :pattern ((MapType0Select (|MultiSet#FromSeq| s@@14) x@@32)))))
(assert (forall ((s@@15 T@U)) (! (let ((T@@106 (SeqTypeInv0 (type s@@15)))) (=> (= (type s@@15) (SeqType T@@106)) (<= 0 (|Seq#Length| s@@15)))) :qid |DafnyPre.792:18| :skolemid |196| :pattern ((|Seq#Length| s@@15)))))
(assert (forall ((T@@107 T@T)) (! (= (|Seq#Length| (|Seq#Empty| T@@107)) 0) :skolemid |197|)))
(assert (forall ((s@@16 T@U)) (! (let ((T@@108 (SeqTypeInv0 (type s@@16)))) (=> (and (= (type s@@16) (SeqType T@@108)) (= (|Seq#Length| s@@16) 0)) (= s@@16 (|Seq#Empty| T@@108)))) :qid |DafnyPre.796:18| :skolemid |198| :pattern ((|Seq#Length| s@@16)))))
(assert (forall ((t@@23 T@U) (T@@109 T@T)) (! (=> (= (type t@@23) TyType) ($Is (|Seq#Empty| T@@109) t@@23)) :qid |DafnyPre.806:18| :skolemid |199| :pattern (($Is (|Seq#Empty| T@@109) t@@23)))))
(assert (forall ((arg0@@79 T@U)) (! (let ((T@@110 (type arg0@@79))) (= (type (|Seq#Singleton| arg0@@79)) (SeqType T@@110))) :qid |funType:Seq#Singleton| :pattern ((|Seq#Singleton| arg0@@79)))))
(assert (forall ((t@@24 T@U)) (! (= (|Seq#Length| (|Seq#Singleton| t@@24)) 1) :qid |DafnyPre.809:18| :skolemid |200| :pattern ((|Seq#Length| (|Seq#Singleton| t@@24))))))
(assert (forall ((s@@17 T@U) (v@@27 T@U)) (! (let ((T@@111 (type v@@27))) (=> (= (type s@@17) (SeqType T@@111)) (= (|Seq#Length| (|Seq#Build| s@@17 v@@27)) (+ 1 (|Seq#Length| s@@17))))) :qid |DafnyPre.812:18| :skolemid |201| :pattern ((|Seq#Length| (|Seq#Build| s@@17 v@@27))))))
(assert (forall ((s@@18 T@U) (i@@11 Int) (v@@28 T@U)) (! (let ((T@@112 (type v@@28))) (=> (= (type s@@18) (SeqType T@@112)) (and (=> (= i@@11 (|Seq#Length| s@@18)) (= (|Seq#Index| (|Seq#Build| s@@18 v@@28) i@@11) v@@28)) (=> (not (= i@@11 (|Seq#Length| s@@18))) (= (|Seq#Index| (|Seq#Build| s@@18 v@@28) i@@11) (|Seq#Index| s@@18 i@@11)))))) :qid |DafnyPre.814:18| :skolemid |202| :pattern ((|Seq#Index| (|Seq#Build| s@@18 v@@28) i@@11)))))
(assert (forall ((s@@19 T@U) (bx@@34 T@U) (t@@25 T@U)) (! (=> (and (and (and (= (type s@@19) (SeqType BoxType)) (= (type bx@@34) BoxType)) (= (type t@@25) TyType)) (and ($Is s@@19 (TSeq t@@25)) ($IsBox bx@@34 t@@25))) ($Is (|Seq#Build| s@@19 bx@@34) (TSeq t@@25))) :qid |DafnyPre.819:15| :skolemid |203| :pattern (($Is (|Seq#Build| s@@19 bx@@34) (TSeq t@@25))))))
(assert (forall ((s0 T@U) (s1 T@U)) (! (let ((T@@113 (SeqTypeInv0 (type s0)))) (=> (and (= (type s0) (SeqType T@@113)) (= (type s1) (SeqType T@@113))) (= (|Seq#Length| (|Seq#Append| s0 s1)) (+ (|Seq#Length| s0) (|Seq#Length| s1))))) :qid |DafnyPre.823:18| :skolemid |204| :pattern ((|Seq#Length| (|Seq#Append| s0 s1))))))
(assert (forall ((s0@@0 T@U) (s1@@0 T@U) (t@@26 T@U)) (! (=> (and (and (and (= (type s0@@0) (SeqType BoxType)) (= (type s1@@0) (SeqType BoxType))) (= (type t@@26) TyType)) (and ($Is s0@@0 t@@26) ($Is s1@@0 t@@26))) ($Is (|Seq#Append| s0@@0 s1@@0) t@@26)) :qid |DafnyPre.827:15| :skolemid |205| :pattern (($Is (|Seq#Append| s0@@0 s1@@0) t@@26)))))
(assert (forall ((t@@27 T@U)) (! (= (|Seq#Index| (|Seq#Singleton| t@@27) 0) t@@27) :qid |DafnyPre.831:18| :skolemid |206| :pattern ((|Seq#Index| (|Seq#Singleton| t@@27) 0)))))
(assert (forall ((s0@@1 T@U) (s1@@1 T@U) (n@@1 Int)) (! (let ((T@@114 (SeqTypeInv0 (type s0@@1)))) (=> (and (= (type s0@@1) (SeqType T@@114)) (= (type s1@@1) (SeqType T@@114))) (and (=> (< n@@1 (|Seq#Length| s0@@1)) (= (|Seq#Index| (|Seq#Append| s0@@1 s1@@1) n@@1) (|Seq#Index| s0@@1 n@@1))) (=> (<= (|Seq#Length| s0@@1) n@@1) (= (|Seq#Index| (|Seq#Append| s0@@1 s1@@1) n@@1) (|Seq#Index| s1@@1 (- n@@1 (|Seq#Length| s0@@1)))))))) :qid |DafnyPre.832:18| :skolemid |207| :pattern ((|Seq#Index| (|Seq#Append| s0@@1 s1@@1) n@@1)))))
(assert (forall ((s@@20 T@U) (i@@12 Int) (v@@29 T@U)) (! (let ((T@@115 (type v@@29))) (=> (= (type s@@20) (SeqType T@@115)) (=> (and (<= 0 i@@12) (< i@@12 (|Seq#Length| s@@20))) (= (|Seq#Length| (|Seq#Update| s@@20 i@@12 v@@29)) (|Seq#Length| s@@20))))) :qid |DafnyPre.837:18| :skolemid |208| :pattern ((|Seq#Length| (|Seq#Update| s@@20 i@@12 v@@29))))))
(assert (forall ((s@@21 T@U) (i@@13 Int) (v@@30 T@U) (n@@2 Int)) (! (let ((T@@116 (type v@@30))) (=> (= (type s@@21) (SeqType T@@116)) (=> (and (<= 0 n@@2) (< n@@2 (|Seq#Length| s@@21))) (and (=> (= i@@13 n@@2) (= (|Seq#Index| (|Seq#Update| s@@21 i@@13 v@@30) n@@2) v@@30)) (=> (not (= i@@13 n@@2)) (= (|Seq#Index| (|Seq#Update| s@@21 i@@13 v@@30) n@@2) (|Seq#Index| s@@21 n@@2))))))) :qid |DafnyPre.839:18| :skolemid |209| :pattern ((|Seq#Index| (|Seq#Update| s@@21 i@@13 v@@30) n@@2)))))
(assert (forall ((s@@22 T@U) (x@@33 T@U)) (! (let ((T@@117 (type x@@33))) (=> (= (type s@@22) (SeqType T@@117)) (and (=> (|Seq#Contains| s@@22 x@@33) (exists ((i@@14 Int)) (! (and (and (<= 0 i@@14) (< i@@14 (|Seq#Length| s@@22))) (= (|Seq#Index| s@@22 i@@14) x@@33)) :qid |DafnyPre.847:13| :skolemid |210| :pattern ((|Seq#Index| s@@22 i@@14))))) (=> (exists ((i@@15 Int)) (! (and (and (<= 0 i@@15) (< i@@15 (|Seq#Length| s@@22))) (= (|Seq#Index| s@@22 i@@15) x@@33)) :qid |DafnyPre.847:13| :skolemid |210| :pattern ((|Seq#Index| s@@22 i@@15)))) (|Seq#Contains| s@@22 x@@33))))) :qid |DafnyPre.845:18| :skolemid |211| :pattern ((|Seq#Contains| s@@22 x@@33)))))
(assert (forall ((x@@34 T@U)) (! (let ((T@@118 (type x@@34))) (not (|Seq#Contains| (|Seq#Empty| T@@118) x@@34))) :qid |DafnyPre.848:18| :skolemid |212| :pattern ((let ((T@@118 (type x@@34))) (|Seq#Contains| (|Seq#Empty| T@@118) x@@34))))))
(assert (forall ((s0@@2 T@U) (s1@@2 T@U) (x@@35 T@U)) (! (let ((T@@119 (type x@@35))) (=> (and (= (type s0@@2) (SeqType T@@119)) (= (type s1@@2) (SeqType T@@119))) (and (=> (|Seq#Contains| (|Seq#Append| s0@@2 s1@@2) x@@35) (or (|Seq#Contains| s0@@2 x@@35) (|Seq#Contains| s1@@2 x@@35))) (=> (or (|Seq#Contains| s0@@2 x@@35) (|Seq#Contains| s1@@2 x@@35)) (|Seq#Contains| (|Seq#Append| s0@@2 s1@@2) x@@35))))) :qid |DafnyPre.852:18| :skolemid |213| :pattern ((|Seq#Contains| (|Seq#Append| s0@@2 s1@@2) x@@35)))))
(assert (forall ((s@@23 T@U) (v@@31 T@U) (x@@36 T@U)) (! (let ((T@@120 (type v@@31))) (=> (and (= (type s@@23) (SeqType T@@120)) (= (type x@@36) T@@120)) (and (=> (|Seq#Contains| (|Seq#Build| s@@23 v@@31) x@@36) (or (= v@@31 x@@36) (|Seq#Contains| s@@23 x@@36))) (=> (or (= v@@31 x@@36) (|Seq#Contains| s@@23 x@@36)) (|Seq#Contains| (|Seq#Build| s@@23 v@@31) x@@36))))) :qid |DafnyPre.857:18| :skolemid |214| :pattern ((|Seq#Contains| (|Seq#Build| s@@23 v@@31) x@@36)))))
(assert (forall ((arg0@@80 T@U) (arg1@@34 Int)) (! (let ((T@@121 (SeqTypeInv0 (type arg0@@80)))) (= (type (|Seq#Take| arg0@@80 arg1@@34)) (SeqType T@@121))) :qid |funType:Seq#Take| :pattern ((|Seq#Take| arg0@@80 arg1@@34)))))
(assert (forall ((s@@24 T@U) (n@@3 Int) (x@@37 T@U)) (! (let ((T@@122 (type x@@37))) (=> (= (type s@@24) (SeqType T@@122)) (and (=> (|Seq#Contains| (|Seq#Take| s@@24 n@@3) x@@37) (exists ((i@@16 Int)) (! (and (and (and (<= 0 i@@16) (< i@@16 n@@3)) (< i@@16 (|Seq#Length| s@@24))) (= (|Seq#Index| s@@24 i@@16) x@@37)) :qid |DafnyPre.864:13| :skolemid |215| :pattern ((|Seq#Index| s@@24 i@@16))))) (=> (exists ((i@@17 Int)) (! (and (and (and (<= 0 i@@17) (< i@@17 n@@3)) (< i@@17 (|Seq#Length| s@@24))) (= (|Seq#Index| s@@24 i@@17) x@@37)) :qid |DafnyPre.864:13| :skolemid |215| :pattern ((|Seq#Index| s@@24 i@@17)))) (|Seq#Contains| (|Seq#Take| s@@24 n@@3) x@@37))))) :qid |DafnyPre.861:18| :skolemid |216| :pattern ((|Seq#Contains| (|Seq#Take| s@@24 n@@3) x@@37)))))
(assert (forall ((arg0@@81 T@U) (arg1@@35 Int)) (! (let ((T@@123 (SeqTypeInv0 (type arg0@@81)))) (= (type (|Seq#Drop| arg0@@81 arg1@@35)) (SeqType T@@123))) :qid |funType:Seq#Drop| :pattern ((|Seq#Drop| arg0@@81 arg1@@35)))))
(assert (forall ((s@@25 T@U) (n@@4 Int) (x@@38 T@U)) (! (let ((T@@124 (type x@@38))) (=> (= (type s@@25) (SeqType T@@124)) (and (=> (|Seq#Contains| (|Seq#Drop| s@@25 n@@4) x@@38) (exists ((i@@18 Int)) (! (and (and (and (<= 0 n@@4) (<= n@@4 i@@18)) (< i@@18 (|Seq#Length| s@@25))) (= (|Seq#Index| s@@25 i@@18) x@@38)) :qid |DafnyPre.869:13| :skolemid |217| :pattern ((|Seq#Index| s@@25 i@@18))))) (=> (exists ((i@@19 Int)) (! (and (and (and (<= 0 n@@4) (<= n@@4 i@@19)) (< i@@19 (|Seq#Length| s@@25))) (= (|Seq#Index| s@@25 i@@19) x@@38)) :qid |DafnyPre.869:13| :skolemid |217| :pattern ((|Seq#Index| s@@25 i@@19)))) (|Seq#Contains| (|Seq#Drop| s@@25 n@@4) x@@38))))) :qid |DafnyPre.866:18| :skolemid |218| :pattern ((|Seq#Contains| (|Seq#Drop| s@@25 n@@4) x@@38)))))
(assert (forall ((s0@@3 T@U) (s1@@3 T@U)) (! (let ((T@@125 (SeqTypeInv0 (type s0@@3)))) (=> (and (= (type s0@@3) (SeqType T@@125)) (= (type s1@@3) (SeqType T@@125))) (and (=> (|Seq#Equal| s0@@3 s1@@3) (and (= (|Seq#Length| s0@@3) (|Seq#Length| s1@@3)) (forall ((j Int)) (! (=> (and (<= 0 j) (< j (|Seq#Length| s0@@3))) (= (|Seq#Index| s0@@3 j) (|Seq#Index| s1@@3 j))) :qid |DafnyPre.876:13| :skolemid |219| :pattern ((|Seq#Index| s0@@3 j)) :pattern ((|Seq#Index| s1@@3 j)))))) (=> (and (= (|Seq#Length| s0@@3) (|Seq#Length| s1@@3)) (forall ((j@@0 Int)) (! (=> (and (<= 0 j@@0) (< j@@0 (|Seq#Length| s0@@3))) (= (|Seq#Index| s0@@3 j@@0) (|Seq#Index| s1@@3 j@@0))) :qid |DafnyPre.876:13| :skolemid |219| :pattern ((|Seq#Index| s0@@3 j@@0)) :pattern ((|Seq#Index| s1@@3 j@@0))))) (|Seq#Equal| s0@@3 s1@@3))))) :qid |DafnyPre.873:18| :skolemid |220| :pattern ((|Seq#Equal| s0@@3 s1@@3)))))
(assert (forall ((a@@65 T@U) (b@@49 T@U)) (! (let ((T@@126 (SeqTypeInv0 (type a@@65)))) (=> (and (and (= (type a@@65) (SeqType T@@126)) (= (type b@@49) (SeqType T@@126))) (|Seq#Equal| a@@65 b@@49)) (= a@@65 b@@49))) :qid |DafnyPre.878:18| :skolemid |221| :pattern ((|Seq#Equal| a@@65 b@@49)))))
(assert (forall ((s0@@4 T@U) (s1@@4 T@U) (n@@5 Int)) (! (let ((T@@127 (SeqTypeInv0 (type s0@@4)))) (=> (and (= (type s0@@4) (SeqType T@@127)) (= (type s1@@4) (SeqType T@@127))) (and (=> (|Seq#SameUntil| s0@@4 s1@@4 n@@5) (forall ((j@@1 Int)) (! (=> (and (<= 0 j@@1) (< j@@1 n@@5)) (= (|Seq#Index| s0@@4 j@@1) (|Seq#Index| s1@@4 j@@1))) :qid |DafnyPre.884:13| :skolemid |222| :pattern ((|Seq#Index| s0@@4 j@@1)) :pattern ((|Seq#Index| s1@@4 j@@1))))) (=> (forall ((j@@2 Int)) (! (=> (and (<= 0 j@@2) (< j@@2 n@@5)) (= (|Seq#Index| s0@@4 j@@2) (|Seq#Index| s1@@4 j@@2))) :qid |DafnyPre.884:13| :skolemid |222| :pattern ((|Seq#Index| s0@@4 j@@2)) :pattern ((|Seq#Index| s1@@4 j@@2)))) (|Seq#SameUntil| s0@@4 s1@@4 n@@5))))) :qid |DafnyPre.882:18| :skolemid |223| :pattern ((|Seq#SameUntil| s0@@4 s1@@4 n@@5)))))
(assert (forall ((s@@26 T@U) (n@@6 Int)) (! (let ((T@@128 (SeqTypeInv0 (type s@@26)))) (=> (= (type s@@26) (SeqType T@@128)) (=> (and (<= 0 n@@6) (<= n@@6 (|Seq#Length| s@@26))) (= (|Seq#Length| (|Seq#Take| s@@26 n@@6)) n@@6)))) :qid |DafnyPre.888:18| :skolemid |224| :pattern ((|Seq#Length| (|Seq#Take| s@@26 n@@6))))))
(assert (forall ((s@@27 T@U) (n@@7 Int) (j@@3 Int)) (! (let ((T@@129 (SeqTypeInv0 (type s@@27)))) (=> (= (type s@@27) (SeqType T@@129)) (=> (and (and (<= 0 j@@3) (< j@@3 n@@7)) (< j@@3 (|Seq#Length| s@@27))) (= (|Seq#Index| (|Seq#Take| s@@27 n@@7) j@@3) (|Seq#Index| s@@27 j@@3))))) :qid |DafnyPre.890:18| :weight 25 :skolemid |225| :pattern ((|Seq#Index| (|Seq#Take| s@@27 n@@7) j@@3)) :pattern ((|Seq#Index| s@@27 j@@3) (|Seq#Take| s@@27 n@@7)))))
(assert (forall ((s@@28 T@U) (n@@8 Int)) (! (let ((T@@130 (SeqTypeInv0 (type s@@28)))) (=> (= (type s@@28) (SeqType T@@130)) (=> (and (<= 0 n@@8) (<= n@@8 (|Seq#Length| s@@28))) (= (|Seq#Length| (|Seq#Drop| s@@28 n@@8)) (- (|Seq#Length| s@@28) n@@8))))) :qid |DafnyPre.898:18| :skolemid |226| :pattern ((|Seq#Length| (|Seq#Drop| s@@28 n@@8))))))
(assert (forall ((s@@29 T@U) (n@@9 Int) (j@@4 Int)) (! (let ((T@@131 (SeqTypeInv0 (type s@@29)))) (=> (= (type s@@29) (SeqType T@@131)) (=> (and (and (<= 0 n@@9) (<= 0 j@@4)) (< j@@4 (- (|Seq#Length| s@@29) n@@9))) (= (|Seq#Index| (|Seq#Drop| s@@29 n@@9) j@@4) (|Seq#Index| s@@29 (+ j@@4 n@@9)))))) :qid |DafnyPre.900:18| :weight 25 :skolemid |227| :pattern ((|Seq#Index| (|Seq#Drop| s@@29 n@@9) j@@4)))))
(assert (forall ((s@@30 T@U) (n@@10 Int) (k@@3 Int)) (! (let ((T@@132 (SeqTypeInv0 (type s@@30)))) (=> (= (type s@@30) (SeqType T@@132)) (=> (and (and (<= 0 n@@10) (<= n@@10 k@@3)) (< k@@3 (|Seq#Length| s@@30))) (= (|Seq#Index| (|Seq#Drop| s@@30 n@@10) (- k@@3 n@@10)) (|Seq#Index| s@@30 k@@3))))) :qid |DafnyPre.905:18| :weight 25 :skolemid |228| :pattern ((|Seq#Index| s@@30 k@@3) (|Seq#Drop| s@@30 n@@10)))))
(assert (forall ((s@@31 T@U) (t@@28 T@U)) (! (let ((T@@133 (SeqTypeInv0 (type s@@31)))) (=> (and (= (type s@@31) (SeqType T@@133)) (= (type t@@28) (SeqType T@@133))) (and (= (|Seq#Take| (|Seq#Append| s@@31 t@@28) (|Seq#Length| s@@31)) s@@31) (= (|Seq#Drop| (|Seq#Append| s@@31 t@@28) (|Seq#Length| s@@31)) t@@28)))) :qid |DafnyPre.911:18| :skolemid |229| :pattern ((|Seq#Append| s@@31 t@@28)))))
(assert (forall ((arg0@@82 T@U) (arg1@@36 T@U)) (! (= (type (|Seq#FromArray| arg0@@82 arg1@@36)) (SeqType BoxType)) :qid |funType:Seq#FromArray| :pattern ((|Seq#FromArray| arg0@@82 arg1@@36)))))
(assert (forall ((h@@16 T@U) (a@@66 T@U)) (! (=> (and (= (type h@@16) (MapType1Type refType)) (= (type a@@66) refType)) (= (|Seq#Length| (|Seq#FromArray| h@@16 a@@66)) (_System.array.Length a@@66))) :qid |DafnyPre.917:15| :skolemid |230| :pattern ((|Seq#Length| (|Seq#FromArray| h@@16 a@@66))))))
(assert (forall ((h@@17 T@U) (a@@67 T@U)) (! (=> (and (= (type h@@17) (MapType1Type refType)) (= (type a@@67) refType)) (forall ((i@@20 Int)) (! (=> (and (<= 0 i@@20) (< i@@20 (|Seq#Length| (|Seq#FromArray| h@@17 a@@67)))) (= (|Seq#Index| (|Seq#FromArray| h@@17 a@@67) i@@20) (MapType1Select h@@17 a@@67 (IndexField i@@20)))) :qid |DafnyPre.922:11| :skolemid |231| :pattern ((MapType1Select h@@17 a@@67 (IndexField i@@20))) :pattern ((|Seq#Index| (|Seq#FromArray| h@@17 a@@67) i@@20))))) :qid |DafnyPre.920:15| :skolemid |232| :pattern ((|Seq#FromArray| h@@17 a@@67)))))
(assert (forall ((h0 T@U) (h1 T@U) (a@@68 T@U)) (! (=> (and (and (= (type h0) (MapType1Type refType)) (= (type h1) (MapType1Type refType))) (= (type a@@68) refType)) (=> (and (and (and ($IsGoodHeap h0) ($IsGoodHeap h1)) ($HeapSucc h0 h1)) (forall ((i@@21 Int)) (! (=> (and (<= 0 i@@21) (< i@@21 (_System.array.Length a@@68))) (= (MapType1Select h0 a@@68 (IndexField i@@21)) (MapType1Select h1 a@@68 (IndexField i@@21)))) :qid |DafnyPre.935:11| :skolemid |233|))) (= (|Seq#FromArray| h0 a@@68) (|Seq#FromArray| h1 a@@68)))) :qid |DafnyPre.932:15| :skolemid |234| :pattern ((|Seq#FromArray| h1 a@@68) ($HeapSucc h0 h1)))))
(assert (forall ((h@@18 T@U) (i@@22 Int) (v@@32 T@U) (a@@69 T@U)) (! (=> (and (and (and (= (type h@@18) (MapType1Type refType)) (= (type v@@32) BoxType)) (= (type a@@69) refType)) (and (<= 0 i@@22) (< i@@22 (_System.array.Length a@@69)))) (= (|Seq#FromArray| (MapType1Store h@@18 a@@69 (IndexField i@@22) v@@32) a@@69) (|Seq#Update| (|Seq#FromArray| h@@18 a@@69) i@@22 v@@32))) :qid |DafnyPre.939:15| :skolemid |235| :pattern ((|Seq#FromArray| (MapType1Store h@@18 a@@69 (IndexField i@@22) v@@32) a@@69)))))
(assert (forall ((s@@32 T@U) (i@@23 Int) (v@@33 T@U) (n@@11 Int)) (! (let ((T@@134 (type v@@33))) (=> (= (type s@@32) (SeqType T@@134)) (=> (and (and (<= 0 i@@23) (< i@@23 n@@11)) (<= n@@11 (|Seq#Length| s@@32))) (= (|Seq#Take| (|Seq#Update| s@@32 i@@23 v@@33) n@@11) (|Seq#Update| (|Seq#Take| s@@32 n@@11) i@@23 v@@33))))) :qid |DafnyPre.944:18| :skolemid |236| :pattern ((|Seq#Take| (|Seq#Update| s@@32 i@@23 v@@33) n@@11)))))
(assert (forall ((s@@33 T@U) (i@@24 Int) (v@@34 T@U) (n@@12 Int)) (! (let ((T@@135 (type v@@34))) (=> (= (type s@@33) (SeqType T@@135)) (=> (and (<= n@@12 i@@24) (< i@@24 (|Seq#Length| s@@33))) (= (|Seq#Take| (|Seq#Update| s@@33 i@@24 v@@34) n@@12) (|Seq#Take| s@@33 n@@12))))) :qid |DafnyPre.947:18| :skolemid |237| :pattern ((|Seq#Take| (|Seq#Update| s@@33 i@@24 v@@34) n@@12)))))
(assert (forall ((s@@34 T@U) (i@@25 Int) (v@@35 T@U) (n@@13 Int)) (! (let ((T@@136 (type v@@35))) (=> (= (type s@@34) (SeqType T@@136)) (=> (and (and (<= 0 n@@13) (<= n@@13 i@@25)) (< i@@25 (|Seq#Length| s@@34))) (= (|Seq#Drop| (|Seq#Update| s@@34 i@@25 v@@35) n@@13) (|Seq#Update| (|Seq#Drop| s@@34 n@@13) (- i@@25 n@@13) v@@35))))) :qid |DafnyPre.950:18| :skolemid |238| :pattern ((|Seq#Drop| (|Seq#Update| s@@34 i@@25 v@@35) n@@13)))))
(assert (forall ((s@@35 T@U) (i@@26 Int) (v@@36 T@U) (n@@14 Int)) (! (let ((T@@137 (type v@@36))) (=> (= (type s@@35) (SeqType T@@137)) (=> (and (and (<= 0 i@@26) (< i@@26 n@@14)) (< n@@14 (|Seq#Length| s@@35))) (= (|Seq#Drop| (|Seq#Update| s@@35 i@@26 v@@36) n@@14) (|Seq#Drop| s@@35 n@@14))))) :qid |DafnyPre.953:18| :skolemid |239| :pattern ((|Seq#Drop| (|Seq#Update| s@@35 i@@26 v@@36) n@@14)))))
(assert (forall ((h@@19 T@U) (a@@70 T@U) (n0 Int) (n1 Int)) (! (=> (and (= (type h@@19) (MapType1Type refType)) (= (type a@@70) refType)) (=> (and (and (= (+ n0 1) n1) (<= 0 n0)) (<= n1 (_System.array.Length a@@70))) (= (|Seq#Take| (|Seq#FromArray| h@@19 a@@70) n1) (|Seq#Build| (|Seq#Take| (|Seq#FromArray| h@@19 a@@70) n0) (MapType1Select h@@19 a@@70 (IndexField n0)))))) :qid |DafnyPre.957:15| :skolemid |240| :pattern ((|Seq#Take| (|Seq#FromArray| h@@19 a@@70) n0) (|Seq#Take| (|Seq#FromArray| h@@19 a@@70) n1)))))
(assert (forall ((s@@36 T@U) (v@@37 T@U) (n@@15 Int)) (! (let ((T@@138 (type v@@37))) (=> (= (type s@@36) (SeqType T@@138)) (=> (and (<= 0 n@@15) (<= n@@15 (|Seq#Length| s@@36))) (= (|Seq#Drop| (|Seq#Build| s@@36 v@@37) n@@15) (|Seq#Build| (|Seq#Drop| s@@36 n@@15) v@@37))))) :qid |DafnyPre.961:18| :skolemid |241| :pattern ((|Seq#Drop| (|Seq#Build| s@@36 v@@37) n@@15)))))
(assert (forall ((s@@37 T@U) (i@@27 Int)) (! (=> (= (type s@@37) (SeqType BoxType)) (=> (and (<= 0 i@@27) (< i@@27 (|Seq#Length| s@@37))) (< (DtRank ($Unbox DatatypeTypeType (|Seq#Index| s@@37 i@@27))) (|Seq#Rank| s@@37)))) :qid |DafnyPre.966:15| :skolemid |242| :pattern ((DtRank ($Unbox DatatypeTypeType (|Seq#Index| s@@37 i@@27)))))))
(assert (forall ((s@@38 T@U) (i@@28 Int)) (! (let ((T@@139 (SeqTypeInv0 (type s@@38)))) (=> (= (type s@@38) (SeqType T@@139)) (=> (and (< 0 i@@28) (<= i@@28 (|Seq#Length| s@@38))) (< (|Seq#Rank| (|Seq#Drop| s@@38 i@@28)) (|Seq#Rank| s@@38))))) :qid |DafnyPre.969:18| :skolemid |243| :pattern ((|Seq#Rank| (|Seq#Drop| s@@38 i@@28))))))
(assert (forall ((s@@39 T@U) (i@@29 Int)) (! (let ((T@@140 (SeqTypeInv0 (type s@@39)))) (=> (= (type s@@39) (SeqType T@@140)) (=> (and (<= 0 i@@29) (< i@@29 (|Seq#Length| s@@39))) (< (|Seq#Rank| (|Seq#Take| s@@39 i@@29)) (|Seq#Rank| s@@39))))) :qid |DafnyPre.972:18| :skolemid |244| :pattern ((|Seq#Rank| (|Seq#Take| s@@39 i@@29))))))
(assert (forall ((s@@40 T@U) (i@@30 Int) (j@@5 Int)) (! (let ((T@@141 (SeqTypeInv0 (type s@@40)))) (=> (= (type s@@40) (SeqType T@@141)) (=> (and (and (<= 0 i@@30) (< i@@30 j@@5)) (<= j@@5 (|Seq#Length| s@@40))) (< (|Seq#Rank| (|Seq#Append| (|Seq#Take| s@@40 i@@30) (|Seq#Drop| s@@40 j@@5))) (|Seq#Rank| s@@40))))) :qid |DafnyPre.975:18| :skolemid |245| :pattern ((|Seq#Rank| (|Seq#Append| (|Seq#Take| s@@40 i@@30) (|Seq#Drop| s@@40 j@@5)))))))
(assert (forall ((s@@41 T@U) (n@@16 Int)) (! (let ((T@@142 (SeqTypeInv0 (type s@@41)))) (=> (and (= (type s@@41) (SeqType T@@142)) (= n@@16 0)) (= (|Seq#Drop| s@@41 n@@16) s@@41))) :qid |DafnyPre.980:18| :skolemid |246| :pattern ((|Seq#Drop| s@@41 n@@16)))))
(assert (forall ((s@@42 T@U) (n@@17 Int)) (! (let ((T@@143 (SeqTypeInv0 (type s@@42)))) (=> (and (= (type s@@42) (SeqType T@@143)) (= n@@17 0)) (= (|Seq#Take| s@@42 n@@17) (|Seq#Empty| T@@143)))) :qid |DafnyPre.982:18| :skolemid |247| :pattern ((|Seq#Take| s@@42 n@@17)))))
(assert (forall ((s@@43 T@U) (m@@6 Int) (n@@18 Int)) (! (let ((T@@144 (SeqTypeInv0 (type s@@43)))) (=> (= (type s@@43) (SeqType T@@144)) (=> (and (and (<= 0 m@@6) (<= 0 n@@18)) (<= (+ m@@6 n@@18) (|Seq#Length| s@@43))) (= (|Seq#Drop| (|Seq#Drop| s@@43 m@@6) n@@18) (|Seq#Drop| s@@43 (+ m@@6 n@@18)))))) :qid |DafnyPre.984:18| :skolemid |248| :pattern ((|Seq#Drop| (|Seq#Drop| s@@43 m@@6) n@@18)))))
(assert (forall ((m@@7 T@U)) (! (let ((V@@1 (MapTypeInv1 (type m@@7)))) (let ((U@@3 (MapTypeInv0 (type m@@7)))) (=> (= (type m@@7) (MapType U@@3 V@@1)) (<= 0 (|Map#Card| m@@7))))) :qid |DafnyPre.998:21| :skolemid |249| :pattern ((|Map#Card| m@@7)))))
(assert (forall ((U@@4 T@T) (V@@2 T@T)) (! (= (type (|Map#Empty| U@@4 V@@2)) (MapType U@@4 V@@2)) :qid |funType:Map#Empty| :pattern ((|Map#Empty| U@@4 V@@2)))))
(assert (forall ((u@@5 T@U) (V@@3 T@T)) (! (let ((U@@5 (type u@@5))) (not (U_2_bool (MapType0Select (|Map#Domain| (|Map#Empty| U@@5 V@@3)) u@@5)))) :qid |DafnyPre.1001:21| :skolemid |250| :pattern ((let ((U@@5 (type u@@5))) (MapType0Select (|Map#Domain| (|Map#Empty| U@@5 V@@3)) u@@5))))))
(assert (forall ((m@@8 T@U)) (! (let ((V@@4 (MapTypeInv1 (type m@@8)))) (let ((U@@6 (MapTypeInv0 (type m@@8)))) (=> (= (type m@@8) (MapType U@@6 V@@4)) (and (and (=> (= (|Map#Card| m@@8) 0) (= m@@8 (|Map#Empty| U@@6 V@@4))) (=> (= m@@8 (|Map#Empty| U@@6 V@@4)) (= (|Map#Card| m@@8) 0))) (=> (not (= (|Map#Card| m@@8) 0)) (exists ((x@@39 T@U)) (! (and (= (type x@@39) U@@6) (U_2_bool (MapType0Select (|Map#Domain| m@@8) x@@39))) :qid |DafnyPre.1006:32| :skolemid |251| :no-pattern (type x@@39) :no-pattern (U_2_int x@@39) :no-pattern (U_2_bool x@@39)))))))) :qid |DafnyPre.1004:21| :skolemid |252| :pattern ((|Map#Card| m@@8)))))
(assert (forall ((arg0@@83 T@U) (arg1@@37 T@U) (arg2@@3 T@U)) (! (let ((V@@5 (MapType0TypeInv1 (type arg1@@37)))) (let ((U@@7 (MapType0TypeInv0 (type arg0@@83)))) (= (type (|Map#Glue| arg0@@83 arg1@@37 arg2@@3)) (MapType U@@7 V@@5)))) :qid |funType:Map#Glue| :pattern ((|Map#Glue| arg0@@83 arg1@@37 arg2@@3)))))
(assert (forall ((a@@71 T@U) (b@@50 T@U) (t@@29 T@U)) (! (let ((V@@6 (MapType0TypeInv1 (type b@@50)))) (let ((U@@8 (MapType0TypeInv0 (type a@@71)))) (=> (and (and (= (type a@@71) (MapType0Type U@@8 boolType)) (= (type b@@50) (MapType0Type U@@8 V@@6))) (= (type t@@29) TyType)) (= (|Map#Domain| (|Map#Glue| a@@71 b@@50 t@@29)) a@@71)))) :qid |DafnyPre.1009:21| :skolemid |253| :pattern ((|Map#Domain| (|Map#Glue| a@@71 b@@50 t@@29))))))
(assert (forall ((a@@72 T@U) (b@@51 T@U) (t@@30 T@U)) (! (let ((V@@7 (MapType0TypeInv1 (type b@@51)))) (let ((U@@9 (MapType0TypeInv0 (type a@@72)))) (=> (and (and (= (type a@@72) (MapType0Type U@@9 boolType)) (= (type b@@51) (MapType0Type U@@9 V@@7))) (= (type t@@30) TyType)) (= (|Map#Elements| (|Map#Glue| a@@72 b@@51 t@@30)) b@@51)))) :qid |DafnyPre.1012:21| :skolemid |254| :pattern ((|Map#Elements| (|Map#Glue| a@@72 b@@51 t@@30))))))
(assert (forall ((a@@73 T@U) (b@@52 T@U) (t@@31 T@U)) (! (let ((V@@8 (MapType0TypeInv1 (type b@@52)))) (let ((U@@10 (MapType0TypeInv0 (type a@@73)))) (=> (and (and (= (type a@@73) (MapType0Type U@@10 boolType)) (= (type b@@52) (MapType0Type U@@10 V@@8))) (= (type t@@31) TyType)) ($Is (|Map#Glue| a@@73 b@@52 t@@31) t@@31)))) :qid |DafnyPre.1015:21| :skolemid |255| :pattern (($Is (|Map#Glue| a@@73 b@@52 t@@31) t@@31)))))
(assert (forall ((arg0@@84 T@U) (arg1@@38 T@U) (arg2@@4 T@U)) (! (let ((V@@9 (type arg2@@4))) (let ((U@@11 (type arg1@@38))) (= (type (|Map#Build| arg0@@84 arg1@@38 arg2@@4)) (MapType U@@11 V@@9)))) :qid |funType:Map#Build| :pattern ((|Map#Build| arg0@@84 arg1@@38 arg2@@4)))))
(assert (forall ((m@@9 T@U) (u@@6 T@U) (|u'| T@U) (v@@38 T@U)) (! (let ((V@@10 (type v@@38))) (let ((U@@12 (type u@@6))) (=> (and (= (type m@@9) (MapType U@@12 V@@10)) (= (type |u'|) U@@12)) (and (=> (= |u'| u@@6) (and (U_2_bool (MapType0Select (|Map#Domain| (|Map#Build| m@@9 u@@6 v@@38)) |u'|)) (= (MapType0Select (|Map#Elements| (|Map#Build| m@@9 u@@6 v@@38)) |u'|) v@@38))) (=> (not (= |u'| u@@6)) (and (and (=> (U_2_bool (MapType0Select (|Map#Domain| (|Map#Build| m@@9 u@@6 v@@38)) |u'|)) (U_2_bool (MapType0Select (|Map#Domain| m@@9) |u'|))) (=> (U_2_bool (MapType0Select (|Map#Domain| m@@9) |u'|)) (U_2_bool (MapType0Select (|Map#Domain| (|Map#Build| m@@9 u@@6 v@@38)) |u'|)))) (= (MapType0Select (|Map#Elements| (|Map#Build| m@@9 u@@6 v@@38)) |u'|) (MapType0Select (|Map#Elements| m@@9) |u'|)))))))) :qid |DafnyPre.1026:21| :skolemid |256| :pattern ((MapType0Select (|Map#Domain| (|Map#Build| m@@9 u@@6 v@@38)) |u'|)) :pattern ((MapType0Select (|Map#Elements| (|Map#Build| m@@9 u@@6 v@@38)) |u'|)))))
(assert (forall ((m@@10 T@U) (u@@7 T@U) (v@@39 T@U)) (! (let ((V@@11 (type v@@39))) (let ((U@@13 (type u@@7))) (=> (and (= (type m@@10) (MapType U@@13 V@@11)) (U_2_bool (MapType0Select (|Map#Domain| m@@10) u@@7))) (= (|Map#Card| (|Map#Build| m@@10 u@@7 v@@39)) (|Map#Card| m@@10))))) :qid |DafnyPre.1032:21| :skolemid |257| :pattern ((|Map#Card| (|Map#Build| m@@10 u@@7 v@@39))))))
(assert (forall ((m@@11 T@U) (u@@8 T@U) (v@@40 T@U)) (! (let ((V@@12 (type v@@40))) (let ((U@@14 (type u@@8))) (=> (and (= (type m@@11) (MapType U@@14 V@@12)) (not (U_2_bool (MapType0Select (|Map#Domain| m@@11) u@@8)))) (= (|Map#Card| (|Map#Build| m@@11 u@@8 v@@40)) (+ (|Map#Card| m@@11) 1))))) :qid |DafnyPre.1034:21| :skolemid |258| :pattern ((|Map#Card| (|Map#Build| m@@11 u@@8 v@@40))))))
(assert (forall ((m@@12 T@U) (|m'| T@U)) (! (let ((V@@13 (MapTypeInv1 (type m@@12)))) (let ((U@@15 (MapTypeInv0 (type m@@12)))) (=> (and (= (type m@@12) (MapType U@@15 V@@13)) (= (type |m'|) (MapType U@@15 V@@13))) (and (=> (|Map#Equal| m@@12 |m'|) (and (forall ((u@@9 T@U)) (! (=> (= (type u@@9) U@@15) (and (=> (U_2_bool (MapType0Select (|Map#Domain| m@@12) u@@9)) (U_2_bool (MapType0Select (|Map#Domain| |m'|) u@@9))) (=> (U_2_bool (MapType0Select (|Map#Domain| |m'|) u@@9)) (U_2_bool (MapType0Select (|Map#Domain| m@@12) u@@9))))) :qid |DafnyPre.1042:35| :skolemid |259| :no-pattern (type u@@9) :no-pattern (U_2_int u@@9) :no-pattern (U_2_bool u@@9))) (forall ((u@@10 T@U)) (! (=> (and (= (type u@@10) U@@15) (U_2_bool (MapType0Select (|Map#Domain| m@@12) u@@10))) (= (MapType0Select (|Map#Elements| m@@12) u@@10) (MapType0Select (|Map#Elements| |m'|) u@@10))) :qid |DafnyPre.1043:35| :skolemid |260| :no-pattern (type u@@10) :no-pattern (U_2_int u@@10) :no-pattern (U_2_bool u@@10))))) (=> (and (forall ((u@@11 T@U)) (! (=> (= (type u@@11) U@@15) (and (=> (U_2_bool (MapType0Select (|Map#Domain| m@@12) u@@11)) (U_2_bool (MapType0Select (|Map#Domain| |m'|) u@@11))) (=> (U_2_bool (MapType0Select (|Map#Domain| |m'|) u@@11)) (U_2_bool (MapType0Select (|Map#Domain| m@@12) u@@11))))) :qid |DafnyPre.1042:35| :skolemid |259| :no-pattern (type u@@11) :no-pattern (U_2_int u@@11) :no-pattern (U_2_bool u@@11))) (forall ((u@@12 T@U)) (! (=> (and (= (type u@@12) U@@15) (U_2_bool (MapType0Select (|Map#Domain| m@@12) u@@12))) (= (MapType0Select (|Map#Elements| m@@12) u@@12) (MapType0Select (|Map#Elements| |m'|) u@@12))) :qid |DafnyPre.1043:35| :skolemid |260| :no-pattern (type u@@12) :no-pattern (U_2_int u@@12) :no-pattern (U_2_bool u@@12)))) (|Map#Equal| m@@12 |m'|)))))) :qid |DafnyPre.1040:21| :skolemid |261| :pattern ((|Map#Equal| m@@12 |m'|)))))
(assert (forall ((m@@13 T@U) (|m'@@0| T@U)) (! (let ((V@@14 (MapTypeInv1 (type m@@13)))) (let ((U@@16 (MapTypeInv0 (type m@@13)))) (=> (and (and (= (type m@@13) (MapType U@@16 V@@14)) (= (type |m'@@0|) (MapType U@@16 V@@14))) (|Map#Equal| m@@13 |m'@@0|)) (= m@@13 |m'@@0|)))) :qid |DafnyPre.1045:21| :skolemid |262| :pattern ((|Map#Equal| m@@13 |m'@@0|)))))
(assert (forall ((m@@14 T@U) (|m'@@1| T@U)) (! (let ((V@@15 (MapTypeInv1 (type m@@14)))) (let ((U@@17 (MapTypeInv0 (type m@@14)))) (=> (and (= (type m@@14) (MapType U@@17 V@@15)) (= (type |m'@@1|) (MapType U@@17 V@@15))) (and (=> (|Map#Disjoint| m@@14 |m'@@1|) (forall ((o@@37 T@U)) (! (=> (= (type o@@37) U@@17) (or (not (U_2_bool (MapType0Select (|Map#Domain| m@@14) o@@37))) (not (U_2_bool (MapType0Select (|Map#Domain| |m'@@1|) o@@37))))) :qid |DafnyPre.1052:38| :skolemid |263| :pattern ((MapType0Select (|Map#Domain| m@@14) o@@37)) :pattern ((MapType0Select (|Map#Domain| |m'@@1|) o@@37))))) (=> (forall ((o@@38 T@U)) (! (=> (= (type o@@38) U@@17) (or (not (U_2_bool (MapType0Select (|Map#Domain| m@@14) o@@38))) (not (U_2_bool (MapType0Select (|Map#Domain| |m'@@1|) o@@38))))) :qid |DafnyPre.1052:38| :skolemid |263| :pattern ((MapType0Select (|Map#Domain| m@@14) o@@38)) :pattern ((MapType0Select (|Map#Domain| |m'@@1|) o@@38)))) (|Map#Disjoint| m@@14 |m'@@1|)))))) :qid |DafnyPre.1050:21| :skolemid |264| :pattern ((|Map#Disjoint| m@@14 |m'@@1|)))))
(assert (forall ((U@@18 T@T) (V@@16 T@T)) (! (= (type (|IMap#Empty| U@@18 V@@16)) (IMapType U@@18 V@@16)) :qid |funType:IMap#Empty| :pattern ((|IMap#Empty| U@@18 V@@16)))))
(assert (forall ((u@@13 T@U) (V@@17 T@T)) (! (let ((U@@19 (type u@@13))) (not (U_2_bool (MapType0Select (|IMap#Domain| (|IMap#Empty| U@@19 V@@17)) u@@13)))) :qid |DafnyPre.1064:21| :skolemid |265| :pattern ((let ((U@@19 (type u@@13))) (MapType0Select (|IMap#Domain| (|IMap#Empty| U@@19 V@@17)) u@@13))))))
(assert (forall ((arg0@@85 T@U) (arg1@@39 T@U) (arg2@@5 T@U)) (! (let ((V@@18 (MapType0TypeInv1 (type arg1@@39)))) (let ((U@@20 (MapType0TypeInv0 (type arg0@@85)))) (= (type (|IMap#Glue| arg0@@85 arg1@@39 arg2@@5)) (IMapType U@@20 V@@18)))) :qid |funType:IMap#Glue| :pattern ((|IMap#Glue| arg0@@85 arg1@@39 arg2@@5)))))
(assert (forall ((a@@74 T@U) (b@@53 T@U) (t@@32 T@U)) (! (let ((V@@19 (MapType0TypeInv1 (type b@@53)))) (let ((U@@21 (MapType0TypeInv0 (type a@@74)))) (=> (and (and (= (type a@@74) (MapType0Type U@@21 boolType)) (= (type b@@53) (MapType0Type U@@21 V@@19))) (= (type t@@32) TyType)) (= (|IMap#Domain| (|IMap#Glue| a@@74 b@@53 t@@32)) a@@74)))) :qid |DafnyPre.1069:21| :skolemid |266| :pattern ((|IMap#Domain| (|IMap#Glue| a@@74 b@@53 t@@32))))))
(assert (forall ((a@@75 T@U) (b@@54 T@U) (t@@33 T@U)) (! (let ((V@@20 (MapType0TypeInv1 (type b@@54)))) (let ((U@@22 (MapType0TypeInv0 (type a@@75)))) (=> (and (and (= (type a@@75) (MapType0Type U@@22 boolType)) (= (type b@@54) (MapType0Type U@@22 V@@20))) (= (type t@@33) TyType)) (= (|IMap#Elements| (|IMap#Glue| a@@75 b@@54 t@@33)) b@@54)))) :qid |DafnyPre.1072:21| :skolemid |267| :pattern ((|IMap#Elements| (|IMap#Glue| a@@75 b@@54 t@@33))))))
(assert (forall ((a@@76 T@U) (b@@55 T@U) (t@@34 T@U)) (! (let ((V@@21 (MapType0TypeInv1 (type b@@55)))) (let ((U@@23 (MapType0TypeInv0 (type a@@76)))) (=> (and (and (= (type a@@76) (MapType0Type U@@23 boolType)) (= (type b@@55) (MapType0Type U@@23 V@@21))) (= (type t@@34) TyType)) ($Is (|IMap#Glue| a@@76 b@@55 t@@34) t@@34)))) :qid |DafnyPre.1075:21| :skolemid |268| :pattern (($Is (|IMap#Glue| a@@76 b@@55 t@@34) t@@34)))))
(assert (forall ((arg0@@86 T@U) (arg1@@40 T@U) (arg2@@6 T@U)) (! (let ((V@@22 (type arg2@@6))) (let ((U@@24 (type arg1@@40))) (= (type (|IMap#Build| arg0@@86 arg1@@40 arg2@@6)) (IMapType U@@24 V@@22)))) :qid |funType:IMap#Build| :pattern ((|IMap#Build| arg0@@86 arg1@@40 arg2@@6)))))
(assert (forall ((m@@15 T@U) (u@@14 T@U) (|u'@@0| T@U) (v@@41 T@U)) (! (let ((V@@23 (type v@@41))) (let ((U@@25 (type u@@14))) (=> (and (= (type m@@15) (IMapType U@@25 V@@23)) (= (type |u'@@0|) U@@25)) (and (=> (= |u'@@0| u@@14) (and (U_2_bool (MapType0Select (|IMap#Domain| (|IMap#Build| m@@15 u@@14 v@@41)) |u'@@0|)) (= (MapType0Select (|IMap#Elements| (|IMap#Build| m@@15 u@@14 v@@41)) |u'@@0|) v@@41))) (=> (not (= |u'@@0| u@@14)) (and (and (=> (U_2_bool (MapType0Select (|IMap#Domain| (|IMap#Build| m@@15 u@@14 v@@41)) |u'@@0|)) (U_2_bool (MapType0Select (|IMap#Domain| m@@15) |u'@@0|))) (=> (U_2_bool (MapType0Select (|IMap#Domain| m@@15) |u'@@0|)) (U_2_bool (MapType0Select (|IMap#Domain| (|IMap#Build| m@@15 u@@14 v@@41)) |u'@@0|)))) (= (MapType0Select (|IMap#Elements| (|IMap#Build| m@@15 u@@14 v@@41)) |u'@@0|) (MapType0Select (|IMap#Elements| m@@15) |u'@@0|)))))))) :qid |DafnyPre.1085:21| :skolemid |269| :pattern ((MapType0Select (|IMap#Domain| (|IMap#Build| m@@15 u@@14 v@@41)) |u'@@0|)) :pattern ((MapType0Select (|IMap#Elements| (|IMap#Build| m@@15 u@@14 v@@41)) |u'@@0|)))))
(assert (forall ((m@@16 T@U) (|m'@@2| T@U)) (! (let ((V@@24 (IMapTypeInv1 (type m@@16)))) (let ((U@@26 (IMapTypeInv0 (type m@@16)))) (=> (and (= (type m@@16) (IMapType U@@26 V@@24)) (= (type |m'@@2|) (IMapType U@@26 V@@24))) (and (=> (|IMap#Equal| m@@16 |m'@@2|) (and (forall ((u@@15 T@U)) (! (=> (= (type u@@15) U@@26) (and (=> (U_2_bool (MapType0Select (|IMap#Domain| m@@16) u@@15)) (U_2_bool (MapType0Select (|IMap#Domain| |m'@@2|) u@@15))) (=> (U_2_bool (MapType0Select (|IMap#Domain| |m'@@2|) u@@15)) (U_2_bool (MapType0Select (|IMap#Domain| m@@16) u@@15))))) :qid |DafnyPre.1096:36| :skolemid |270| :no-pattern (type u@@15) :no-pattern (U_2_int u@@15) :no-pattern (U_2_bool u@@15))) (forall ((u@@16 T@U)) (! (=> (and (= (type u@@16) U@@26) (U_2_bool (MapType0Select (|IMap#Domain| m@@16) u@@16))) (= (MapType0Select (|IMap#Elements| m@@16) u@@16) (MapType0Select (|IMap#Elements| |m'@@2|) u@@16))) :qid |DafnyPre.1097:35| :skolemid |271| :no-pattern (type u@@16) :no-pattern (U_2_int u@@16) :no-pattern (U_2_bool u@@16))))) (=> (and (forall ((u@@17 T@U)) (! (=> (= (type u@@17) U@@26) (and (=> (U_2_bool (MapType0Select (|IMap#Domain| m@@16) u@@17)) (U_2_bool (MapType0Select (|IMap#Domain| |m'@@2|) u@@17))) (=> (U_2_bool (MapType0Select (|IMap#Domain| |m'@@2|) u@@17)) (U_2_bool (MapType0Select (|IMap#Domain| m@@16) u@@17))))) :qid |DafnyPre.1096:36| :skolemid |270| :no-pattern (type u@@17) :no-pattern (U_2_int u@@17) :no-pattern (U_2_bool u@@17))) (forall ((u@@18 T@U)) (! (=> (and (= (type u@@18) U@@26) (U_2_bool (MapType0Select (|IMap#Domain| m@@16) u@@18))) (= (MapType0Select (|IMap#Elements| m@@16) u@@18) (MapType0Select (|IMap#Elements| |m'@@2|) u@@18))) :qid |DafnyPre.1097:35| :skolemid |271| :no-pattern (type u@@18) :no-pattern (U_2_int u@@18) :no-pattern (U_2_bool u@@18)))) (|IMap#Equal| m@@16 |m'@@2|)))))) :qid |DafnyPre.1094:21| :skolemid |272| :pattern ((|IMap#Equal| m@@16 |m'@@2|)))))
(assert (forall ((m@@17 T@U) (|m'@@3| T@U)) (! (let ((V@@25 (IMapTypeInv1 (type m@@17)))) (let ((U@@27 (IMapTypeInv0 (type m@@17)))) (=> (and (and (= (type m@@17) (IMapType U@@27 V@@25)) (= (type |m'@@3|) (IMapType U@@27 V@@25))) (|IMap#Equal| m@@17 |m'@@3|)) (= m@@17 |m'@@3|)))) :qid |DafnyPre.1099:21| :skolemid |273| :pattern ((|IMap#Equal| m@@17 |m'@@3|)))))
(assert (forall ((x@@40 Int) (y@@12 Int)) (! (= (INTERNAL_add_boogie x@@40 y@@12) (+ x@@40 y@@12)) :qid |DafnyPre.1107:30| :skolemid |274| :pattern ((INTERNAL_add_boogie x@@40 y@@12)))))
(assert (forall ((x@@41 Int) (y@@13 Int)) (! (= (INTERNAL_sub_boogie x@@41 y@@13) (- x@@41 y@@13)) :qid |DafnyPre.1108:30| :skolemid |275| :pattern ((INTERNAL_sub_boogie x@@41 y@@13)))))
(assert (forall ((x@@42 Int) (y@@14 Int)) (! (= (INTERNAL_mul_boogie x@@42 y@@14) (* x@@42 y@@14)) :qid |DafnyPre.1109:30| :skolemid |276| :pattern ((INTERNAL_mul_boogie x@@42 y@@14)))))
(assert (forall ((x@@43 Int) (y@@15 Int)) (! (= (INTERNAL_div_boogie x@@43 y@@15) (div x@@43 y@@15)) :qid |DafnyPre.1110:30| :skolemid |277| :pattern ((INTERNAL_div_boogie x@@43 y@@15)))))
(assert (forall ((x@@44 Int) (y@@16 Int)) (! (= (INTERNAL_mod_boogie x@@44 y@@16) (mod x@@44 y@@16)) :qid |DafnyPre.1111:30| :skolemid |278| :pattern ((INTERNAL_mod_boogie x@@44 y@@16)))))
(assert (forall ((x@@45 Int) (y@@17 Int)) (! (and (=> (INTERNAL_lt_boogie x@@45 y@@17) (< x@@45 y@@17)) (=> (< x@@45 y@@17) (INTERNAL_lt_boogie x@@45 y@@17))) :qid |DafnyPre.1112:51| :skolemid |279| :pattern ((INTERNAL_lt_boogie x@@45 y@@17)))))
(assert (forall ((x@@46 Int) (y@@18 Int)) (! (and (=> (INTERNAL_le_boogie x@@46 y@@18) (<= x@@46 y@@18)) (=> (<= x@@46 y@@18) (INTERNAL_le_boogie x@@46 y@@18))) :qid |DafnyPre.1113:51| :skolemid |280| :pattern ((INTERNAL_le_boogie x@@46 y@@18)))))
(assert (forall ((x@@47 Int) (y@@19 Int)) (! (and (=> (INTERNAL_gt_boogie x@@47 y@@19) (> x@@47 y@@19)) (=> (> x@@47 y@@19) (INTERNAL_gt_boogie x@@47 y@@19))) :qid |DafnyPre.1114:51| :skolemid |281| :pattern ((INTERNAL_gt_boogie x@@47 y@@19)))))
(assert (forall ((x@@48 Int) (y@@20 Int)) (! (and (=> (INTERNAL_ge_boogie x@@48 y@@20) (>= x@@48 y@@20)) (=> (>= x@@48 y@@20) (INTERNAL_ge_boogie x@@48 y@@20))) :qid |DafnyPre.1115:51| :skolemid |282| :pattern ((INTERNAL_ge_boogie x@@48 y@@20)))))
(assert (= (Tag Tclass._System.object) Tagclass._System.object))
(assert (forall ((bx@@35 T@U)) (! (=> (and (= (type bx@@35) BoxType) ($IsBox bx@@35 Tclass._System.object)) (and (= ($Box ($Unbox refType bx@@35)) bx@@35) ($Is ($Unbox refType bx@@35) Tclass._System.object))) :qid |unknown.0:0| :skolemid |283| :pattern (($IsBox bx@@35 Tclass._System.object)))))
(assert (forall (($o T@U)) (! (=> (= (type $o) refType) ($Is $o Tclass._System.object)) :qid |unknown.0:0| :skolemid |284| :pattern (($Is $o Tclass._System.object)))))
(assert (= (type null) refType))
(assert (forall (($o@@0 T@U) ($h T@U)) (! (=> (and (= (type $o@@0) refType) (= (type $h) (MapType1Type refType))) (and (=> ($IsAlloc $o@@0 Tclass._System.object $h) (or (= $o@@0 null) (U_2_bool (MapType1Select $h $o@@0 alloc)))) (=> (or (= $o@@0 null) (U_2_bool (MapType1Select $h $o@@0 alloc))) ($IsAlloc $o@@0 Tclass._System.object $h)))) :qid |unknown.0:0| :skolemid |285| :pattern (($IsAlloc $o@@0 Tclass._System.object $h)))))
(assert (forall ((arg0@@87 T@U)) (! (= (type (Tclass._System.array arg0@@87)) TyType) :qid |funType:Tclass._System.array| :pattern ((Tclass._System.array arg0@@87)))))
(assert (forall ((|#$arg| T@U)) (! (=> (= (type |#$arg|) TyType) (= (Tag (Tclass._System.array |#$arg|)) Tagclass._System.array)) :qid |unknown.0:0| :skolemid |286| :pattern ((Tclass._System.array |#$arg|)))))
(assert (forall ((arg0@@88 T@U)) (! (= (type (Tclass._System.array_0 arg0@@88)) TyType) :qid |funType:Tclass._System.array_0| :pattern ((Tclass._System.array_0 arg0@@88)))))
(assert (forall ((|#$arg@@0| T@U)) (! (=> (= (type |#$arg@@0|) TyType) (= (Tclass._System.array_0 (Tclass._System.array |#$arg@@0|)) |#$arg@@0|)) :qid |unknown.0:0| :skolemid |287| :pattern ((Tclass._System.array |#$arg@@0|)))))
(assert (forall ((|#$arg@@1| T@U) (bx@@36 T@U)) (! (=> (and (and (= (type |#$arg@@1|) TyType) (= (type bx@@36) BoxType)) ($IsBox bx@@36 (Tclass._System.array |#$arg@@1|))) (and (= ($Box ($Unbox refType bx@@36)) bx@@36) ($Is ($Unbox refType bx@@36) (Tclass._System.array |#$arg@@1|)))) :qid |unknown.0:0| :skolemid |288| :pattern (($IsBox bx@@36 (Tclass._System.array |#$arg@@1|))))))
(assert (forall ((arg0@@89 T@U)) (! (= (type (dtype arg0@@89)) TyType) :qid |funType:dtype| :pattern ((dtype arg0@@89)))))
(assert (forall ((|#$arg@@2| T@U) ($i0 Int) ($h@@0 T@U) ($o@@1 T@U)) (! (=> (and (and (= (type |#$arg@@2|) TyType) (= (type $h@@0) (MapType1Type refType))) (= (type $o@@1) refType)) (=> (and (and (and ($IsGoodHeap $h@@0) (not (= $o@@1 null))) (= (dtype $o@@1) (Tclass._System.array |#$arg@@2|))) (and (<= 0 $i0) (< $i0 (_System.array.Length $o@@1)))) (and ($IsBox (MapType1Select $h@@0 $o@@1 (IndexField $i0)) |#$arg@@2|) (=> (U_2_bool (MapType1Select $h@@0 $o@@1 alloc)) ($IsAllocBox (MapType1Select $h@@0 $o@@1 (IndexField $i0)) |#$arg@@2| $h@@0))))) :qid |unknown.0:0| :skolemid |289| :pattern ((MapType1Select $h@@0 $o@@1 (IndexField $i0)) (Tclass._System.array |#$arg@@2|)))))
(assert (forall ((|#$arg@@3| T@U) ($o@@2 T@U)) (! (=> (and (= (type |#$arg@@3|) TyType) (= (type $o@@2) refType)) (and (=> ($Is $o@@2 (Tclass._System.array |#$arg@@3|)) (or (= $o@@2 null) (= (dtype $o@@2) (Tclass._System.array |#$arg@@3|)))) (=> (or (= $o@@2 null) (= (dtype $o@@2) (Tclass._System.array |#$arg@@3|))) ($Is $o@@2 (Tclass._System.array |#$arg@@3|))))) :qid |unknown.0:0| :skolemid |290| :pattern (($Is $o@@2 (Tclass._System.array |#$arg@@3|))))))
(assert (forall ((|#$arg@@4| T@U) ($o@@3 T@U) ($h@@1 T@U)) (! (=> (and (and (= (type |#$arg@@4|) TyType) (= (type $o@@3) refType)) (= (type $h@@1) (MapType1Type refType))) (and (=> ($IsAlloc $o@@3 (Tclass._System.array |#$arg@@4|) $h@@1) (or (= $o@@3 null) (U_2_bool (MapType1Select $h@@1 $o@@3 alloc)))) (=> (or (= $o@@3 null) (U_2_bool (MapType1Select $h@@1 $o@@3 alloc))) ($IsAlloc $o@@3 (Tclass._System.array |#$arg@@4|) $h@@1)))) :qid |unknown.0:0| :skolemid |291| :pattern (($IsAlloc $o@@3 (Tclass._System.array |#$arg@@4|) $h@@1)))))
(assert (forall ((|#$arg@@5| T@U) ($h@@2 T@U) ($o@@4 T@U)) (! (=> (and (and (and (= (type |#$arg@@5|) TyType) (= (type $h@@2) (MapType1Type refType))) (= (type $o@@4) refType)) (and (and ($IsGoodHeap $h@@2) (not (= $o@@4 null))) (= (dtype $o@@4) (Tclass._System.array |#$arg@@5|)))) (and ($Is (int_2_U (_System.array.Length $o@@4)) TInt) (=> (U_2_bool (MapType1Select $h@@2 $o@@4 alloc)) ($IsAlloc (int_2_U (_System.array.Length $o@@4)) TInt $h@@2)))) :qid |unknown.0:0| :skolemid |292| :no-pattern (type |#$arg@@5|) :no-pattern (type $h@@2) :no-pattern (type $o@@4) :no-pattern (U_2_int |#$arg@@5|) :no-pattern (U_2_bool |#$arg@@5|) :no-pattern (U_2_int $h@@2) :no-pattern (U_2_bool $h@@2) :no-pattern (U_2_int $o@@4) :no-pattern (U_2_bool $o@@4))))
(assert (forall ((arg0@@90 T@U)) (! (= (type (Tclass._System.___hFunc0 arg0@@90)) TyType) :qid |funType:Tclass._System.___hFunc0| :pattern ((Tclass._System.___hFunc0 arg0@@90)))))
(assert (forall ((|#$T0| T@U)) (! (=> (= (type |#$T0|) TyType) (= (Tag (Tclass._System.___hFunc0 |#$T0|)) Tagclass._System.___hFunc0)) :qid |unknown.0:0| :skolemid |293| :pattern ((Tclass._System.___hFunc0 |#$T0|)))))
(assert (forall ((arg0@@91 T@U)) (! (= (type (Tclass._System.___hFunc0_0 arg0@@91)) TyType) :qid |funType:Tclass._System.___hFunc0_0| :pattern ((Tclass._System.___hFunc0_0 arg0@@91)))))
(assert (forall ((|#$T0@@0| T@U)) (! (=> (= (type |#$T0@@0|) TyType) (= (Tclass._System.___hFunc0_0 (Tclass._System.___hFunc0 |#$T0@@0|)) |#$T0@@0|)) :qid |unknown.0:0| :skolemid |294| :pattern ((Tclass._System.___hFunc0 |#$T0@@0|)))))
(assert (= (Ctor HandleTypeType) 18))
(assert (forall ((|#$T0@@1| T@U) (bx@@37 T@U)) (! (=> (and (and (= (type |#$T0@@1|) TyType) (= (type bx@@37) BoxType)) ($IsBox bx@@37 (Tclass._System.___hFunc0 |#$T0@@1|))) (and (= ($Box ($Unbox HandleTypeType bx@@37)) bx@@37) ($Is ($Unbox HandleTypeType bx@@37) (Tclass._System.___hFunc0 |#$T0@@1|)))) :qid |unknown.0:0| :skolemid |295| :pattern (($IsBox bx@@37 (Tclass._System.___hFunc0 |#$T0@@1|))))))
(assert (and (forall ((arg0@@92 T@U) (arg1@@41 T@U) (arg2@@7 T@U)) (! (= (type (Apply0 arg0@@92 arg1@@41 arg2@@7)) BoxType) :qid |funType:Apply0| :pattern ((Apply0 arg0@@92 arg1@@41 arg2@@7)))) (forall ((arg0@@93 T@U) (arg1@@42 T@U) (arg2@@8 T@U)) (! (= (type (Handle0 arg0@@93 arg1@@42 arg2@@8)) HandleTypeType) :qid |funType:Handle0| :pattern ((Handle0 arg0@@93 arg1@@42 arg2@@8))))))
(assert (forall ((t0@@12 T@U) (heap T@U) (h@@20 T@U) (r@@5 T@U) (rd T@U)) (! (=> (and (and (and (and (= (type t0@@12) TyType) (= (type heap) (MapType1Type refType))) (= (type h@@20) (MapType0Type (MapType1Type refType) BoxType))) (= (type r@@5) (MapType0Type (MapType1Type refType) boolType))) (= (type rd) (MapType0Type (MapType1Type refType) (MapType0Type BoxType boolType)))) (= (Apply0 t0@@12 (Handle0 h@@20 r@@5 rd) heap) (MapType0Select h@@20 heap))) :qid |unknown.0:0| :skolemid |296| :pattern ((Apply0 t0@@12 (Handle0 h@@20 r@@5 rd) heap)))))
(assert (forall ((t0@@13 T@U) (heap@@0 T@U) (h@@21 T@U) (r@@6 T@U) (rd@@0 T@U)) (! (=> (and (and (and (and (and (= (type t0@@13) TyType) (= (type heap@@0) (MapType1Type refType))) (= (type h@@21) (MapType0Type (MapType1Type refType) BoxType))) (= (type r@@6) (MapType0Type (MapType1Type refType) boolType))) (= (type rd@@0) (MapType0Type (MapType1Type refType) (MapType0Type BoxType boolType)))) (U_2_bool (MapType0Select r@@6 heap@@0))) (Requires0 t0@@13 (Handle0 h@@21 r@@6 rd@@0) heap@@0)) :qid |unknown.0:0| :skolemid |297| :pattern ((Requires0 t0@@13 (Handle0 h@@21 r@@6 rd@@0) heap@@0)))))
(assert (forall ((arg0@@94 T@U) (arg1@@43 T@U) (arg2@@9 T@U)) (! (= (type (Reads0 arg0@@94 arg1@@43 arg2@@9)) (MapType0Type BoxType boolType)) :qid |funType:Reads0| :pattern ((Reads0 arg0@@94 arg1@@43 arg2@@9)))))
(assert (forall ((t0@@14 T@U) (heap@@1 T@U) (h@@22 T@U) (r@@7 T@U) (rd@@1 T@U) (bx@@38 T@U)) (! (=> (and (and (and (and (and (= (type t0@@14) TyType) (= (type heap@@1) (MapType1Type refType))) (= (type h@@22) (MapType0Type (MapType1Type refType) BoxType))) (= (type r@@7) (MapType0Type (MapType1Type refType) boolType))) (= (type rd@@1) (MapType0Type (MapType1Type refType) (MapType0Type BoxType boolType)))) (= (type bx@@38) BoxType)) (and (=> (U_2_bool (MapType0Select (Reads0 t0@@14 (Handle0 h@@22 r@@7 rd@@1) heap@@1) bx@@38)) (U_2_bool (MapType0Select (MapType0Select rd@@1 heap@@1) bx@@38))) (=> (U_2_bool (MapType0Select (MapType0Select rd@@1 heap@@1) bx@@38)) (U_2_bool (MapType0Select (Reads0 t0@@14 (Handle0 h@@22 r@@7 rd@@1) heap@@1) bx@@38))))) :qid |unknown.0:0| :skolemid |298| :pattern ((MapType0Select (Reads0 t0@@14 (Handle0 h@@22 r@@7 rd@@1) heap@@1) bx@@38)))))
(assert (forall ((t0@@15 T@U) (h0@@0 T@U) (h1@@0 T@U) (f@@5 T@U)) (! (=> (and (and (and (and (= (type t0@@15) TyType) (= (type h0@@0) (MapType1Type refType))) (= (type h1@@0) (MapType1Type refType))) (= (type f@@5) HandleTypeType)) (and (and (and ($HeapSucc h0@@0 h1@@0) (and ($IsGoodHeap h0@@0) ($IsGoodHeap h1@@0))) (and ($Is f@@5 (Tclass._System.___hFunc0 t0@@15)) ($IsAlloc f@@5 (Tclass._System.___hFunc0 t0@@15) h0@@0))) (forall ((o@@39 T@U) (fld T@U)) (! (let ((a@@77 (FieldTypeInv0 (type fld)))) (=> (and (= (type o@@39) refType) (= (type fld) (FieldType a@@77))) (=> (and (and (and (not (= o@@39 null)) (U_2_bool (MapType1Select h0@@0 o@@39 alloc))) (U_2_bool (MapType1Select h1@@0 o@@39 alloc))) (U_2_bool (MapType0Select (Reads0 t0@@15 f@@5 h0@@0) ($Box o@@39)))) (= (MapType1Select h0@@0 o@@39 fld) (MapType1Select h1@@0 o@@39 fld))))) :qid |unknown.0:0| :skolemid |299| :no-pattern (type o@@39) :no-pattern (type fld) :no-pattern (U_2_int o@@39) :no-pattern (U_2_bool o@@39) :no-pattern (U_2_int fld) :no-pattern (U_2_bool fld))))) (= (Reads0 t0@@15 f@@5 h0@@0) (Reads0 t0@@15 f@@5 h1@@0))) :qid |unknown.0:0| :skolemid |300| :pattern (($HeapSucc h0@@0 h1@@0) (Reads0 t0@@15 f@@5 h1@@0)))))
(assert (forall ((t0@@16 T@U) (h0@@1 T@U) (h1@@1 T@U) (f@@6 T@U)) (! (=> (and (and (and (and (= (type t0@@16) TyType) (= (type h0@@1) (MapType1Type refType))) (= (type h1@@1) (MapType1Type refType))) (= (type f@@6) HandleTypeType)) (and (and (and ($HeapSucc h0@@1 h1@@1) (and ($IsGoodHeap h0@@1) ($IsGoodHeap h1@@1))) (and ($Is f@@6 (Tclass._System.___hFunc0 t0@@16)) ($IsAlloc f@@6 (Tclass._System.___hFunc0 t0@@16) h0@@1))) (forall ((o@@40 T@U) (fld@@0 T@U)) (! (let ((a@@78 (FieldTypeInv0 (type fld@@0)))) (=> (and (= (type o@@40) refType) (= (type fld@@0) (FieldType a@@78))) (=> (and (and (and (not (= o@@40 null)) (U_2_bool (MapType1Select h0@@1 o@@40 alloc))) (U_2_bool (MapType1Select h1@@1 o@@40 alloc))) (U_2_bool (MapType0Select (Reads0 t0@@16 f@@6 h1@@1) ($Box o@@40)))) (= (MapType1Select h0@@1 o@@40 fld@@0) (MapType1Select h1@@1 o@@40 fld@@0))))) :qid |unknown.0:0| :skolemid |301| :no-pattern (type o@@40) :no-pattern (type fld@@0) :no-pattern (U_2_int o@@40) :no-pattern (U_2_bool o@@40) :no-pattern (U_2_int fld@@0) :no-pattern (U_2_bool fld@@0))))) (= (Reads0 t0@@16 f@@6 h0@@1) (Reads0 t0@@16 f@@6 h1@@1))) :qid |unknown.0:0| :skolemid |302| :pattern (($HeapSucc h0@@1 h1@@1) (Reads0 t0@@16 f@@6 h1@@1)))))
(assert (forall ((t0@@17 T@U) (h0@@2 T@U) (h1@@2 T@U) (f@@7 T@U)) (! (=> (and (and (and (and (= (type t0@@17) TyType) (= (type h0@@2) (MapType1Type refType))) (= (type h1@@2) (MapType1Type refType))) (= (type f@@7) HandleTypeType)) (and (and (and ($HeapSucc h0@@2 h1@@2) (and ($IsGoodHeap h0@@2) ($IsGoodHeap h1@@2))) (and ($Is f@@7 (Tclass._System.___hFunc0 t0@@17)) ($IsAlloc f@@7 (Tclass._System.___hFunc0 t0@@17) h0@@2))) (forall ((o@@41 T@U) (fld@@1 T@U)) (! (let ((a@@79 (FieldTypeInv0 (type fld@@1)))) (=> (and (= (type o@@41) refType) (= (type fld@@1) (FieldType a@@79))) (=> (and (and (and (not (= o@@41 null)) (U_2_bool (MapType1Select h0@@2 o@@41 alloc))) (U_2_bool (MapType1Select h1@@2 o@@41 alloc))) (U_2_bool (MapType0Select (Reads0 t0@@17 f@@7 h0@@2) ($Box o@@41)))) (= (MapType1Select h0@@2 o@@41 fld@@1) (MapType1Select h1@@2 o@@41 fld@@1))))) :qid |unknown.0:0| :skolemid |303| :no-pattern (type o@@41) :no-pattern (type fld@@1) :no-pattern (U_2_int o@@41) :no-pattern (U_2_bool o@@41) :no-pattern (U_2_int fld@@1) :no-pattern (U_2_bool fld@@1))))) (and (=> (Requires0 t0@@17 f@@7 h0@@2) (Requires0 t0@@17 f@@7 h1@@2)) (=> (Requires0 t0@@17 f@@7 h1@@2) (Requires0 t0@@17 f@@7 h0@@2)))) :qid |unknown.0:0| :skolemid |304| :pattern (($HeapSucc h0@@2 h1@@2) (Requires0 t0@@17 f@@7 h1@@2)))))
(assert (forall ((t0@@18 T@U) (h0@@3 T@U) (h1@@3 T@U) (f@@8 T@U)) (! (=> (and (and (and (and (= (type t0@@18) TyType) (= (type h0@@3) (MapType1Type refType))) (= (type h1@@3) (MapType1Type refType))) (= (type f@@8) HandleTypeType)) (and (and (and ($HeapSucc h0@@3 h1@@3) (and ($IsGoodHeap h0@@3) ($IsGoodHeap h1@@3))) (and ($Is f@@8 (Tclass._System.___hFunc0 t0@@18)) ($IsAlloc f@@8 (Tclass._System.___hFunc0 t0@@18) h0@@3))) (forall ((o@@42 T@U) (fld@@2 T@U)) (! (let ((a@@80 (FieldTypeInv0 (type fld@@2)))) (=> (and (= (type o@@42) refType) (= (type fld@@2) (FieldType a@@80))) (=> (and (and (and (not (= o@@42 null)) (U_2_bool (MapType1Select h0@@3 o@@42 alloc))) (U_2_bool (MapType1Select h1@@3 o@@42 alloc))) (U_2_bool (MapType0Select (Reads0 t0@@18 f@@8 h1@@3) ($Box o@@42)))) (= (MapType1Select h0@@3 o@@42 fld@@2) (MapType1Select h1@@3 o@@42 fld@@2))))) :qid |unknown.0:0| :skolemid |305| :no-pattern (type o@@42) :no-pattern (type fld@@2) :no-pattern (U_2_int o@@42) :no-pattern (U_2_bool o@@42) :no-pattern (U_2_int fld@@2) :no-pattern (U_2_bool fld@@2))))) (and (=> (Requires0 t0@@18 f@@8 h0@@3) (Requires0 t0@@18 f@@8 h1@@3)) (=> (Requires0 t0@@18 f@@8 h1@@3) (Requires0 t0@@18 f@@8 h0@@3)))) :qid |unknown.0:0| :skolemid |306| :pattern (($HeapSucc h0@@3 h1@@3) (Requires0 t0@@18 f@@8 h1@@3)))))
(assert (forall ((t0@@19 T@U) (h0@@4 T@U) (h1@@4 T@U) (f@@9 T@U)) (! (=> (and (and (and (and (= (type t0@@19) TyType) (= (type h0@@4) (MapType1Type refType))) (= (type h1@@4) (MapType1Type refType))) (= (type f@@9) HandleTypeType)) (and (and (and ($HeapSucc h0@@4 h1@@4) (and ($IsGoodHeap h0@@4) ($IsGoodHeap h1@@4))) (and ($Is f@@9 (Tclass._System.___hFunc0 t0@@19)) ($IsAlloc f@@9 (Tclass._System.___hFunc0 t0@@19) h0@@4))) (forall ((o@@43 T@U) (fld@@3 T@U)) (! (let ((a@@81 (FieldTypeInv0 (type fld@@3)))) (=> (and (= (type o@@43) refType) (= (type fld@@3) (FieldType a@@81))) (=> (and (and (and (not (= o@@43 null)) (U_2_bool (MapType1Select h0@@4 o@@43 alloc))) (U_2_bool (MapType1Select h1@@4 o@@43 alloc))) (U_2_bool (MapType0Select (Reads0 t0@@19 f@@9 h0@@4) ($Box o@@43)))) (= (MapType1Select h0@@4 o@@43 fld@@3) (MapType1Select h1@@4 o@@43 fld@@3))))) :qid |unknown.0:0| :skolemid |307| :no-pattern (type o@@43) :no-pattern (type fld@@3) :no-pattern (U_2_int o@@43) :no-pattern (U_2_bool o@@43) :no-pattern (U_2_int fld@@3) :no-pattern (U_2_bool fld@@3))))) (= (Apply0 t0@@19 f@@9 h0@@4) (Apply0 t0@@19 f@@9 h1@@4))) :qid |unknown.0:0| :skolemid |308| :pattern (($HeapSucc h0@@4 h1@@4) (Apply0 t0@@19 f@@9 h1@@4)))))
(assert (forall ((t0@@20 T@U) (h0@@5 T@U) (h1@@5 T@U) (f@@10 T@U)) (! (=> (and (and (and (and (= (type t0@@20) TyType) (= (type h0@@5) (MapType1Type refType))) (= (type h1@@5) (MapType1Type refType))) (= (type f@@10) HandleTypeType)) (and (and (and ($HeapSucc h0@@5 h1@@5) (and ($IsGoodHeap h0@@5) ($IsGoodHeap h1@@5))) (and ($Is f@@10 (Tclass._System.___hFunc0 t0@@20)) ($IsAlloc f@@10 (Tclass._System.___hFunc0 t0@@20) h0@@5))) (forall ((o@@44 T@U) (fld@@4 T@U)) (! (let ((a@@82 (FieldTypeInv0 (type fld@@4)))) (=> (and (= (type o@@44) refType) (= (type fld@@4) (FieldType a@@82))) (=> (and (and (and (not (= o@@44 null)) (U_2_bool (MapType1Select h0@@5 o@@44 alloc))) (U_2_bool (MapType1Select h1@@5 o@@44 alloc))) (U_2_bool (MapType0Select (Reads0 t0@@20 f@@10 h1@@5) ($Box o@@44)))) (= (MapType1Select h0@@5 o@@44 fld@@4) (MapType1Select h1@@5 o@@44 fld@@4))))) :qid |unknown.0:0| :skolemid |309| :no-pattern (type o@@44) :no-pattern (type fld@@4) :no-pattern (U_2_int o@@44) :no-pattern (U_2_bool o@@44) :no-pattern (U_2_int fld@@4) :no-pattern (U_2_bool fld@@4))))) (= (Apply0 t0@@20 f@@10 h0@@5) (Apply0 t0@@20 f@@10 h1@@5))) :qid |unknown.0:0| :skolemid |310| :pattern (($HeapSucc h0@@5 h1@@5) (Apply0 t0@@20 f@@10 h1@@5)))))
(assert (forall ((t0@@21 T@U) (h@@23 T@U) (f@@11 T@U)) (! (=> (and (and (and (= (type t0@@21) TyType) (= (type h@@23) (MapType1Type refType))) (= (type f@@11) HandleTypeType)) (and ($IsGoodHeap h@@23) (and ($Is f@@11 (Tclass._System.___hFunc0 t0@@21)) ($IsAlloc f@@11 (Tclass._System.___hFunc0 t0@@21) h@@23)))) (and ($IsBox (Apply0 t0@@21 f@@11 h@@23) t0@@21) ($IsAllocBox (Apply0 t0@@21 f@@11 h@@23) t0@@21 h@@23))) :qid |unknown.0:0| :skolemid |311| :pattern ((Apply0 t0@@21 f@@11 h@@23)))))
(assert (forall ((arg0@@95 T@U) (arg1@@44 T@U)) (! (= (type (Tclass._System.___hFunc1 arg0@@95 arg1@@44)) TyType) :qid |funType:Tclass._System.___hFunc1| :pattern ((Tclass._System.___hFunc1 arg0@@95 arg1@@44)))))
(assert (forall ((|#$T0@@2| T@U) (|#$T1| T@U)) (! (=> (and (= (type |#$T0@@2|) TyType) (= (type |#$T1|) TyType)) (= (Tag (Tclass._System.___hFunc1 |#$T0@@2| |#$T1|)) Tagclass._System.___hFunc1)) :qid |unknown.0:0| :skolemid |312| :pattern ((Tclass._System.___hFunc1 |#$T0@@2| |#$T1|)))))
(assert (forall ((arg0@@96 T@U)) (! (= (type (Tclass._System.___hFunc1_0 arg0@@96)) TyType) :qid |funType:Tclass._System.___hFunc1_0| :pattern ((Tclass._System.___hFunc1_0 arg0@@96)))))
(assert (forall ((|#$T0@@3| T@U) (|#$T1@@0| T@U)) (! (=> (and (= (type |#$T0@@3|) TyType) (= (type |#$T1@@0|) TyType)) (= (Tclass._System.___hFunc1_0 (Tclass._System.___hFunc1 |#$T0@@3| |#$T1@@0|)) |#$T0@@3|)) :qid |unknown.0:0| :skolemid |313| :pattern ((Tclass._System.___hFunc1 |#$T0@@3| |#$T1@@0|)))))
(assert (forall ((arg0@@97 T@U)) (! (= (type (Tclass._System.___hFunc1_1 arg0@@97)) TyType) :qid |funType:Tclass._System.___hFunc1_1| :pattern ((Tclass._System.___hFunc1_1 arg0@@97)))))
(assert (forall ((|#$T0@@4| T@U) (|#$T1@@1| T@U)) (! (=> (and (= (type |#$T0@@4|) TyType) (= (type |#$T1@@1|) TyType)) (= (Tclass._System.___hFunc1_1 (Tclass._System.___hFunc1 |#$T0@@4| |#$T1@@1|)) |#$T1@@1|)) :qid |unknown.0:0| :skolemid |314| :pattern ((Tclass._System.___hFunc1 |#$T0@@4| |#$T1@@1|)))))
(assert (forall ((|#$T0@@5| T@U) (|#$T1@@2| T@U) (bx@@39 T@U)) (! (=> (and (and (and (= (type |#$T0@@5|) TyType) (= (type |#$T1@@2|) TyType)) (= (type bx@@39) BoxType)) ($IsBox bx@@39 (Tclass._System.___hFunc1 |#$T0@@5| |#$T1@@2|))) (and (= ($Box ($Unbox HandleTypeType bx@@39)) bx@@39) ($Is ($Unbox HandleTypeType bx@@39) (Tclass._System.___hFunc1 |#$T0@@5| |#$T1@@2|)))) :qid |unknown.0:0| :skolemid |315| :pattern (($IsBox bx@@39 (Tclass._System.___hFunc1 |#$T0@@5| |#$T1@@2|))))))
(assert (and (and (and (and (and (and (and (and (and (forall ((arg0@@98 T@T) (arg1@@45 T@T) (arg2@@10 T@T)) (! (= (Ctor (MapType2Type arg0@@98 arg1@@45 arg2@@10)) 19) :qid |ctor:MapType2Type|)) (forall ((arg0@@99 T@T) (arg1@@46 T@T) (arg2@@11 T@T)) (! (= (MapType2TypeInv0 (MapType2Type arg0@@99 arg1@@46 arg2@@11)) arg0@@99) :qid |typeInv:MapType2TypeInv0| :pattern ((MapType2Type arg0@@99 arg1@@46 arg2@@11))))) (forall ((arg0@@100 T@T) (arg1@@47 T@T) (arg2@@12 T@T)) (! (= (MapType2TypeInv1 (MapType2Type arg0@@100 arg1@@47 arg2@@12)) arg1@@47) :qid |typeInv:MapType2TypeInv1| :pattern ((MapType2Type arg0@@100 arg1@@47 arg2@@12))))) (forall ((arg0@@101 T@T) (arg1@@48 T@T) (arg2@@13 T@T)) (! (= (MapType2TypeInv2 (MapType2Type arg0@@101 arg1@@48 arg2@@13)) arg2@@13) :qid |typeInv:MapType2TypeInv2| :pattern ((MapType2Type arg0@@101 arg1@@48 arg2@@13))))) (forall ((arg0@@102 T@U) (arg1@@49 T@U) (arg2@@14 T@U)) (! (let ((aVar2 (MapType2TypeInv2 (type arg0@@102)))) (= (type (MapType2Select arg0@@102 arg1@@49 arg2@@14)) aVar2)) :qid |funType:MapType2Select| :pattern ((MapType2Select arg0@@102 arg1@@49 arg2@@14))))) (forall ((arg0@@103 T@U) (arg1@@50 T@U) (arg2@@15 T@U) (arg3@@0 T@U)) (! (let ((aVar2@@0 (type arg3@@0))) (let ((aVar1@@2 (type arg2@@15))) (let ((aVar0@@1 (type arg1@@50))) (= (type (MapType2Store arg0@@103 arg1@@50 arg2@@15 arg3@@0)) (MapType2Type aVar0@@1 aVar1@@2 aVar2@@0))))) :qid |funType:MapType2Store| :pattern ((MapType2Store arg0@@103 arg1@@50 arg2@@15 arg3@@0))))) (forall ((m@@18 T@U) (x0@@6 T@U) (x1@@3 T@U) (val@@6 T@U)) (! (let ((aVar2@@1 (MapType2TypeInv2 (type m@@18)))) (=> (= (type val@@6) aVar2@@1) (= (MapType2Select (MapType2Store m@@18 x0@@6 x1@@3 val@@6) x0@@6 x1@@3) val@@6))) :qid |mapAx0:MapType2Select| :weight 0))) (and (and (forall ((val@@7 T@U) (m@@19 T@U) (x0@@7 T@U) (x1@@4 T@U) (y0@@4 T@U) (y1@@2 T@U)) (! (or (= x0@@7 y0@@4) (= (MapType2Select (MapType2Store m@@19 x0@@7 x1@@4 val@@7) y0@@4 y1@@2) (MapType2Select m@@19 y0@@4 y1@@2))) :qid |mapAx1:MapType2Select:0| :weight 0)) (forall ((val@@8 T@U) (m@@20 T@U) (x0@@8 T@U) (x1@@5 T@U) (y0@@5 T@U) (y1@@3 T@U)) (! (or (= x1@@5 y1@@3) (= (MapType2Select (MapType2Store m@@20 x0@@8 x1@@5 val@@8) y0@@5 y1@@3) (MapType2Select m@@20 y0@@5 y1@@3))) :qid |mapAx1:MapType2Select:1| :weight 0))) (forall ((val@@9 T@U) (m@@21 T@U) (x0@@9 T@U) (x1@@6 T@U) (y0@@6 T@U) (y1@@4 T@U)) (! (or true (= (MapType2Select (MapType2Store m@@21 x0@@9 x1@@6 val@@9) y0@@6 y1@@4) (MapType2Select m@@21 y0@@6 y1@@4))) :qid |mapAx2:MapType2Select| :weight 0)))) (forall ((arg0@@104 T@U) (arg1@@51 T@U) (arg2@@16 T@U) (arg3@@1 T@U) (arg4 T@U)) (! (= (type (Apply1 arg0@@104 arg1@@51 arg2@@16 arg3@@1 arg4)) BoxType) :qid |funType:Apply1| :pattern ((Apply1 arg0@@104 arg1@@51 arg2@@16 arg3@@1 arg4))))) (forall ((arg0@@105 T@U) (arg1@@52 T@U) (arg2@@17 T@U)) (! (= (type (Handle1 arg0@@105 arg1@@52 arg2@@17)) HandleTypeType) :qid |funType:Handle1| :pattern ((Handle1 arg0@@105 arg1@@52 arg2@@17))))))
(assert (forall ((t0@@22 T@U) (t1@@3 T@U) (heap@@2 T@U) (h@@24 T@U) (r@@8 T@U) (rd@@2 T@U) (bx0 T@U)) (! (=> (and (and (and (and (and (and (= (type t0@@22) TyType) (= (type t1@@3) TyType)) (= (type heap@@2) (MapType1Type refType))) (= (type h@@24) (MapType2Type (MapType1Type refType) BoxType BoxType))) (= (type r@@8) (MapType2Type (MapType1Type refType) BoxType boolType))) (= (type rd@@2) (MapType2Type (MapType1Type refType) BoxType (MapType0Type BoxType boolType)))) (= (type bx0) BoxType)) (= (Apply1 t0@@22 t1@@3 (Handle1 h@@24 r@@8 rd@@2) heap@@2 bx0) (MapType2Select h@@24 heap@@2 bx0))) :qid |unknown.0:0| :skolemid |316| :pattern ((Apply1 t0@@22 t1@@3 (Handle1 h@@24 r@@8 rd@@2) heap@@2 bx0)))))
(assert (forall ((t0@@23 T@U) (t1@@4 T@U) (heap@@3 T@U) (h@@25 T@U) (r@@9 T@U) (rd@@3 T@U) (bx0@@0 T@U)) (! (=> (and (and (and (and (and (and (and (= (type t0@@23) TyType) (= (type t1@@4) TyType)) (= (type heap@@3) (MapType1Type refType))) (= (type h@@25) (MapType2Type (MapType1Type refType) BoxType BoxType))) (= (type r@@9) (MapType2Type (MapType1Type refType) BoxType boolType))) (= (type rd@@3) (MapType2Type (MapType1Type refType) BoxType (MapType0Type BoxType boolType)))) (= (type bx0@@0) BoxType)) (U_2_bool (MapType2Select r@@9 heap@@3 bx0@@0))) (Requires1 t0@@23 t1@@4 (Handle1 h@@25 r@@9 rd@@3) heap@@3 bx0@@0)) :qid |unknown.0:0| :skolemid |317| :pattern ((Requires1 t0@@23 t1@@4 (Handle1 h@@25 r@@9 rd@@3) heap@@3 bx0@@0)))))
(assert (forall ((arg0@@106 T@U) (arg1@@53 T@U) (arg2@@18 T@U) (arg3@@2 T@U) (arg4@@0 T@U)) (! (= (type (Reads1 arg0@@106 arg1@@53 arg2@@18 arg3@@2 arg4@@0)) (MapType0Type BoxType boolType)) :qid |funType:Reads1| :pattern ((Reads1 arg0@@106 arg1@@53 arg2@@18 arg3@@2 arg4@@0)))))
(assert (forall ((t0@@24 T@U) (t1@@5 T@U) (heap@@4 T@U) (h@@26 T@U) (r@@10 T@U) (rd@@4 T@U) (bx0@@1 T@U) (bx@@40 T@U)) (! (=> (and (and (and (and (and (and (and (= (type t0@@24) TyType) (= (type t1@@5) TyType)) (= (type heap@@4) (MapType1Type refType))) (= (type h@@26) (MapType2Type (MapType1Type refType) BoxType BoxType))) (= (type r@@10) (MapType2Type (MapType1Type refType) BoxType boolType))) (= (type rd@@4) (MapType2Type (MapType1Type refType) BoxType (MapType0Type BoxType boolType)))) (= (type bx0@@1) BoxType)) (= (type bx@@40) BoxType)) (and (=> (U_2_bool (MapType0Select (Reads1 t0@@24 t1@@5 (Handle1 h@@26 r@@10 rd@@4) heap@@4 bx0@@1) bx@@40)) (U_2_bool (MapType0Select (MapType2Select rd@@4 heap@@4 bx0@@1) bx@@40))) (=> (U_2_bool (MapType0Select (MapType2Select rd@@4 heap@@4 bx0@@1) bx@@40)) (U_2_bool (MapType0Select (Reads1 t0@@24 t1@@5 (Handle1 h@@26 r@@10 rd@@4) heap@@4 bx0@@1) bx@@40))))) :qid |unknown.0:0| :skolemid |318| :pattern ((MapType0Select (Reads1 t0@@24 t1@@5 (Handle1 h@@26 r@@10 rd@@4) heap@@4 bx0@@1) bx@@40)))))
(assert (forall ((t0@@25 T@U) (t1@@6 T@U) (h0@@6 T@U) (h1@@6 T@U) (f@@12 T@U) (bx0@@2 T@U)) (! (=> (and (and (and (and (and (and (= (type t0@@25) TyType) (= (type t1@@6) TyType)) (= (type h0@@6) (MapType1Type refType))) (= (type h1@@6) (MapType1Type refType))) (= (type f@@12) HandleTypeType)) (= (type bx0@@2) BoxType)) (and (and (and ($HeapSucc h0@@6 h1@@6) (and ($IsGoodHeap h0@@6) ($IsGoodHeap h1@@6))) (and (and ($IsBox bx0@@2 t0@@25) ($IsAllocBox bx0@@2 t0@@25 h0@@6)) (and ($Is f@@12 (Tclass._System.___hFunc1 t0@@25 t1@@6)) ($IsAlloc f@@12 (Tclass._System.___hFunc1 t0@@25 t1@@6) h0@@6)))) (forall ((o@@45 T@U) (fld@@5 T@U)) (! (let ((a@@83 (FieldTypeInv0 (type fld@@5)))) (=> (and (= (type o@@45) refType) (= (type fld@@5) (FieldType a@@83))) (=> (and (and (and (not (= o@@45 null)) (U_2_bool (MapType1Select h0@@6 o@@45 alloc))) (U_2_bool (MapType1Select h1@@6 o@@45 alloc))) (U_2_bool (MapType0Select (Reads1 t0@@25 t1@@6 f@@12 h0@@6 bx0@@2) ($Box o@@45)))) (= (MapType1Select h0@@6 o@@45 fld@@5) (MapType1Select h1@@6 o@@45 fld@@5))))) :qid |unknown.0:0| :skolemid |319| :no-pattern (type o@@45) :no-pattern (type fld@@5) :no-pattern (U_2_int o@@45) :no-pattern (U_2_bool o@@45) :no-pattern (U_2_int fld@@5) :no-pattern (U_2_bool fld@@5))))) (= (Reads1 t0@@25 t1@@6 f@@12 h0@@6 bx0@@2) (Reads1 t0@@25 t1@@6 f@@12 h1@@6 bx0@@2))) :qid |unknown.0:0| :skolemid |320| :pattern (($HeapSucc h0@@6 h1@@6) (Reads1 t0@@25 t1@@6 f@@12 h1@@6 bx0@@2)))))
(assert (forall ((t0@@26 T@U) (t1@@7 T@U) (h0@@7 T@U) (h1@@7 T@U) (f@@13 T@U) (bx0@@3 T@U)) (! (=> (and (and (and (and (and (and (= (type t0@@26) TyType) (= (type t1@@7) TyType)) (= (type h0@@7) (MapType1Type refType))) (= (type h1@@7) (MapType1Type refType))) (= (type f@@13) HandleTypeType)) (= (type bx0@@3) BoxType)) (and (and (and ($HeapSucc h0@@7 h1@@7) (and ($IsGoodHeap h0@@7) ($IsGoodHeap h1@@7))) (and (and ($IsBox bx0@@3 t0@@26) ($IsAllocBox bx0@@3 t0@@26 h0@@7)) (and ($Is f@@13 (Tclass._System.___hFunc1 t0@@26 t1@@7)) ($IsAlloc f@@13 (Tclass._System.___hFunc1 t0@@26 t1@@7) h0@@7)))) (forall ((o@@46 T@U) (fld@@6 T@U)) (! (let ((a@@84 (FieldTypeInv0 (type fld@@6)))) (=> (and (= (type o@@46) refType) (= (type fld@@6) (FieldType a@@84))) (=> (and (and (and (not (= o@@46 null)) (U_2_bool (MapType1Select h0@@7 o@@46 alloc))) (U_2_bool (MapType1Select h1@@7 o@@46 alloc))) (U_2_bool (MapType0Select (Reads1 t0@@26 t1@@7 f@@13 h1@@7 bx0@@3) ($Box o@@46)))) (= (MapType1Select h0@@7 o@@46 fld@@6) (MapType1Select h1@@7 o@@46 fld@@6))))) :qid |unknown.0:0| :skolemid |321| :no-pattern (type o@@46) :no-pattern (type fld@@6) :no-pattern (U_2_int o@@46) :no-pattern (U_2_bool o@@46) :no-pattern (U_2_int fld@@6) :no-pattern (U_2_bool fld@@6))))) (= (Reads1 t0@@26 t1@@7 f@@13 h0@@7 bx0@@3) (Reads1 t0@@26 t1@@7 f@@13 h1@@7 bx0@@3))) :qid |unknown.0:0| :skolemid |322| :pattern (($HeapSucc h0@@7 h1@@7) (Reads1 t0@@26 t1@@7 f@@13 h1@@7 bx0@@3)))))
(assert (forall ((t0@@27 T@U) (t1@@8 T@U) (h0@@8 T@U) (h1@@8 T@U) (f@@14 T@U) (bx0@@4 T@U)) (! (=> (and (and (and (and (and (and (= (type t0@@27) TyType) (= (type t1@@8) TyType)) (= (type h0@@8) (MapType1Type refType))) (= (type h1@@8) (MapType1Type refType))) (= (type f@@14) HandleTypeType)) (= (type bx0@@4) BoxType)) (and (and (and ($HeapSucc h0@@8 h1@@8) (and ($IsGoodHeap h0@@8) ($IsGoodHeap h1@@8))) (and (and ($IsBox bx0@@4 t0@@27) ($IsAllocBox bx0@@4 t0@@27 h0@@8)) (and ($Is f@@14 (Tclass._System.___hFunc1 t0@@27 t1@@8)) ($IsAlloc f@@14 (Tclass._System.___hFunc1 t0@@27 t1@@8) h0@@8)))) (forall ((o@@47 T@U) (fld@@7 T@U)) (! (let ((a@@85 (FieldTypeInv0 (type fld@@7)))) (=> (and (= (type o@@47) refType) (= (type fld@@7) (FieldType a@@85))) (=> (and (and (and (not (= o@@47 null)) (U_2_bool (MapType1Select h0@@8 o@@47 alloc))) (U_2_bool (MapType1Select h1@@8 o@@47 alloc))) (U_2_bool (MapType0Select (Reads1 t0@@27 t1@@8 f@@14 h0@@8 bx0@@4) ($Box o@@47)))) (= (MapType1Select h0@@8 o@@47 fld@@7) (MapType1Select h1@@8 o@@47 fld@@7))))) :qid |unknown.0:0| :skolemid |323| :no-pattern (type o@@47) :no-pattern (type fld@@7) :no-pattern (U_2_int o@@47) :no-pattern (U_2_bool o@@47) :no-pattern (U_2_int fld@@7) :no-pattern (U_2_bool fld@@7))))) (and (=> (Requires1 t0@@27 t1@@8 f@@14 h0@@8 bx0@@4) (Requires1 t0@@27 t1@@8 f@@14 h1@@8 bx0@@4)) (=> (Requires1 t0@@27 t1@@8 f@@14 h1@@8 bx0@@4) (Requires1 t0@@27 t1@@8 f@@14 h0@@8 bx0@@4)))) :qid |unknown.0:0| :skolemid |324| :pattern (($HeapSucc h0@@8 h1@@8) (Requires1 t0@@27 t1@@8 f@@14 h1@@8 bx0@@4)))))
(assert (forall ((t0@@28 T@U) (t1@@9 T@U) (h0@@9 T@U) (h1@@9 T@U) (f@@15 T@U) (bx0@@5 T@U)) (! (=> (and (and (and (and (and (and (= (type t0@@28) TyType) (= (type t1@@9) TyType)) (= (type h0@@9) (MapType1Type refType))) (= (type h1@@9) (MapType1Type refType))) (= (type f@@15) HandleTypeType)) (= (type bx0@@5) BoxType)) (and (and (and ($HeapSucc h0@@9 h1@@9) (and ($IsGoodHeap h0@@9) ($IsGoodHeap h1@@9))) (and (and ($IsBox bx0@@5 t0@@28) ($IsAllocBox bx0@@5 t0@@28 h0@@9)) (and ($Is f@@15 (Tclass._System.___hFunc1 t0@@28 t1@@9)) ($IsAlloc f@@15 (Tclass._System.___hFunc1 t0@@28 t1@@9) h0@@9)))) (forall ((o@@48 T@U) (fld@@8 T@U)) (! (let ((a@@86 (FieldTypeInv0 (type fld@@8)))) (=> (and (= (type o@@48) refType) (= (type fld@@8) (FieldType a@@86))) (=> (and (and (and (not (= o@@48 null)) (U_2_bool (MapType1Select h0@@9 o@@48 alloc))) (U_2_bool (MapType1Select h1@@9 o@@48 alloc))) (U_2_bool (MapType0Select (Reads1 t0@@28 t1@@9 f@@15 h1@@9 bx0@@5) ($Box o@@48)))) (= (MapType1Select h0@@9 o@@48 fld@@8) (MapType1Select h1@@9 o@@48 fld@@8))))) :qid |unknown.0:0| :skolemid |325| :no-pattern (type o@@48) :no-pattern (type fld@@8) :no-pattern (U_2_int o@@48) :no-pattern (U_2_bool o@@48) :no-pattern (U_2_int fld@@8) :no-pattern (U_2_bool fld@@8))))) (and (=> (Requires1 t0@@28 t1@@9 f@@15 h0@@9 bx0@@5) (Requires1 t0@@28 t1@@9 f@@15 h1@@9 bx0@@5)) (=> (Requires1 t0@@28 t1@@9 f@@15 h1@@9 bx0@@5) (Requires1 t0@@28 t1@@9 f@@15 h0@@9 bx0@@5)))) :qid |unknown.0:0| :skolemid |326| :pattern (($HeapSucc h0@@9 h1@@9) (Requires1 t0@@28 t1@@9 f@@15 h1@@9 bx0@@5)))))
(assert (forall ((t0@@29 T@U) (t1@@10 T@U) (h0@@10 T@U) (h1@@10 T@U) (f@@16 T@U) (bx0@@6 T@U)) (! (=> (and (and (and (and (and (and (= (type t0@@29) TyType) (= (type t1@@10) TyType)) (= (type h0@@10) (MapType1Type refType))) (= (type h1@@10) (MapType1Type refType))) (= (type f@@16) HandleTypeType)) (= (type bx0@@6) BoxType)) (and (and (and ($HeapSucc h0@@10 h1@@10) (and ($IsGoodHeap h0@@10) ($IsGoodHeap h1@@10))) (and (and ($IsBox bx0@@6 t0@@29) ($IsAllocBox bx0@@6 t0@@29 h0@@10)) (and ($Is f@@16 (Tclass._System.___hFunc1 t0@@29 t1@@10)) ($IsAlloc f@@16 (Tclass._System.___hFunc1 t0@@29 t1@@10) h0@@10)))) (forall ((o@@49 T@U) (fld@@9 T@U)) (! (let ((a@@87 (FieldTypeInv0 (type fld@@9)))) (=> (and (= (type o@@49) refType) (= (type fld@@9) (FieldType a@@87))) (=> (and (and (and (not (= o@@49 null)) (U_2_bool (MapType1Select h0@@10 o@@49 alloc))) (U_2_bool (MapType1Select h1@@10 o@@49 alloc))) (U_2_bool (MapType0Select (Reads1 t0@@29 t1@@10 f@@16 h0@@10 bx0@@6) ($Box o@@49)))) (= (MapType1Select h0@@10 o@@49 fld@@9) (MapType1Select h1@@10 o@@49 fld@@9))))) :qid |unknown.0:0| :skolemid |327| :no-pattern (type o@@49) :no-pattern (type fld@@9) :no-pattern (U_2_int o@@49) :no-pattern (U_2_bool o@@49) :no-pattern (U_2_int fld@@9) :no-pattern (U_2_bool fld@@9))))) (= (Apply1 t0@@29 t1@@10 f@@16 h0@@10 bx0@@6) (Apply1 t0@@29 t1@@10 f@@16 h1@@10 bx0@@6))) :qid |unknown.0:0| :skolemid |328| :pattern (($HeapSucc h0@@10 h1@@10) (Apply1 t0@@29 t1@@10 f@@16 h1@@10 bx0@@6)))))
(assert (forall ((t0@@30 T@U) (t1@@11 T@U) (h0@@11 T@U) (h1@@11 T@U) (f@@17 T@U) (bx0@@7 T@U)) (! (=> (and (and (and (and (and (and (= (type t0@@30) TyType) (= (type t1@@11) TyType)) (= (type h0@@11) (MapType1Type refType))) (= (type h1@@11) (MapType1Type refType))) (= (type f@@17) HandleTypeType)) (= (type bx0@@7) BoxType)) (and (and (and ($HeapSucc h0@@11 h1@@11) (and ($IsGoodHeap h0@@11) ($IsGoodHeap h1@@11))) (and (and ($IsBox bx0@@7 t0@@30) ($IsAllocBox bx0@@7 t0@@30 h0@@11)) (and ($Is f@@17 (Tclass._System.___hFunc1 t0@@30 t1@@11)) ($IsAlloc f@@17 (Tclass._System.___hFunc1 t0@@30 t1@@11) h0@@11)))) (forall ((o@@50 T@U) (fld@@10 T@U)) (! (let ((a@@88 (FieldTypeInv0 (type fld@@10)))) (=> (and (= (type o@@50) refType) (= (type fld@@10) (FieldType a@@88))) (=> (and (and (and (not (= o@@50 null)) (U_2_bool (MapType1Select h0@@11 o@@50 alloc))) (U_2_bool (MapType1Select h1@@11 o@@50 alloc))) (U_2_bool (MapType0Select (Reads1 t0@@30 t1@@11 f@@17 h1@@11 bx0@@7) ($Box o@@50)))) (= (MapType1Select h0@@11 o@@50 fld@@10) (MapType1Select h1@@11 o@@50 fld@@10))))) :qid |unknown.0:0| :skolemid |329| :no-pattern (type o@@50) :no-pattern (type fld@@10) :no-pattern (U_2_int o@@50) :no-pattern (U_2_bool o@@50) :no-pattern (U_2_int fld@@10) :no-pattern (U_2_bool fld@@10))))) (= (Apply1 t0@@30 t1@@11 f@@17 h0@@11 bx0@@7) (Apply1 t0@@30 t1@@11 f@@17 h1@@11 bx0@@7))) :qid |unknown.0:0| :skolemid |330| :pattern (($HeapSucc h0@@11 h1@@11) (Apply1 t0@@30 t1@@11 f@@17 h1@@11 bx0@@7)))))
(assert (forall ((t0@@31 T@U) (t1@@12 T@U) (h@@27 T@U) (f@@18 T@U) (bx0@@8 T@U)) (! (=> (and (and (and (and (and (= (type t0@@31) TyType) (= (type t1@@12) TyType)) (= (type h@@27) (MapType1Type refType))) (= (type f@@18) HandleTypeType)) (= (type bx0@@8) BoxType)) (and ($IsGoodHeap h@@27) (and (and ($IsBox bx0@@8 t0@@31) ($IsAllocBox bx0@@8 t0@@31 h@@27)) (and ($Is f@@18 (Tclass._System.___hFunc1 t0@@31 t1@@12)) ($IsAlloc f@@18 (Tclass._System.___hFunc1 t0@@31 t1@@12) h@@27))))) (and ($IsBox (Apply1 t0@@31 t1@@12 f@@18 h@@27 bx0@@8) t1@@12) ($IsAllocBox (Apply1 t0@@31 t1@@12 f@@18 h@@27 bx0@@8) t1@@12 h@@27))) :qid |unknown.0:0| :skolemid |331| :pattern ((Apply1 t0@@31 t1@@12 f@@18 h@@27 bx0@@8)))))
(assert (= (type Tclass._module.__default) TyType))
(assert (= (Tag Tclass._module.__default) Tagclass._module.__default))
(assert (forall ((bx@@41 T@U)) (! (=> (and (= (type bx@@41) BoxType) ($IsBox bx@@41 Tclass._module.__default)) (and (= ($Box ($Unbox refType bx@@41)) bx@@41) ($Is ($Unbox refType bx@@41) Tclass._module.__default))) :qid |unknown.0:0| :skolemid |332| :pattern (($IsBox bx@@41 Tclass._module.__default)))))
(assert (forall (($o@@5 T@U)) (! (=> (= (type $o@@5) refType) (and (=> ($Is $o@@5 Tclass._module.__default) (or (= $o@@5 null) (= (dtype $o@@5) Tclass._module.__default))) (=> (or (= $o@@5 null) (= (dtype $o@@5) Tclass._module.__default)) ($Is $o@@5 Tclass._module.__default)))) :qid |unknown.0:0| :skolemid |333| :pattern (($Is $o@@5 Tclass._module.__default)))))
(assert (forall (($o@@6 T@U) ($h@@3 T@U)) (! (=> (and (= (type $o@@6) refType) (= (type $h@@3) (MapType1Type refType))) (and (=> ($IsAlloc $o@@6 Tclass._module.__default $h@@3) (or (= $o@@6 null) (U_2_bool (MapType1Select $h@@3 $o@@6 alloc)))) (=> (or (= $o@@6 null) (U_2_bool (MapType1Select $h@@3 $o@@6 alloc))) ($IsAlloc $o@@6 Tclass._module.__default $h@@3)))) :qid |unknown.0:0| :skolemid |334| :pattern (($IsAlloc $o@@6 Tclass._module.__default $h@@3)))))
(assert (forall (($ly T@U) ($Heap T@U) (|n#0| Int)) (! (=> (and (= (type $ly) LayerTypeType) (= (type $Heap) (MapType1Type refType))) (= (_module.__default.Factorial ($LS $ly) $Heap |n#0|) (_module.__default.Factorial $ly $Heap |n#0|))) :qid |Classics.7:10| :skolemid |335| :pattern ((_module.__default.Factorial ($LS $ly) $Heap |n#0|)))))
(assert (forall (($ly@@0 T@U) ($h0 T@U) ($h1 T@U) (|n#0@@0| Int)) (! (=> (and (and (= (type $ly@@0) LayerTypeType) (= (type $h0) (MapType1Type refType))) (= (type $h1) (MapType1Type refType))) (=> (and (and (and ($IsGoodHeap $h0) ($IsGoodHeap $h1)) (and (or (|_module.__default.Factorial#canCall| $h0 |n#0@@0|) (<= 0 |n#0@@0|)) (or (|_module.__default.Factorial#canCall| $h1 |n#0@@0|) (<= 0 |n#0@@0|)))) (and ($IsHeapAnchor $h0) ($HeapSucc $h0 $h1))) (=> (forall (($o@@7 T@U) ($f T@U)) (! (let ((alpha@@6 (FieldTypeInv0 (type $f)))) (=> (and (and (= (type $o@@7) refType) (= (type $f) (FieldType alpha@@6))) false) (= (MapType1Select $h0 $o@@7 $f) (MapType1Select $h1 $o@@7 $f)))) :qid |unknown.0:0| :skolemid |336| :no-pattern (type $o@@7) :no-pattern (type $f) :no-pattern (U_2_int $o@@7) :no-pattern (U_2_bool $o@@7) :no-pattern (U_2_int $f) :no-pattern (U_2_bool $f))) (= (_module.__default.Factorial $ly@@0 $h0 |n#0@@0|) (_module.__default.Factorial $ly@@0 $h1 |n#0@@0|))))) :qid |unknown.0:0| :skolemid |337| :pattern (($IsHeapAnchor $h0) ($HeapSucc $h0 $h1) (_module.__default.Factorial $ly@@0 $h1 |n#0@@0|)))))
(assert (=> (or (< 0 $ModuleContextHeight) (and (= 0 $ModuleContextHeight) (<= 0 $FunctionContextHeight))) (forall (($ly@@1 T@U) ($Heap@@0 T@U) (|n#0@@1| Int)) (! (=> (and (and (= (type $ly@@1) LayerTypeType) (= (type $Heap@@0) (MapType1Type refType))) (or (|_module.__default.Factorial#canCall| $Heap@@0 |n#0@@1|) (and (or (not (= 0 $ModuleContextHeight)) (not (= 0 $FunctionContextHeight))) (and ($IsGoodHeap $Heap@@0) (<= 0 |n#0@@1|))))) (<= 0 (_module.__default.Factorial ($LS $ly@@1) $Heap@@0 |n#0@@1|))) :qid |Classics.7:10| :skolemid |338| :pattern ((_module.__default.Factorial ($LS $ly@@1) $Heap@@0 |n#0@@1|))))))
(assert (forall (($ly@@2 T@U) ($Heap@@1 T@U) (|n#0@@2| Int)) (! (=> (and (and (= (type $ly@@2) LayerTypeType) (= (type $Heap@@1) (MapType1Type refType))) (and ($IsGoodHeap $Heap@@1) (<= 0 |n#0@@2|))) (and (=> (|_module.__default.Factorial#requires| $ly@@2 $Heap@@1 |n#0@@2|) true) (=> true (|_module.__default.Factorial#requires| $ly@@2 $Heap@@1 |n#0@@2|)))) :qid |Classics.7:10| :skolemid |339| :pattern ((|_module.__default.Factorial#requires| $ly@@2 $Heap@@1 |n#0@@2|)))))
(assert (=> (and (= 0 $ModuleContextHeight) (<= 0 $FunctionContextHeight)) (forall (($ly@@3 T@U) ($Heap@@2 T@U) (|n#0@@3| Int)) (! (=> (and (and (= (type $ly@@3) LayerTypeType) (= (type $Heap@@2) (MapType1Type refType))) (or (|_module.__default.Factorial#canCall| $Heap@@2 |n#0@@3|) (and (not (= 0 $FunctionContextHeight)) (and ($IsGoodHeap $Heap@@2) (<= 0 |n#0@@3|))))) (and (and (=> (= |n#0@@3| (LitInt 0)) true) (=> (not (= |n#0@@3| (LitInt 0))) (|_module.__default.Factorial#canCall| $Heap@@2 (- |n#0@@3| 1)))) (= (_module.__default.Factorial ($LS $ly@@3) $Heap@@2 |n#0@@3|) (ite (= |n#0@@3| (LitInt 0)) 1 (* |n#0@@3| (_module.__default.Factorial $ly@@3 $Heap@@2 (- |n#0@@3| 1))))))) :qid |Classics.7:10| :skolemid |340| :pattern ((_module.__default.Factorial ($LS $ly@@3) $Heap@@2 |n#0@@3|))))))
(assert (=> (and (= 0 $ModuleContextHeight) (<= 0 $FunctionContextHeight)) (forall (($ly@@4 T@U) ($Heap@@3 T@U) (|n#0@@4| Int)) (! (=> (and (and (= (type $ly@@4) LayerTypeType) (= (type $Heap@@3) (MapType1Type refType))) (or (|_module.__default.Factorial#canCall| $Heap@@3 (LitInt |n#0@@4|)) (and (not (= 0 $FunctionContextHeight)) (and ($IsGoodHeap $Heap@@3) (<= 0 |n#0@@4|))))) (and (and (=> (= (LitInt |n#0@@4|) (LitInt 0)) true) (=> (not (= (LitInt |n#0@@4|) (LitInt 0))) (|_module.__default.Factorial#canCall| $Heap@@3 (LitInt (- |n#0@@4| 1))))) (= (_module.__default.Factorial $ly@@4 $Heap@@3 (LitInt |n#0@@4|)) (ite (= (LitInt |n#0@@4|) (LitInt 0)) 1 (* |n#0@@4| (_module.__default.Factorial $ly@@4 $Heap@@3 (LitInt (- |n#0@@4| 1)))))))) :qid |Classics.7:10| :weight 3 :skolemid |341| :pattern ((_module.__default.Factorial $ly@@4 $Heap@@3 (LitInt |n#0@@4|)))))))
(assert (=> (< 0 $ModuleContextHeight) (forall (($ly@@5 T@U) ($Heap@@4 T@U) (|n#0@@5| Int)) (! (=> (and (and (= (type $ly@@5) LayerTypeType) (= (type $Heap@@4) (MapType1Type refType))) (or (|_module.__default.Factorial#canCall| $Heap@@4 |n#0@@5|) (and ($IsGoodHeap $Heap@@4) (<= 0 |n#0@@5|)))) (and (and (=> (= |n#0@@5| (LitInt 0)) true) (=> (not (= |n#0@@5| (LitInt 0))) (|_module.__default.Factorial#canCall| $Heap@@4 (- |n#0@@5| 1)))) (= (_module.__default.Factorial ($LS $ly@@5) $Heap@@4 |n#0@@5|) (ite (= |n#0@@5| (LitInt 0)) 1 (* |n#0@@5| (_module.__default.Factorial $ly@@5 $Heap@@4 (- |n#0@@5| 1))))))) :qid |Classics.7:10| :skolemid |342| :pattern ((_module.__default.Factorial ($LS $ly@@5) $Heap@@4 |n#0@@5|))))))
(assert (=> (< 0 $ModuleContextHeight) (forall (($ly@@6 T@U) ($Heap@@5 T@U) (|n#0@@6| Int)) (! (=> (and (and (= (type $ly@@6) LayerTypeType) (= (type $Heap@@5) (MapType1Type refType))) (or (|_module.__default.Factorial#canCall| $Heap@@5 (LitInt |n#0@@6|)) (and ($IsGoodHeap $Heap@@5) (<= 0 |n#0@@6|)))) (and (and (=> (= (LitInt |n#0@@6|) (LitInt 0)) true) (=> (not (= (LitInt |n#0@@6|) (LitInt 0))) (|_module.__default.Factorial#canCall| $Heap@@5 (LitInt (- |n#0@@6| 1))))) (= (_module.__default.Factorial $ly@@6 $Heap@@5 (LitInt |n#0@@6|)) (ite (= (LitInt |n#0@@6|) (LitInt 0)) 1 (* |n#0@@6| (_module.__default.Factorial $ly@@6 $Heap@@5 (LitInt (- |n#0@@6| 1)))))))) :qid |Classics.7:10| :weight 3 :skolemid |343| :pattern ((_module.__default.Factorial $ly@@6 $Heap@@5 (LitInt |n#0@@6|)))))))
(assert (and (and (and (and (and (and (and (forall ((arg0@@107 T@T) (arg1@@54 T@T)) (! (= (Ctor (MapType3Type arg0@@107 arg1@@54)) 20) :qid |ctor:MapType3Type|)) (forall ((arg0@@108 T@T) (arg1@@55 T@T)) (! (= (MapType3TypeInv0 (MapType3Type arg0@@108 arg1@@55)) arg0@@108) :qid |typeInv:MapType3TypeInv0| :pattern ((MapType3Type arg0@@108 arg1@@55))))) (forall ((arg0@@109 T@T) (arg1@@56 T@T)) (! (= (MapType3TypeInv1 (MapType3Type arg0@@109 arg1@@56)) arg1@@56) :qid |typeInv:MapType3TypeInv1| :pattern ((MapType3Type arg0@@109 arg1@@56))))) (forall ((arg0@@110 T@U) (arg1@@57 T@U) (arg2@@19 T@U)) (! (let ((aVar1@@3 (MapType3TypeInv1 (type arg0@@110)))) (= (type (MapType3Select arg0@@110 arg1@@57 arg2@@19)) aVar1@@3)) :qid |funType:MapType3Select| :pattern ((MapType3Select arg0@@110 arg1@@57 arg2@@19))))) (forall ((arg0@@111 T@U) (arg1@@58 T@U) (arg2@@20 T@U) (arg3@@3 T@U)) (! (let ((aVar1@@4 (type arg3@@3))) (let ((aVar0@@2 (type arg1@@58))) (= (type (MapType3Store arg0@@111 arg1@@58 arg2@@20 arg3@@3)) (MapType3Type aVar0@@2 aVar1@@4)))) :qid |funType:MapType3Store| :pattern ((MapType3Store arg0@@111 arg1@@58 arg2@@20 arg3@@3))))) (forall ((m@@22 T@U) (x0@@10 T@U) (x1@@7 T@U) (val@@10 T@U)) (! (let ((aVar1@@5 (MapType3TypeInv1 (type m@@22)))) (=> (= (type val@@10) aVar1@@5) (= (MapType3Select (MapType3Store m@@22 x0@@10 x1@@7 val@@10) x0@@10 x1@@7) val@@10))) :qid |mapAx0:MapType3Select| :weight 0))) (and (and (forall ((val@@11 T@U) (m@@23 T@U) (x0@@11 T@U) (x1@@8 T@U) (y0@@7 T@U) (y1@@5 T@U)) (! (or (= x0@@11 y0@@7) (= (MapType3Select (MapType3Store m@@23 x0@@11 x1@@8 val@@11) y0@@7 y1@@5) (MapType3Select m@@23 y0@@7 y1@@5))) :qid |mapAx1:MapType3Select:0| :weight 0)) (forall ((val@@12 T@U) (m@@24 T@U) (x0@@12 T@U) (x1@@9 T@U) (y0@@8 T@U) (y1@@6 T@U)) (! (or (= x1@@9 y1@@6) (= (MapType3Select (MapType3Store m@@24 x0@@12 x1@@9 val@@12) y0@@8 y1@@6) (MapType3Select m@@24 y0@@8 y1@@6))) :qid |mapAx1:MapType3Select:1| :weight 0))) (forall ((val@@13 T@U) (m@@25 T@U) (x0@@13 T@U) (x1@@10 T@U) (y0@@9 T@U) (y1@@7 T@U)) (! (or true (= (MapType3Select (MapType3Store m@@25 x0@@13 x1@@10 val@@13) y0@@9 y1@@7) (MapType3Select m@@25 y0@@9 y1@@7))) :qid |mapAx2:MapType3Select| :weight 0)))) (forall ((arg0@@112 T@U) (arg1@@59 T@U) (arg2@@21 T@U)) (! (= (type (|lambda#0| arg0@@112 arg1@@59 arg2@@21)) (MapType3Type refType boolType)) :qid |funType:lambda#0| :pattern ((|lambda#0| arg0@@112 arg1@@59 arg2@@21))))))
(assert (forall (($o@@8 T@U) ($f@@0 T@U) (alloc@@0 T@U) (null@@0 T@U) ($Heap@@6 T@U)) (! (let ((alpha@@7 (FieldTypeInv0 (type $f@@0)))) (=> (and (and (and (and (= (type $o@@8) refType) (= (type $f@@0) (FieldType alpha@@7))) (= (type alloc@@0) (FieldType boolType))) (= (type null@@0) refType)) (= (type $Heap@@6) (MapType1Type refType))) (= (U_2_bool (MapType3Select (|lambda#0| alloc@@0 null@@0 $Heap@@6) $o@@8 $f@@0)) (=> (and (not (= $o@@8 null@@0)) (U_2_bool (MapType1Select $Heap@@6 $o@@8 alloc@@0))) false)))) :qid |Classics.7:10| :skolemid |454| :pattern ((MapType3Select (|lambda#0| alloc@@0 null@@0 $Heap@@6) $o@@8 $f@@0)))))
(assert (forall ((arg0@@113 T@U) (arg1@@60 T@U) (arg2@@22 T@U)) (! (= (type (|lambda#1| arg0@@113 arg1@@60 arg2@@22)) (MapType3Type refType boolType)) :qid |funType:lambda#1| :pattern ((|lambda#1| arg0@@113 arg1@@60 arg2@@22)))))
(assert (forall (($o@@9 T@U) ($f@@1 T@U) (alloc@@1 T@U) (null@@1 T@U) ($Heap@@7 T@U)) (! (let ((alpha@@8 (FieldTypeInv0 (type $f@@1)))) (=> (and (and (and (and (= (type $o@@9) refType) (= (type $f@@1) (FieldType alpha@@8))) (= (type alloc@@1) (FieldType boolType))) (= (type null@@1) refType)) (= (type $Heap@@7) (MapType1Type refType))) (= (U_2_bool (MapType3Select (|lambda#1| alloc@@1 null@@1 $Heap@@7) $o@@9 $f@@1)) (=> (and (not (= $o@@9 null@@1)) (U_2_bool (MapType1Select $Heap@@7 $o@@9 alloc@@1))) false)))) :qid |Classics.7:10| :skolemid |455| :pattern ((MapType3Select (|lambda#1| alloc@@1 null@@1 $Heap@@7) $o@@9 $f@@1)))))
(assert (forall ((arg0@@114 T@U) (arg1@@61 T@U) (arg2@@23 T@U)) (! (= (type (|lambda#2| arg0@@114 arg1@@61 arg2@@23)) (MapType3Type refType boolType)) :qid |funType:lambda#2| :pattern ((|lambda#2| arg0@@114 arg1@@61 arg2@@23)))))
(assert (forall (($o@@10 T@U) ($f@@2 T@U) (alloc@@2 T@U) (null@@2 T@U) ($Heap@@8 T@U)) (! (let ((alpha@@9 (FieldTypeInv0 (type $f@@2)))) (=> (and (and (and (and (= (type $o@@10) refType) (= (type $f@@2) (FieldType alpha@@9))) (= (type alloc@@2) (FieldType boolType))) (= (type null@@2) refType)) (= (type $Heap@@8) (MapType1Type refType))) (= (U_2_bool (MapType3Select (|lambda#2| alloc@@2 null@@2 $Heap@@8) $o@@10 $f@@2)) (=> (and (not (= $o@@10 null@@2)) (U_2_bool (MapType1Select $Heap@@8 $o@@10 alloc@@2))) false)))) :qid |Classics.12:8| :skolemid |456| :pattern ((MapType3Select (|lambda#2| alloc@@2 null@@2 $Heap@@8) $o@@10 $f@@2)))))
(assert (forall ((arg0@@115 T@U) (arg1@@62 T@U) (arg2@@24 T@U)) (! (= (type (|lambda#3| arg0@@115 arg1@@62 arg2@@24)) (MapType3Type refType boolType)) :qid |funType:lambda#3| :pattern ((|lambda#3| arg0@@115 arg1@@62 arg2@@24)))))
(assert (forall (($o@@11 T@U) ($f@@3 T@U) (alloc@@3 T@U) (null@@3 T@U) ($Heap@@9 T@U)) (! (let ((alpha@@10 (FieldTypeInv0 (type $f@@3)))) (=> (and (and (and (and (= (type $o@@11) refType) (= (type $f@@3) (FieldType alpha@@10))) (= (type alloc@@3) (FieldType boolType))) (= (type null@@3) refType)) (= (type $Heap@@9) (MapType1Type refType))) (= (U_2_bool (MapType3Select (|lambda#3| alloc@@3 null@@3 $Heap@@9) $o@@11 $f@@3)) (=> (and (not (= $o@@11 null@@3)) (U_2_bool (MapType1Select $Heap@@9 $o@@11 alloc@@3))) false)))) :qid |Classics.12:8| :skolemid |457| :pattern ((MapType3Select (|lambda#3| alloc@@3 null@@3 $Heap@@9) $o@@11 $f@@3)))))
(assert (forall ((arg0@@116 T@U) (arg1@@63 T@U) (arg2@@25 T@U) (arg3@@4 T@U)) (! (= (type (|lambda#4| arg0@@116 arg1@@63 arg2@@25 arg3@@4)) (MapType3Type refType boolType)) :qid |funType:lambda#4| :pattern ((|lambda#4| arg0@@116 arg1@@63 arg2@@25 arg3@@4)))))
(assert (forall (($o@@12 T@U) ($f@@4 T@U) (|A#0| T@U) (null@@4 T@U) ($Heap@@10 T@U) (alloc@@4 T@U)) (! (let ((alpha@@11 (FieldTypeInv0 (type $f@@4)))) (=> (and (and (and (and (and (= (type $o@@12) refType) (= (type $f@@4) (FieldType alpha@@11))) (= (type |A#0|) refType)) (= (type null@@4) refType)) (= (type $Heap@@10) (MapType1Type refType))) (= (type alloc@@4) (FieldType boolType))) (= (U_2_bool (MapType3Select (|lambda#4| |A#0| null@@4 $Heap@@10 alloc@@4) $o@@12 $f@@4)) (=> (and (not (= $o@@12 null@@4)) (U_2_bool (MapType1Select $Heap@@10 $o@@12 alloc@@4))) (= $o@@12 |A#0|))))) :qid |Classics.47:8| :skolemid |458| :pattern ((MapType3Select (|lambda#4| |A#0| null@@4 $Heap@@10 alloc@@4) $o@@12 $f@@4)))))
(assert (forall ((arg0@@117 T@U) (arg1@@64 T@U) (arg2@@26 T@U) (arg3@@5 T@U)) (! (= (type (|lambda#5| arg0@@117 arg1@@64 arg2@@26 arg3@@5)) (MapType3Type refType boolType)) :qid |funType:lambda#5| :pattern ((|lambda#5| arg0@@117 arg1@@64 arg2@@26 arg3@@5)))))
(assert (forall (($o@@13 T@U) ($f@@5 T@U) (|A#0@@0| T@U) (null@@5 T@U) ($Heap@@11 T@U) (alloc@@5 T@U)) (! (let ((alpha@@12 (FieldTypeInv0 (type $f@@5)))) (=> (and (and (and (and (and (= (type $o@@13) refType) (= (type $f@@5) (FieldType alpha@@12))) (= (type |A#0@@0|) refType)) (= (type null@@5) refType)) (= (type $Heap@@11) (MapType1Type refType))) (= (type alloc@@5) (FieldType boolType))) (= (U_2_bool (MapType3Select (|lambda#5| |A#0@@0| null@@5 $Heap@@11 alloc@@5) $o@@13 $f@@5)) (=> (and (not (= $o@@13 null@@5)) (U_2_bool (MapType1Select $Heap@@11 $o@@13 alloc@@5))) (= $o@@13 |A#0@@0|))))) :qid |Classics.47:8| :skolemid |459| :pattern ((MapType3Select (|lambda#5| |A#0@@0| null@@5 $Heap@@11 alloc@@5) $o@@13 $f@@5)))))
(assert (and (and (and (= (type $LZ) LayerTypeType) (= (type $Heap@@12) (MapType1Type refType))) (= (type $_Frame@0) (MapType3Type refType boolType))) (= (type $_Frame@0@@0) (MapType3Type refType boolType))))
(set-option :TIMEOUT 0)
(declare-fun $_Frame@0@@1 () T@U)
(declare-fun $Heap@0 () T@U)
(declare-fun %lbl%+13222 () Bool)
(declare-fun |u#0@0| () Int)
(declare-fun %lbl%@38757 () Bool)
(declare-fun |n#0@@8| () Int)
(declare-fun %lbl%+38617 () Bool)
(declare-fun |u#0| () Int)
(assert (and (= (type $_Frame@0@@1) (MapType3Type refType boolType)) (= (type $Heap@0) (MapType1Type refType))))
(push 1)
(set-info :boogie-vc-id CheckWellformed$$_module.__default.AdditiveFactorial)
(assert (not (let ((anon0_correct@@0 (=> (! (and %lbl%+13222 true) :lblpos +13222) (=> (= $_Frame@0@@1 (|lambda#2| alloc null $Heap@@12)) (=> (and (and (and ($IsGoodHeap $Heap@0) ($IsHeapAnchor $Heap@0)) (forall (($o@@16 T@U) ($f@@8 T@U)) (! (let ((alpha@@15 (FieldTypeInv0 (type $f@@8)))) (=> (and (and (= (type $o@@16) refType) (= (type $f@@8) (FieldType alpha@@15))) (and (not (= $o@@16 null)) (U_2_bool (MapType1Select $Heap@@12 $o@@16 alloc)))) (= (MapType1Select $Heap@0 $o@@16 $f@@8) (MapType1Select $Heap@@12 $o@@16 $f@@8)))) :qid |Classics.12:8| :skolemid |345| :pattern ((MapType1Select $Heap@0 $o@@16 $f@@8))))) (and ($HeapSucc $Heap@@12 $Heap@0) (<= 0 |u#0@0|))) (! (or %lbl%@38757 ($Is (int_2_U |n#0@@8|) TNat)) :lblneg @38757)))))) (let ((PreconditionGeneratedEntry_correct@@0 (=> (! (and %lbl%+38617 true) :lblpos +38617) (=> (and ($IsGoodHeap $Heap@@12) ($IsHeapAnchor $Heap@@12)) (=> (and (and (<= 0 |n#0@@8|) (<= 0 |u#0|)) (and (= 0 $ModuleContextHeight) (= 1 $FunctionContextHeight))) anon0_correct@@0))))) PreconditionGeneratedEntry_correct@@0))))
(check-sat)
(pop 1)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.0)
(set-option :AUTO_CONFIG false)
(set-option :pp.bv_literals false)
(set-option :MODEL.V2 true)
(set-option :smt.PHASE_SELECTION 0)
(set-option :smt.RESTART_STRATEGY 0)
(set-option :smt.RESTART_FACTOR |1.5|)
(set-option :smt.ARITH.RANDOM_INITIAL_VALUE true)
(set-option :smt.CASE_SPLIT 3)
(set-option :smt.DELAY_UNITS true)
(set-option :NNF.SK_HACK true)
(set-option :smt.MBQI false)
(set-option :smt.QI.EAGER_THRESHOLD 100)
(set-option :TYPE_CHECK true)
(set-option :smt.BV.REFLECT true)
(set-option :TIMEOUT 0)
(set-info :category "industrial")
(declare-sort |T@U| 0)
(declare-sort |T@T| 0)
(declare-fun real_pow (Real Real) Real)
(declare-fun UOrdering2 (|T@U| |T@U|) Bool)
(declare-fun UOrdering3 (|T@T| |T@U| |T@U|) Bool)
(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-fun Ctor (T@T) Int)
(declare-fun intType () T@T)
(declare-fun realType () T@T)
(declare-fun boolType () T@T)
(declare-fun int_2_U (Int) T@U)
(declare-fun U_2_int (T@U) Int)
(declare-fun type (T@U) T@T)
(declare-fun real_2_U (Real) T@U)
(declare-fun U_2_real (T@U) Real)
(declare-fun bool_2_U (Bool) T@U)
(declare-fun U_2_bool (T@U) Bool)
(declare-fun TyType () T@T)
(declare-fun TBool () T@U)
(declare-fun TChar () T@U)
(declare-fun TInt () T@U)
(declare-fun TNat () T@U)
(declare-fun TReal () T@U)
(declare-fun TyTagType () T@T)
(declare-fun TagBool () T@U)
(declare-fun TagChar () T@U)
(declare-fun TagInt () T@U)
(declare-fun TagNat () T@U)
(declare-fun TagReal () T@U)
(declare-fun TagSet () T@U)
(declare-fun TagISet () T@U)
(declare-fun TagMultiSet () T@U)
(declare-fun TagSeq () T@U)
(declare-fun TagMap () T@U)
(declare-fun TagIMap () T@U)
(declare-fun TagClass () T@U)
(declare-fun ClassNameType () T@T)
(declare-fun NoTraitAtAll () T@U)
(declare-fun class._System.int () T@U)
(declare-fun class._System.bool () T@U)
(declare-fun class._System.set () T@U)
(declare-fun class._System.seq () T@U)
(declare-fun class._System.multiset () T@U)
(declare-fun FieldType (T@T) T@T)
(declare-fun FieldTypeInv0 (T@T) T@T)
(declare-fun alloc () T@U)
(declare-fun class._System.object () T@U)
(declare-fun Tagclass._System.object () T@U)
(declare-fun class._System.array () T@U)
(declare-fun Tagclass._System.array () T@U)
(declare-fun Tagclass._System.___hFunc0 () T@U)
(declare-fun Tagclass._System.___hFunc1 () T@U)
(declare-fun class._module.__default () T@U)
(declare-fun Tagclass._module.__default () T@U)
(declare-fun $$Language$Dafny () Bool)
(declare-fun TSet (T@U) T@U)
(declare-fun Inv0_TSet (T@U) T@U)
(declare-fun TISet (T@U) T@U)
(declare-fun Inv0_TISet (T@U) T@U)
(declare-fun TSeq (T@U) T@U)
(declare-fun Inv0_TSeq (T@U) T@U)
(declare-fun TMultiSet (T@U) T@U)
(declare-fun Inv0_TMultiSet (T@U) T@U)
(declare-fun TMap (T@U T@U) T@U)
(declare-fun Inv0_TMap (T@U) T@U)
(declare-fun Inv1_TMap (T@U) T@U)
(declare-fun TIMap (T@U T@U) T@U)
(declare-fun Inv0_TIMap (T@U) T@U)
(declare-fun Inv1_TIMap (T@U) T@U)
(declare-fun Tag (T@U) T@U)
(declare-fun LitInt (Int) Int)
(declare-fun BoxType () T@T)
(declare-fun $Box (T@U) T@U)
(declare-fun Lit (T@U) T@U)
(declare-fun LitReal (Real) Real)
(declare-fun charType () T@T)
(declare-fun |char#FromInt| (Int) T@U)
(declare-fun |char#ToInt| (T@U) Int)
(declare-fun $Unbox (T@T T@U) T@U)
(declare-fun $IsBox (T@U T@U) Bool)
(declare-fun $Is (T@U T@U) Bool)
(declare-fun MapType0Type (T@T T@T) T@T)
(declare-fun MapType0TypeInv0 (T@T) T@T)
(declare-fun MapType0TypeInv1 (T@T) T@T)
(declare-fun MapType0Select (T@U T@U) T@U)
(declare-fun MapType0Store (T@U T@U T@U) T@U)
(declare-fun SeqType (T@T) T@T)
(declare-fun SeqTypeInv0 (T@T) T@T)
(declare-fun MapType (T@T T@T) T@T)
(declare-fun MapTypeInv0 (T@T) T@T)
(declare-fun MapTypeInv1 (T@T) T@T)
(declare-fun IMapType (T@T T@T) T@T)
(declare-fun IMapTypeInv0 (T@T) T@T)
(declare-fun IMapTypeInv1 (T@T) T@T)
(declare-fun MapType1Type (T@T) T@T)
(declare-fun MapType1TypeInv0 (T@T) T@T)
(declare-fun MapType1Select (T@U T@U T@U) T@U)
(declare-fun MapType1Store (T@U T@U T@U T@U) T@U)
(declare-fun refType () T@T)
(declare-fun $IsAllocBox (T@U T@U T@U) Bool)
(declare-fun $IsAlloc (T@U T@U T@U) Bool)
(declare-fun $IsGoodMultiSet (T@U) Bool)
(declare-fun |Seq#Index| (T@U Int) T@U)
(declare-fun |Seq#Length| (T@U) Int)
(declare-fun |Map#Elements| (T@U) T@U)
(declare-fun |Map#Domain| (T@U) T@U)
(declare-fun |IMap#Elements| (T@U) T@U)
(declare-fun |IMap#Domain| (T@U) T@U)
(declare-fun TypeTuple (T@U T@U) T@U)
(declare-fun TypeTupleCar (T@U) T@U)
(declare-fun TypeTupleCdr (T@U) T@U)
(declare-fun SetRef_to_SetBox (T@U) T@U)
(declare-fun Tclass._System.object () T@U)
(declare-fun DatatypeTypeType () T@T)
(declare-fun BoxRank (T@U) Int)
(declare-fun DtRank (T@U) Int)
(declare-fun LayerTypeType () T@T)
(declare-fun AtLayer (T@U T@U) T@U)
(declare-fun $LS (T@U) T@U)
(declare-fun IndexField (Int) T@U)
(declare-fun FDim (T@U) Int)
(declare-fun IndexField_Inverse (T@U) Int)
(declare-fun MultiIndexField (T@U Int) T@U)
(declare-fun MultiIndexField_Inverse0 (T@U) T@U)
(declare-fun MultiIndexField_Inverse1 (T@U) Int)
(declare-fun NameFamilyType () T@T)
(declare-fun FieldOfDecl (T@T T@U T@U) T@U)
(declare-fun DeclType (T@U) T@U)
(declare-fun DeclName (T@U) T@U)
(declare-fun $HeapSucc (T@U T@U) Bool)
(declare-fun $IsGhostField (T@U) Bool)
(declare-fun _System.array.Length (T@U) Int)
(declare-fun q@Int (Real) Int)
(declare-fun q@Real (Int) Real)
(declare-fun $IsGoodHeap (T@U) Bool)
(declare-fun $HeapSuccGhost (T@U T@U) Bool)
(declare-fun |Set#Card| (T@U) Int)
(declare-fun |Set#Empty| (T@T) T@U)
(declare-fun |Set#Singleton| (T@U) T@U)
(declare-fun |Set#UnionOne| (T@U T@U) T@U)
(declare-fun |Set#Union| (T@U T@U) T@U)
(declare-fun |Set#Difference| (T@U T@U) T@U)
(declare-fun |Set#Disjoint| (T@U T@U) Bool)
(declare-fun |Set#Intersection| (T@U T@U) T@U)
(declare-fun |Set#Subset| (T@U T@U) Bool)
(declare-fun |Set#Equal| (T@U T@U) Bool)
(declare-fun |ISet#Empty| (T@T) T@U)
(declare-fun |ISet#UnionOne| (T@U T@U) T@U)
(declare-fun |ISet#Union| (T@U T@U) T@U)
(declare-fun |ISet#Difference| (T@U T@U) T@U)
(declare-fun |ISet#Disjoint| (T@U T@U) Bool)
(declare-fun |ISet#Intersection| (T@U T@U) T@U)
(declare-fun |ISet#Subset| (T@U T@U) Bool)
(declare-fun |ISet#Equal| (T@U T@U) Bool)
(declare-fun |Math#min| (Int Int) Int)
(declare-fun |Math#clip| (Int) Int)
(declare-fun |MultiSet#Card| (T@U) Int)
(declare-fun |MultiSet#Empty| (T@T) T@U)
(declare-fun |MultiSet#Singleton| (T@U) T@U)
(declare-fun |MultiSet#UnionOne| (T@U T@U) T@U)
(declare-fun |MultiSet#Union| (T@U T@U) T@U)
(declare-fun |MultiSet#Intersection| (T@U T@U) T@U)
(declare-fun |MultiSet#Difference| (T@U T@U) T@U)
(declare-fun |MultiSet#Subset| (T@U T@U) Bool)
(declare-fun |MultiSet#Equal| (T@U T@U) Bool)
(declare-fun |MultiSet#Disjoint| (T@U T@U) Bool)
(declare-fun |MultiSet#FromSet| (T@U) T@U)
(declare-fun |MultiSet#FromSeq| (T@U) T@U)
(declare-fun |Seq#Build| (T@U T@U) T@U)
(declare-fun |Seq#Empty| (T@T) T@U)
(declare-fun |Seq#Append| (T@U T@U) T@U)
(declare-fun |Seq#Update| (T@U Int T@U) T@U)
(declare-fun |Seq#Singleton| (T@U) T@U)
(declare-fun |Seq#Contains| (T@U T@U) Bool)
(declare-fun |Seq#Take| (T@U Int) T@U)
(declare-fun |Seq#Drop| (T@U Int) T@U)
(declare-fun |Seq#Equal| (T@U T@U) Bool)
(declare-fun |Seq#SameUntil| (T@U T@U Int) Bool)
(declare-fun |Seq#FromArray| (T@U T@U) T@U)
(declare-fun |Seq#Rank| (T@U) Int)
(declare-fun |Map#Card| (T@U) Int)
(declare-fun |Map#Empty| (T@T T@T) T@U)
(declare-fun |Map#Glue| (T@U T@U T@U) T@U)
(declare-fun |Map#Build| (T@U T@U T@U) T@U)
(declare-fun |Map#Equal| (T@U T@U) Bool)
(declare-fun |Map#Disjoint| (T@U T@U) Bool)
(declare-fun |IMap#Empty| (T@T T@T) T@U)
(declare-fun |IMap#Glue| (T@U T@U T@U) T@U)
(declare-fun |IMap#Build| (T@U T@U T@U) T@U)
(declare-fun |IMap#Equal| (T@U T@U) Bool)
(declare-fun INTERNAL_add_boogie (Int Int) Int)
(declare-fun INTERNAL_sub_boogie (Int Int) Int)
(declare-fun INTERNAL_mul_boogie (Int Int) Int)
(declare-fun INTERNAL_div_boogie (Int Int) Int)
(declare-fun INTERNAL_mod_boogie (Int Int) Int)
(declare-fun INTERNAL_lt_boogie (Int Int) Bool)
(declare-fun INTERNAL_le_boogie (Int Int) Bool)
(declare-fun INTERNAL_gt_boogie (Int Int) Bool)
(declare-fun INTERNAL_ge_boogie (Int Int) Bool)
(declare-fun null () T@U)
(declare-fun Tclass._System.array (T@U) T@U)
(declare-fun Tclass._System.array_0 (T@U) T@U)
(declare-fun dtype (T@U) T@U)
(declare-fun Tclass._System.___hFunc0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc0_0 (T@U) T@U)
(declare-fun HandleTypeType () T@T)
(declare-fun Apply0 (T@U T@U T@U) T@U)
(declare-fun Handle0 (T@U T@U T@U) T@U)
(declare-fun Requires0 (T@U T@U T@U) Bool)
(declare-fun Reads0 (T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hFunc1 (T@U T@U) T@U)
(declare-fun Tclass._System.___hFunc1_0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc1_1 (T@U) T@U)
(declare-fun MapType2Type (T@T T@T T@T) T@T)
(declare-fun MapType2TypeInv0 (T@T) T@T)
(declare-fun MapType2TypeInv1 (T@T) T@T)
(declare-fun MapType2TypeInv2 (T@T) T@T)
(declare-fun MapType2Select (T@U T@U T@U) T@U)
(declare-fun MapType2Store (T@U T@U T@U T@U) T@U)
(declare-fun Apply1 (T@U T@U T@U T@U T@U) T@U)
(declare-fun Handle1 (T@U T@U T@U) T@U)
(declare-fun Requires1 (T@U T@U T@U T@U T@U) Bool)
(declare-fun Reads1 (T@U T@U T@U T@U T@U) T@U)
(declare-fun Tclass._module.__default () T@U)
(declare-fun _module.__default.Factorial (T@U T@U Int) Int)
(declare-fun $IsHeapAnchor (T@U) Bool)
(declare-fun |_module.__default.Factorial#canCall| (T@U Int) Bool)
(declare-fun $ModuleContextHeight () Int)
(declare-fun $FunctionContextHeight () Int)
(declare-fun |_module.__default.Factorial#requires| (T@U T@U Int) Bool)
(declare-fun MapType3Type (T@T T@T) T@T)
(declare-fun MapType3TypeInv0 (T@T) T@T)
(declare-fun MapType3TypeInv1 (T@T) T@T)
(declare-fun MapType3Select (T@U T@U T@U) T@U)
(declare-fun MapType3Store (T@U T@U T@U T@U) T@U)
(declare-fun |lambda#0| (T@U T@U T@U) T@U)
(declare-fun |lambda#1| (T@U T@U T@U) T@U)
(declare-fun |lambda#2| (T@U T@U T@U) T@U)
(declare-fun |lambda#3| (T@U T@U T@U) T@U)
(declare-fun |lambda#4| (T@U T@U T@U T@U) T@U)
(declare-fun |lambda#5| (T@U T@U T@U T@U) T@U)
(declare-fun $LZ () T@U)
(declare-fun $Heap@@12 () T@U)
(declare-fun $_Frame@0 () T@U)
(declare-fun $_Frame@0@@0 () T@U)
(declare-fun %lbl%+13101 () Bool)
(declare-fun %lbl%@34767 () Bool)
(declare-fun |b$reqreads#0@1| () Bool)
(declare-fun %lbl%+13099 () Bool)
(declare-fun |n#0@@7| () Int)
(declare-fun %lbl%@34589 () Bool)
(declare-fun |##n#0@0| () Int)
(declare-fun |b$reqreads#0@0| () Bool)
(declare-fun %lbl%@34638 () Bool)
(declare-fun %lbl%@34651 () Bool)
(declare-fun %lbl%@34666 () Bool)
(declare-fun %lbl%+13097 () Bool)
(declare-fun %lbl%@34525 () Bool)
(declare-fun %lbl%+13095 () Bool)
(declare-fun %lbl%+13088 () Bool)
(declare-fun %lbl%+13084 () Bool)
(declare-fun %lbl%+34404 () Bool)
(assert (and (and (and (and (and (and (and (and (and (and (and (= (Ctor intType) 0) (= (Ctor realType) 1)) (= (Ctor boolType) 2)) (forall ((arg0 Int)) (! (= (U_2_int (int_2_U arg0)) arg0) :qid |typeInv:U_2_int| :pattern ((int_2_U arg0))))) (forall ((x T@U)) (! (=> (= (type x) intType) (= (int_2_U (U_2_int x)) x)) :qid |cast:U_2_int| :pattern ((U_2_int x))))) (forall ((arg0@@0 Int)) (! (= (type (int_2_U arg0@@0)) intType) :qid |funType:int_2_U| :pattern ((int_2_U arg0@@0))))) (forall ((arg0@@1 Real)) (! (= (U_2_real (real_2_U arg0@@1)) arg0@@1) :qid |typeInv:U_2_real| :pattern ((real_2_U arg0@@1))))) (forall ((x@@0 T@U)) (! (=> (= (type x@@0) realType) (= (real_2_U (U_2_real x@@0)) x@@0)) :qid |cast:U_2_real| :pattern ((U_2_real x@@0))))) (forall ((arg0@@2 Real)) (! (= (type (real_2_U arg0@@2)) realType) :qid |funType:real_2_U| :pattern ((real_2_U arg0@@2))))) (forall ((arg0@@3 Bool)) (! (= (U_2_bool (bool_2_U arg0@@3)) arg0@@3) :qid |typeInv:U_2_bool| :pattern ((bool_2_U arg0@@3))))) (forall ((x@@1 T@U)) (! (=> (= (type x@@1) boolType) (= (bool_2_U (U_2_bool x@@1)) x@@1)) :qid |cast:U_2_bool| :pattern ((U_2_bool x@@1))))) (forall ((arg0@@4 Bool)) (! (= (type (bool_2_U arg0@@4)) boolType) :qid |funType:bool_2_U| :pattern ((bool_2_U arg0@@4))))))
(assert (forall ((x@@2 T@U)) (! (UOrdering2 x@@2 x@@2) :qid |bg:subtype-refl| :no-pattern (U_2_int x@@2) :no-pattern (U_2_bool x@@2))))
(assert (forall ((x@@3 T@U) (y T@U) (z T@U)) (! (let ((alpha (type x@@3))) (=> (and (and (= (type y) alpha) (= (type z) alpha)) (and (UOrdering2 x@@3 y) (UOrdering2 y z))) (UOrdering2 x@@3 z))) :qid |bg:subtype-trans| :pattern ((UOrdering2 x@@3 y) (UOrdering2 y z)))))
(assert (forall ((x@@4 T@U) (y@@0 T@U)) (! (let ((alpha@@0 (type x@@4))) (=> (= (type y@@0) alpha@@0) (=> (and (UOrdering2 x@@4 y@@0) (UOrdering2 y@@0 x@@4)) (= x@@4 y@@0)))) :qid |bg:subtype-antisymm| :pattern ((UOrdering2 x@@4 y@@0) (UOrdering2 y@@0 x@@4)))))
(assert (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (= (Ctor TyType) 3) (= (type TBool) TyType)) (= (type TChar) TyType)) (= (type TInt) TyType)) (= (type TNat) TyType)) (= (type TReal) TyType)) (= (Ctor TyTagType) 4)) (= (type TagBool) TyTagType)) (= (type TagChar) TyTagType)) (= (type TagInt) TyTagType)) (= (type TagNat) TyTagType)) (= (type TagReal) TyTagType)) (= (type TagSet) TyTagType)) (= (type TagISet) TyTagType)) (= (type TagMultiSet) TyTagType)) (= (type TagSeq) TyTagType)) (= (type TagMap) TyTagType)) (= (type TagIMap) TyTagType)) (= (type TagClass) TyTagType)) (= (Ctor ClassNameType) 5)) (= (type NoTraitAtAll) ClassNameType)) (= (type class._System.int) ClassNameType)) (= (type class._System.bool) ClassNameType)) (= (type class._System.set) ClassNameType)) (= (type class._System.seq) ClassNameType)) (= (type class._System.multiset) ClassNameType)) (forall ((arg0@@5 T@T)) (! (= (Ctor (FieldType arg0@@5)) 6) :qid |ctor:FieldType|))) (forall ((arg0@@6 T@T)) (! (= (FieldTypeInv0 (FieldType arg0@@6)) arg0@@6) :qid |typeInv:FieldTypeInv0| :pattern ((FieldType arg0@@6))))) (= (type alloc) (FieldType boolType))) (= (type class._System.object) ClassNameType)) (= (type Tagclass._System.object) TyTagType)) (= (type class._System.array) ClassNameType)) (= (type Tagclass._System.array) TyTagType)) (= (type Tagclass._System.___hFunc0) TyTagType)) (= (type Tagclass._System.___hFunc1) TyTagType)) (= (type class._module.__default) ClassNameType)) (= (type Tagclass._module.__default) TyTagType)))
(assert (distinct TBool TChar TInt TNat TReal TagBool TagChar TagInt TagNat TagReal TagSet TagISet TagMultiSet TagSeq TagMap TagIMap TagClass NoTraitAtAll class._System.int class._System.bool class._System.set class._System.seq class._System.multiset alloc class._System.object Tagclass._System.object class._System.array Tagclass._System.array Tagclass._System.___hFunc0 Tagclass._System.___hFunc1 class._module.__default Tagclass._module.__default))
(assert $$Language$Dafny)
(assert (and (forall ((arg0@@7 T@U)) (! (= (type (TSet arg0@@7)) TyType) :qid |funType:TSet| :pattern ((TSet arg0@@7)))) (forall ((arg0@@8 T@U)) (! (= (type (Inv0_TSet arg0@@8)) TyType) :qid |funType:Inv0_TSet| :pattern ((Inv0_TSet arg0@@8))))))
(assert (forall ((t T@U)) (! (=> (= (type t) TyType) (= (Inv0_TSet (TSet t)) t)) :qid |DafnyPre.30:15| :skolemid |0| :pattern ((TSet t)))))
(assert (and (forall ((arg0@@9 T@U)) (! (= (type (TISet arg0@@9)) TyType) :qid |funType:TISet| :pattern ((TISet arg0@@9)))) (forall ((arg0@@10 T@U)) (! (= (type (Inv0_TISet arg0@@10)) TyType) :qid |funType:Inv0_TISet| :pattern ((Inv0_TISet arg0@@10))))))
(assert (forall ((t@@0 T@U)) (! (=> (= (type t@@0) TyType) (= (Inv0_TISet (TISet t@@0)) t@@0)) :qid |DafnyPre.32:15| :skolemid |1| :pattern ((TISet t@@0)))))
(assert (and (forall ((arg0@@11 T@U)) (! (= (type (TSeq arg0@@11)) TyType) :qid |funType:TSeq| :pattern ((TSeq arg0@@11)))) (forall ((arg0@@12 T@U)) (! (= (type (Inv0_TSeq arg0@@12)) TyType) :qid |funType:Inv0_TSeq| :pattern ((Inv0_TSeq arg0@@12))))))
(assert (forall ((t@@1 T@U)) (! (=> (= (type t@@1) TyType) (= (Inv0_TSeq (TSeq t@@1)) t@@1)) :qid |DafnyPre.34:15| :skolemid |2| :pattern ((TSeq t@@1)))))
(assert (and (forall ((arg0@@13 T@U)) (! (= (type (TMultiSet arg0@@13)) TyType) :qid |funType:TMultiSet| :pattern ((TMultiSet arg0@@13)))) (forall ((arg0@@14 T@U)) (! (= (type (Inv0_TMultiSet arg0@@14)) TyType) :qid |funType:Inv0_TMultiSet| :pattern ((Inv0_TMultiSet arg0@@14))))))
(assert (forall ((t@@2 T@U)) (! (=> (= (type t@@2) TyType) (= (Inv0_TMultiSet (TMultiSet t@@2)) t@@2)) :qid |DafnyPre.36:15| :skolemid |3| :pattern ((TMultiSet t@@2)))))
(assert (and (forall ((arg0@@15 T@U) (arg1 T@U)) (! (= (type (TMap arg0@@15 arg1)) TyType) :qid |funType:TMap| :pattern ((TMap arg0@@15 arg1)))) (forall ((arg0@@16 T@U)) (! (= (type (Inv0_TMap arg0@@16)) TyType) :qid |funType:Inv0_TMap| :pattern ((Inv0_TMap arg0@@16))))))
(assert (forall ((t@@3 T@U) (u T@U)) (! (=> (and (= (type t@@3) TyType) (= (type u) TyType)) (= (Inv0_TMap (TMap t@@3 u)) t@@3)) :qid |DafnyPre.39:15| :skolemid |4| :pattern ((TMap t@@3 u)))))
(assert (forall ((arg0@@17 T@U)) (! (= (type (Inv1_TMap arg0@@17)) TyType) :qid |funType:Inv1_TMap| :pattern ((Inv1_TMap arg0@@17)))))
(assert (forall ((t@@4 T@U) (u@@0 T@U)) (! (=> (and (= (type t@@4) TyType) (= (type u@@0) TyType)) (= (Inv1_TMap (TMap t@@4 u@@0)) u@@0)) :qid |DafnyPre.40:15| :skolemid |5| :pattern ((TMap t@@4 u@@0)))))
(assert (and (forall ((arg0@@18 T@U) (arg1@@0 T@U)) (! (= (type (TIMap arg0@@18 arg1@@0)) TyType) :qid |funType:TIMap| :pattern ((TIMap arg0@@18 arg1@@0)))) (forall ((arg0@@19 T@U)) (! (= (type (Inv0_TIMap arg0@@19)) TyType) :qid |funType:Inv0_TIMap| :pattern ((Inv0_TIMap arg0@@19))))))
(assert (forall ((t@@5 T@U) (u@@1 T@U)) (! (=> (and (= (type t@@5) TyType) (= (type u@@1) TyType)) (= (Inv0_TIMap (TIMap t@@5 u@@1)) t@@5)) :qid |DafnyPre.43:15| :skolemid |6| :pattern ((TIMap t@@5 u@@1)))))
(assert (forall ((arg0@@20 T@U)) (! (= (type (Inv1_TIMap arg0@@20)) TyType) :qid |funType:Inv1_TIMap| :pattern ((Inv1_TIMap arg0@@20)))))
(assert (forall ((t@@6 T@U) (u@@2 T@U)) (! (=> (and (= (type t@@6) TyType) (= (type u@@2) TyType)) (= (Inv1_TIMap (TIMap t@@6 u@@2)) u@@2)) :qid |DafnyPre.44:15| :skolemid |7| :pattern ((TIMap t@@6 u@@2)))))
(assert (forall ((arg0@@21 T@U)) (! (= (type (Tag arg0@@21)) TyTagType) :qid |funType:Tag| :pattern ((Tag arg0@@21)))))
(assert (= (Tag TBool) TagBool))
(assert (= (Tag TChar) TagChar))
(assert (= (Tag TInt) TagInt))
(assert (= (Tag TNat) TagNat))
(assert (= (Tag TReal) TagReal))
(assert (forall ((t@@7 T@U)) (! (=> (= (type t@@7) TyType) (= (Tag (TSet t@@7)) TagSet)) :qid |DafnyPre.70:15| :skolemid |8| :pattern ((TSet t@@7)))))
(assert (forall ((t@@8 T@U)) (! (=> (= (type t@@8) TyType) (= (Tag (TISet t@@8)) TagISet)) :qid |DafnyPre.71:15| :skolemid |9| :pattern ((TISet t@@8)))))
(assert (forall ((t@@9 T@U)) (! (=> (= (type t@@9) TyType) (= (Tag (TMultiSet t@@9)) TagMultiSet)) :qid |DafnyPre.72:15| :skolemid |10| :pattern ((TMultiSet t@@9)))))
(assert (forall ((t@@10 T@U)) (! (=> (= (type t@@10) TyType) (= (Tag (TSeq t@@10)) TagSeq)) :qid |DafnyPre.73:15| :skolemid |11| :pattern ((TSeq t@@10)))))
(assert (forall ((t@@11 T@U) (u@@3 T@U)) (! (=> (and (= (type t@@11) TyType) (= (type u@@3) TyType)) (= (Tag (TMap t@@11 u@@3)) TagMap)) :qid |DafnyPre.74:15| :skolemid |12| :pattern ((TMap t@@11 u@@3)))))
(assert (forall ((t@@12 T@U) (u@@4 T@U)) (! (=> (and (= (type t@@12) TyType) (= (type u@@4) TyType)) (= (Tag (TIMap t@@12 u@@4)) TagIMap)) :qid |DafnyPre.75:15| :skolemid |13| :pattern ((TIMap t@@12 u@@4)))))
(assert (forall ((x@@5 Int)) (! (= (LitInt x@@5) x@@5) :qid |DafnyPre.80:29| :skolemid |14| :pattern ((LitInt x@@5)))))
(assert (and (and (= (Ctor BoxType) 7) (forall ((arg0@@22 T@U)) (! (= (type ($Box arg0@@22)) BoxType) :qid |funType:$Box| :pattern (($Box arg0@@22))))) (forall ((arg0@@23 T@U)) (! (let ((T (type arg0@@23))) (= (type (Lit arg0@@23)) T)) :qid |funType:Lit| :pattern ((Lit arg0@@23))))))
(assert (forall ((x@@6 Int)) (! (= ($Box (int_2_U (LitInt x@@6))) (Lit ($Box (int_2_U x@@6)))) :qid |DafnyPre.81:15| :skolemid |15| :pattern (($Box (int_2_U (LitInt x@@6)))))))
(assert (forall ((x@@7 Real)) (! (= (LitReal x@@7) x@@7) :qid |DafnyPre.82:30| :skolemid |16| :pattern ((LitReal x@@7)))))
(assert (forall ((x@@8 Real)) (! (= ($Box (real_2_U (LitReal x@@8))) (Lit ($Box (real_2_U x@@8)))) :qid |DafnyPre.83:15| :skolemid |17| :pattern (($Box (real_2_U (LitReal x@@8)))))))
(assert (forall ((x@@9 T@U)) (! (= (Lit x@@9) x@@9) :qid |DafnyPre.84:29| :skolemid |18| :pattern ((Lit x@@9)))))
(assert (forall ((x@@10 T@U)) (! (= ($Box (Lit x@@10)) (Lit ($Box x@@10))) :qid |DafnyPre.85:18| :skolemid |19| :pattern (($Box (Lit x@@10))))))
(assert (and (= (Ctor charType) 8) (forall ((arg0@@24 Int)) (! (= (type (|char#FromInt| arg0@@24)) charType) :qid |funType:char#FromInt| :pattern ((|char#FromInt| arg0@@24))))))
(assert (forall ((ch T@U)) (! (=> (= (type ch) charType) (= (|char#FromInt| (|char#ToInt| ch)) ch)) :qid |DafnyPre.94:15| :skolemid |20| :pattern ((|char#ToInt| ch)))))
(assert (forall ((n Int)) (! (=> (and (<= 0 n) (< n 65536)) (= (|char#ToInt| (|char#FromInt| n)) n)) :qid |DafnyPre.97:15| :skolemid |21| :pattern ((|char#FromInt| n)))))
(assert (forall ((T@@0 T@T) (arg0@@25 T@U)) (! (= (type ($Unbox T@@0 arg0@@25)) T@@0) :qid |funType:$Unbox| :pattern (($Unbox T@@0 arg0@@25)))))
(assert (forall ((x@@11 T@U)) (! (let ((T@@1 (type x@@11))) (= ($Unbox T@@1 ($Box x@@11)) x@@11)) :qid |DafnyPre.125:18| :skolemid |22| :pattern (($Box x@@11)))))
(assert (forall ((bx T@U)) (! (=> (and (= (type bx) BoxType) ($IsBox bx TInt)) (and (= ($Box ($Unbox intType bx)) bx) ($Is ($Unbox intType bx) TInt))) :qid |DafnyPre.127:15| :skolemid |23| :pattern (($IsBox bx TInt)))))
(assert (forall ((bx@@0 T@U)) (! (=> (and (= (type bx@@0) BoxType) ($IsBox bx@@0 TNat)) (and (= ($Box ($Unbox intType bx@@0)) bx@@0) ($Is ($Unbox intType bx@@0) TNat))) :qid |DafnyPre.130:15| :skolemid |24| :pattern (($IsBox bx@@0 TNat)))))
(assert (forall ((bx@@1 T@U)) (! (=> (and (= (type bx@@1) BoxType) ($IsBox bx@@1 TReal)) (and (= ($Box ($Unbox realType bx@@1)) bx@@1) ($Is ($Unbox realType bx@@1) TReal))) :qid |DafnyPre.133:15| :skolemid |25| :pattern (($IsBox bx@@1 TReal)))))
(assert (forall ((bx@@2 T@U)) (! (=> (and (= (type bx@@2) BoxType) ($IsBox bx@@2 TBool)) (and (= ($Box ($Unbox boolType bx@@2)) bx@@2) ($Is ($Unbox boolType bx@@2) TBool))) :qid |DafnyPre.136:15| :skolemid |26| :pattern (($IsBox bx@@2 TBool)))))
(assert (forall ((bx@@3 T@U)) (! (=> (and (= (type bx@@3) BoxType) ($IsBox bx@@3 TChar)) (and (= ($Box ($Unbox charType bx@@3)) bx@@3) ($Is ($Unbox charType bx@@3) TChar))) :qid |DafnyPre.139:15| :skolemid |27| :pattern (($IsBox bx@@3 TChar)))))
(assert (and (and (and (and (and (and (forall ((arg0@@26 T@T) (arg1@@1 T@T)) (! (= (Ctor (MapType0Type arg0@@26 arg1@@1)) 9) :qid |ctor:MapType0Type|)) (forall ((arg0@@27 T@T) (arg1@@2 T@T)) (! (= (MapType0TypeInv0 (MapType0Type arg0@@27 arg1@@2)) arg0@@27) :qid |typeInv:MapType0TypeInv0| :pattern ((MapType0Type arg0@@27 arg1@@2))))) (forall ((arg0@@28 T@T) (arg1@@3 T@T)) (! (= (MapType0TypeInv1 (MapType0Type arg0@@28 arg1@@3)) arg1@@3) :qid |typeInv:MapType0TypeInv1| :pattern ((MapType0Type arg0@@28 arg1@@3))))) (forall ((arg0@@29 T@U) (arg1@@4 T@U)) (! (let ((aVar1 (MapType0TypeInv1 (type arg0@@29)))) (= (type (MapType0Select arg0@@29 arg1@@4)) aVar1)) :qid |funType:MapType0Select| :pattern ((MapType0Select arg0@@29 arg1@@4))))) (forall ((arg0@@30 T@U) (arg1@@5 T@U) (arg2 T@U)) (! (let ((aVar1@@0 (type arg2))) (let ((aVar0 (type arg1@@5))) (= (type (MapType0Store arg0@@30 arg1@@5 arg2)) (MapType0Type aVar0 aVar1@@0)))) :qid |funType:MapType0Store| :pattern ((MapType0Store arg0@@30 arg1@@5 arg2))))) (forall ((m T@U) (x0 T@U) (val T@U)) (! (let ((aVar1@@1 (MapType0TypeInv1 (type m)))) (=> (= (type val) aVar1@@1) (= (MapType0Select (MapType0Store m x0 val) x0) val))) :qid |mapAx0:MapType0Select| :weight 0))) (and (forall ((val@@0 T@U) (m@@0 T@U) (x0@@0 T@U) (y0 T@U)) (! (or (= x0@@0 y0) (= (MapType0Select (MapType0Store m@@0 x0@@0 val@@0) y0) (MapType0Select m@@0 y0))) :qid |mapAx1:MapType0Select:0| :weight 0)) (forall ((val@@1 T@U) (m@@1 T@U) (x0@@1 T@U) (y0@@0 T@U)) (! (or true (= (MapType0Select (MapType0Store m@@1 x0@@1 val@@1) y0@@0) (MapType0Select m@@1 y0@@0))) :qid |mapAx2:MapType0Select| :weight 0)))))
(assert (forall ((bx@@4 T@U) (t@@13 T@U)) (! (=> (and (and (= (type bx@@4) BoxType) (= (type t@@13) TyType)) ($IsBox bx@@4 (TSet t@@13))) (and (= ($Box ($Unbox (MapType0Type BoxType boolType) bx@@4)) bx@@4) ($Is ($Unbox (MapType0Type BoxType boolType) bx@@4) (TSet t@@13)))) :qid |DafnyPre.142:15| :skolemid |28| :pattern (($IsBox bx@@4 (TSet t@@13))))))
(assert (forall ((bx@@5 T@U) (t@@14 T@U)) (! (=> (and (and (= (type bx@@5) BoxType) (= (type t@@14) TyType)) ($IsBox bx@@5 (TISet t@@14))) (and (= ($Box ($Unbox (MapType0Type BoxType boolType) bx@@5)) bx@@5) ($Is ($Unbox (MapType0Type BoxType boolType) bx@@5) (TISet t@@14)))) :qid |DafnyPre.145:15| :skolemid |29| :pattern (($IsBox bx@@5 (TISet t@@14))))))
(assert (forall ((bx@@6 T@U) (t@@15 T@U)) (! (=> (and (and (= (type bx@@6) BoxType) (= (type t@@15) TyType)) ($IsBox bx@@6 (TMultiSet t@@15))) (and (= ($Box ($Unbox (MapType0Type BoxType intType) bx@@6)) bx@@6) ($Is ($Unbox (MapType0Type BoxType intType) bx@@6) (TMultiSet t@@15)))) :qid |DafnyPre.148:15| :skolemid |30| :pattern (($IsBox bx@@6 (TMultiSet t@@15))))))
(assert (and (forall ((arg0@@31 T@T)) (! (= (Ctor (SeqType arg0@@31)) 10) :qid |ctor:SeqType|)) (forall ((arg0@@32 T@T)) (! (= (SeqTypeInv0 (SeqType arg0@@32)) arg0@@32) :qid |typeInv:SeqTypeInv0| :pattern ((SeqType arg0@@32))))))
(assert (forall ((bx@@7 T@U) (t@@16 T@U)) (! (=> (and (and (= (type bx@@7) BoxType) (= (type t@@16) TyType)) ($IsBox bx@@7 (TSeq t@@16))) (and (= ($Box ($Unbox (SeqType BoxType) bx@@7)) bx@@7) ($Is ($Unbox (SeqType BoxType) bx@@7) (TSeq t@@16)))) :qid |DafnyPre.151:15| :skolemid |31| :pattern (($IsBox bx@@7 (TSeq t@@16))))))
(assert (and (and (forall ((arg0@@33 T@T) (arg1@@6 T@T)) (! (= (Ctor (MapType arg0@@33 arg1@@6)) 11) :qid |ctor:MapType|)) (forall ((arg0@@34 T@T) (arg1@@7 T@T)) (! (= (MapTypeInv0 (MapType arg0@@34 arg1@@7)) arg0@@34) :qid |typeInv:MapTypeInv0| :pattern ((MapType arg0@@34 arg1@@7))))) (forall ((arg0@@35 T@T) (arg1@@8 T@T)) (! (= (MapTypeInv1 (MapType arg0@@35 arg1@@8)) arg1@@8) :qid |typeInv:MapTypeInv1| :pattern ((MapType arg0@@35 arg1@@8))))))
(assert (forall ((bx@@8 T@U) (s T@U) (t@@17 T@U)) (! (=> (and (and (and (= (type bx@@8) BoxType) (= (type s) TyType)) (= (type t@@17) TyType)) ($IsBox bx@@8 (TMap s t@@17))) (and (= ($Box ($Unbox (MapType BoxType BoxType) bx@@8)) bx@@8) ($Is ($Unbox (MapType BoxType BoxType) bx@@8) (TMap s t@@17)))) :qid |DafnyPre.154:15| :skolemid |32| :pattern (($IsBox bx@@8 (TMap s t@@17))))))
(assert (and (and (forall ((arg0@@36 T@T) (arg1@@9 T@T)) (! (= (Ctor (IMapType arg0@@36 arg1@@9)) 12) :qid |ctor:IMapType|)) (forall ((arg0@@37 T@T) (arg1@@10 T@T)) (! (= (IMapTypeInv0 (IMapType arg0@@37 arg1@@10)) arg0@@37) :qid |typeInv:IMapTypeInv0| :pattern ((IMapType arg0@@37 arg1@@10))))) (forall ((arg0@@38 T@T) (arg1@@11 T@T)) (! (= (IMapTypeInv1 (IMapType arg0@@38 arg1@@11)) arg1@@11) :qid |typeInv:IMapTypeInv1| :pattern ((IMapType arg0@@38 arg1@@11))))))
(assert (forall ((bx@@9 T@U) (s@@0 T@U) (t@@18 T@U)) (! (=> (and (and (and (= (type bx@@9) BoxType) (= (type s@@0) TyType)) (= (type t@@18) TyType)) ($IsBox bx@@9 (TIMap s@@0 t@@18))) (and (= ($Box ($Unbox (IMapType BoxType BoxType) bx@@9)) bx@@9) ($Is ($Unbox (IMapType BoxType BoxType) bx@@9) (TIMap s@@0 t@@18)))) :qid |DafnyPre.157:15| :skolemid |33| :pattern (($IsBox bx@@9 (TIMap s@@0 t@@18))))))
(assert (forall ((v T@U) (t@@19 T@U)) (! (=> (= (type t@@19) TyType) (and (=> ($IsBox ($Box v) t@@19) ($Is v t@@19)) (=> ($Is v t@@19) ($IsBox ($Box v) t@@19)))) :qid |DafnyPre.161:18| :skolemid |34| :pattern (($IsBox ($Box v) t@@19)))))
(assert (and (and (and (and (and (and (forall ((arg0@@39 T@T)) (! (= (Ctor (MapType1Type arg0@@39)) 13) :qid |ctor:MapType1Type|)) (forall ((arg0@@40 T@T)) (! (= (MapType1TypeInv0 (MapType1Type arg0@@40)) arg0@@40) :qid |typeInv:MapType1TypeInv0| :pattern ((MapType1Type arg0@@40))))) (forall ((arg0@@41 T@U) (arg1@@12 T@U) (arg2@@0 T@U)) (! (let ((alpha@@1 (FieldTypeInv0 (type arg2@@0)))) (= (type (MapType1Select arg0@@41 arg1@@12 arg2@@0)) alpha@@1)) :qid |funType:MapType1Select| :pattern ((MapType1Select arg0@@41 arg1@@12 arg2@@0))))) (forall ((arg0@@42 T@U) (arg1@@13 T@U) (arg2@@1 T@U) (arg3 T@U)) (! (let ((aVar0@@0 (type arg1@@13))) (= (type (MapType1Store arg0@@42 arg1@@13 arg2@@1 arg3)) (MapType1Type aVar0@@0))) :qid |funType:MapType1Store| :pattern ((MapType1Store arg0@@42 arg1@@13 arg2@@1 arg3))))) (forall ((m@@2 T@U) (x0@@2 T@U) (x1 T@U) (val@@2 T@U)) (! (let ((alpha@@2 (FieldTypeInv0 (type x1)))) (=> (= (type val@@2) alpha@@2) (= (MapType1Select (MapType1Store m@@2 x0@@2 x1 val@@2) x0@@2 x1) val@@2))) :qid |mapAx0:MapType1Select| :weight 0))) (and (and (forall ((val@@3 T@U) (m@@3 T@U) (x0@@3 T@U) (x1@@0 T@U) (y0@@1 T@U) (y1 T@U)) (! (or (= x0@@3 y0@@1) (= (MapType1Select (MapType1Store m@@3 x0@@3 x1@@0 val@@3) y0@@1 y1) (MapType1Select m@@3 y0@@1 y1))) :qid |mapAx1:MapType1Select:0| :weight 0)) (forall ((val@@4 T@U) (m@@4 T@U) (x0@@4 T@U) (x1@@1 T@U) (y0@@2 T@U) (y1@@0 T@U)) (! (or (= x1@@1 y1@@0) (= (MapType1Select (MapType1Store m@@4 x0@@4 x1@@1 val@@4) y0@@2 y1@@0) (MapType1Select m@@4 y0@@2 y1@@0))) :qid |mapAx1:MapType1Select:1| :weight 0))) (forall ((val@@5 T@U) (m@@5 T@U) (x0@@5 T@U) (x1@@2 T@U) (y0@@3 T@U) (y1@@1 T@U)) (! (or true (= (MapType1Select (MapType1Store m@@5 x0@@5 x1@@2 val@@5) y0@@3 y1@@1) (MapType1Select m@@5 y0@@3 y1@@1))) :qid |mapAx2:MapType1Select| :weight 0)))) (= (Ctor refType) 14)))
(assert (forall ((v@@0 T@U) (t@@20 T@U) (h T@U)) (! (=> (and (= (type t@@20) TyType) (= (type h) (MapType1Type refType))) (and (=> ($IsAllocBox ($Box v@@0) t@@20 h) ($IsAlloc v@@0 t@@20 h)) (=> ($IsAlloc v@@0 t@@20 h) ($IsAllocBox ($Box v@@0) t@@20 h)))) :qid |DafnyPre.164:18| :skolemid |35| :pattern (($IsAllocBox ($Box v@@0) t@@20 h)))))
(assert (forall ((v@@1 T@U)) (! (=> (= (type v@@1) intType) ($Is v@@1 TInt)) :qid |DafnyPre.182:14| :skolemid |36| :pattern (($Is v@@1 TInt)))))
(assert (forall ((v@@2 T@U)) (! (=> (= (type v@@2) intType) (and (=> ($Is v@@2 TNat) (>= (U_2_int v@@2) 0)) (=> (>= (U_2_int v@@2) 0) ($Is v@@2 TNat)))) :qid |DafnyPre.183:14| :skolemid |37| :pattern (($Is v@@2 TNat)))))
(assert (forall ((v@@3 T@U)) (! (=> (= (type v@@3) realType) ($Is v@@3 TReal)) :qid |DafnyPre.184:14| :skolemid |38| :pattern (($Is v@@3 TReal)))))
(assert (forall ((v@@4 T@U)) (! (=> (= (type v@@4) boolType) ($Is v@@4 TBool)) :qid |DafnyPre.185:14| :skolemid |39| :pattern (($Is v@@4 TBool)))))
(assert (forall ((v@@5 T@U)) (! (=> (= (type v@@5) charType) ($Is v@@5 TChar)) :qid |DafnyPre.186:14| :skolemid |40| :pattern (($Is v@@5 TChar)))))
(assert (forall ((h@@0 T@U) (v@@6 T@U)) (! (=> (and (= (type h@@0) (MapType1Type refType)) (= (type v@@6) intType)) ($IsAlloc v@@6 TInt h@@0)) :qid |DafnyPre.188:14| :skolemid |41| :pattern (($IsAlloc v@@6 TInt h@@0)))))
(assert (forall ((h@@1 T@U) (v@@7 T@U)) (! (=> (and (= (type h@@1) (MapType1Type refType)) (= (type v@@7) intType)) ($IsAlloc v@@7 TNat h@@1)) :qid |DafnyPre.189:14| :skolemid |42| :pattern (($IsAlloc v@@7 TNat h@@1)))))
(assert (forall ((h@@2 T@U) (v@@8 T@U)) (! (=> (and (= (type h@@2) (MapType1Type refType)) (= (type v@@8) realType)) ($IsAlloc v@@8 TReal h@@2)) :qid |DafnyPre.190:14| :skolemid |43| :pattern (($IsAlloc v@@8 TReal h@@2)))))
(assert (forall ((h@@3 T@U) (v@@9 T@U)) (! (=> (and (= (type h@@3) (MapType1Type refType)) (= (type v@@9) boolType)) ($IsAlloc v@@9 TBool h@@3)) :qid |DafnyPre.191:14| :skolemid |44| :pattern (($IsAlloc v@@9 TBool h@@3)))))
(assert (forall ((h@@4 T@U) (v@@10 T@U)) (! (=> (and (= (type h@@4) (MapType1Type refType)) (= (type v@@10) charType)) ($IsAlloc v@@10 TChar h@@4)) :qid |DafnyPre.192:14| :skolemid |45| :pattern (($IsAlloc v@@10 TChar h@@4)))))
(assert (forall ((v@@11 T@U) (t0 T@U)) (! (=> (and (= (type v@@11) (MapType0Type BoxType boolType)) (= (type t0) TyType)) (and (=> ($Is v@@11 (TSet t0)) (forall ((bx@@10 T@U)) (! (=> (and (= (type bx@@10) BoxType) (U_2_bool (MapType0Select v@@11 bx@@10))) ($IsBox bx@@10 t0)) :qid |DafnyPre.196:11| :skolemid |46| :pattern ((MapType0Select v@@11 bx@@10))))) (=> (forall ((bx@@11 T@U)) (! (=> (and (= (type bx@@11) BoxType) (U_2_bool (MapType0Select v@@11 bx@@11))) ($IsBox bx@@11 t0)) :qid |DafnyPre.196:11| :skolemid |46| :pattern ((MapType0Select v@@11 bx@@11)))) ($Is v@@11 (TSet t0))))) :qid |DafnyPre.194:15| :skolemid |47| :pattern (($Is v@@11 (TSet t0))))))
(assert (forall ((v@@12 T@U) (t0@@0 T@U)) (! (=> (and (= (type v@@12) (MapType0Type BoxType boolType)) (= (type t0@@0) TyType)) (and (=> ($Is v@@12 (TISet t0@@0)) (forall ((bx@@12 T@U)) (! (=> (and (= (type bx@@12) BoxType) (U_2_bool (MapType0Select v@@12 bx@@12))) ($IsBox bx@@12 t0@@0)) :qid |DafnyPre.200:11| :skolemid |48| :pattern ((MapType0Select v@@12 bx@@12))))) (=> (forall ((bx@@13 T@U)) (! (=> (and (= (type bx@@13) BoxType) (U_2_bool (MapType0Select v@@12 bx@@13))) ($IsBox bx@@13 t0@@0)) :qid |DafnyPre.200:11| :skolemid |48| :pattern ((MapType0Select v@@12 bx@@13)))) ($Is v@@12 (TISet t0@@0))))) :qid |DafnyPre.198:15| :skolemid |49| :pattern (($Is v@@12 (TISet t0@@0))))))
(assert (forall ((v@@13 T@U) (t0@@1 T@U)) (! (=> (and (= (type v@@13) (MapType0Type BoxType intType)) (= (type t0@@1) TyType)) (and (=> ($Is v@@13 (TMultiSet t0@@1)) (forall ((bx@@14 T@U)) (! (=> (and (= (type bx@@14) BoxType) (< 0 (U_2_int (MapType0Select v@@13 bx@@14)))) ($IsBox bx@@14 t0@@1)) :qid |DafnyPre.204:11| :skolemid |50| :pattern ((MapType0Select v@@13 bx@@14))))) (=> (forall ((bx@@15 T@U)) (! (=> (and (= (type bx@@15) BoxType) (< 0 (U_2_int (MapType0Select v@@13 bx@@15)))) ($IsBox bx@@15 t0@@1)) :qid |DafnyPre.204:11| :skolemid |50| :pattern ((MapType0Select v@@13 bx@@15)))) ($Is v@@13 (TMultiSet t0@@1))))) :qid |DafnyPre.202:15| :skolemid |51| :pattern (($Is v@@13 (TMultiSet t0@@1))))))
(assert (forall ((v@@14 T@U) (t0@@2 T@U)) (! (=> (and (and (= (type v@@14) (MapType0Type BoxType intType)) (= (type t0@@2) TyType)) ($Is v@@14 (TMultiSet t0@@2))) ($IsGoodMultiSet v@@14)) :qid |DafnyPre.206:15| :skolemid |52| :pattern (($Is v@@14 (TMultiSet t0@@2))))))
(assert (forall ((arg0@@43 T@U) (arg1@@14 Int)) (! (let ((T@@2 (SeqTypeInv0 (type arg0@@43)))) (= (type (|Seq#Index| arg0@@43 arg1@@14)) T@@2)) :qid |funType:Seq#Index| :pattern ((|Seq#Index| arg0@@43 arg1@@14)))))
(assert (forall ((v@@15 T@U) (t0@@3 T@U)) (! (=> (and (= (type v@@15) (SeqType BoxType)) (= (type t0@@3) TyType)) (and (=> ($Is v@@15 (TSeq t0@@3)) (forall ((i Int)) (! (=> (and (<= 0 i) (< i (|Seq#Length| v@@15))) ($IsBox (|Seq#Index| v@@15 i) t0@@3)) :qid |DafnyPre.210:11| :skolemid |53| :pattern ((|Seq#Index| v@@15 i))))) (=> (forall ((i@@0 Int)) (! (=> (and (<= 0 i@@0) (< i@@0 (|Seq#Length| v@@15))) ($IsBox (|Seq#Index| v@@15 i@@0) t0@@3)) :qid |DafnyPre.210:11| :skolemid |53| :pattern ((|Seq#Index| v@@15 i@@0)))) ($Is v@@15 (TSeq t0@@3))))) :qid |DafnyPre.208:15| :skolemid |54| :pattern (($Is v@@15 (TSeq t0@@3))))))
(assert (forall ((v@@16 T@U) (t0@@4 T@U) (h@@5 T@U)) (! (=> (and (and (= (type v@@16) (MapType0Type BoxType boolType)) (= (type t0@@4) TyType)) (= (type h@@5) (MapType1Type refType))) (and (=> ($IsAlloc v@@16 (TSet t0@@4) h@@5) (forall ((bx@@16 T@U)) (! (=> (and (= (type bx@@16) BoxType) (U_2_bool (MapType0Select v@@16 bx@@16))) ($IsAllocBox bx@@16 t0@@4 h@@5)) :qid |DafnyPre.215:11| :skolemid |55| :pattern ((MapType0Select v@@16 bx@@16))))) (=> (forall ((bx@@17 T@U)) (! (=> (and (= (type bx@@17) BoxType) (U_2_bool (MapType0Select v@@16 bx@@17))) ($IsAllocBox bx@@17 t0@@4 h@@5)) :qid |DafnyPre.215:11| :skolemid |55| :pattern ((MapType0Select v@@16 bx@@17)))) ($IsAlloc v@@16 (TSet t0@@4) h@@5)))) :qid |DafnyPre.213:15| :skolemid |56| :pattern (($IsAlloc v@@16 (TSet t0@@4) h@@5)))))
(assert (forall ((v@@17 T@U) (t0@@5 T@U) (h@@6 T@U)) (! (=> (and (and (= (type v@@17) (MapType0Type BoxType boolType)) (= (type t0@@5) TyType)) (= (type h@@6) (MapType1Type refType))) (and (=> ($IsAlloc v@@17 (TISet t0@@5) h@@6) (forall ((bx@@18 T@U)) (! (=> (and (= (type bx@@18) BoxType) (U_2_bool (MapType0Select v@@17 bx@@18))) ($IsAllocBox bx@@18 t0@@5 h@@6)) :qid |DafnyPre.219:11| :skolemid |57| :pattern ((MapType0Select v@@17 bx@@18))))) (=> (forall ((bx@@19 T@U)) (! (=> (and (= (type bx@@19) BoxType) (U_2_bool (MapType0Select v@@17 bx@@19))) ($IsAllocBox bx@@19 t0@@5 h@@6)) :qid |DafnyPre.219:11| :skolemid |57| :pattern ((MapType0Select v@@17 bx@@19)))) ($IsAlloc v@@17 (TISet t0@@5) h@@6)))) :qid |DafnyPre.217:15| :skolemid |58| :pattern (($IsAlloc v@@17 (TISet t0@@5) h@@6)))))
(assert (forall ((v@@18 T@U) (t0@@6 T@U) (h@@7 T@U)) (! (=> (and (and (= (type v@@18) (MapType0Type BoxType intType)) (= (type t0@@6) TyType)) (= (type h@@7) (MapType1Type refType))) (and (=> ($IsAlloc v@@18 (TMultiSet t0@@6) h@@7) (forall ((bx@@20 T@U)) (! (=> (and (= (type bx@@20) BoxType) (< 0 (U_2_int (MapType0Select v@@18 bx@@20)))) ($IsAllocBox bx@@20 t0@@6 h@@7)) :qid |DafnyPre.223:11| :skolemid |59| :pattern ((MapType0Select v@@18 bx@@20))))) (=> (forall ((bx@@21 T@U)) (! (=> (and (= (type bx@@21) BoxType) (< 0 (U_2_int (MapType0Select v@@18 bx@@21)))) ($IsAllocBox bx@@21 t0@@6 h@@7)) :qid |DafnyPre.223:11| :skolemid |59| :pattern ((MapType0Select v@@18 bx@@21)))) ($IsAlloc v@@18 (TMultiSet t0@@6) h@@7)))) :qid |DafnyPre.221:15| :skolemid |60| :pattern (($IsAlloc v@@18 (TMultiSet t0@@6) h@@7)))))
(assert (forall ((v@@19 T@U) (t0@@7 T@U) (h@@8 T@U)) (! (=> (and (and (= (type v@@19) (SeqType BoxType)) (= (type t0@@7) TyType)) (= (type h@@8) (MapType1Type refType))) (and (=> ($IsAlloc v@@19 (TSeq t0@@7) h@@8) (forall ((i@@1 Int)) (! (=> (and (<= 0 i@@1) (< i@@1 (|Seq#Length| v@@19))) ($IsAllocBox (|Seq#Index| v@@19 i@@1) t0@@7 h@@8)) :qid |DafnyPre.227:11| :skolemid |61| :pattern ((|Seq#Index| v@@19 i@@1))))) (=> (forall ((i@@2 Int)) (! (=> (and (<= 0 i@@2) (< i@@2 (|Seq#Length| v@@19))) ($IsAllocBox (|Seq#Index| v@@19 i@@2) t0@@7 h@@8)) :qid |DafnyPre.227:11| :skolemid |61| :pattern ((|Seq#Index| v@@19 i@@2)))) ($IsAlloc v@@19 (TSeq t0@@7) h@@8)))) :qid |DafnyPre.225:15| :skolemid |62| :pattern (($IsAlloc v@@19 (TSeq t0@@7) h@@8)))))
(assert (and (forall ((arg0@@44 T@U)) (! (let ((V (MapTypeInv1 (type arg0@@44)))) (let ((U (MapTypeInv0 (type arg0@@44)))) (= (type (|Map#Elements| arg0@@44)) (MapType0Type U V)))) :qid |funType:Map#Elements| :pattern ((|Map#Elements| arg0@@44)))) (forall ((arg0@@45 T@U)) (! (let ((U@@0 (MapTypeInv0 (type arg0@@45)))) (= (type (|Map#Domain| arg0@@45)) (MapType0Type U@@0 boolType))) :qid |funType:Map#Domain| :pattern ((|Map#Domain| arg0@@45))))))
(assert (forall ((v@@20 T@U) (t0@@8 T@U) (t1 T@U)) (! (=> (and (and (= (type v@@20) (MapType BoxType BoxType)) (= (type t0@@8) TyType)) (= (type t1) TyType)) (and (=> ($Is v@@20 (TMap t0@@8 t1)) (forall ((bx@@22 T@U)) (! (=> (and (= (type bx@@22) BoxType) (U_2_bool (MapType0Select (|Map#Domain| v@@20) bx@@22))) (and ($IsBox (MapType0Select (|Map#Elements| v@@20) bx@@22) t1) ($IsBox bx@@22 t0@@8))) :qid |DafnyPre.234:19| :skolemid |63| :pattern ((MapType0Select (|Map#Elements| v@@20) bx@@22)) :pattern ((MapType0Select (|Map#Domain| v@@20) bx@@22))))) (=> (forall ((bx@@23 T@U)) (! (=> (and (= (type bx@@23) BoxType) (U_2_bool (MapType0Select (|Map#Domain| v@@20) bx@@23))) (and ($IsBox (MapType0Select (|Map#Elements| v@@20) bx@@23) t1) ($IsBox bx@@23 t0@@8))) :qid |DafnyPre.234:19| :skolemid |63| :pattern ((MapType0Select (|Map#Elements| v@@20) bx@@23)) :pattern ((MapType0Select (|Map#Domain| v@@20) bx@@23)))) ($Is v@@20 (TMap t0@@8 t1))))) :qid |DafnyPre.231:15| :skolemid |64| :pattern (($Is v@@20 (TMap t0@@8 t1))))))
(assert (forall ((v@@21 T@U) (t0@@9 T@U) (t1@@0 T@U) (h@@9 T@U)) (! (=> (and (and (and (= (type v@@21) (MapType BoxType BoxType)) (= (type t0@@9) TyType)) (= (type t1@@0) TyType)) (= (type h@@9) (MapType1Type refType))) (and (=> ($IsAlloc v@@21 (TMap t0@@9 t1@@0) h@@9) (forall ((bx@@24 T@U)) (! (=> (and (= (type bx@@24) BoxType) (U_2_bool (MapType0Select (|Map#Domain| v@@21) bx@@24))) (and ($IsAllocBox (MapType0Select (|Map#Elements| v@@21) bx@@24) t1@@0 h@@9) ($IsAllocBox bx@@24 t0@@9 h@@9))) :qid |DafnyPre.242:19| :skolemid |65| :pattern ((MapType0Select (|Map#Elements| v@@21) bx@@24)) :pattern ((MapType0Select (|Map#Domain| v@@21) bx@@24))))) (=> (forall ((bx@@25 T@U)) (! (=> (and (= (type bx@@25) BoxType) (U_2_bool (MapType0Select (|Map#Domain| v@@21) bx@@25))) (and ($IsAllocBox (MapType0Select (|Map#Elements| v@@21) bx@@25) t1@@0 h@@9) ($IsAllocBox bx@@25 t0@@9 h@@9))) :qid |DafnyPre.242:19| :skolemid |65| :pattern ((MapType0Select (|Map#Elements| v@@21) bx@@25)) :pattern ((MapType0Select (|Map#Domain| v@@21) bx@@25)))) ($IsAlloc v@@21 (TMap t0@@9 t1@@0) h@@9)))) :qid |DafnyPre.239:15| :skolemid |66| :pattern (($IsAlloc v@@21 (TMap t0@@9 t1@@0) h@@9)))))
(assert (and (forall ((arg0@@46 T@U)) (! (let ((V@@0 (IMapTypeInv1 (type arg0@@46)))) (let ((U@@1 (IMapTypeInv0 (type arg0@@46)))) (= (type (|IMap#Elements| arg0@@46)) (MapType0Type U@@1 V@@0)))) :qid |funType:IMap#Elements| :pattern ((|IMap#Elements| arg0@@46)))) (forall ((arg0@@47 T@U)) (! (let ((U@@2 (IMapTypeInv0 (type arg0@@47)))) (= (type (|IMap#Domain| arg0@@47)) (MapType0Type U@@2 boolType))) :qid |funType:IMap#Domain| :pattern ((|IMap#Domain| arg0@@47))))))
(assert (forall ((v@@22 T@U) (t0@@10 T@U) (t1@@1 T@U)) (! (=> (and (and (= (type v@@22) (IMapType BoxType BoxType)) (= (type t0@@10) TyType)) (= (type t1@@1) TyType)) (and (=> ($Is v@@22 (TIMap t0@@10 t1@@1)) (forall ((bx@@26 T@U)) (! (=> (and (= (type bx@@26) BoxType) (U_2_bool (MapType0Select (|IMap#Domain| v@@22) bx@@26))) (and ($IsBox (MapType0Select (|IMap#Elements| v@@22) bx@@26) t1@@1) ($IsBox bx@@26 t0@@10))) :qid |DafnyPre.251:19| :skolemid |67| :pattern ((MapType0Select (|IMap#Elements| v@@22) bx@@26)) :pattern ((MapType0Select (|IMap#Domain| v@@22) bx@@26))))) (=> (forall ((bx@@27 T@U)) (! (=> (and (= (type bx@@27) BoxType) (U_2_bool (MapType0Select (|IMap#Domain| v@@22) bx@@27))) (and ($IsBox (MapType0Select (|IMap#Elements| v@@22) bx@@27) t1@@1) ($IsBox bx@@27 t0@@10))) :qid |DafnyPre.251:19| :skolemid |67| :pattern ((MapType0Select (|IMap#Elements| v@@22) bx@@27)) :pattern ((MapType0Select (|IMap#Domain| v@@22) bx@@27)))) ($Is v@@22 (TIMap t0@@10 t1@@1))))) :qid |DafnyPre.248:15| :skolemid |68| :pattern (($Is v@@22 (TIMap t0@@10 t1@@1))))))
(assert (forall ((v@@23 T@U) (t0@@11 T@U) (t1@@2 T@U) (h@@10 T@U)) (! (=> (and (and (and (= (type v@@23) (IMapType BoxType BoxType)) (= (type t0@@11) TyType)) (= (type t1@@2) TyType)) (= (type h@@10) (MapType1Type refType))) (and (=> ($IsAlloc v@@23 (TIMap t0@@11 t1@@2) h@@10) (forall ((bx@@28 T@U)) (! (=> (and (= (type bx@@28) BoxType) (U_2_bool (MapType0Select (|IMap#Domain| v@@23) bx@@28))) (and ($IsAllocBox (MapType0Select (|IMap#Elements| v@@23) bx@@28) t1@@2 h@@10) ($IsAllocBox bx@@28 t0@@11 h@@10))) :qid |DafnyPre.259:19| :skolemid |69| :pattern ((MapType0Select (|IMap#Elements| v@@23) bx@@28)) :pattern ((MapType0Select (|IMap#Domain| v@@23) bx@@28))))) (=> (forall ((bx@@29 T@U)) (! (=> (and (= (type bx@@29) BoxType) (U_2_bool (MapType0Select (|IMap#Domain| v@@23) bx@@29))) (and ($IsAllocBox (MapType0Select (|IMap#Elements| v@@23) bx@@29) t1@@2 h@@10) ($IsAllocBox bx@@29 t0@@11 h@@10))) :qid |DafnyPre.259:19| :skolemid |69| :pattern ((MapType0Select (|IMap#Elements| v@@23) bx@@29)) :pattern ((MapType0Select (|IMap#Domain| v@@23) bx@@29)))) ($IsAlloc v@@23 (TIMap t0@@11 t1@@2) h@@10)))) :qid |DafnyPre.256:15| :skolemid |70| :pattern (($IsAlloc v@@23 (TIMap t0@@11 t1@@2) h@@10)))))
(assert (and (and (forall ((arg0@@48 T@U) (arg1@@15 T@U)) (! (= (type (TypeTuple arg0@@48 arg1@@15)) ClassNameType) :qid |funType:TypeTuple| :pattern ((TypeTuple arg0@@48 arg1@@15)))) (forall ((arg0@@49 T@U)) (! (= (type (TypeTupleCar arg0@@49)) ClassNameType) :qid |funType:TypeTupleCar| :pattern ((TypeTupleCar arg0@@49))))) (forall ((arg0@@50 T@U)) (! (= (type (TypeTupleCdr arg0@@50)) ClassNameType) :qid |funType:TypeTupleCdr| :pattern ((TypeTupleCdr arg0@@50))))))
(assert (forall ((a T@U) (b T@U)) (! (=> (and (= (type a) ClassNameType) (= (type b) ClassNameType)) (and (= (TypeTupleCar (TypeTuple a b)) a) (= (TypeTupleCdr (TypeTuple a b)) b))) :qid |DafnyPre.284:15| :skolemid |71| :pattern ((TypeTuple a b)))))
(assert (forall ((arg0@@51 T@U)) (! (= (type (SetRef_to_SetBox arg0@@51)) (MapType0Type BoxType boolType)) :qid |funType:SetRef_to_SetBox| :pattern ((SetRef_to_SetBox arg0@@51)))))
(assert (forall ((s@@1 T@U) (bx@@30 T@U)) (! (=> (and (= (type s@@1) (MapType0Type refType boolType)) (= (type bx@@30) BoxType)) (and (=> (U_2_bool (MapType0Select (SetRef_to_SetBox s@@1) bx@@30)) (U_2_bool (MapType0Select s@@1 ($Unbox refType bx@@30)))) (=> (U_2_bool (MapType0Select s@@1 ($Unbox refType bx@@30))) (U_2_bool (MapType0Select (SetRef_to_SetBox s@@1) bx@@30))))) :qid |DafnyPre.293:15| :skolemid |72| :pattern ((MapType0Select (SetRef_to_SetBox s@@1) bx@@30)))))
(assert (= (type Tclass._System.object) TyType))
(assert (forall ((s@@2 T@U)) (! (=> (= (type s@@2) (MapType0Type refType boolType)) ($Is (SetRef_to_SetBox s@@2) (TSet Tclass._System.object))) :qid |DafnyPre.295:15| :skolemid |73| :pattern ((SetRef_to_SetBox s@@2)))))
(assert (= (Ctor DatatypeTypeType) 15))
(assert (forall ((d T@U)) (! (=> (= (type d) DatatypeTypeType) (= (BoxRank ($Box d)) (DtRank d))) :qid |DafnyPre.310:15| :skolemid |74| :pattern ((BoxRank ($Box d))))))
(assert (and (= (Ctor LayerTypeType) 16) (forall ((arg0@@52 T@U) (arg1@@16 T@U)) (! (let ((A (MapType0TypeInv1 (type arg0@@52)))) (= (type (AtLayer arg0@@52 arg1@@16)) A)) :qid |funType:AtLayer| :pattern ((AtLayer arg0@@52 arg1@@16))))))
(assert (forall ((f T@U) (ly T@U)) (! (let ((A@@0 (MapType0TypeInv1 (type f)))) (=> (and (= (type f) (MapType0Type LayerTypeType A@@0)) (= (type ly) LayerTypeType)) (= (AtLayer f ly) (MapType0Select f ly)))) :qid |DafnyPre.329:18| :skolemid |75| :pattern ((AtLayer f ly)))))
(assert (forall ((arg0@@53 T@U)) (! (= (type ($LS arg0@@53)) LayerTypeType) :qid |funType:$LS| :pattern (($LS arg0@@53)))))
(assert (forall ((f@@0 T@U) (ly@@0 T@U)) (! (let ((A@@1 (MapType0TypeInv1 (type f@@0)))) (=> (and (= (type f@@0) (MapType0Type LayerTypeType A@@1)) (= (type ly@@0) LayerTypeType)) (= (AtLayer f@@0 ($LS ly@@0)) (AtLayer f@@0 ly@@0)))) :qid |DafnyPre.330:18| :skolemid |76| :pattern ((AtLayer f@@0 ($LS ly@@0))))))
(assert (forall ((arg0@@54 Int)) (! (= (type (IndexField arg0@@54)) (FieldType BoxType)) :qid |funType:IndexField| :pattern ((IndexField arg0@@54)))))
(assert (forall ((i@@3 Int)) (! (= (FDim (IndexField i@@3)) 1) :qid |DafnyPre.341:15| :skolemid |77| :pattern ((IndexField i@@3)))))
(assert (forall ((i@@4 Int)) (! (= (IndexField_Inverse (IndexField i@@4)) i@@4) :qid |DafnyPre.343:15| :skolemid |78| :pattern ((IndexField i@@4)))))
(assert (forall ((arg0@@55 T@U) (arg1@@17 Int)) (! (= (type (MultiIndexField arg0@@55 arg1@@17)) (FieldType BoxType)) :qid |funType:MultiIndexField| :pattern ((MultiIndexField arg0@@55 arg1@@17)))))
(assert (forall ((f@@1 T@U) (i@@5 Int)) (! (=> (= (type f@@1) (FieldType BoxType)) (= (FDim (MultiIndexField f@@1 i@@5)) (+ (FDim f@@1) 1))) :qid |DafnyPre.346:15| :skolemid |79| :pattern ((MultiIndexField f@@1 i@@5)))))
(assert (forall ((arg0@@56 T@U)) (! (let ((T@@3 (FieldTypeInv0 (type arg0@@56)))) (= (type (MultiIndexField_Inverse0 arg0@@56)) (FieldType T@@3))) :qid |funType:MultiIndexField_Inverse0| :pattern ((MultiIndexField_Inverse0 arg0@@56)))))
(assert (forall ((f@@2 T@U) (i@@6 Int)) (! (=> (= (type f@@2) (FieldType BoxType)) (and (= (MultiIndexField_Inverse0 (MultiIndexField f@@2 i@@6)) f@@2) (= (MultiIndexField_Inverse1 (MultiIndexField f@@2 i@@6)) i@@6))) :qid |DafnyPre.349:15| :skolemid |80| :pattern ((MultiIndexField f@@2 i@@6)))))
(assert (and (and (and (= (Ctor NameFamilyType) 17) (forall ((alpha@@3 T@T) (arg0@@57 T@U) (arg1@@18 T@U)) (! (= (type (FieldOfDecl alpha@@3 arg0@@57 arg1@@18)) (FieldType alpha@@3)) :qid |funType:FieldOfDecl| :pattern ((FieldOfDecl alpha@@3 arg0@@57 arg1@@18))))) (forall ((arg0@@58 T@U)) (! (= (type (DeclType arg0@@58)) ClassNameType) :qid |funType:DeclType| :pattern ((DeclType arg0@@58))))) (forall ((arg0@@59 T@U)) (! (= (type (DeclName arg0@@59)) NameFamilyType) :qid |funType:DeclName| :pattern ((DeclName arg0@@59))))))
(assert (forall ((cl T@U) (nm T@U) (T@@4 T@T)) (! (=> (and (= (type cl) ClassNameType) (= (type nm) NameFamilyType)) (and (= (DeclType (FieldOfDecl T@@4 cl nm)) cl) (= (DeclName (FieldOfDecl T@@4 cl nm)) nm))) :qid |DafnyPre.358:18| :skolemid |81| :pattern ((FieldOfDecl T@@4 cl nm)))))
(assert (forall ((h@@11 T@U) (k T@U) (v@@24 T@U) (t@@21 T@U)) (! (=> (and (and (and (and (= (type h@@11) (MapType1Type refType)) (= (type k) (MapType1Type refType))) (= (type t@@21) TyType)) ($HeapSucc h@@11 k)) ($IsAlloc v@@24 t@@21 h@@11)) ($IsAlloc v@@24 t@@21 k)) :qid |DafnyPre.371:17| :skolemid |82| :pattern (($HeapSucc h@@11 k) ($IsAlloc v@@24 t@@21 h@@11)))))
(assert (forall ((h@@12 T@U) (k@@0 T@U) (bx@@31 T@U) (t@@22 T@U)) (! (=> (and (and (and (and (and (= (type h@@12) (MapType1Type refType)) (= (type k@@0) (MapType1Type refType))) (= (type bx@@31) BoxType)) (= (type t@@22) TyType)) ($HeapSucc h@@12 k@@0)) ($IsAllocBox bx@@31 t@@22 h@@12)) ($IsAllocBox bx@@31 t@@22 k@@0)) :qid |DafnyPre.374:14| :skolemid |83| :pattern (($HeapSucc h@@12 k@@0) ($IsAllocBox bx@@31 t@@22 h@@12)))))
(assert (= (FDim alloc) 0))
(assert (not ($IsGhostField alloc)))
(assert (forall ((o T@U)) (! (=> (= (type o) refType) (<= 0 (_System.array.Length o))) :qid |DafnyPre.388:15| :skolemid |84| :no-pattern (type o) :no-pattern (U_2_int o) :no-pattern (U_2_bool o))))
(assert (forall ((x@@12 Real)) (! (= (q@Int x@@12) (to_int x@@12)) :qid |DafnyPre.394:14| :skolemid |85| :pattern ((q@Int x@@12)))))
(assert (forall ((x@@13 Int)) (! (= (q@Real x@@13) (to_real x@@13)) :qid |DafnyPre.395:15| :skolemid |86| :pattern ((q@Real x@@13)))))
(assert (forall ((i@@7 Int)) (! (= (q@Int (q@Real i@@7)) i@@7) :qid |DafnyPre.396:15| :skolemid |87| :pattern ((q@Int (q@Real i@@7))))))
(assert (forall ((h@@13 T@U) (r T@U) (f@@3 T@U) (x@@14 T@U)) (! (let ((alpha@@4 (type x@@14))) (=> (and (and (and (= (type h@@13) (MapType1Type refType)) (= (type r) refType)) (= (type f@@3) (FieldType alpha@@4))) ($IsGoodHeap (MapType1Store h@@13 r f@@3 x@@14))) ($HeapSucc h@@13 (MapType1Store h@@13 r f@@3 x@@14)))) :qid |DafnyPre.413:22| :skolemid |88| :pattern ((MapType1Store h@@13 r f@@3 x@@14)))))
(assert (forall ((a@@0 T@U) (b@@0 T@U) (c T@U)) (! (=> (and (and (and (= (type a@@0) (MapType1Type refType)) (= (type b@@0) (MapType1Type refType))) (= (type c) (MapType1Type refType))) (and ($HeapSucc a@@0 b@@0) ($HeapSucc b@@0 c))) ($HeapSucc a@@0 c)) :qid |DafnyPre.416:15| :skolemid |89| :pattern (($HeapSucc a@@0 b@@0) ($HeapSucc b@@0 c)))))
(assert (forall ((h@@14 T@U) (k@@1 T@U)) (! (=> (and (and (= (type h@@14) (MapType1Type refType)) (= (type k@@1) (MapType1Type refType))) ($HeapSucc h@@14 k@@1)) (forall ((o@@0 T@U)) (! (=> (and (= (type o@@0) refType) (U_2_bool (MapType1Select h@@14 o@@0 alloc))) (U_2_bool (MapType1Select k@@1 o@@0 alloc))) :qid |DafnyPre.419:30| :skolemid |90| :pattern ((MapType1Select k@@1 o@@0 alloc))))) :qid |DafnyPre.418:15| :skolemid |91| :pattern (($HeapSucc h@@14 k@@1)))))
(assert (forall ((h@@15 T@U) (k@@2 T@U)) (! (=> (and (and (= (type h@@15) (MapType1Type refType)) (= (type k@@2) (MapType1Type refType))) ($HeapSuccGhost h@@15 k@@2)) (and ($HeapSucc h@@15 k@@2) (forall ((o@@1 T@U) (f@@4 T@U)) (! (let ((alpha@@5 (FieldTypeInv0 (type f@@4)))) (=> (and (and (= (type o@@1) refType) (= (type f@@4) (FieldType alpha@@5))) (not ($IsGhostField f@@4))) (= (MapType1Select h@@15 o@@1 f@@4) (MapType1Select k@@2 o@@1 f@@4)))) :qid |DafnyPre.425:20| :skolemid |92| :pattern ((MapType1Select k@@2 o@@1 f@@4)))))) :qid |DafnyPre.422:15| :skolemid |93| :pattern (($HeapSuccGhost h@@15 k@@2)))))
(assert (forall ((s@@3 T@U)) (! (let ((T@@5 (MapType0TypeInv0 (type s@@3)))) (=> (= (type s@@3) (MapType0Type T@@5 boolType)) (<= 0 (|Set#Card| s@@3)))) :qid |DafnyPre.483:18| :skolemid |98| :pattern ((|Set#Card| s@@3)))))
(assert (forall ((T@@6 T@T)) (! (= (type (|Set#Empty| T@@6)) (MapType0Type T@@6 boolType)) :qid |funType:Set#Empty| :pattern ((|Set#Empty| T@@6)))))
(assert (forall ((o@@2 T@U)) (! (let ((T@@7 (type o@@2))) (not (U_2_bool (MapType0Select (|Set#Empty| T@@7) o@@2)))) :qid |DafnyPre.486:18| :skolemid |99| :pattern ((let ((T@@7 (type o@@2))) (MapType0Select (|Set#Empty| T@@7) o@@2))))))
(assert (forall ((s@@4 T@U)) (! (let ((T@@8 (MapType0TypeInv0 (type s@@4)))) (=> (= (type s@@4) (MapType0Type T@@8 boolType)) (and (and (=> (= (|Set#Card| s@@4) 0) (= s@@4 (|Set#Empty| T@@8))) (=> (= s@@4 (|Set#Empty| T@@8)) (= (|Set#Card| s@@4) 0))) (=> (not (= (|Set#Card| s@@4) 0)) (exists ((x@@15 T@U)) (! (and (= (type x@@15) T@@8) (U_2_bool (MapType0Select s@@4 x@@15))) :qid |DafnyPre.489:33| :skolemid |100| :no-pattern (type x@@15) :no-pattern (U_2_int x@@15) :no-pattern (U_2_bool x@@15))))))) :qid |DafnyPre.487:18| :skolemid |101| :pattern ((|Set#Card| s@@4)))))
(assert (forall ((arg0@@60 T@U)) (! (let ((T@@9 (type arg0@@60))) (= (type (|Set#Singleton| arg0@@60)) (MapType0Type T@@9 boolType))) :qid |funType:Set#Singleton| :pattern ((|Set#Singleton| arg0@@60)))))
(assert (forall ((r@@0 T@U)) (! (U_2_bool (MapType0Select (|Set#Singleton| r@@0) r@@0)) :qid |DafnyPre.495:18| :skolemid |102| :pattern ((|Set#Singleton| r@@0)))))
(assert (forall ((r@@1 T@U) (o@@3 T@U)) (! (let ((T@@10 (type r@@1))) (=> (= (type o@@3) T@@10) (and (=> (U_2_bool (MapType0Select (|Set#Singleton| r@@1) o@@3)) (= r@@1 o@@3)) (=> (= r@@1 o@@3) (U_2_bool (MapType0Select (|Set#Singleton| r@@1) o@@3)))))) :qid |DafnyPre.496:18| :skolemid |103| :pattern ((MapType0Select (|Set#Singleton| r@@1) o@@3)))))
(assert (forall ((r@@2 T@U)) (! (= (|Set#Card| (|Set#Singleton| r@@2)) 1) :qid |DafnyPre.497:18| :skolemid |104| :pattern ((|Set#Card| (|Set#Singleton| r@@2))))))
(assert (forall ((arg0@@61 T@U) (arg1@@19 T@U)) (! (let ((T@@11 (type arg1@@19))) (= (type (|Set#UnionOne| arg0@@61 arg1@@19)) (MapType0Type T@@11 boolType))) :qid |funType:Set#UnionOne| :pattern ((|Set#UnionOne| arg0@@61 arg1@@19)))))
(assert (forall ((a@@1 T@U) (x@@16 T@U) (o@@4 T@U)) (! (let ((T@@12 (type x@@16))) (=> (and (= (type a@@1) (MapType0Type T@@12 boolType)) (= (type o@@4) T@@12)) (and (=> (U_2_bool (MapType0Select (|Set#UnionOne| a@@1 x@@16) o@@4)) (or (= o@@4 x@@16) (U_2_bool (MapType0Select a@@1 o@@4)))) (=> (or (= o@@4 x@@16) (U_2_bool (MapType0Select a@@1 o@@4))) (U_2_bool (MapType0Select (|Set#UnionOne| a@@1 x@@16) o@@4)))))) :qid |DafnyPre.500:18| :skolemid |105| :pattern ((MapType0Select (|Set#UnionOne| a@@1 x@@16) o@@4)))))
(assert (forall ((a@@2 T@U) (x@@17 T@U)) (! (let ((T@@13 (type x@@17))) (=> (= (type a@@2) (MapType0Type T@@13 boolType)) (U_2_bool (MapType0Select (|Set#UnionOne| a@@2 x@@17) x@@17)))) :qid |DafnyPre.502:18| :skolemid |106| :pattern ((|Set#UnionOne| a@@2 x@@17)))))
(assert (forall ((a@@3 T@U) (x@@18 T@U) (y@@1 T@U)) (! (let ((T@@14 (type x@@18))) (=> (and (and (= (type a@@3) (MapType0Type T@@14 boolType)) (= (type y@@1) T@@14)) (U_2_bool (MapType0Select a@@3 y@@1))) (U_2_bool (MapType0Select (|Set#UnionOne| a@@3 x@@18) y@@1)))) :qid |DafnyPre.504:18| :skolemid |107| :pattern ((|Set#UnionOne| a@@3 x@@18) (MapType0Select a@@3 y@@1)))))
(assert (forall ((a@@4 T@U) (x@@19 T@U)) (! (let ((T@@15 (type x@@19))) (=> (and (= (type a@@4) (MapType0Type T@@15 boolType)) (U_2_bool (MapType0Select a@@4 x@@19))) (= (|Set#Card| (|Set#UnionOne| a@@4 x@@19)) (|Set#Card| a@@4)))) :qid |DafnyPre.506:18| :skolemid |108| :pattern ((|Set#Card| (|Set#UnionOne| a@@4 x@@19))))))
(assert (forall ((a@@5 T@U) (x@@20 T@U)) (! (let ((T@@16 (type x@@20))) (=> (and (= (type a@@5) (MapType0Type T@@16 boolType)) (not (U_2_bool (MapType0Select a@@5 x@@20)))) (= (|Set#Card| (|Set#UnionOne| a@@5 x@@20)) (+ (|Set#Card| a@@5) 1)))) :qid |DafnyPre.508:18| :skolemid |109| :pattern ((|Set#Card| (|Set#UnionOne| a@@5 x@@20))))))
(assert (forall ((arg0@@62 T@U) (arg1@@20 T@U)) (! (let ((T@@17 (MapType0TypeInv0 (type arg0@@62)))) (= (type (|Set#Union| arg0@@62 arg1@@20)) (MapType0Type T@@17 boolType))) :qid |funType:Set#Union| :pattern ((|Set#Union| arg0@@62 arg1@@20)))))
(assert (forall ((a@@6 T@U) (b@@1 T@U) (o@@5 T@U)) (! (let ((T@@18 (type o@@5))) (=> (and (= (type a@@6) (MapType0Type T@@18 boolType)) (= (type b@@1) (MapType0Type T@@18 boolType))) (and (=> (U_2_bool (MapType0Select (|Set#Union| a@@6 b@@1) o@@5)) (or (U_2_bool (MapType0Select a@@6 o@@5)) (U_2_bool (MapType0Select b@@1 o@@5)))) (=> (or (U_2_bool (MapType0Select a@@6 o@@5)) (U_2_bool (MapType0Select b@@1 o@@5))) (U_2_bool (MapType0Select (|Set#Union| a@@6 b@@1) o@@5)))))) :qid |DafnyPre.512:18| :skolemid |110| :pattern ((MapType0Select (|Set#Union| a@@6 b@@1) o@@5)))))
(assert (forall ((a@@7 T@U) (b@@2 T@U) (y@@2 T@U)) (! (let ((T@@19 (type y@@2))) (=> (and (and (= (type a@@7) (MapType0Type T@@19 boolType)) (= (type b@@2) (MapType0Type T@@19 boolType))) (U_2_bool (MapType0Select a@@7 y@@2))) (U_2_bool (MapType0Select (|Set#Union| a@@7 b@@2) y@@2)))) :qid |DafnyPre.514:18| :skolemid |111| :pattern ((|Set#Union| a@@7 b@@2) (MapType0Select a@@7 y@@2)))))
(assert (forall ((a@@8 T@U) (b@@3 T@U) (y@@3 T@U)) (! (let ((T@@20 (type y@@3))) (=> (and (and (= (type a@@8) (MapType0Type T@@20 boolType)) (= (type b@@3) (MapType0Type T@@20 boolType))) (U_2_bool (MapType0Select b@@3 y@@3))) (U_2_bool (MapType0Select (|Set#Union| a@@8 b@@3) y@@3)))) :qid |DafnyPre.516:18| :skolemid |112| :pattern ((|Set#Union| a@@8 b@@3) (MapType0Select b@@3 y@@3)))))
(assert (forall ((arg0@@63 T@U) (arg1@@21 T@U)) (! (let ((T@@21 (MapType0TypeInv0 (type arg0@@63)))) (= (type (|Set#Difference| arg0@@63 arg1@@21)) (MapType0Type T@@21 boolType))) :qid |funType:Set#Difference| :pattern ((|Set#Difference| arg0@@63 arg1@@21)))))
(assert (forall ((a@@9 T@U) (b@@4 T@U)) (! (let ((T@@22 (MapType0TypeInv0 (type a@@9)))) (=> (and (and (= (type a@@9) (MapType0Type T@@22 boolType)) (= (type b@@4) (MapType0Type T@@22 boolType))) (|Set#Disjoint| a@@9 b@@4)) (and (= (|Set#Difference| (|Set#Union| a@@9 b@@4) a@@9) b@@4) (= (|Set#Difference| (|Set#Union| a@@9 b@@4) b@@4) a@@9)))) :qid |DafnyPre.518:18| :skolemid |113| :pattern ((|Set#Union| a@@9 b@@4)))))
(assert (forall ((arg0@@64 T@U) (arg1@@22 T@U)) (! (let ((T@@23 (MapType0TypeInv0 (type arg0@@64)))) (= (type (|Set#Intersection| arg0@@64 arg1@@22)) (MapType0Type T@@23 boolType))) :qid |funType:Set#Intersection| :pattern ((|Set#Intersection| arg0@@64 arg1@@22)))))
(assert (forall ((a@@10 T@U) (b@@5 T@U) (o@@6 T@U)) (! (let ((T@@24 (type o@@6))) (=> (and (= (type a@@10) (MapType0Type T@@24 boolType)) (= (type b@@5) (MapType0Type T@@24 boolType))) (and (=> (U_2_bool (MapType0Select (|Set#Intersection| a@@10 b@@5) o@@6)) (and (U_2_bool (MapType0Select a@@10 o@@6)) (U_2_bool (MapType0Select b@@5 o@@6)))) (=> (and (U_2_bool (MapType0Select a@@10 o@@6)) (U_2_bool (MapType0Select b@@5 o@@6))) (U_2_bool (MapType0Select (|Set#Intersection| a@@10 b@@5) o@@6)))))) :qid |DafnyPre.528:18| :skolemid |114| :pattern ((MapType0Select (|Set#Intersection| a@@10 b@@5) o@@6)))))
(assert (forall ((a@@11 T@U) (b@@6 T@U)) (! (let ((T@@25 (MapType0TypeInv0 (type a@@11)))) (=> (and (= (type a@@11) (MapType0Type T@@25 boolType)) (= (type b@@6) (MapType0Type T@@25 boolType))) (= (|Set#Union| (|Set#Union| a@@11 b@@6) b@@6) (|Set#Union| a@@11 b@@6)))) :qid |DafnyPre.531:18| :skolemid |115| :pattern ((|Set#Union| (|Set#Union| a@@11 b@@6) b@@6)))))
(assert (forall ((a@@12 T@U) (b@@7 T@U)) (! (let ((T@@26 (MapType0TypeInv0 (type a@@12)))) (=> (and (= (type a@@12) (MapType0Type T@@26 boolType)) (= (type b@@7) (MapType0Type T@@26 boolType))) (= (|Set#Union| a@@12 (|Set#Union| a@@12 b@@7)) (|Set#Union| a@@12 b@@7)))) :qid |DafnyPre.533:18| :skolemid |116| :pattern ((|Set#Union| a@@12 (|Set#Union| a@@12 b@@7))))))
(assert (forall ((a@@13 T@U) (b@@8 T@U)) (! (let ((T@@27 (MapType0TypeInv0 (type a@@13)))) (=> (and (= (type a@@13) (MapType0Type T@@27 boolType)) (= (type b@@8) (MapType0Type T@@27 boolType))) (= (|Set#Intersection| (|Set#Intersection| a@@13 b@@8) b@@8) (|Set#Intersection| a@@13 b@@8)))) :qid |DafnyPre.535:18| :skolemid |117| :pattern ((|Set#Intersection| (|Set#Intersection| a@@13 b@@8) b@@8)))))
(assert (forall ((a@@14 T@U) (b@@9 T@U)) (! (let ((T@@28 (MapType0TypeInv0 (type a@@14)))) (=> (and (= (type a@@14) (MapType0Type T@@28 boolType)) (= (type b@@9) (MapType0Type T@@28 boolType))) (= (|Set#Intersection| a@@14 (|Set#Intersection| a@@14 b@@9)) (|Set#Intersection| a@@14 b@@9)))) :qid |DafnyPre.537:18| :skolemid |118| :pattern ((|Set#Intersection| a@@14 (|Set#Intersection| a@@14 b@@9))))))
(assert (forall ((a@@15 T@U) (b@@10 T@U)) (! (let ((T@@29 (MapType0TypeInv0 (type a@@15)))) (=> (and (= (type a@@15) (MapType0Type T@@29 boolType)) (= (type b@@10) (MapType0Type T@@29 boolType))) (= (+ (|Set#Card| (|Set#Union| a@@15 b@@10)) (|Set#Card| (|Set#Intersection| a@@15 b@@10))) (+ (|Set#Card| a@@15) (|Set#Card| b@@10))))) :qid |DafnyPre.539:18| :skolemid |119| :pattern ((|Set#Card| (|Set#Union| a@@15 b@@10))) :pattern ((|Set#Card| (|Set#Intersection| a@@15 b@@10))))))
(assert (forall ((a@@16 T@U) (b@@11 T@U) (o@@7 T@U)) (! (let ((T@@30 (type o@@7))) (=> (and (= (type a@@16) (MapType0Type T@@30 boolType)) (= (type b@@11) (MapType0Type T@@30 boolType))) (and (=> (U_2_bool (MapType0Select (|Set#Difference| a@@16 b@@11) o@@7)) (and (U_2_bool (MapType0Select a@@16 o@@7)) (not (U_2_bool (MapType0Select b@@11 o@@7))))) (=> (and (U_2_bool (MapType0Select a@@16 o@@7)) (not (U_2_bool (MapType0Select b@@11 o@@7)))) (U_2_bool (MapType0Select (|Set#Difference| a@@16 b@@11) o@@7)))))) :qid |DafnyPre.543:18| :skolemid |120| :pattern ((MapType0Select (|Set#Difference| a@@16 b@@11) o@@7)))))
(assert (forall ((a@@17 T@U) (b@@12 T@U) (y@@4 T@U)) (! (let ((T@@31 (type y@@4))) (=> (and (and (= (type a@@17) (MapType0Type T@@31 boolType)) (= (type b@@12) (MapType0Type T@@31 boolType))) (U_2_bool (MapType0Select b@@12 y@@4))) (not (U_2_bool (MapType0Select (|Set#Difference| a@@17 b@@12) y@@4))))) :qid |DafnyPre.545:18| :skolemid |121| :pattern ((|Set#Difference| a@@17 b@@12) (MapType0Select b@@12 y@@4)))))
(assert (forall ((a@@18 T@U) (b@@13 T@U)) (! (let ((T@@32 (MapType0TypeInv0 (type a@@18)))) (=> (and (= (type a@@18) (MapType0Type T@@32 boolType)) (= (type b@@13) (MapType0Type T@@32 boolType))) (and (= (+ (+ (|Set#Card| (|Set#Difference| a@@18 b@@13)) (|Set#Card| (|Set#Difference| b@@13 a@@18))) (|Set#Card| (|Set#Intersection| a@@18 b@@13))) (|Set#Card| (|Set#Union| a@@18 b@@13))) (= (|Set#Card| (|Set#Difference| a@@18 b@@13)) (- (|Set#Card| a@@18) (|Set#Card| (|Set#Intersection| a@@18 b@@13))))))) :qid |DafnyPre.547:18| :skolemid |122| :pattern ((|Set#Card| (|Set#Difference| a@@18 b@@13))))))
(assert (forall ((a@@19 T@U) (b@@14 T@U)) (! (let ((T@@33 (MapType0TypeInv0 (type a@@19)))) (=> (and (= (type a@@19) (MapType0Type T@@33 boolType)) (= (type b@@14) (MapType0Type T@@33 boolType))) (and (=> (|Set#Subset| a@@19 b@@14) (forall ((o@@8 T@U)) (! (=> (and (= (type o@@8) T@@33) (U_2_bool (MapType0Select a@@19 o@@8))) (U_2_bool (MapType0Select b@@14 o@@8))) :qid |DafnyPre.556:32| :skolemid |123| :pattern ((MapType0Select a@@19 o@@8)) :pattern ((MapType0Select b@@14 o@@8))))) (=> (forall ((o@@9 T@U)) (! (=> (and (= (type o@@9) T@@33) (U_2_bool (MapType0Select a@@19 o@@9))) (U_2_bool (MapType0Select b@@14 o@@9))) :qid |DafnyPre.556:32| :skolemid |123| :pattern ((MapType0Select a@@19 o@@9)) :pattern ((MapType0Select b@@14 o@@9)))) (|Set#Subset| a@@19 b@@14))))) :qid |DafnyPre.555:17| :skolemid |124| :pattern ((|Set#Subset| a@@19 b@@14)))))
(assert (forall ((a@@20 T@U) (b@@15 T@U)) (! (let ((T@@34 (MapType0TypeInv0 (type a@@20)))) (=> (and (= (type a@@20) (MapType0Type T@@34 boolType)) (= (type b@@15) (MapType0Type T@@34 boolType))) (and (=> (|Set#Equal| a@@20 b@@15) (forall ((o@@10 T@U)) (! (=> (= (type o@@10) T@@34) (and (=> (U_2_bool (MapType0Select a@@20 o@@10)) (U_2_bool (MapType0Select b@@15 o@@10))) (=> (U_2_bool (MapType0Select b@@15 o@@10)) (U_2_bool (MapType0Select a@@20 o@@10))))) :qid |DafnyPre.564:31| :skolemid |125| :pattern ((MapType0Select a@@20 o@@10)) :pattern ((MapType0Select b@@15 o@@10))))) (=> (forall ((o@@11 T@U)) (! (=> (= (type o@@11) T@@34) (and (=> (U_2_bool (MapType0Select a@@20 o@@11)) (U_2_bool (MapType0Select b@@15 o@@11))) (=> (U_2_bool (MapType0Select b@@15 o@@11)) (U_2_bool (MapType0Select a@@20 o@@11))))) :qid |DafnyPre.564:31| :skolemid |125| :pattern ((MapType0Select a@@20 o@@11)) :pattern ((MapType0Select b@@15 o@@11)))) (|Set#Equal| a@@20 b@@15))))) :qid |DafnyPre.563:17| :skolemid |126| :pattern ((|Set#Equal| a@@20 b@@15)))))
(assert (forall ((a@@21 T@U) (b@@16 T@U)) (! (let ((T@@35 (MapType0TypeInv0 (type a@@21)))) (=> (and (and (= (type a@@21) (MapType0Type T@@35 boolType)) (= (type b@@16) (MapType0Type T@@35 boolType))) (|Set#Equal| a@@21 b@@16)) (= a@@21 b@@16))) :qid |DafnyPre.565:17| :skolemid |127| :pattern ((|Set#Equal| a@@21 b@@16)))))
(assert (forall ((a@@22 T@U) (b@@17 T@U)) (! (let ((T@@36 (MapType0TypeInv0 (type a@@22)))) (=> (and (= (type a@@22) (MapType0Type T@@36 boolType)) (= (type b@@17) (MapType0Type T@@36 boolType))) (and (=> (|Set#Disjoint| a@@22 b@@17) (forall ((o@@12 T@U)) (! (=> (= (type o@@12) T@@36) (or (not (U_2_bool (MapType0Select a@@22 o@@12))) (not (U_2_bool (MapType0Select b@@17 o@@12))))) :qid |DafnyPre.570:34| :skolemid |128| :pattern ((MapType0Select a@@22 o@@12)) :pattern ((MapType0Select b@@17 o@@12))))) (=> (forall ((o@@13 T@U)) (! (=> (= (type o@@13) T@@36) (or (not (U_2_bool (MapType0Select a@@22 o@@13))) (not (U_2_bool (MapType0Select b@@17 o@@13))))) :qid |DafnyPre.570:34| :skolemid |128| :pattern ((MapType0Select a@@22 o@@13)) :pattern ((MapType0Select b@@17 o@@13)))) (|Set#Disjoint| a@@22 b@@17))))) :qid |DafnyPre.569:18| :skolemid |129| :pattern ((|Set#Disjoint| a@@22 b@@17)))))
(assert (forall ((T@@37 T@T)) (! (= (type (|ISet#Empty| T@@37)) (MapType0Type T@@37 boolType)) :qid |funType:ISet#Empty| :pattern ((|ISet#Empty| T@@37)))))
(assert (forall ((o@@14 T@U)) (! (let ((T@@38 (type o@@14))) (not (U_2_bool (MapType0Select (|ISet#Empty| T@@38) o@@14)))) :qid |DafnyPre.579:18| :skolemid |130| :pattern ((let ((T@@38 (type o@@14))) (MapType0Select (|ISet#Empty| T@@38) o@@14))))))
(assert (forall ((arg0@@65 T@U) (arg1@@23 T@U)) (! (let ((T@@39 (type arg1@@23))) (= (type (|ISet#UnionOne| arg0@@65 arg1@@23)) (MapType0Type T@@39 boolType))) :qid |funType:ISet#UnionOne| :pattern ((|ISet#UnionOne| arg0@@65 arg1@@23)))))
(assert (forall ((a@@23 T@U) (x@@21 T@U) (o@@15 T@U)) (! (let ((T@@40 (type x@@21))) (=> (and (= (type a@@23) (MapType0Type T@@40 boolType)) (= (type o@@15) T@@40)) (and (=> (U_2_bool (MapType0Select (|ISet#UnionOne| a@@23 x@@21) o@@15)) (or (= o@@15 x@@21) (U_2_bool (MapType0Select a@@23 o@@15)))) (=> (or (= o@@15 x@@21) (U_2_bool (MapType0Select a@@23 o@@15))) (U_2_bool (MapType0Select (|ISet#UnionOne| a@@23 x@@21) o@@15)))))) :qid |DafnyPre.586:18| :skolemid |131| :pattern ((MapType0Select (|ISet#UnionOne| a@@23 x@@21) o@@15)))))
(assert (forall ((a@@24 T@U) (x@@22 T@U)) (! (let ((T@@41 (type x@@22))) (=> (= (type a@@24) (MapType0Type T@@41 boolType)) (U_2_bool (MapType0Select (|ISet#UnionOne| a@@24 x@@22) x@@22)))) :qid |DafnyPre.588:18| :skolemid |132| :pattern ((|ISet#UnionOne| a@@24 x@@22)))))
(assert (forall ((a@@25 T@U) (x@@23 T@U) (y@@5 T@U)) (! (let ((T@@42 (type x@@23))) (=> (and (and (= (type a@@25) (MapType0Type T@@42 boolType)) (= (type y@@5) T@@42)) (U_2_bool (MapType0Select a@@25 y@@5))) (U_2_bool (MapType0Select (|ISet#UnionOne| a@@25 x@@23) y@@5)))) :qid |DafnyPre.590:18| :skolemid |133| :pattern ((|ISet#UnionOne| a@@25 x@@23) (MapType0Select a@@25 y@@5)))))
(assert (forall ((arg0@@66 T@U) (arg1@@24 T@U)) (! (let ((T@@43 (MapType0TypeInv0 (type arg0@@66)))) (= (type (|ISet#Union| arg0@@66 arg1@@24)) (MapType0Type T@@43 boolType))) :qid |funType:ISet#Union| :pattern ((|ISet#Union| arg0@@66 arg1@@24)))))
(assert (forall ((a@@26 T@U) (b@@18 T@U) (o@@16 T@U)) (! (let ((T@@44 (type o@@16))) (=> (and (= (type a@@26) (MapType0Type T@@44 boolType)) (= (type b@@18) (MapType0Type T@@44 boolType))) (and (=> (U_2_bool (MapType0Select (|ISet#Union| a@@26 b@@18) o@@16)) (or (U_2_bool (MapType0Select a@@26 o@@16)) (U_2_bool (MapType0Select b@@18 o@@16)))) (=> (or (U_2_bool (MapType0Select a@@26 o@@16)) (U_2_bool (MapType0Select b@@18 o@@16))) (U_2_bool (MapType0Select (|ISet#Union| a@@26 b@@18) o@@16)))))) :qid |DafnyPre.594:18| :skolemid |134| :pattern ((MapType0Select (|ISet#Union| a@@26 b@@18) o@@16)))))
(assert (forall ((a@@27 T@U) (b@@19 T@U) (y@@6 T@U)) (! (let ((T@@45 (type y@@6))) (=> (and (and (= (type a@@27) (MapType0Type T@@45 boolType)) (= (type b@@19) (MapType0Type T@@45 boolType))) (U_2_bool (MapType0Select a@@27 y@@6))) (U_2_bool (MapType0Select (|ISet#Union| a@@27 b@@19) y@@6)))) :qid |DafnyPre.596:18| :skolemid |135| :pattern ((|ISet#Union| a@@27 b@@19) (MapType0Select a@@27 y@@6)))))
(assert (forall ((a@@28 T@U) (b@@20 T@U) (y@@7 T@U)) (! (let ((T@@46 (type y@@7))) (=> (and (and (= (type a@@28) (MapType0Type T@@46 boolType)) (= (type b@@20) (MapType0Type T@@46 boolType))) (U_2_bool (MapType0Select b@@20 y@@7))) (U_2_bool (MapType0Select (|ISet#Union| a@@28 b@@20) y@@7)))) :qid |DafnyPre.598:18| :skolemid |136| :pattern ((|ISet#Union| a@@28 b@@20) (MapType0Select b@@20 y@@7)))))
(assert (forall ((arg0@@67 T@U) (arg1@@25 T@U)) (! (let ((T@@47 (MapType0TypeInv0 (type arg0@@67)))) (= (type (|ISet#Difference| arg0@@67 arg1@@25)) (MapType0Type T@@47 boolType))) :qid |funType:ISet#Difference| :pattern ((|ISet#Difference| arg0@@67 arg1@@25)))))
(assert (forall ((a@@29 T@U) (b@@21 T@U)) (! (let ((T@@48 (MapType0TypeInv0 (type a@@29)))) (=> (and (and (= (type a@@29) (MapType0Type T@@48 boolType)) (= (type b@@21) (MapType0Type T@@48 boolType))) (|ISet#Disjoint| a@@29 b@@21)) (and (= (|ISet#Difference| (|ISet#Union| a@@29 b@@21) a@@29) b@@21) (= (|ISet#Difference| (|ISet#Union| a@@29 b@@21) b@@21) a@@29)))) :qid |DafnyPre.600:18| :skolemid |137| :pattern ((|ISet#Union| a@@29 b@@21)))))
(assert (forall ((arg0@@68 T@U) (arg1@@26 T@U)) (! (let ((T@@49 (MapType0TypeInv0 (type arg0@@68)))) (= (type (|ISet#Intersection| arg0@@68 arg1@@26)) (MapType0Type T@@49 boolType))) :qid |funType:ISet#Intersection| :pattern ((|ISet#Intersection| arg0@@68 arg1@@26)))))
(assert (forall ((a@@30 T@U) (b@@22 T@U) (o@@17 T@U)) (! (let ((T@@50 (type o@@17))) (=> (and (= (type a@@30) (MapType0Type T@@50 boolType)) (= (type b@@22) (MapType0Type T@@50 boolType))) (and (=> (U_2_bool (MapType0Select (|ISet#Intersection| a@@30 b@@22) o@@17)) (and (U_2_bool (MapType0Select a@@30 o@@17)) (U_2_bool (MapType0Select b@@22 o@@17)))) (=> (and (U_2_bool (MapType0Select a@@30 o@@17)) (U_2_bool (MapType0Select b@@22 o@@17))) (U_2_bool (MapType0Select (|ISet#Intersection| a@@30 b@@22) o@@17)))))) :qid |DafnyPre.610:18| :skolemid |138| :pattern ((MapType0Select (|ISet#Intersection| a@@30 b@@22) o@@17)))))
(assert (forall ((a@@31 T@U) (b@@23 T@U)) (! (let ((T@@51 (MapType0TypeInv0 (type a@@31)))) (=> (and (= (type a@@31) (MapType0Type T@@51 boolType)) (= (type b@@23) (MapType0Type T@@51 boolType))) (= (|ISet#Union| (|ISet#Union| a@@31 b@@23) b@@23) (|ISet#Union| a@@31 b@@23)))) :qid |DafnyPre.613:18| :skolemid |139| :pattern ((|ISet#Union| (|ISet#Union| a@@31 b@@23) b@@23)))))
(assert (forall ((a@@32 T@U) (b@@24 T@U)) (! (let ((T@@52 (MapType0TypeInv0 (type a@@32)))) (=> (and (= (type a@@32) (MapType0Type T@@52 boolType)) (= (type b@@24) (MapType0Type T@@52 boolType))) (= (|ISet#Union| a@@32 (|ISet#Union| a@@32 b@@24)) (|ISet#Union| a@@32 b@@24)))) :qid |DafnyPre.615:18| :skolemid |140| :pattern ((|ISet#Union| a@@32 (|ISet#Union| a@@32 b@@24))))))
(assert (forall ((a@@33 T@U) (b@@25 T@U)) (! (let ((T@@53 (MapType0TypeInv0 (type a@@33)))) (=> (and (= (type a@@33) (MapType0Type T@@53 boolType)) (= (type b@@25) (MapType0Type T@@53 boolType))) (= (|ISet#Intersection| (|ISet#Intersection| a@@33 b@@25) b@@25) (|ISet#Intersection| a@@33 b@@25)))) :qid |DafnyPre.617:18| :skolemid |141| :pattern ((|ISet#Intersection| (|ISet#Intersection| a@@33 b@@25) b@@25)))))
(assert (forall ((a@@34 T@U) (b@@26 T@U)) (! (let ((T@@54 (MapType0TypeInv0 (type a@@34)))) (=> (and (= (type a@@34) (MapType0Type T@@54 boolType)) (= (type b@@26) (MapType0Type T@@54 boolType))) (= (|ISet#Intersection| a@@34 (|ISet#Intersection| a@@34 b@@26)) (|ISet#Intersection| a@@34 b@@26)))) :qid |DafnyPre.619:18| :skolemid |142| :pattern ((|ISet#Intersection| a@@34 (|ISet#Intersection| a@@34 b@@26))))))
(assert (forall ((a@@35 T@U) (b@@27 T@U) (o@@18 T@U)) (! (let ((T@@55 (type o@@18))) (=> (and (= (type a@@35) (MapType0Type T@@55 boolType)) (= (type b@@27) (MapType0Type T@@55 boolType))) (and (=> (U_2_bool (MapType0Select (|ISet#Difference| a@@35 b@@27) o@@18)) (and (U_2_bool (MapType0Select a@@35 o@@18)) (not (U_2_bool (MapType0Select b@@27 o@@18))))) (=> (and (U_2_bool (MapType0Select a@@35 o@@18)) (not (U_2_bool (MapType0Select b@@27 o@@18)))) (U_2_bool (MapType0Select (|ISet#Difference| a@@35 b@@27) o@@18)))))) :qid |DafnyPre.624:18| :skolemid |143| :pattern ((MapType0Select (|ISet#Difference| a@@35 b@@27) o@@18)))))
(assert (forall ((a@@36 T@U) (b@@28 T@U) (y@@8 T@U)) (! (let ((T@@56 (type y@@8))) (=> (and (and (= (type a@@36) (MapType0Type T@@56 boolType)) (= (type b@@28) (MapType0Type T@@56 boolType))) (U_2_bool (MapType0Select b@@28 y@@8))) (not (U_2_bool (MapType0Select (|ISet#Difference| a@@36 b@@28) y@@8))))) :qid |DafnyPre.626:18| :skolemid |144| :pattern ((|ISet#Difference| a@@36 b@@28) (MapType0Select b@@28 y@@8)))))
(assert (forall ((a@@37 T@U) (b@@29 T@U)) (! (let ((T@@57 (MapType0TypeInv0 (type a@@37)))) (=> (and (= (type a@@37) (MapType0Type T@@57 boolType)) (= (type b@@29) (MapType0Type T@@57 boolType))) (and (=> (|ISet#Subset| a@@37 b@@29) (forall ((o@@19 T@U)) (! (=> (and (= (type o@@19) T@@57) (U_2_bool (MapType0Select a@@37 o@@19))) (U_2_bool (MapType0Select b@@29 o@@19))) :qid |DafnyPre.631:33| :skolemid |145| :pattern ((MapType0Select a@@37 o@@19)) :pattern ((MapType0Select b@@29 o@@19))))) (=> (forall ((o@@20 T@U)) (! (=> (and (= (type o@@20) T@@57) (U_2_bool (MapType0Select a@@37 o@@20))) (U_2_bool (MapType0Select b@@29 o@@20))) :qid |DafnyPre.631:33| :skolemid |145| :pattern ((MapType0Select a@@37 o@@20)) :pattern ((MapType0Select b@@29 o@@20)))) (|ISet#Subset| a@@37 b@@29))))) :qid |DafnyPre.630:17| :skolemid |146| :pattern ((|ISet#Subset| a@@37 b@@29)))))
(assert (forall ((a@@38 T@U) (b@@30 T@U)) (! (let ((T@@58 (MapType0TypeInv0 (type a@@38)))) (=> (and (= (type a@@38) (MapType0Type T@@58 boolType)) (= (type b@@30) (MapType0Type T@@58 boolType))) (and (=> (|ISet#Equal| a@@38 b@@30) (forall ((o@@21 T@U)) (! (=> (= (type o@@21) T@@58) (and (=> (U_2_bool (MapType0Select a@@38 o@@21)) (U_2_bool (MapType0Select b@@30 o@@21))) (=> (U_2_bool (MapType0Select b@@30 o@@21)) (U_2_bool (MapType0Select a@@38 o@@21))))) :qid |DafnyPre.639:32| :skolemid |147| :pattern ((MapType0Select a@@38 o@@21)) :pattern ((MapType0Select b@@30 o@@21))))) (=> (forall ((o@@22 T@U)) (! (=> (= (type o@@22) T@@58) (and (=> (U_2_bool (MapType0Select a@@38 o@@22)) (U_2_bool (MapType0Select b@@30 o@@22))) (=> (U_2_bool (MapType0Select b@@30 o@@22)) (U_2_bool (MapType0Select a@@38 o@@22))))) :qid |DafnyPre.639:32| :skolemid |147| :pattern ((MapType0Select a@@38 o@@22)) :pattern ((MapType0Select b@@30 o@@22)))) (|ISet#Equal| a@@38 b@@30))))) :qid |DafnyPre.638:17| :skolemid |148| :pattern ((|ISet#Equal| a@@38 b@@30)))))
(assert (forall ((a@@39 T@U) (b@@31 T@U)) (! (let ((T@@59 (MapType0TypeInv0 (type a@@39)))) (=> (and (and (= (type a@@39) (MapType0Type T@@59 boolType)) (= (type b@@31) (MapType0Type T@@59 boolType))) (|ISet#Equal| a@@39 b@@31)) (= a@@39 b@@31))) :qid |DafnyPre.640:17| :skolemid |149| :pattern ((|ISet#Equal| a@@39 b@@31)))))
(assert (forall ((a@@40 T@U) (b@@32 T@U)) (! (let ((T@@60 (MapType0TypeInv0 (type a@@40)))) (=> (and (= (type a@@40) (MapType0Type T@@60 boolType)) (= (type b@@32) (MapType0Type T@@60 boolType))) (and (=> (|ISet#Disjoint| a@@40 b@@32) (forall ((o@@23 T@U)) (! (=> (= (type o@@23) T@@60) (or (not (U_2_bool (MapType0Select a@@40 o@@23))) (not (U_2_bool (MapType0Select b@@32 o@@23))))) :qid |DafnyPre.645:35| :skolemid |150| :pattern ((MapType0Select a@@40 o@@23)) :pattern ((MapType0Select b@@32 o@@23))))) (=> (forall ((o@@24 T@U)) (! (=> (= (type o@@24) T@@60) (or (not (U_2_bool (MapType0Select a@@40 o@@24))) (not (U_2_bool (MapType0Select b@@32 o@@24))))) :qid |DafnyPre.645:35| :skolemid |150| :pattern ((MapType0Select a@@40 o@@24)) :pattern ((MapType0Select b@@32 o@@24)))) (|ISet#Disjoint| a@@40 b@@32))))) :qid |DafnyPre.644:18| :skolemid |151| :pattern ((|ISet#Disjoint| a@@40 b@@32)))))
(assert (forall ((a@@41 Int) (b@@33 Int)) (! (and (=> (<= a@@41 b@@33) (= (|Math#min| a@@41 b@@33) a@@41)) (=> (= (|Math#min| a@@41 b@@33) a@@41) (<= a@@41 b@@33))) :qid |DafnyPre.652:15| :skolemid |152| :pattern ((|Math#min| a@@41 b@@33)))))
(assert (forall ((a@@42 Int) (b@@34 Int)) (! (and (=> (<= b@@34 a@@42) (= (|Math#min| a@@42 b@@34) b@@34)) (=> (= (|Math#min| a@@42 b@@34) b@@34) (<= b@@34 a@@42))) :qid |DafnyPre.653:15| :skolemid |153| :pattern ((|Math#min| a@@42 b@@34)))))
(assert (forall ((a@@43 Int) (b@@35 Int)) (! (or (= (|Math#min| a@@43 b@@35) a@@43) (= (|Math#min| a@@43 b@@35) b@@35)) :qid |DafnyPre.654:15| :skolemid |154| :pattern ((|Math#min| a@@43 b@@35)))))
(assert (forall ((a@@44 Int)) (! (=> (<= 0 a@@44) (= (|Math#clip| a@@44) a@@44)) :qid |DafnyPre.657:15| :skolemid |155| :pattern ((|Math#clip| a@@44)))))
(assert (forall ((a@@45 Int)) (! (=> (< a@@45 0) (= (|Math#clip| a@@45) 0)) :qid |DafnyPre.658:15| :skolemid |156| :pattern ((|Math#clip| a@@45)))))
(assert (forall ((ms T@U)) (! (let ((T@@61 (MapType0TypeInv0 (type ms)))) (=> (= (type ms) (MapType0Type T@@61 intType)) (and (=> ($IsGoodMultiSet ms) (forall ((bx@@32 T@U)) (! (=> (= (type bx@@32) T@@61) (and (<= 0 (U_2_int (MapType0Select ms bx@@32))) (<= (U_2_int (MapType0Select ms bx@@32)) (|MultiSet#Card| ms)))) :qid |DafnyPre.666:11| :skolemid |157| :pattern ((MapType0Select ms bx@@32))))) (=> (forall ((bx@@33 T@U)) (! (=> (= (type bx@@33) T@@61) (and (<= 0 (U_2_int (MapType0Select ms bx@@33))) (<= (U_2_int (MapType0Select ms bx@@33)) (|MultiSet#Card| ms)))) :qid |DafnyPre.666:11| :skolemid |157| :pattern ((MapType0Select ms bx@@33)))) ($IsGoodMultiSet ms))))) :qid |DafnyPre.664:18| :skolemid |158| :pattern (($IsGoodMultiSet ms)))))
(assert (forall ((s@@5 T@U)) (! (let ((T@@62 (MapType0TypeInv0 (type s@@5)))) (=> (= (type s@@5) (MapType0Type T@@62 intType)) (<= 0 (|MultiSet#Card| s@@5)))) :qid |DafnyPre.669:18| :skolemid |159| :pattern ((|MultiSet#Card| s@@5)))))
(assert (forall ((s@@6 T@U) (x@@24 T@U) (n@@0 T@U)) (! (let ((T@@63 (type x@@24))) (=> (and (and (= (type s@@6) (MapType0Type T@@63 intType)) (= (type n@@0) intType)) (<= 0 (U_2_int n@@0))) (= (|MultiSet#Card| (MapType0Store s@@6 x@@24 n@@0)) (+ (- (|MultiSet#Card| s@@6) (U_2_int (MapType0Select s@@6 x@@24))) (U_2_int n@@0))))) :qid |DafnyPre.670:18| :skolemid |160| :pattern ((|MultiSet#Card| (MapType0Store s@@6 x@@24 n@@0))))))
(assert (forall ((T@@64 T@T)) (! (= (type (|MultiSet#Empty| T@@64)) (MapType0Type T@@64 intType)) :qid |funType:MultiSet#Empty| :pattern ((|MultiSet#Empty| T@@64)))))
(assert (forall ((o@@25 T@U)) (! (let ((T@@65 (type o@@25))) (= (U_2_int (MapType0Select (|MultiSet#Empty| T@@65) o@@25)) 0)) :qid |DafnyPre.674:18| :skolemid |161| :pattern ((let ((T@@65 (type o@@25))) (MapType0Select (|MultiSet#Empty| T@@65) o@@25))))))
(assert (forall ((s@@7 T@U)) (! (let ((T@@66 (MapType0TypeInv0 (type s@@7)))) (=> (= (type s@@7) (MapType0Type T@@66 intType)) (and (and (=> (= (|MultiSet#Card| s@@7) 0) (= s@@7 (|MultiSet#Empty| T@@66))) (=> (= s@@7 (|MultiSet#Empty| T@@66)) (= (|MultiSet#Card| s@@7) 0))) (=> (not (= (|MultiSet#Card| s@@7) 0)) (exists ((x@@25 T@U)) (! (and (= (type x@@25) T@@66) (< 0 (U_2_int (MapType0Select s@@7 x@@25)))) :qid |DafnyPre.677:38| :skolemid |162| :no-pattern (type x@@25) :no-pattern (U_2_int x@@25) :no-pattern (U_2_bool x@@25))))))) :qid |DafnyPre.675:18| :skolemid |163| :pattern ((|MultiSet#Card| s@@7)))))
(assert (forall ((arg0@@69 T@U)) (! (let ((T@@67 (type arg0@@69))) (= (type (|MultiSet#Singleton| arg0@@69)) (MapType0Type T@@67 intType))) :qid |funType:MultiSet#Singleton| :pattern ((|MultiSet#Singleton| arg0@@69)))))
(assert (forall ((r@@3 T@U) (o@@26 T@U)) (! (let ((T@@68 (type r@@3))) (=> (= (type o@@26) T@@68) (and (and (=> (= (U_2_int (MapType0Select (|MultiSet#Singleton| r@@3) o@@26)) 1) (= r@@3 o@@26)) (=> (= r@@3 o@@26) (= (U_2_int (MapType0Select (|MultiSet#Singleton| r@@3) o@@26)) 1))) (and (=> (= (U_2_int (MapType0Select (|MultiSet#Singleton| r@@3) o@@26)) 0) (not (= r@@3 o@@26))) (=> (not (= r@@3 o@@26)) (= (U_2_int (MapType0Select (|MultiSet#Singleton| r@@3) o@@26)) 0)))))) :qid |DafnyPre.680:18| :skolemid |164| :pattern ((MapType0Select (|MultiSet#Singleton| r@@3) o@@26)))))
(assert (forall ((arg0@@70 T@U) (arg1@@27 T@U)) (! (let ((T@@69 (type arg1@@27))) (= (type (|MultiSet#UnionOne| arg0@@70 arg1@@27)) (MapType0Type T@@69 intType))) :qid |funType:MultiSet#UnionOne| :pattern ((|MultiSet#UnionOne| arg0@@70 arg1@@27)))))
(assert (forall ((r@@4 T@U)) (! (let ((T@@70 (type r@@4))) (= (|MultiSet#Singleton| r@@4) (|MultiSet#UnionOne| (|MultiSet#Empty| T@@70) r@@4))) :qid |DafnyPre.682:18| :skolemid |165| :pattern ((|MultiSet#Singleton| r@@4)))))
(assert (forall ((a@@46 T@U) (x@@26 T@U) (o@@27 T@U)) (! (let ((T@@71 (type x@@26))) (=> (and (= (type a@@46) (MapType0Type T@@71 intType)) (= (type o@@27) T@@71)) (and (=> (< 0 (U_2_int (MapType0Select (|MultiSet#UnionOne| a@@46 x@@26) o@@27))) (or (= o@@27 x@@26) (< 0 (U_2_int (MapType0Select a@@46 o@@27))))) (=> (or (= o@@27 x@@26) (< 0 (U_2_int (MapType0Select a@@46 o@@27)))) (< 0 (U_2_int (MapType0Select (|MultiSet#UnionOne| a@@46 x@@26) o@@27))))))) :qid |DafnyPre.686:18| :skolemid |166| :pattern ((MapType0Select (|MultiSet#UnionOne| a@@46 x@@26) o@@27)))))
(assert (forall ((a@@47 T@U) (x@@27 T@U)) (! (let ((T@@72 (type x@@27))) (=> (= (type a@@47) (MapType0Type T@@72 intType)) (= (U_2_int (MapType0Select (|MultiSet#UnionOne| a@@47 x@@27) x@@27)) (+ (U_2_int (MapType0Select a@@47 x@@27)) 1)))) :qid |DafnyPre.689:18| :skolemid |167| :pattern ((|MultiSet#UnionOne| a@@47 x@@27)))))
(assert (forall ((a@@48 T@U) (x@@28 T@U) (y@@9 T@U)) (! (let ((T@@73 (type x@@28))) (=> (and (and (= (type a@@48) (MapType0Type T@@73 intType)) (= (type y@@9) T@@73)) (< 0 (U_2_int (MapType0Select a@@48 y@@9)))) (< 0 (U_2_int (MapType0Select (|MultiSet#UnionOne| a@@48 x@@28) y@@9))))) :qid |DafnyPre.692:18| :skolemid |168| :pattern ((|MultiSet#UnionOne| a@@48 x@@28) (MapType0Select a@@48 y@@9)))))
(assert (forall ((a@@49 T@U) (x@@29 T@U) (y@@10 T@U)) (! (let ((T@@74 (type x@@29))) (=> (and (and (= (type a@@49) (MapType0Type T@@74 intType)) (= (type y@@10) T@@74)) (not (= x@@29 y@@10))) (= (U_2_int (MapType0Select a@@49 y@@10)) (U_2_int (MapType0Select (|MultiSet#UnionOne| a@@49 x@@29) y@@10))))) :qid |DafnyPre.695:18| :skolemid |169| :pattern ((|MultiSet#UnionOne| a@@49 x@@29) (MapType0Select a@@49 y@@10)))))
(assert (forall ((a@@50 T@U) (x@@30 T@U)) (! (let ((T@@75 (type x@@30))) (=> (= (type a@@50) (MapType0Type T@@75 intType)) (= (|MultiSet#Card| (|MultiSet#UnionOne| a@@50 x@@30)) (+ (|MultiSet#Card| a@@50) 1)))) :qid |DafnyPre.697:18| :skolemid |170| :pattern ((|MultiSet#Card| (|MultiSet#UnionOne| a@@50 x@@30))))))
(assert (forall ((arg0@@71 T@U) (arg1@@28 T@U)) (! (let ((T@@76 (MapType0TypeInv0 (type arg0@@71)))) (= (type (|MultiSet#Union| arg0@@71 arg1@@28)) (MapType0Type T@@76 intType))) :qid |funType:MultiSet#Union| :pattern ((|MultiSet#Union| arg0@@71 arg1@@28)))))
(assert (forall ((a@@51 T@U) (b@@36 T@U) (o@@28 T@U)) (! (let ((T@@77 (type o@@28))) (=> (and (= (type a@@51) (MapType0Type T@@77 intType)) (= (type b@@36) (MapType0Type T@@77 intType))) (= (U_2_int (MapType0Select (|MultiSet#Union| a@@51 b@@36) o@@28)) (+ (U_2_int (MapType0Select a@@51 o@@28)) (U_2_int (MapType0Select b@@36 o@@28)))))) :qid |DafnyPre.703:18| :skolemid |171| :pattern ((MapType0Select (|MultiSet#Union| a@@51 b@@36) o@@28)))))
(assert (forall ((a@@52 T@U) (b@@37 T@U)) (! (let ((T@@78 (MapType0TypeInv0 (type a@@52)))) (=> (and (= (type a@@52) (MapType0Type T@@78 intType)) (= (type b@@37) (MapType0Type T@@78 intType))) (= (|MultiSet#Card| (|MultiSet#Union| a@@52 b@@37)) (+ (|MultiSet#Card| a@@52) (|MultiSet#Card| b@@37))))) :qid |DafnyPre.705:18| :skolemid |172| :pattern ((|MultiSet#Card| (|MultiSet#Union| a@@52 b@@37))))))
(assert (forall ((arg0@@72 T@U) (arg1@@29 T@U)) (! (let ((T@@79 (MapType0TypeInv0 (type arg0@@72)))) (= (type (|MultiSet#Intersection| arg0@@72 arg1@@29)) (MapType0Type T@@79 intType))) :qid |funType:MultiSet#Intersection| :pattern ((|MultiSet#Intersection| arg0@@72 arg1@@29)))))
(assert (forall ((a@@53 T@U) (b@@38 T@U) (o@@29 T@U)) (! (let ((T@@80 (type o@@29))) (=> (and (= (type a@@53) (MapType0Type T@@80 intType)) (= (type b@@38) (MapType0Type T@@80 intType))) (= (U_2_int (MapType0Select (|MultiSet#Intersection| a@@53 b@@38) o@@29)) (|Math#min| (U_2_int (MapType0Select a@@53 o@@29)) (U_2_int (MapType0Select b@@38 o@@29)))))) :qid |DafnyPre.709:18| :skolemid |173| :pattern ((MapType0Select (|MultiSet#Intersection| a@@53 b@@38) o@@29)))))
(assert (forall ((a@@54 T@U) (b@@39 T@U)) (! (let ((T@@81 (MapType0TypeInv0 (type a@@54)))) (=> (and (= (type a@@54) (MapType0Type T@@81 intType)) (= (type b@@39) (MapType0Type T@@81 intType))) (= (|MultiSet#Intersection| (|MultiSet#Intersection| a@@54 b@@39) b@@39) (|MultiSet#Intersection| a@@54 b@@39)))) :qid |DafnyPre.713:18| :skolemid |174| :pattern ((|MultiSet#Intersection| (|MultiSet#Intersection| a@@54 b@@39) b@@39)))))
(assert (forall ((a@@55 T@U) (b@@40 T@U)) (! (let ((T@@82 (MapType0TypeInv0 (type a@@55)))) (=> (and (= (type a@@55) (MapType0Type T@@82 intType)) (= (type b@@40) (MapType0Type T@@82 intType))) (= (|MultiSet#Intersection| a@@55 (|MultiSet#Intersection| a@@55 b@@40)) (|MultiSet#Intersection| a@@55 b@@40)))) :qid |DafnyPre.715:18| :skolemid |175| :pattern ((|MultiSet#Intersection| a@@55 (|MultiSet#Intersection| a@@55 b@@40))))))
(assert (forall ((arg0@@73 T@U) (arg1@@30 T@U)) (! (let ((T@@83 (MapType0TypeInv0 (type arg0@@73)))) (= (type (|MultiSet#Difference| arg0@@73 arg1@@30)) (MapType0Type T@@83 intType))) :qid |funType:MultiSet#Difference| :pattern ((|MultiSet#Difference| arg0@@73 arg1@@30)))))
(assert (forall ((a@@56 T@U) (b@@41 T@U) (o@@30 T@U)) (! (let ((T@@84 (type o@@30))) (=> (and (= (type a@@56) (MapType0Type T@@84 intType)) (= (type b@@41) (MapType0Type T@@84 intType))) (= (U_2_int (MapType0Select (|MultiSet#Difference| a@@56 b@@41) o@@30)) (|Math#clip| (- (U_2_int (MapType0Select a@@56 o@@30)) (U_2_int (MapType0Select b@@41 o@@30))))))) :qid |DafnyPre.720:18| :skolemid |176| :pattern ((MapType0Select (|MultiSet#Difference| a@@56 b@@41) o@@30)))))
(assert (forall ((a@@57 T@U) (b@@42 T@U) (y@@11 T@U)) (! (let ((T@@85 (type y@@11))) (=> (and (and (= (type a@@57) (MapType0Type T@@85 intType)) (= (type b@@42) (MapType0Type T@@85 intType))) (<= (U_2_int (MapType0Select a@@57 y@@11)) (U_2_int (MapType0Select b@@42 y@@11)))) (= (U_2_int (MapType0Select (|MultiSet#Difference| a@@57 b@@42) y@@11)) 0))) :qid |DafnyPre.722:18| :skolemid |177| :pattern ((|MultiSet#Difference| a@@57 b@@42) (MapType0Select b@@42 y@@11) (MapType0Select a@@57 y@@11)))))
(assert (forall ((a@@58 T@U) (b@@43 T@U)) (! (let ((T@@86 (MapType0TypeInv0 (type a@@58)))) (=> (and (= (type a@@58) (MapType0Type T@@86 intType)) (= (type b@@43) (MapType0Type T@@86 intType))) (and (= (+ (+ (|MultiSet#Card| (|MultiSet#Difference| a@@58 b@@43)) (|MultiSet#Card| (|MultiSet#Difference| b@@43 a@@58))) (* 2 (|MultiSet#Card| (|MultiSet#Intersection| a@@58 b@@43)))) (|MultiSet#Card| (|MultiSet#Union| a@@58 b@@43))) (= (|MultiSet#Card| (|MultiSet#Difference| a@@58 b@@43)) (- (|MultiSet#Card| a@@58) (|MultiSet#Card| (|MultiSet#Intersection| a@@58 b@@43))))))) :qid |DafnyPre.724:18| :skolemid |178| :pattern ((|MultiSet#Card| (|MultiSet#Difference| a@@58 b@@43))))))
(assert (forall ((a@@59 T@U) (b@@44 T@U)) (! (let ((T@@87 (MapType0TypeInv0 (type a@@59)))) (=> (and (= (type a@@59) (MapType0Type T@@87 intType)) (= (type b@@44) (MapType0Type T@@87 intType))) (and (=> (|MultiSet#Subset| a@@59 b@@44) (forall ((o@@31 T@U)) (! (=> (= (type o@@31) T@@87) (<= (U_2_int (MapType0Select a@@59 o@@31)) (U_2_int (MapType0Select b@@44 o@@31)))) :qid |DafnyPre.734:37| :skolemid |179| :pattern ((MapType0Select a@@59 o@@31)) :pattern ((MapType0Select b@@44 o@@31))))) (=> (forall ((o@@32 T@U)) (! (=> (= (type o@@32) T@@87) (<= (U_2_int (MapType0Select a@@59 o@@32)) (U_2_int (MapType0Select b@@44 o@@32)))) :qid |DafnyPre.734:37| :skolemid |179| :pattern ((MapType0Select a@@59 o@@32)) :pattern ((MapType0Select b@@44 o@@32)))) (|MultiSet#Subset| a@@59 b@@44))))) :qid |DafnyPre.733:17| :skolemid |180| :pattern ((|MultiSet#Subset| a@@59 b@@44)))))
(assert (forall ((a@@60 T@U) (b@@45 T@U)) (! (let ((T@@88 (MapType0TypeInv0 (type a@@60)))) (=> (and (= (type a@@60) (MapType0Type T@@88 intType)) (= (type b@@45) (MapType0Type T@@88 intType))) (and (=> (|MultiSet#Equal| a@@60 b@@45) (forall ((o@@33 T@U)) (! (=> (= (type o@@33) T@@88) (= (U_2_int (MapType0Select a@@60 o@@33)) (U_2_int (MapType0Select b@@45 o@@33)))) :qid |DafnyPre.738:36| :skolemid |181| :pattern ((MapType0Select a@@60 o@@33)) :pattern ((MapType0Select b@@45 o@@33))))) (=> (forall ((o@@34 T@U)) (! (=> (= (type o@@34) T@@88) (= (U_2_int (MapType0Select a@@60 o@@34)) (U_2_int (MapType0Select b@@45 o@@34)))) :qid |DafnyPre.738:36| :skolemid |181| :pattern ((MapType0Select a@@60 o@@34)) :pattern ((MapType0Select b@@45 o@@34)))) (|MultiSet#Equal| a@@60 b@@45))))) :qid |DafnyPre.737:17| :skolemid |182| :pattern ((|MultiSet#Equal| a@@60 b@@45)))))
(assert (forall ((a@@61 T@U) (b@@46 T@U)) (! (let ((T@@89 (MapType0TypeInv0 (type a@@61)))) (=> (and (and (= (type a@@61) (MapType0Type T@@89 intType)) (= (type b@@46) (MapType0Type T@@89 intType))) (|MultiSet#Equal| a@@61 b@@46)) (= a@@61 b@@46))) :qid |DafnyPre.740:17| :skolemid |183| :pattern ((|MultiSet#Equal| a@@61 b@@46)))))
(assert (forall ((a@@62 T@U) (b@@47 T@U)) (! (let ((T@@90 (MapType0TypeInv0 (type a@@62)))) (=> (and (= (type a@@62) (MapType0Type T@@90 intType)) (= (type b@@47) (MapType0Type T@@90 intType))) (and (=> (|MultiSet#Disjoint| a@@62 b@@47) (forall ((o@@35 T@U)) (! (=> (= (type o@@35) T@@90) (or (= (U_2_int (MapType0Select a@@62 o@@35)) 0) (= (U_2_int (MapType0Select b@@47 o@@35)) 0))) :qid |DafnyPre.745:39| :skolemid |184| :pattern ((MapType0Select a@@62 o@@35)) :pattern ((MapType0Select b@@47 o@@35))))) (=> (forall ((o@@36 T@U)) (! (=> (= (type o@@36) T@@90) (or (= (U_2_int (MapType0Select a@@62 o@@36)) 0) (= (U_2_int (MapType0Select b@@47 o@@36)) 0))) :qid |DafnyPre.745:39| :skolemid |184| :pattern ((MapType0Select a@@62 o@@36)) :pattern ((MapType0Select b@@47 o@@36)))) (|MultiSet#Disjoint| a@@62 b@@47))))) :qid |DafnyPre.744:18| :skolemid |185| :pattern ((|MultiSet#Disjoint| a@@62 b@@47)))))
(assert (forall ((arg0@@74 T@U)) (! (let ((T@@91 (MapType0TypeInv0 (type arg0@@74)))) (= (type (|MultiSet#FromSet| arg0@@74)) (MapType0Type T@@91 intType))) :qid |funType:MultiSet#FromSet| :pattern ((|MultiSet#FromSet| arg0@@74)))))
(assert (forall ((s@@8 T@U) (a@@63 T@U)) (! (let ((T@@92 (type a@@63))) (=> (= (type s@@8) (MapType0Type T@@92 boolType)) (and (and (=> (= (U_2_int (MapType0Select (|MultiSet#FromSet| s@@8) a@@63)) 0) (not (U_2_bool (MapType0Select s@@8 a@@63)))) (=> (not (U_2_bool (MapType0Select s@@8 a@@63))) (= (U_2_int (MapType0Select (|MultiSet#FromSet| s@@8) a@@63)) 0))) (and (=> (= (U_2_int (MapType0Select (|MultiSet#FromSet| s@@8) a@@63)) 1) (U_2_bool (MapType0Select s@@8 a@@63))) (=> (U_2_bool (MapType0Select s@@8 a@@63)) (= (U_2_int (MapType0Select (|MultiSet#FromSet| s@@8) a@@63)) 1)))))) :qid |DafnyPre.749:18| :skolemid |186| :pattern ((MapType0Select (|MultiSet#FromSet| s@@8) a@@63)))))
(assert (forall ((s@@9 T@U)) (! (let ((T@@93 (MapType0TypeInv0 (type s@@9)))) (=> (= (type s@@9) (MapType0Type T@@93 boolType)) (= (|MultiSet#Card| (|MultiSet#FromSet| s@@9)) (|Set#Card| s@@9)))) :qid |DafnyPre.752:18| :skolemid |187| :pattern ((|MultiSet#Card| (|MultiSet#FromSet| s@@9))))))
(assert (forall ((arg0@@75 T@U)) (! (let ((T@@94 (SeqTypeInv0 (type arg0@@75)))) (= (type (|MultiSet#FromSeq| arg0@@75)) (MapType0Type T@@94 intType))) :qid |funType:MultiSet#FromSeq| :pattern ((|MultiSet#FromSeq| arg0@@75)))))
(assert (forall ((s@@10 T@U)) (! (let ((T@@95 (SeqTypeInv0 (type s@@10)))) (=> (= (type s@@10) (SeqType T@@95)) ($IsGoodMultiSet (|MultiSet#FromSeq| s@@10)))) :qid |DafnyPre.758:18| :skolemid |188| :pattern ((|MultiSet#FromSeq| s@@10)))))
(assert (forall ((s@@11 T@U)) (! (let ((T@@96 (SeqTypeInv0 (type s@@11)))) (=> (= (type s@@11) (SeqType T@@96)) (= (|MultiSet#Card| (|MultiSet#FromSeq| s@@11)) (|Seq#Length| s@@11)))) :qid |DafnyPre.760:18| :skolemid |189| :pattern ((|MultiSet#Card| (|MultiSet#FromSeq| s@@11))))))
(assert (forall ((arg0@@76 T@U) (arg1@@31 T@U)) (! (let ((T@@97 (type arg1@@31))) (= (type (|Seq#Build| arg0@@76 arg1@@31)) (SeqType T@@97))) :qid |funType:Seq#Build| :pattern ((|Seq#Build| arg0@@76 arg1@@31)))))
(assert (forall ((s@@12 T@U) (v@@25 T@U)) (! (let ((T@@98 (type v@@25))) (=> (= (type s@@12) (SeqType T@@98)) (= (|MultiSet#FromSeq| (|Seq#Build| s@@12 v@@25)) (|MultiSet#UnionOne| (|MultiSet#FromSeq| s@@12) v@@25)))) :qid |DafnyPre.764:18| :skolemid |190| :pattern ((|MultiSet#FromSeq| (|Seq#Build| s@@12 v@@25))))))
(assert (forall ((T@@99 T@T)) (! (= (type (|Seq#Empty| T@@99)) (SeqType T@@99)) :qid |funType:Seq#Empty| :pattern ((|Seq#Empty| T@@99)))))
(assert (forall ((T@@100 T@T)) (! (= (|MultiSet#FromSeq| (|Seq#Empty| T@@100)) (|MultiSet#Empty| T@@100)) :skolemid |191|)))
(assert (forall ((arg0@@77 T@U) (arg1@@32 T@U)) (! (let ((T@@101 (SeqTypeInv0 (type arg0@@77)))) (= (type (|Seq#Append| arg0@@77 arg1@@32)) (SeqType T@@101))) :qid |funType:Seq#Append| :pattern ((|Seq#Append| arg0@@77 arg1@@32)))))
(assert (forall ((a@@64 T@U) (b@@48 T@U)) (! (let ((T@@102 (SeqTypeInv0 (type a@@64)))) (=> (and (= (type a@@64) (SeqType T@@102)) (= (type b@@48) (SeqType T@@102))) (= (|MultiSet#FromSeq| (|Seq#Append| a@@64 b@@48)) (|MultiSet#Union| (|MultiSet#FromSeq| a@@64) (|MultiSet#FromSeq| b@@48))))) :qid |DafnyPre.771:18| :skolemid |192| :pattern ((|MultiSet#FromSeq| (|Seq#Append| a@@64 b@@48))))))
(assert (forall ((arg0@@78 T@U) (arg1@@33 Int) (arg2@@2 T@U)) (! (let ((T@@103 (type arg2@@2))) (= (type (|Seq#Update| arg0@@78 arg1@@33 arg2@@2)) (SeqType T@@103))) :qid |funType:Seq#Update| :pattern ((|Seq#Update| arg0@@78 arg1@@33 arg2@@2)))))
(assert (forall ((s@@13 T@U) (i@@8 Int) (v@@26 T@U) (x@@31 T@U)) (! (let ((T@@104 (type v@@26))) (=> (and (and (= (type s@@13) (SeqType T@@104)) (= (type x@@31) T@@104)) (and (<= 0 i@@8) (< i@@8 (|Seq#Length| s@@13)))) (= (U_2_int (MapType0Select (|MultiSet#FromSeq| (|Seq#Update| s@@13 i@@8 v@@26)) x@@31)) (U_2_int (MapType0Select (|MultiSet#Union| (|MultiSet#Difference| (|MultiSet#FromSeq| s@@13) (|MultiSet#Singleton| (|Seq#Index| s@@13 i@@8))) (|MultiSet#Singleton| v@@26)) x@@31))))) :qid |DafnyPre.776:18| :skolemid |193| :pattern ((MapType0Select (|MultiSet#FromSeq| (|Seq#Update| s@@13 i@@8 v@@26)) x@@31)))))
(assert (forall ((s@@14 T@U) (x@@32 T@U)) (! (let ((T@@105 (type x@@32))) (=> (= (type s@@14) (SeqType T@@105)) (and (=> (exists ((i@@9 Int)) (! (and (and (<= 0 i@@9) (< i@@9 (|Seq#Length| s@@14))) (= x@@32 (|Seq#Index| s@@14 i@@9))) :qid |DafnyPre.783:11| :skolemid |194| :pattern ((|Seq#Index| s@@14 i@@9)))) (< 0 (U_2_int (MapType0Select (|MultiSet#FromSeq| s@@14) x@@32)))) (=> (< 0 (U_2_int (MapType0Select (|MultiSet#FromSeq| s@@14) x@@32))) (exists ((i@@10 Int)) (! (and (and (<= 0 i@@10) (< i@@10 (|Seq#Length| s@@14))) (= x@@32 (|Seq#Index| s@@14 i@@10))) :qid |DafnyPre.783:11| :skolemid |194| :pattern ((|Seq#Index| s@@14 i@@10)))))))) :qid |DafnyPre.782:18| :skolemid |195| :pattern ((MapType0Select (|MultiSet#FromSeq| s@@14) x@@32)))))
(assert (forall ((s@@15 T@U)) (! (let ((T@@106 (SeqTypeInv0 (type s@@15)))) (=> (= (type s@@15) (SeqType T@@106)) (<= 0 (|Seq#Length| s@@15)))) :qid |DafnyPre.792:18| :skolemid |196| :pattern ((|Seq#Length| s@@15)))))
(assert (forall ((T@@107 T@T)) (! (= (|Seq#Length| (|Seq#Empty| T@@107)) 0) :skolemid |197|)))
(assert (forall ((s@@16 T@U)) (! (let ((T@@108 (SeqTypeInv0 (type s@@16)))) (=> (and (= (type s@@16) (SeqType T@@108)) (= (|Seq#Length| s@@16) 0)) (= s@@16 (|Seq#Empty| T@@108)))) :qid |DafnyPre.796:18| :skolemid |198| :pattern ((|Seq#Length| s@@16)))))
(assert (forall ((t@@23 T@U) (T@@109 T@T)) (! (=> (= (type t@@23) TyType) ($Is (|Seq#Empty| T@@109) t@@23)) :qid |DafnyPre.806:18| :skolemid |199| :pattern (($Is (|Seq#Empty| T@@109) t@@23)))))
(assert (forall ((arg0@@79 T@U)) (! (let ((T@@110 (type arg0@@79))) (= (type (|Seq#Singleton| arg0@@79)) (SeqType T@@110))) :qid |funType:Seq#Singleton| :pattern ((|Seq#Singleton| arg0@@79)))))
(assert (forall ((t@@24 T@U)) (! (= (|Seq#Length| (|Seq#Singleton| t@@24)) 1) :qid |DafnyPre.809:18| :skolemid |200| :pattern ((|Seq#Length| (|Seq#Singleton| t@@24))))))
(assert (forall ((s@@17 T@U) (v@@27 T@U)) (! (let ((T@@111 (type v@@27))) (=> (= (type s@@17) (SeqType T@@111)) (= (|Seq#Length| (|Seq#Build| s@@17 v@@27)) (+ 1 (|Seq#Length| s@@17))))) :qid |DafnyPre.812:18| :skolemid |201| :pattern ((|Seq#Length| (|Seq#Build| s@@17 v@@27))))))
(assert (forall ((s@@18 T@U) (i@@11 Int) (v@@28 T@U)) (! (let ((T@@112 (type v@@28))) (=> (= (type s@@18) (SeqType T@@112)) (and (=> (= i@@11 (|Seq#Length| s@@18)) (= (|Seq#Index| (|Seq#Build| s@@18 v@@28) i@@11) v@@28)) (=> (not (= i@@11 (|Seq#Length| s@@18))) (= (|Seq#Index| (|Seq#Build| s@@18 v@@28) i@@11) (|Seq#Index| s@@18 i@@11)))))) :qid |DafnyPre.814:18| :skolemid |202| :pattern ((|Seq#Index| (|Seq#Build| s@@18 v@@28) i@@11)))))
(assert (forall ((s@@19 T@U) (bx@@34 T@U) (t@@25 T@U)) (! (=> (and (and (and (= (type s@@19) (SeqType BoxType)) (= (type bx@@34) BoxType)) (= (type t@@25) TyType)) (and ($Is s@@19 (TSeq t@@25)) ($IsBox bx@@34 t@@25))) ($Is (|Seq#Build| s@@19 bx@@34) (TSeq t@@25))) :qid |DafnyPre.819:15| :skolemid |203| :pattern (($Is (|Seq#Build| s@@19 bx@@34) (TSeq t@@25))))))
(assert (forall ((s0 T@U) (s1 T@U)) (! (let ((T@@113 (SeqTypeInv0 (type s0)))) (=> (and (= (type s0) (SeqType T@@113)) (= (type s1) (SeqType T@@113))) (= (|Seq#Length| (|Seq#Append| s0 s1)) (+ (|Seq#Length| s0) (|Seq#Length| s1))))) :qid |DafnyPre.823:18| :skolemid |204| :pattern ((|Seq#Length| (|Seq#Append| s0 s1))))))
(assert (forall ((s0@@0 T@U) (s1@@0 T@U) (t@@26 T@U)) (! (=> (and (and (and (= (type s0@@0) (SeqType BoxType)) (= (type s1@@0) (SeqType BoxType))) (= (type t@@26) TyType)) (and ($Is s0@@0 t@@26) ($Is s1@@0 t@@26))) ($Is (|Seq#Append| s0@@0 s1@@0) t@@26)) :qid |DafnyPre.827:15| :skolemid |205| :pattern (($Is (|Seq#Append| s0@@0 s1@@0) t@@26)))))
(assert (forall ((t@@27 T@U)) (! (= (|Seq#Index| (|Seq#Singleton| t@@27) 0) t@@27) :qid |DafnyPre.831:18| :skolemid |206| :pattern ((|Seq#Index| (|Seq#Singleton| t@@27) 0)))))
(assert (forall ((s0@@1 T@U) (s1@@1 T@U) (n@@1 Int)) (! (let ((T@@114 (SeqTypeInv0 (type s0@@1)))) (=> (and (= (type s0@@1) (SeqType T@@114)) (= (type s1@@1) (SeqType T@@114))) (and (=> (< n@@1 (|Seq#Length| s0@@1)) (= (|Seq#Index| (|Seq#Append| s0@@1 s1@@1) n@@1) (|Seq#Index| s0@@1 n@@1))) (=> (<= (|Seq#Length| s0@@1) n@@1) (= (|Seq#Index| (|Seq#Append| s0@@1 s1@@1) n@@1) (|Seq#Index| s1@@1 (- n@@1 (|Seq#Length| s0@@1)))))))) :qid |DafnyPre.832:18| :skolemid |207| :pattern ((|Seq#Index| (|Seq#Append| s0@@1 s1@@1) n@@1)))))
(assert (forall ((s@@20 T@U) (i@@12 Int) (v@@29 T@U)) (! (let ((T@@115 (type v@@29))) (=> (= (type s@@20) (SeqType T@@115)) (=> (and (<= 0 i@@12) (< i@@12 (|Seq#Length| s@@20))) (= (|Seq#Length| (|Seq#Update| s@@20 i@@12 v@@29)) (|Seq#Length| s@@20))))) :qid |DafnyPre.837:18| :skolemid |208| :pattern ((|Seq#Length| (|Seq#Update| s@@20 i@@12 v@@29))))))
(assert (forall ((s@@21 T@U) (i@@13 Int) (v@@30 T@U) (n@@2 Int)) (! (let ((T@@116 (type v@@30))) (=> (= (type s@@21) (SeqType T@@116)) (=> (and (<= 0 n@@2) (< n@@2 (|Seq#Length| s@@21))) (and (=> (= i@@13 n@@2) (= (|Seq#Index| (|Seq#Update| s@@21 i@@13 v@@30) n@@2) v@@30)) (=> (not (= i@@13 n@@2)) (= (|Seq#Index| (|Seq#Update| s@@21 i@@13 v@@30) n@@2) (|Seq#Index| s@@21 n@@2))))))) :qid |DafnyPre.839:18| :skolemid |209| :pattern ((|Seq#Index| (|Seq#Update| s@@21 i@@13 v@@30) n@@2)))))
(assert (forall ((s@@22 T@U) (x@@33 T@U)) (! (let ((T@@117 (type x@@33))) (=> (= (type s@@22) (SeqType T@@117)) (and (=> (|Seq#Contains| s@@22 x@@33) (exists ((i@@14 Int)) (! (and (and (<= 0 i@@14) (< i@@14 (|Seq#Length| s@@22))) (= (|Seq#Index| s@@22 i@@14) x@@33)) :qid |DafnyPre.847:13| :skolemid |210| :pattern ((|Seq#Index| s@@22 i@@14))))) (=> (exists ((i@@15 Int)) (! (and (and (<= 0 i@@15) (< i@@15 (|Seq#Length| s@@22))) (= (|Seq#Index| s@@22 i@@15) x@@33)) :qid |DafnyPre.847:13| :skolemid |210| :pattern ((|Seq#Index| s@@22 i@@15)))) (|Seq#Contains| s@@22 x@@33))))) :qid |DafnyPre.845:18| :skolemid |211| :pattern ((|Seq#Contains| s@@22 x@@33)))))
(assert (forall ((x@@34 T@U)) (! (let ((T@@118 (type x@@34))) (not (|Seq#Contains| (|Seq#Empty| T@@118) x@@34))) :qid |DafnyPre.848:18| :skolemid |212| :pattern ((let ((T@@118 (type x@@34))) (|Seq#Contains| (|Seq#Empty| T@@118) x@@34))))))
(assert (forall ((s0@@2 T@U) (s1@@2 T@U) (x@@35 T@U)) (! (let ((T@@119 (type x@@35))) (=> (and (= (type s0@@2) (SeqType T@@119)) (= (type s1@@2) (SeqType T@@119))) (and (=> (|Seq#Contains| (|Seq#Append| s0@@2 s1@@2) x@@35) (or (|Seq#Contains| s0@@2 x@@35) (|Seq#Contains| s1@@2 x@@35))) (=> (or (|Seq#Contains| s0@@2 x@@35) (|Seq#Contains| s1@@2 x@@35)) (|Seq#Contains| (|Seq#Append| s0@@2 s1@@2) x@@35))))) :qid |DafnyPre.852:18| :skolemid |213| :pattern ((|Seq#Contains| (|Seq#Append| s0@@2 s1@@2) x@@35)))))
(assert (forall ((s@@23 T@U) (v@@31 T@U) (x@@36 T@U)) (! (let ((T@@120 (type v@@31))) (=> (and (= (type s@@23) (SeqType T@@120)) (= (type x@@36) T@@120)) (and (=> (|Seq#Contains| (|Seq#Build| s@@23 v@@31) x@@36) (or (= v@@31 x@@36) (|Seq#Contains| s@@23 x@@36))) (=> (or (= v@@31 x@@36) (|Seq#Contains| s@@23 x@@36)) (|Seq#Contains| (|Seq#Build| s@@23 v@@31) x@@36))))) :qid |DafnyPre.857:18| :skolemid |214| :pattern ((|Seq#Contains| (|Seq#Build| s@@23 v@@31) x@@36)))))
(assert (forall ((arg0@@80 T@U) (arg1@@34 Int)) (! (let ((T@@121 (SeqTypeInv0 (type arg0@@80)))) (= (type (|Seq#Take| arg0@@80 arg1@@34)) (SeqType T@@121))) :qid |funType:Seq#Take| :pattern ((|Seq#Take| arg0@@80 arg1@@34)))))
(assert (forall ((s@@24 T@U) (n@@3 Int) (x@@37 T@U)) (! (let ((T@@122 (type x@@37))) (=> (= (type s@@24) (SeqType T@@122)) (and (=> (|Seq#Contains| (|Seq#Take| s@@24 n@@3) x@@37) (exists ((i@@16 Int)) (! (and (and (and (<= 0 i@@16) (< i@@16 n@@3)) (< i@@16 (|Seq#Length| s@@24))) (= (|Seq#Index| s@@24 i@@16) x@@37)) :qid |DafnyPre.864:13| :skolemid |215| :pattern ((|Seq#Index| s@@24 i@@16))))) (=> (exists ((i@@17 Int)) (! (and (and (and (<= 0 i@@17) (< i@@17 n@@3)) (< i@@17 (|Seq#Length| s@@24))) (= (|Seq#Index| s@@24 i@@17) x@@37)) :qid |DafnyPre.864:13| :skolemid |215| :pattern ((|Seq#Index| s@@24 i@@17)))) (|Seq#Contains| (|Seq#Take| s@@24 n@@3) x@@37))))) :qid |DafnyPre.861:18| :skolemid |216| :pattern ((|Seq#Contains| (|Seq#Take| s@@24 n@@3) x@@37)))))
(assert (forall ((arg0@@81 T@U) (arg1@@35 Int)) (! (let ((T@@123 (SeqTypeInv0 (type arg0@@81)))) (= (type (|Seq#Drop| arg0@@81 arg1@@35)) (SeqType T@@123))) :qid |funType:Seq#Drop| :pattern ((|Seq#Drop| arg0@@81 arg1@@35)))))
(assert (forall ((s@@25 T@U) (n@@4 Int) (x@@38 T@U)) (! (let ((T@@124 (type x@@38))) (=> (= (type s@@25) (SeqType T@@124)) (and (=> (|Seq#Contains| (|Seq#Drop| s@@25 n@@4) x@@38) (exists ((i@@18 Int)) (! (and (and (and (<= 0 n@@4) (<= n@@4 i@@18)) (< i@@18 (|Seq#Length| s@@25))) (= (|Seq#Index| s@@25 i@@18) x@@38)) :qid |DafnyPre.869:13| :skolemid |217| :pattern ((|Seq#Index| s@@25 i@@18))))) (=> (exists ((i@@19 Int)) (! (and (and (and (<= 0 n@@4) (<= n@@4 i@@19)) (< i@@19 (|Seq#Length| s@@25))) (= (|Seq#Index| s@@25 i@@19) x@@38)) :qid |DafnyPre.869:13| :skolemid |217| :pattern ((|Seq#Index| s@@25 i@@19)))) (|Seq#Contains| (|Seq#Drop| s@@25 n@@4) x@@38))))) :qid |DafnyPre.866:18| :skolemid |218| :pattern ((|Seq#Contains| (|Seq#Drop| s@@25 n@@4) x@@38)))))
(assert (forall ((s0@@3 T@U) (s1@@3 T@U)) (! (let ((T@@125 (SeqTypeInv0 (type s0@@3)))) (=> (and (= (type s0@@3) (SeqType T@@125)) (= (type s1@@3) (SeqType T@@125))) (and (=> (|Seq#Equal| s0@@3 s1@@3) (and (= (|Seq#Length| s0@@3) (|Seq#Length| s1@@3)) (forall ((j Int)) (! (=> (and (<= 0 j) (< j (|Seq#Length| s0@@3))) (= (|Seq#Index| s0@@3 j) (|Seq#Index| s1@@3 j))) :qid |DafnyPre.876:13| :skolemid |219| :pattern ((|Seq#Index| s0@@3 j)) :pattern ((|Seq#Index| s1@@3 j)))))) (=> (and (= (|Seq#Length| s0@@3) (|Seq#Length| s1@@3)) (forall ((j@@0 Int)) (! (=> (and (<= 0 j@@0) (< j@@0 (|Seq#Length| s0@@3))) (= (|Seq#Index| s0@@3 j@@0) (|Seq#Index| s1@@3 j@@0))) :qid |DafnyPre.876:13| :skolemid |219| :pattern ((|Seq#Index| s0@@3 j@@0)) :pattern ((|Seq#Index| s1@@3 j@@0))))) (|Seq#Equal| s0@@3 s1@@3))))) :qid |DafnyPre.873:18| :skolemid |220| :pattern ((|Seq#Equal| s0@@3 s1@@3)))))
(assert (forall ((a@@65 T@U) (b@@49 T@U)) (! (let ((T@@126 (SeqTypeInv0 (type a@@65)))) (=> (and (and (= (type a@@65) (SeqType T@@126)) (= (type b@@49) (SeqType T@@126))) (|Seq#Equal| a@@65 b@@49)) (= a@@65 b@@49))) :qid |DafnyPre.878:18| :skolemid |221| :pattern ((|Seq#Equal| a@@65 b@@49)))))
(assert (forall ((s0@@4 T@U) (s1@@4 T@U) (n@@5 Int)) (! (let ((T@@127 (SeqTypeInv0 (type s0@@4)))) (=> (and (= (type s0@@4) (SeqType T@@127)) (= (type s1@@4) (SeqType T@@127))) (and (=> (|Seq#SameUntil| s0@@4 s1@@4 n@@5) (forall ((j@@1 Int)) (! (=> (and (<= 0 j@@1) (< j@@1 n@@5)) (= (|Seq#Index| s0@@4 j@@1) (|Seq#Index| s1@@4 j@@1))) :qid |DafnyPre.884:13| :skolemid |222| :pattern ((|Seq#Index| s0@@4 j@@1)) :pattern ((|Seq#Index| s1@@4 j@@1))))) (=> (forall ((j@@2 Int)) (! (=> (and (<= 0 j@@2) (< j@@2 n@@5)) (= (|Seq#Index| s0@@4 j@@2) (|Seq#Index| s1@@4 j@@2))) :qid |DafnyPre.884:13| :skolemid |222| :pattern ((|Seq#Index| s0@@4 j@@2)) :pattern ((|Seq#Index| s1@@4 j@@2)))) (|Seq#SameUntil| s0@@4 s1@@4 n@@5))))) :qid |DafnyPre.882:18| :skolemid |223| :pattern ((|Seq#SameUntil| s0@@4 s1@@4 n@@5)))))
(assert (forall ((s@@26 T@U) (n@@6 Int)) (! (let ((T@@128 (SeqTypeInv0 (type s@@26)))) (=> (= (type s@@26) (SeqType T@@128)) (=> (and (<= 0 n@@6) (<= n@@6 (|Seq#Length| s@@26))) (= (|Seq#Length| (|Seq#Take| s@@26 n@@6)) n@@6)))) :qid |DafnyPre.888:18| :skolemid |224| :pattern ((|Seq#Length| (|Seq#Take| s@@26 n@@6))))))
(assert (forall ((s@@27 T@U) (n@@7 Int) (j@@3 Int)) (! (let ((T@@129 (SeqTypeInv0 (type s@@27)))) (=> (= (type s@@27) (SeqType T@@129)) (=> (and (and (<= 0 j@@3) (< j@@3 n@@7)) (< j@@3 (|Seq#Length| s@@27))) (= (|Seq#Index| (|Seq#Take| s@@27 n@@7) j@@3) (|Seq#Index| s@@27 j@@3))))) :qid |DafnyPre.890:18| :weight 25 :skolemid |225| :pattern ((|Seq#Index| (|Seq#Take| s@@27 n@@7) j@@3)) :pattern ((|Seq#Index| s@@27 j@@3) (|Seq#Take| s@@27 n@@7)))))
(assert (forall ((s@@28 T@U) (n@@8 Int)) (! (let ((T@@130 (SeqTypeInv0 (type s@@28)))) (=> (= (type s@@28) (SeqType T@@130)) (=> (and (<= 0 n@@8) (<= n@@8 (|Seq#Length| s@@28))) (= (|Seq#Length| (|Seq#Drop| s@@28 n@@8)) (- (|Seq#Length| s@@28) n@@8))))) :qid |DafnyPre.898:18| :skolemid |226| :pattern ((|Seq#Length| (|Seq#Drop| s@@28 n@@8))))))
(assert (forall ((s@@29 T@U) (n@@9 Int) (j@@4 Int)) (! (let ((T@@131 (SeqTypeInv0 (type s@@29)))) (=> (= (type s@@29) (SeqType T@@131)) (=> (and (and (<= 0 n@@9) (<= 0 j@@4)) (< j@@4 (- (|Seq#Length| s@@29) n@@9))) (= (|Seq#Index| (|Seq#Drop| s@@29 n@@9) j@@4) (|Seq#Index| s@@29 (+ j@@4 n@@9)))))) :qid |DafnyPre.900:18| :weight 25 :skolemid |227| :pattern ((|Seq#Index| (|Seq#Drop| s@@29 n@@9) j@@4)))))
(assert (forall ((s@@30 T@U) (n@@10 Int) (k@@3 Int)) (! (let ((T@@132 (SeqTypeInv0 (type s@@30)))) (=> (= (type s@@30) (SeqType T@@132)) (=> (and (and (<= 0 n@@10) (<= n@@10 k@@3)) (< k@@3 (|Seq#Length| s@@30))) (= (|Seq#Index| (|Seq#Drop| s@@30 n@@10) (- k@@3 n@@10)) (|Seq#Index| s@@30 k@@3))))) :qid |DafnyPre.905:18| :weight 25 :skolemid |228| :pattern ((|Seq#Index| s@@30 k@@3) (|Seq#Drop| s@@30 n@@10)))))
(assert (forall ((s@@31 T@U) (t@@28 T@U)) (! (let ((T@@133 (SeqTypeInv0 (type s@@31)))) (=> (and (= (type s@@31) (SeqType T@@133)) (= (type t@@28) (SeqType T@@133))) (and (= (|Seq#Take| (|Seq#Append| s@@31 t@@28) (|Seq#Length| s@@31)) s@@31) (= (|Seq#Drop| (|Seq#Append| s@@31 t@@28) (|Seq#Length| s@@31)) t@@28)))) :qid |DafnyPre.911:18| :skolemid |229| :pattern ((|Seq#Append| s@@31 t@@28)))))
(assert (forall ((arg0@@82 T@U) (arg1@@36 T@U)) (! (= (type (|Seq#FromArray| arg0@@82 arg1@@36)) (SeqType BoxType)) :qid |funType:Seq#FromArray| :pattern ((|Seq#FromArray| arg0@@82 arg1@@36)))))
(assert (forall ((h@@16 T@U) (a@@66 T@U)) (! (=> (and (= (type h@@16) (MapType1Type refType)) (= (type a@@66) refType)) (= (|Seq#Length| (|Seq#FromArray| h@@16 a@@66)) (_System.array.Length a@@66))) :qid |DafnyPre.917:15| :skolemid |230| :pattern ((|Seq#Length| (|Seq#FromArray| h@@16 a@@66))))))
(assert (forall ((h@@17 T@U) (a@@67 T@U)) (! (=> (and (= (type h@@17) (MapType1Type refType)) (= (type a@@67) refType)) (forall ((i@@20 Int)) (! (=> (and (<= 0 i@@20) (< i@@20 (|Seq#Length| (|Seq#FromArray| h@@17 a@@67)))) (= (|Seq#Index| (|Seq#FromArray| h@@17 a@@67) i@@20) (MapType1Select h@@17 a@@67 (IndexField i@@20)))) :qid |DafnyPre.922:11| :skolemid |231| :pattern ((MapType1Select h@@17 a@@67 (IndexField i@@20))) :pattern ((|Seq#Index| (|Seq#FromArray| h@@17 a@@67) i@@20))))) :qid |DafnyPre.920:15| :skolemid |232| :pattern ((|Seq#FromArray| h@@17 a@@67)))))
(assert (forall ((h0 T@U) (h1 T@U) (a@@68 T@U)) (! (=> (and (and (= (type h0) (MapType1Type refType)) (= (type h1) (MapType1Type refType))) (= (type a@@68) refType)) (=> (and (and (and ($IsGoodHeap h0) ($IsGoodHeap h1)) ($HeapSucc h0 h1)) (forall ((i@@21 Int)) (! (=> (and (<= 0 i@@21) (< i@@21 (_System.array.Length a@@68))) (= (MapType1Select h0 a@@68 (IndexField i@@21)) (MapType1Select h1 a@@68 (IndexField i@@21)))) :qid |DafnyPre.935:11| :skolemid |233|))) (= (|Seq#FromArray| h0 a@@68) (|Seq#FromArray| h1 a@@68)))) :qid |DafnyPre.932:15| :skolemid |234| :pattern ((|Seq#FromArray| h1 a@@68) ($HeapSucc h0 h1)))))
(assert (forall ((h@@18 T@U) (i@@22 Int) (v@@32 T@U) (a@@69 T@U)) (! (=> (and (and (and (= (type h@@18) (MapType1Type refType)) (= (type v@@32) BoxType)) (= (type a@@69) refType)) (and (<= 0 i@@22) (< i@@22 (_System.array.Length a@@69)))) (= (|Seq#FromArray| (MapType1Store h@@18 a@@69 (IndexField i@@22) v@@32) a@@69) (|Seq#Update| (|Seq#FromArray| h@@18 a@@69) i@@22 v@@32))) :qid |DafnyPre.939:15| :skolemid |235| :pattern ((|Seq#FromArray| (MapType1Store h@@18 a@@69 (IndexField i@@22) v@@32) a@@69)))))
(assert (forall ((s@@32 T@U) (i@@23 Int) (v@@33 T@U) (n@@11 Int)) (! (let ((T@@134 (type v@@33))) (=> (= (type s@@32) (SeqType T@@134)) (=> (and (and (<= 0 i@@23) (< i@@23 n@@11)) (<= n@@11 (|Seq#Length| s@@32))) (= (|Seq#Take| (|Seq#Update| s@@32 i@@23 v@@33) n@@11) (|Seq#Update| (|Seq#Take| s@@32 n@@11) i@@23 v@@33))))) :qid |DafnyPre.944:18| :skolemid |236| :pattern ((|Seq#Take| (|Seq#Update| s@@32 i@@23 v@@33) n@@11)))))
(assert (forall ((s@@33 T@U) (i@@24 Int) (v@@34 T@U) (n@@12 Int)) (! (let ((T@@135 (type v@@34))) (=> (= (type s@@33) (SeqType T@@135)) (=> (and (<= n@@12 i@@24) (< i@@24 (|Seq#Length| s@@33))) (= (|Seq#Take| (|Seq#Update| s@@33 i@@24 v@@34) n@@12) (|Seq#Take| s@@33 n@@12))))) :qid |DafnyPre.947:18| :skolemid |237| :pattern ((|Seq#Take| (|Seq#Update| s@@33 i@@24 v@@34) n@@12)))))
(assert (forall ((s@@34 T@U) (i@@25 Int) (v@@35 T@U) (n@@13 Int)) (! (let ((T@@136 (type v@@35))) (=> (= (type s@@34) (SeqType T@@136)) (=> (and (and (<= 0 n@@13) (<= n@@13 i@@25)) (< i@@25 (|Seq#Length| s@@34))) (= (|Seq#Drop| (|Seq#Update| s@@34 i@@25 v@@35) n@@13) (|Seq#Update| (|Seq#Drop| s@@34 n@@13) (- i@@25 n@@13) v@@35))))) :qid |DafnyPre.950:18| :skolemid |238| :pattern ((|Seq#Drop| (|Seq#Update| s@@34 i@@25 v@@35) n@@13)))))
(assert (forall ((s@@35 T@U) (i@@26 Int) (v@@36 T@U) (n@@14 Int)) (! (let ((T@@137 (type v@@36))) (=> (= (type s@@35) (SeqType T@@137)) (=> (and (and (<= 0 i@@26) (< i@@26 n@@14)) (< n@@14 (|Seq#Length| s@@35))) (= (|Seq#Drop| (|Seq#Update| s@@35 i@@26 v@@36) n@@14) (|Seq#Drop| s@@35 n@@14))))) :qid |DafnyPre.953:18| :skolemid |239| :pattern ((|Seq#Drop| (|Seq#Update| s@@35 i@@26 v@@36) n@@14)))))
(assert (forall ((h@@19 T@U) (a@@70 T@U) (n0 Int) (n1 Int)) (! (=> (and (= (type h@@19) (MapType1Type refType)) (= (type a@@70) refType)) (=> (and (and (= (+ n0 1) n1) (<= 0 n0)) (<= n1 (_System.array.Length a@@70))) (= (|Seq#Take| (|Seq#FromArray| h@@19 a@@70) n1) (|Seq#Build| (|Seq#Take| (|Seq#FromArray| h@@19 a@@70) n0) (MapType1Select h@@19 a@@70 (IndexField n0)))))) :qid |DafnyPre.957:15| :skolemid |240| :pattern ((|Seq#Take| (|Seq#FromArray| h@@19 a@@70) n0) (|Seq#Take| (|Seq#FromArray| h@@19 a@@70) n1)))))
(assert (forall ((s@@36 T@U) (v@@37 T@U) (n@@15 Int)) (! (let ((T@@138 (type v@@37))) (=> (= (type s@@36) (SeqType T@@138)) (=> (and (<= 0 n@@15) (<= n@@15 (|Seq#Length| s@@36))) (= (|Seq#Drop| (|Seq#Build| s@@36 v@@37) n@@15) (|Seq#Build| (|Seq#Drop| s@@36 n@@15) v@@37))))) :qid |DafnyPre.961:18| :skolemid |241| :pattern ((|Seq#Drop| (|Seq#Build| s@@36 v@@37) n@@15)))))
(assert (forall ((s@@37 T@U) (i@@27 Int)) (! (=> (= (type s@@37) (SeqType BoxType)) (=> (and (<= 0 i@@27) (< i@@27 (|Seq#Length| s@@37))) (< (DtRank ($Unbox DatatypeTypeType (|Seq#Index| s@@37 i@@27))) (|Seq#Rank| s@@37)))) :qid |DafnyPre.966:15| :skolemid |242| :pattern ((DtRank ($Unbox DatatypeTypeType (|Seq#Index| s@@37 i@@27)))))))
(assert (forall ((s@@38 T@U) (i@@28 Int)) (! (let ((T@@139 (SeqTypeInv0 (type s@@38)))) (=> (= (type s@@38) (SeqType T@@139)) (=> (and (< 0 i@@28) (<= i@@28 (|Seq#Length| s@@38))) (< (|Seq#Rank| (|Seq#Drop| s@@38 i@@28)) (|Seq#Rank| s@@38))))) :qid |DafnyPre.969:18| :skolemid |243| :pattern ((|Seq#Rank| (|Seq#Drop| s@@38 i@@28))))))
(assert (forall ((s@@39 T@U) (i@@29 Int)) (! (let ((T@@140 (SeqTypeInv0 (type s@@39)))) (=> (= (type s@@39) (SeqType T@@140)) (=> (and (<= 0 i@@29) (< i@@29 (|Seq#Length| s@@39))) (< (|Seq#Rank| (|Seq#Take| s@@39 i@@29)) (|Seq#Rank| s@@39))))) :qid |DafnyPre.972:18| :skolemid |244| :pattern ((|Seq#Rank| (|Seq#Take| s@@39 i@@29))))))
(assert (forall ((s@@40 T@U) (i@@30 Int) (j@@5 Int)) (! (let ((T@@141 (SeqTypeInv0 (type s@@40)))) (=> (= (type s@@40) (SeqType T@@141)) (=> (and (and (<= 0 i@@30) (< i@@30 j@@5)) (<= j@@5 (|Seq#Length| s@@40))) (< (|Seq#Rank| (|Seq#Append| (|Seq#Take| s@@40 i@@30) (|Seq#Drop| s@@40 j@@5))) (|Seq#Rank| s@@40))))) :qid |DafnyPre.975:18| :skolemid |245| :pattern ((|Seq#Rank| (|Seq#Append| (|Seq#Take| s@@40 i@@30) (|Seq#Drop| s@@40 j@@5)))))))
(assert (forall ((s@@41 T@U) (n@@16 Int)) (! (let ((T@@142 (SeqTypeInv0 (type s@@41)))) (=> (and (= (type s@@41) (SeqType T@@142)) (= n@@16 0)) (= (|Seq#Drop| s@@41 n@@16) s@@41))) :qid |DafnyPre.980:18| :skolemid |246| :pattern ((|Seq#Drop| s@@41 n@@16)))))
(assert (forall ((s@@42 T@U) (n@@17 Int)) (! (let ((T@@143 (SeqTypeInv0 (type s@@42)))) (=> (and (= (type s@@42) (SeqType T@@143)) (= n@@17 0)) (= (|Seq#Take| s@@42 n@@17) (|Seq#Empty| T@@143)))) :qid |DafnyPre.982:18| :skolemid |247| :pattern ((|Seq#Take| s@@42 n@@17)))))
(assert (forall ((s@@43 T@U) (m@@6 Int) (n@@18 Int)) (! (let ((T@@144 (SeqTypeInv0 (type s@@43)))) (=> (= (type s@@43) (SeqType T@@144)) (=> (and (and (<= 0 m@@6) (<= 0 n@@18)) (<= (+ m@@6 n@@18) (|Seq#Length| s@@43))) (= (|Seq#Drop| (|Seq#Drop| s@@43 m@@6) n@@18) (|Seq#Drop| s@@43 (+ m@@6 n@@18)))))) :qid |DafnyPre.984:18| :skolemid |248| :pattern ((|Seq#Drop| (|Seq#Drop| s@@43 m@@6) n@@18)))))
(assert (forall ((m@@7 T@U)) (! (let ((V@@1 (MapTypeInv1 (type m@@7)))) (let ((U@@3 (MapTypeInv0 (type m@@7)))) (=> (= (type m@@7) (MapType U@@3 V@@1)) (<= 0 (|Map#Card| m@@7))))) :qid |DafnyPre.998:21| :skolemid |249| :pattern ((|Map#Card| m@@7)))))
(assert (forall ((U@@4 T@T) (V@@2 T@T)) (! (= (type (|Map#Empty| U@@4 V@@2)) (MapType U@@4 V@@2)) :qid |funType:Map#Empty| :pattern ((|Map#Empty| U@@4 V@@2)))))
(assert (forall ((u@@5 T@U) (V@@3 T@T)) (! (let ((U@@5 (type u@@5))) (not (U_2_bool (MapType0Select (|Map#Domain| (|Map#Empty| U@@5 V@@3)) u@@5)))) :qid |DafnyPre.1001:21| :skolemid |250| :pattern ((let ((U@@5 (type u@@5))) (MapType0Select (|Map#Domain| (|Map#Empty| U@@5 V@@3)) u@@5))))))
(assert (forall ((m@@8 T@U)) (! (let ((V@@4 (MapTypeInv1 (type m@@8)))) (let ((U@@6 (MapTypeInv0 (type m@@8)))) (=> (= (type m@@8) (MapType U@@6 V@@4)) (and (and (=> (= (|Map#Card| m@@8) 0) (= m@@8 (|Map#Empty| U@@6 V@@4))) (=> (= m@@8 (|Map#Empty| U@@6 V@@4)) (= (|Map#Card| m@@8) 0))) (=> (not (= (|Map#Card| m@@8) 0)) (exists ((x@@39 T@U)) (! (and (= (type x@@39) U@@6) (U_2_bool (MapType0Select (|Map#Domain| m@@8) x@@39))) :qid |DafnyPre.1006:32| :skolemid |251| :no-pattern (type x@@39) :no-pattern (U_2_int x@@39) :no-pattern (U_2_bool x@@39)))))))) :qid |DafnyPre.1004:21| :skolemid |252| :pattern ((|Map#Card| m@@8)))))
(assert (forall ((arg0@@83 T@U) (arg1@@37 T@U) (arg2@@3 T@U)) (! (let ((V@@5 (MapType0TypeInv1 (type arg1@@37)))) (let ((U@@7 (MapType0TypeInv0 (type arg0@@83)))) (= (type (|Map#Glue| arg0@@83 arg1@@37 arg2@@3)) (MapType U@@7 V@@5)))) :qid |funType:Map#Glue| :pattern ((|Map#Glue| arg0@@83 arg1@@37 arg2@@3)))))
(assert (forall ((a@@71 T@U) (b@@50 T@U) (t@@29 T@U)) (! (let ((V@@6 (MapType0TypeInv1 (type b@@50)))) (let ((U@@8 (MapType0TypeInv0 (type a@@71)))) (=> (and (and (= (type a@@71) (MapType0Type U@@8 boolType)) (= (type b@@50) (MapType0Type U@@8 V@@6))) (= (type t@@29) TyType)) (= (|Map#Domain| (|Map#Glue| a@@71 b@@50 t@@29)) a@@71)))) :qid |DafnyPre.1009:21| :skolemid |253| :pattern ((|Map#Domain| (|Map#Glue| a@@71 b@@50 t@@29))))))
(assert (forall ((a@@72 T@U) (b@@51 T@U) (t@@30 T@U)) (! (let ((V@@7 (MapType0TypeInv1 (type b@@51)))) (let ((U@@9 (MapType0TypeInv0 (type a@@72)))) (=> (and (and (= (type a@@72) (MapType0Type U@@9 boolType)) (= (type b@@51) (MapType0Type U@@9 V@@7))) (= (type t@@30) TyType)) (= (|Map#Elements| (|Map#Glue| a@@72 b@@51 t@@30)) b@@51)))) :qid |DafnyPre.1012:21| :skolemid |254| :pattern ((|Map#Elements| (|Map#Glue| a@@72 b@@51 t@@30))))))
(assert (forall ((a@@73 T@U) (b@@52 T@U) (t@@31 T@U)) (! (let ((V@@8 (MapType0TypeInv1 (type b@@52)))) (let ((U@@10 (MapType0TypeInv0 (type a@@73)))) (=> (and (and (= (type a@@73) (MapType0Type U@@10 boolType)) (= (type b@@52) (MapType0Type U@@10 V@@8))) (= (type t@@31) TyType)) ($Is (|Map#Glue| a@@73 b@@52 t@@31) t@@31)))) :qid |DafnyPre.1015:21| :skolemid |255| :pattern (($Is (|Map#Glue| a@@73 b@@52 t@@31) t@@31)))))
(assert (forall ((arg0@@84 T@U) (arg1@@38 T@U) (arg2@@4 T@U)) (! (let ((V@@9 (type arg2@@4))) (let ((U@@11 (type arg1@@38))) (= (type (|Map#Build| arg0@@84 arg1@@38 arg2@@4)) (MapType U@@11 V@@9)))) :qid |funType:Map#Build| :pattern ((|Map#Build| arg0@@84 arg1@@38 arg2@@4)))))
(assert (forall ((m@@9 T@U) (u@@6 T@U) (|u'| T@U) (v@@38 T@U)) (! (let ((V@@10 (type v@@38))) (let ((U@@12 (type u@@6))) (=> (and (= (type m@@9) (MapType U@@12 V@@10)) (= (type |u'|) U@@12)) (and (=> (= |u'| u@@6) (and (U_2_bool (MapType0Select (|Map#Domain| (|Map#Build| m@@9 u@@6 v@@38)) |u'|)) (= (MapType0Select (|Map#Elements| (|Map#Build| m@@9 u@@6 v@@38)) |u'|) v@@38))) (=> (not (= |u'| u@@6)) (and (and (=> (U_2_bool (MapType0Select (|Map#Domain| (|Map#Build| m@@9 u@@6 v@@38)) |u'|)) (U_2_bool (MapType0Select (|Map#Domain| m@@9) |u'|))) (=> (U_2_bool (MapType0Select (|Map#Domain| m@@9) |u'|)) (U_2_bool (MapType0Select (|Map#Domain| (|Map#Build| m@@9 u@@6 v@@38)) |u'|)))) (= (MapType0Select (|Map#Elements| (|Map#Build| m@@9 u@@6 v@@38)) |u'|) (MapType0Select (|Map#Elements| m@@9) |u'|)))))))) :qid |DafnyPre.1026:21| :skolemid |256| :pattern ((MapType0Select (|Map#Domain| (|Map#Build| m@@9 u@@6 v@@38)) |u'|)) :pattern ((MapType0Select (|Map#Elements| (|Map#Build| m@@9 u@@6 v@@38)) |u'|)))))
(assert (forall ((m@@10 T@U) (u@@7 T@U) (v@@39 T@U)) (! (let ((V@@11 (type v@@39))) (let ((U@@13 (type u@@7))) (=> (and (= (type m@@10) (MapType U@@13 V@@11)) (U_2_bool (MapType0Select (|Map#Domain| m@@10) u@@7))) (= (|Map#Card| (|Map#Build| m@@10 u@@7 v@@39)) (|Map#Card| m@@10))))) :qid |DafnyPre.1032:21| :skolemid |257| :pattern ((|Map#Card| (|Map#Build| m@@10 u@@7 v@@39))))))
(assert (forall ((m@@11 T@U) (u@@8 T@U) (v@@40 T@U)) (! (let ((V@@12 (type v@@40))) (let ((U@@14 (type u@@8))) (=> (and (= (type m@@11) (MapType U@@14 V@@12)) (not (U_2_bool (MapType0Select (|Map#Domain| m@@11) u@@8)))) (= (|Map#Card| (|Map#Build| m@@11 u@@8 v@@40)) (+ (|Map#Card| m@@11) 1))))) :qid |DafnyPre.1034:21| :skolemid |258| :pattern ((|Map#Card| (|Map#Build| m@@11 u@@8 v@@40))))))
(assert (forall ((m@@12 T@U) (|m'| T@U)) (! (let ((V@@13 (MapTypeInv1 (type m@@12)))) (let ((U@@15 (MapTypeInv0 (type m@@12)))) (=> (and (= (type m@@12) (MapType U@@15 V@@13)) (= (type |m'|) (MapType U@@15 V@@13))) (and (=> (|Map#Equal| m@@12 |m'|) (and (forall ((u@@9 T@U)) (! (=> (= (type u@@9) U@@15) (and (=> (U_2_bool (MapType0Select (|Map#Domain| m@@12) u@@9)) (U_2_bool (MapType0Select (|Map#Domain| |m'|) u@@9))) (=> (U_2_bool (MapType0Select (|Map#Domain| |m'|) u@@9)) (U_2_bool (MapType0Select (|Map#Domain| m@@12) u@@9))))) :qid |DafnyPre.1042:35| :skolemid |259| :no-pattern (type u@@9) :no-pattern (U_2_int u@@9) :no-pattern (U_2_bool u@@9))) (forall ((u@@10 T@U)) (! (=> (and (= (type u@@10) U@@15) (U_2_bool (MapType0Select (|Map#Domain| m@@12) u@@10))) (= (MapType0Select (|Map#Elements| m@@12) u@@10) (MapType0Select (|Map#Elements| |m'|) u@@10))) :qid |DafnyPre.1043:35| :skolemid |260| :no-pattern (type u@@10) :no-pattern (U_2_int u@@10) :no-pattern (U_2_bool u@@10))))) (=> (and (forall ((u@@11 T@U)) (! (=> (= (type u@@11) U@@15) (and (=> (U_2_bool (MapType0Select (|Map#Domain| m@@12) u@@11)) (U_2_bool (MapType0Select (|Map#Domain| |m'|) u@@11))) (=> (U_2_bool (MapType0Select (|Map#Domain| |m'|) u@@11)) (U_2_bool (MapType0Select (|Map#Domain| m@@12) u@@11))))) :qid |DafnyPre.1042:35| :skolemid |259| :no-pattern (type u@@11) :no-pattern (U_2_int u@@11) :no-pattern (U_2_bool u@@11))) (forall ((u@@12 T@U)) (! (=> (and (= (type u@@12) U@@15) (U_2_bool (MapType0Select (|Map#Domain| m@@12) u@@12))) (= (MapType0Select (|Map#Elements| m@@12) u@@12) (MapType0Select (|Map#Elements| |m'|) u@@12))) :qid |DafnyPre.1043:35| :skolemid |260| :no-pattern (type u@@12) :no-pattern (U_2_int u@@12) :no-pattern (U_2_bool u@@12)))) (|Map#Equal| m@@12 |m'|)))))) :qid |DafnyPre.1040:21| :skolemid |261| :pattern ((|Map#Equal| m@@12 |m'|)))))
(assert (forall ((m@@13 T@U) (|m'@@0| T@U)) (! (let ((V@@14 (MapTypeInv1 (type m@@13)))) (let ((U@@16 (MapTypeInv0 (type m@@13)))) (=> (and (and (= (type m@@13) (MapType U@@16 V@@14)) (= (type |m'@@0|) (MapType U@@16 V@@14))) (|Map#Equal| m@@13 |m'@@0|)) (= m@@13 |m'@@0|)))) :qid |DafnyPre.1045:21| :skolemid |262| :pattern ((|Map#Equal| m@@13 |m'@@0|)))))
(assert (forall ((m@@14 T@U) (|m'@@1| T@U)) (! (let ((V@@15 (MapTypeInv1 (type m@@14)))) (let ((U@@17 (MapTypeInv0 (type m@@14)))) (=> (and (= (type m@@14) (MapType U@@17 V@@15)) (= (type |m'@@1|) (MapType U@@17 V@@15))) (and (=> (|Map#Disjoint| m@@14 |m'@@1|) (forall ((o@@37 T@U)) (! (=> (= (type o@@37) U@@17) (or (not (U_2_bool (MapType0Select (|Map#Domain| m@@14) o@@37))) (not (U_2_bool (MapType0Select (|Map#Domain| |m'@@1|) o@@37))))) :qid |DafnyPre.1052:38| :skolemid |263| :pattern ((MapType0Select (|Map#Domain| m@@14) o@@37)) :pattern ((MapType0Select (|Map#Domain| |m'@@1|) o@@37))))) (=> (forall ((o@@38 T@U)) (! (=> (= (type o@@38) U@@17) (or (not (U_2_bool (MapType0Select (|Map#Domain| m@@14) o@@38))) (not (U_2_bool (MapType0Select (|Map#Domain| |m'@@1|) o@@38))))) :qid |DafnyPre.1052:38| :skolemid |263| :pattern ((MapType0Select (|Map#Domain| m@@14) o@@38)) :pattern ((MapType0Select (|Map#Domain| |m'@@1|) o@@38)))) (|Map#Disjoint| m@@14 |m'@@1|)))))) :qid |DafnyPre.1050:21| :skolemid |264| :pattern ((|Map#Disjoint| m@@14 |m'@@1|)))))
(assert (forall ((U@@18 T@T) (V@@16 T@T)) (! (= (type (|IMap#Empty| U@@18 V@@16)) (IMapType U@@18 V@@16)) :qid |funType:IMap#Empty| :pattern ((|IMap#Empty| U@@18 V@@16)))))
(assert (forall ((u@@13 T@U) (V@@17 T@T)) (! (let ((U@@19 (type u@@13))) (not (U_2_bool (MapType0Select (|IMap#Domain| (|IMap#Empty| U@@19 V@@17)) u@@13)))) :qid |DafnyPre.1064:21| :skolemid |265| :pattern ((let ((U@@19 (type u@@13))) (MapType0Select (|IMap#Domain| (|IMap#Empty| U@@19 V@@17)) u@@13))))))
(assert (forall ((arg0@@85 T@U) (arg1@@39 T@U) (arg2@@5 T@U)) (! (let ((V@@18 (MapType0TypeInv1 (type arg1@@39)))) (let ((U@@20 (MapType0TypeInv0 (type arg0@@85)))) (= (type (|IMap#Glue| arg0@@85 arg1@@39 arg2@@5)) (IMapType U@@20 V@@18)))) :qid |funType:IMap#Glue| :pattern ((|IMap#Glue| arg0@@85 arg1@@39 arg2@@5)))))
(assert (forall ((a@@74 T@U) (b@@53 T@U) (t@@32 T@U)) (! (let ((V@@19 (MapType0TypeInv1 (type b@@53)))) (let ((U@@21 (MapType0TypeInv0 (type a@@74)))) (=> (and (and (= (type a@@74) (MapType0Type U@@21 boolType)) (= (type b@@53) (MapType0Type U@@21 V@@19))) (= (type t@@32) TyType)) (= (|IMap#Domain| (|IMap#Glue| a@@74 b@@53 t@@32)) a@@74)))) :qid |DafnyPre.1069:21| :skolemid |266| :pattern ((|IMap#Domain| (|IMap#Glue| a@@74 b@@53 t@@32))))))
(assert (forall ((a@@75 T@U) (b@@54 T@U) (t@@33 T@U)) (! (let ((V@@20 (MapType0TypeInv1 (type b@@54)))) (let ((U@@22 (MapType0TypeInv0 (type a@@75)))) (=> (and (and (= (type a@@75) (MapType0Type U@@22 boolType)) (= (type b@@54) (MapType0Type U@@22 V@@20))) (= (type t@@33) TyType)) (= (|IMap#Elements| (|IMap#Glue| a@@75 b@@54 t@@33)) b@@54)))) :qid |DafnyPre.1072:21| :skolemid |267| :pattern ((|IMap#Elements| (|IMap#Glue| a@@75 b@@54 t@@33))))))
(assert (forall ((a@@76 T@U) (b@@55 T@U) (t@@34 T@U)) (! (let ((V@@21 (MapType0TypeInv1 (type b@@55)))) (let ((U@@23 (MapType0TypeInv0 (type a@@76)))) (=> (and (and (= (type a@@76) (MapType0Type U@@23 boolType)) (= (type b@@55) (MapType0Type U@@23 V@@21))) (= (type t@@34) TyType)) ($Is (|IMap#Glue| a@@76 b@@55 t@@34) t@@34)))) :qid |DafnyPre.1075:21| :skolemid |268| :pattern (($Is (|IMap#Glue| a@@76 b@@55 t@@34) t@@34)))))
(assert (forall ((arg0@@86 T@U) (arg1@@40 T@U) (arg2@@6 T@U)) (! (let ((V@@22 (type arg2@@6))) (let ((U@@24 (type arg1@@40))) (= (type (|IMap#Build| arg0@@86 arg1@@40 arg2@@6)) (IMapType U@@24 V@@22)))) :qid |funType:IMap#Build| :pattern ((|IMap#Build| arg0@@86 arg1@@40 arg2@@6)))))
(assert (forall ((m@@15 T@U) (u@@14 T@U) (|u'@@0| T@U) (v@@41 T@U)) (! (let ((V@@23 (type v@@41))) (let ((U@@25 (type u@@14))) (=> (and (= (type m@@15) (IMapType U@@25 V@@23)) (= (type |u'@@0|) U@@25)) (and (=> (= |u'@@0| u@@14) (and (U_2_bool (MapType0Select (|IMap#Domain| (|IMap#Build| m@@15 u@@14 v@@41)) |u'@@0|)) (= (MapType0Select (|IMap#Elements| (|IMap#Build| m@@15 u@@14 v@@41)) |u'@@0|) v@@41))) (=> (not (= |u'@@0| u@@14)) (and (and (=> (U_2_bool (MapType0Select (|IMap#Domain| (|IMap#Build| m@@15 u@@14 v@@41)) |u'@@0|)) (U_2_bool (MapType0Select (|IMap#Domain| m@@15) |u'@@0|))) (=> (U_2_bool (MapType0Select (|IMap#Domain| m@@15) |u'@@0|)) (U_2_bool (MapType0Select (|IMap#Domain| (|IMap#Build| m@@15 u@@14 v@@41)) |u'@@0|)))) (= (MapType0Select (|IMap#Elements| (|IMap#Build| m@@15 u@@14 v@@41)) |u'@@0|) (MapType0Select (|IMap#Elements| m@@15) |u'@@0|)))))))) :qid |DafnyPre.1085:21| :skolemid |269| :pattern ((MapType0Select (|IMap#Domain| (|IMap#Build| m@@15 u@@14 v@@41)) |u'@@0|)) :pattern ((MapType0Select (|IMap#Elements| (|IMap#Build| m@@15 u@@14 v@@41)) |u'@@0|)))))
(assert (forall ((m@@16 T@U) (|m'@@2| T@U)) (! (let ((V@@24 (IMapTypeInv1 (type m@@16)))) (let ((U@@26 (IMapTypeInv0 (type m@@16)))) (=> (and (= (type m@@16) (IMapType U@@26 V@@24)) (= (type |m'@@2|) (IMapType U@@26 V@@24))) (and (=> (|IMap#Equal| m@@16 |m'@@2|) (and (forall ((u@@15 T@U)) (! (=> (= (type u@@15) U@@26) (and (=> (U_2_bool (MapType0Select (|IMap#Domain| m@@16) u@@15)) (U_2_bool (MapType0Select (|IMap#Domain| |m'@@2|) u@@15))) (=> (U_2_bool (MapType0Select (|IMap#Domain| |m'@@2|) u@@15)) (U_2_bool (MapType0Select (|IMap#Domain| m@@16) u@@15))))) :qid |DafnyPre.1096:36| :skolemid |270| :no-pattern (type u@@15) :no-pattern (U_2_int u@@15) :no-pattern (U_2_bool u@@15))) (forall ((u@@16 T@U)) (! (=> (and (= (type u@@16) U@@26) (U_2_bool (MapType0Select (|IMap#Domain| m@@16) u@@16))) (= (MapType0Select (|IMap#Elements| m@@16) u@@16) (MapType0Select (|IMap#Elements| |m'@@2|) u@@16))) :qid |DafnyPre.1097:35| :skolemid |271| :no-pattern (type u@@16) :no-pattern (U_2_int u@@16) :no-pattern (U_2_bool u@@16))))) (=> (and (forall ((u@@17 T@U)) (! (=> (= (type u@@17) U@@26) (and (=> (U_2_bool (MapType0Select (|IMap#Domain| m@@16) u@@17)) (U_2_bool (MapType0Select (|IMap#Domain| |m'@@2|) u@@17))) (=> (U_2_bool (MapType0Select (|IMap#Domain| |m'@@2|) u@@17)) (U_2_bool (MapType0Select (|IMap#Domain| m@@16) u@@17))))) :qid |DafnyPre.1096:36| :skolemid |270| :no-pattern (type u@@17) :no-pattern (U_2_int u@@17) :no-pattern (U_2_bool u@@17))) (forall ((u@@18 T@U)) (! (=> (and (= (type u@@18) U@@26) (U_2_bool (MapType0Select (|IMap#Domain| m@@16) u@@18))) (= (MapType0Select (|IMap#Elements| m@@16) u@@18) (MapType0Select (|IMap#Elements| |m'@@2|) u@@18))) :qid |DafnyPre.1097:35| :skolemid |271| :no-pattern (type u@@18) :no-pattern (U_2_int u@@18) :no-pattern (U_2_bool u@@18)))) (|IMap#Equal| m@@16 |m'@@2|)))))) :qid |DafnyPre.1094:21| :skolemid |272| :pattern ((|IMap#Equal| m@@16 |m'@@2|)))))
(assert (forall ((m@@17 T@U) (|m'@@3| T@U)) (! (let ((V@@25 (IMapTypeInv1 (type m@@17)))) (let ((U@@27 (IMapTypeInv0 (type m@@17)))) (=> (and (and (= (type m@@17) (IMapType U@@27 V@@25)) (= (type |m'@@3|) (IMapType U@@27 V@@25))) (|IMap#Equal| m@@17 |m'@@3|)) (= m@@17 |m'@@3|)))) :qid |DafnyPre.1099:21| :skolemid |273| :pattern ((|IMap#Equal| m@@17 |m'@@3|)))))
(assert (forall ((x@@40 Int) (y@@12 Int)) (! (= (INTERNAL_add_boogie x@@40 y@@12) (+ x@@40 y@@12)) :qid |DafnyPre.1107:30| :skolemid |274| :pattern ((INTERNAL_add_boogie x@@40 y@@12)))))
(assert (forall ((x@@41 Int) (y@@13 Int)) (! (= (INTERNAL_sub_boogie x@@41 y@@13) (- x@@41 y@@13)) :qid |DafnyPre.1108:30| :skolemid |275| :pattern ((INTERNAL_sub_boogie x@@41 y@@13)))))
(assert (forall ((x@@42 Int) (y@@14 Int)) (! (= (INTERNAL_mul_boogie x@@42 y@@14) (* x@@42 y@@14)) :qid |DafnyPre.1109:30| :skolemid |276| :pattern ((INTERNAL_mul_boogie x@@42 y@@14)))))
(assert (forall ((x@@43 Int) (y@@15 Int)) (! (= (INTERNAL_div_boogie x@@43 y@@15) (div x@@43 y@@15)) :qid |DafnyPre.1110:30| :skolemid |277| :pattern ((INTERNAL_div_boogie x@@43 y@@15)))))
(assert (forall ((x@@44 Int) (y@@16 Int)) (! (= (INTERNAL_mod_boogie x@@44 y@@16) (mod x@@44 y@@16)) :qid |DafnyPre.1111:30| :skolemid |278| :pattern ((INTERNAL_mod_boogie x@@44 y@@16)))))
(assert (forall ((x@@45 Int) (y@@17 Int)) (! (and (=> (INTERNAL_lt_boogie x@@45 y@@17) (< x@@45 y@@17)) (=> (< x@@45 y@@17) (INTERNAL_lt_boogie x@@45 y@@17))) :qid |DafnyPre.1112:51| :skolemid |279| :pattern ((INTERNAL_lt_boogie x@@45 y@@17)))))
(assert (forall ((x@@46 Int) (y@@18 Int)) (! (and (=> (INTERNAL_le_boogie x@@46 y@@18) (<= x@@46 y@@18)) (=> (<= x@@46 y@@18) (INTERNAL_le_boogie x@@46 y@@18))) :qid |DafnyPre.1113:51| :skolemid |280| :pattern ((INTERNAL_le_boogie x@@46 y@@18)))))
(assert (forall ((x@@47 Int) (y@@19 Int)) (! (and (=> (INTERNAL_gt_boogie x@@47 y@@19) (> x@@47 y@@19)) (=> (> x@@47 y@@19) (INTERNAL_gt_boogie x@@47 y@@19))) :qid |DafnyPre.1114:51| :skolemid |281| :pattern ((INTERNAL_gt_boogie x@@47 y@@19)))))
(assert (forall ((x@@48 Int) (y@@20 Int)) (! (and (=> (INTERNAL_ge_boogie x@@48 y@@20) (>= x@@48 y@@20)) (=> (>= x@@48 y@@20) (INTERNAL_ge_boogie x@@48 y@@20))) :qid |DafnyPre.1115:51| :skolemid |282| :pattern ((INTERNAL_ge_boogie x@@48 y@@20)))))
(assert (= (Tag Tclass._System.object) Tagclass._System.object))
(assert (forall ((bx@@35 T@U)) (! (=> (and (= (type bx@@35) BoxType) ($IsBox bx@@35 Tclass._System.object)) (and (= ($Box ($Unbox refType bx@@35)) bx@@35) ($Is ($Unbox refType bx@@35) Tclass._System.object))) :qid |unknown.0:0| :skolemid |283| :pattern (($IsBox bx@@35 Tclass._System.object)))))
(assert (forall (($o T@U)) (! (=> (= (type $o) refType) ($Is $o Tclass._System.object)) :qid |unknown.0:0| :skolemid |284| :pattern (($Is $o Tclass._System.object)))))
(assert (= (type null) refType))
(assert (forall (($o@@0 T@U) ($h T@U)) (! (=> (and (= (type $o@@0) refType) (= (type $h) (MapType1Type refType))) (and (=> ($IsAlloc $o@@0 Tclass._System.object $h) (or (= $o@@0 null) (U_2_bool (MapType1Select $h $o@@0 alloc)))) (=> (or (= $o@@0 null) (U_2_bool (MapType1Select $h $o@@0 alloc))) ($IsAlloc $o@@0 Tclass._System.object $h)))) :qid |unknown.0:0| :skolemid |285| :pattern (($IsAlloc $o@@0 Tclass._System.object $h)))))
(assert (forall ((arg0@@87 T@U)) (! (= (type (Tclass._System.array arg0@@87)) TyType) :qid |funType:Tclass._System.array| :pattern ((Tclass._System.array arg0@@87)))))
(assert (forall ((|#$arg| T@U)) (! (=> (= (type |#$arg|) TyType) (= (Tag (Tclass._System.array |#$arg|)) Tagclass._System.array)) :qid |unknown.0:0| :skolemid |286| :pattern ((Tclass._System.array |#$arg|)))))
(assert (forall ((arg0@@88 T@U)) (! (= (type (Tclass._System.array_0 arg0@@88)) TyType) :qid |funType:Tclass._System.array_0| :pattern ((Tclass._System.array_0 arg0@@88)))))
(assert (forall ((|#$arg@@0| T@U)) (! (=> (= (type |#$arg@@0|) TyType) (= (Tclass._System.array_0 (Tclass._System.array |#$arg@@0|)) |#$arg@@0|)) :qid |unknown.0:0| :skolemid |287| :pattern ((Tclass._System.array |#$arg@@0|)))))
(assert (forall ((|#$arg@@1| T@U) (bx@@36 T@U)) (! (=> (and (and (= (type |#$arg@@1|) TyType) (= (type bx@@36) BoxType)) ($IsBox bx@@36 (Tclass._System.array |#$arg@@1|))) (and (= ($Box ($Unbox refType bx@@36)) bx@@36) ($Is ($Unbox refType bx@@36) (Tclass._System.array |#$arg@@1|)))) :qid |unknown.0:0| :skolemid |288| :pattern (($IsBox bx@@36 (Tclass._System.array |#$arg@@1|))))))
(assert (forall ((arg0@@89 T@U)) (! (= (type (dtype arg0@@89)) TyType) :qid |funType:dtype| :pattern ((dtype arg0@@89)))))
(assert (forall ((|#$arg@@2| T@U) ($i0 Int) ($h@@0 T@U) ($o@@1 T@U)) (! (=> (and (and (= (type |#$arg@@2|) TyType) (= (type $h@@0) (MapType1Type refType))) (= (type $o@@1) refType)) (=> (and (and (and ($IsGoodHeap $h@@0) (not (= $o@@1 null))) (= (dtype $o@@1) (Tclass._System.array |#$arg@@2|))) (and (<= 0 $i0) (< $i0 (_System.array.Length $o@@1)))) (and ($IsBox (MapType1Select $h@@0 $o@@1 (IndexField $i0)) |#$arg@@2|) (=> (U_2_bool (MapType1Select $h@@0 $o@@1 alloc)) ($IsAllocBox (MapType1Select $h@@0 $o@@1 (IndexField $i0)) |#$arg@@2| $h@@0))))) :qid |unknown.0:0| :skolemid |289| :pattern ((MapType1Select $h@@0 $o@@1 (IndexField $i0)) (Tclass._System.array |#$arg@@2|)))))
(assert (forall ((|#$arg@@3| T@U) ($o@@2 T@U)) (! (=> (and (= (type |#$arg@@3|) TyType) (= (type $o@@2) refType)) (and (=> ($Is $o@@2 (Tclass._System.array |#$arg@@3|)) (or (= $o@@2 null) (= (dtype $o@@2) (Tclass._System.array |#$arg@@3|)))) (=> (or (= $o@@2 null) (= (dtype $o@@2) (Tclass._System.array |#$arg@@3|))) ($Is $o@@2 (Tclass._System.array |#$arg@@3|))))) :qid |unknown.0:0| :skolemid |290| :pattern (($Is $o@@2 (Tclass._System.array |#$arg@@3|))))))
(assert (forall ((|#$arg@@4| T@U) ($o@@3 T@U) ($h@@1 T@U)) (! (=> (and (and (= (type |#$arg@@4|) TyType) (= (type $o@@3) refType)) (= (type $h@@1) (MapType1Type refType))) (and (=> ($IsAlloc $o@@3 (Tclass._System.array |#$arg@@4|) $h@@1) (or (= $o@@3 null) (U_2_bool (MapType1Select $h@@1 $o@@3 alloc)))) (=> (or (= $o@@3 null) (U_2_bool (MapType1Select $h@@1 $o@@3 alloc))) ($IsAlloc $o@@3 (Tclass._System.array |#$arg@@4|) $h@@1)))) :qid |unknown.0:0| :skolemid |291| :pattern (($IsAlloc $o@@3 (Tclass._System.array |#$arg@@4|) $h@@1)))))
(assert (forall ((|#$arg@@5| T@U) ($h@@2 T@U) ($o@@4 T@U)) (! (=> (and (and (and (= (type |#$arg@@5|) TyType) (= (type $h@@2) (MapType1Type refType))) (= (type $o@@4) refType)) (and (and ($IsGoodHeap $h@@2) (not (= $o@@4 null))) (= (dtype $o@@4) (Tclass._System.array |#$arg@@5|)))) (and ($Is (int_2_U (_System.array.Length $o@@4)) TInt) (=> (U_2_bool (MapType1Select $h@@2 $o@@4 alloc)) ($IsAlloc (int_2_U (_System.array.Length $o@@4)) TInt $h@@2)))) :qid |unknown.0:0| :skolemid |292| :no-pattern (type |#$arg@@5|) :no-pattern (type $h@@2) :no-pattern (type $o@@4) :no-pattern (U_2_int |#$arg@@5|) :no-pattern (U_2_bool |#$arg@@5|) :no-pattern (U_2_int $h@@2) :no-pattern (U_2_bool $h@@2) :no-pattern (U_2_int $o@@4) :no-pattern (U_2_bool $o@@4))))
(assert (forall ((arg0@@90 T@U)) (! (= (type (Tclass._System.___hFunc0 arg0@@90)) TyType) :qid |funType:Tclass._System.___hFunc0| :pattern ((Tclass._System.___hFunc0 arg0@@90)))))
(assert (forall ((|#$T0| T@U)) (! (=> (= (type |#$T0|) TyType) (= (Tag (Tclass._System.___hFunc0 |#$T0|)) Tagclass._System.___hFunc0)) :qid |unknown.0:0| :skolemid |293| :pattern ((Tclass._System.___hFunc0 |#$T0|)))))
(assert (forall ((arg0@@91 T@U)) (! (= (type (Tclass._System.___hFunc0_0 arg0@@91)) TyType) :qid |funType:Tclass._System.___hFunc0_0| :pattern ((Tclass._System.___hFunc0_0 arg0@@91)))))
(assert (forall ((|#$T0@@0| T@U)) (! (=> (= (type |#$T0@@0|) TyType) (= (Tclass._System.___hFunc0_0 (Tclass._System.___hFunc0 |#$T0@@0|)) |#$T0@@0|)) :qid |unknown.0:0| :skolemid |294| :pattern ((Tclass._System.___hFunc0 |#$T0@@0|)))))
(assert (= (Ctor HandleTypeType) 18))
(assert (forall ((|#$T0@@1| T@U) (bx@@37 T@U)) (! (=> (and (and (= (type |#$T0@@1|) TyType) (= (type bx@@37) BoxType)) ($IsBox bx@@37 (Tclass._System.___hFunc0 |#$T0@@1|))) (and (= ($Box ($Unbox HandleTypeType bx@@37)) bx@@37) ($Is ($Unbox HandleTypeType bx@@37) (Tclass._System.___hFunc0 |#$T0@@1|)))) :qid |unknown.0:0| :skolemid |295| :pattern (($IsBox bx@@37 (Tclass._System.___hFunc0 |#$T0@@1|))))))
(assert (and (forall ((arg0@@92 T@U) (arg1@@41 T@U) (arg2@@7 T@U)) (! (= (type (Apply0 arg0@@92 arg1@@41 arg2@@7)) BoxType) :qid |funType:Apply0| :pattern ((Apply0 arg0@@92 arg1@@41 arg2@@7)))) (forall ((arg0@@93 T@U) (arg1@@42 T@U) (arg2@@8 T@U)) (! (= (type (Handle0 arg0@@93 arg1@@42 arg2@@8)) HandleTypeType) :qid |funType:Handle0| :pattern ((Handle0 arg0@@93 arg1@@42 arg2@@8))))))
(assert (forall ((t0@@12 T@U) (heap T@U) (h@@20 T@U) (r@@5 T@U) (rd T@U)) (! (=> (and (and (and (and (= (type t0@@12) TyType) (= (type heap) (MapType1Type refType))) (= (type h@@20) (MapType0Type (MapType1Type refType) BoxType))) (= (type r@@5) (MapType0Type (MapType1Type refType) boolType))) (= (type rd) (MapType0Type (MapType1Type refType) (MapType0Type BoxType boolType)))) (= (Apply0 t0@@12 (Handle0 h@@20 r@@5 rd) heap) (MapType0Select h@@20 heap))) :qid |unknown.0:0| :skolemid |296| :pattern ((Apply0 t0@@12 (Handle0 h@@20 r@@5 rd) heap)))))
(assert (forall ((t0@@13 T@U) (heap@@0 T@U) (h@@21 T@U) (r@@6 T@U) (rd@@0 T@U)) (! (=> (and (and (and (and (and (= (type t0@@13) TyType) (= (type heap@@0) (MapType1Type refType))) (= (type h@@21) (MapType0Type (MapType1Type refType) BoxType))) (= (type r@@6) (MapType0Type (MapType1Type refType) boolType))) (= (type rd@@0) (MapType0Type (MapType1Type refType) (MapType0Type BoxType boolType)))) (U_2_bool (MapType0Select r@@6 heap@@0))) (Requires0 t0@@13 (Handle0 h@@21 r@@6 rd@@0) heap@@0)) :qid |unknown.0:0| :skolemid |297| :pattern ((Requires0 t0@@13 (Handle0 h@@21 r@@6 rd@@0) heap@@0)))))
(assert (forall ((arg0@@94 T@U) (arg1@@43 T@U) (arg2@@9 T@U)) (! (= (type (Reads0 arg0@@94 arg1@@43 arg2@@9)) (MapType0Type BoxType boolType)) :qid |funType:Reads0| :pattern ((Reads0 arg0@@94 arg1@@43 arg2@@9)))))
(assert (forall ((t0@@14 T@U) (heap@@1 T@U) (h@@22 T@U) (r@@7 T@U) (rd@@1 T@U) (bx@@38 T@U)) (! (=> (and (and (and (and (and (= (type t0@@14) TyType) (= (type heap@@1) (MapType1Type refType))) (= (type h@@22) (MapType0Type (MapType1Type refType) BoxType))) (= (type r@@7) (MapType0Type (MapType1Type refType) boolType))) (= (type rd@@1) (MapType0Type (MapType1Type refType) (MapType0Type BoxType boolType)))) (= (type bx@@38) BoxType)) (and (=> (U_2_bool (MapType0Select (Reads0 t0@@14 (Handle0 h@@22 r@@7 rd@@1) heap@@1) bx@@38)) (U_2_bool (MapType0Select (MapType0Select rd@@1 heap@@1) bx@@38))) (=> (U_2_bool (MapType0Select (MapType0Select rd@@1 heap@@1) bx@@38)) (U_2_bool (MapType0Select (Reads0 t0@@14 (Handle0 h@@22 r@@7 rd@@1) heap@@1) bx@@38))))) :qid |unknown.0:0| :skolemid |298| :pattern ((MapType0Select (Reads0 t0@@14 (Handle0 h@@22 r@@7 rd@@1) heap@@1) bx@@38)))))
(assert (forall ((t0@@15 T@U) (h0@@0 T@U) (h1@@0 T@U) (f@@5 T@U)) (! (=> (and (and (and (and (= (type t0@@15) TyType) (= (type h0@@0) (MapType1Type refType))) (= (type h1@@0) (MapType1Type refType))) (= (type f@@5) HandleTypeType)) (and (and (and ($HeapSucc h0@@0 h1@@0) (and ($IsGoodHeap h0@@0) ($IsGoodHeap h1@@0))) (and ($Is f@@5 (Tclass._System.___hFunc0 t0@@15)) ($IsAlloc f@@5 (Tclass._System.___hFunc0 t0@@15) h0@@0))) (forall ((o@@39 T@U) (fld T@U)) (! (let ((a@@77 (FieldTypeInv0 (type fld)))) (=> (and (= (type o@@39) refType) (= (type fld) (FieldType a@@77))) (=> (and (and (and (not (= o@@39 null)) (U_2_bool (MapType1Select h0@@0 o@@39 alloc))) (U_2_bool (MapType1Select h1@@0 o@@39 alloc))) (U_2_bool (MapType0Select (Reads0 t0@@15 f@@5 h0@@0) ($Box o@@39)))) (= (MapType1Select h0@@0 o@@39 fld) (MapType1Select h1@@0 o@@39 fld))))) :qid |unknown.0:0| :skolemid |299| :no-pattern (type o@@39) :no-pattern (type fld) :no-pattern (U_2_int o@@39) :no-pattern (U_2_bool o@@39) :no-pattern (U_2_int fld) :no-pattern (U_2_bool fld))))) (= (Reads0 t0@@15 f@@5 h0@@0) (Reads0 t0@@15 f@@5 h1@@0))) :qid |unknown.0:0| :skolemid |300| :pattern (($HeapSucc h0@@0 h1@@0) (Reads0 t0@@15 f@@5 h1@@0)))))
(assert (forall ((t0@@16 T@U) (h0@@1 T@U) (h1@@1 T@U) (f@@6 T@U)) (! (=> (and (and (and (and (= (type t0@@16) TyType) (= (type h0@@1) (MapType1Type refType))) (= (type h1@@1) (MapType1Type refType))) (= (type f@@6) HandleTypeType)) (and (and (and ($HeapSucc h0@@1 h1@@1) (and ($IsGoodHeap h0@@1) ($IsGoodHeap h1@@1))) (and ($Is f@@6 (Tclass._System.___hFunc0 t0@@16)) ($IsAlloc f@@6 (Tclass._System.___hFunc0 t0@@16) h0@@1))) (forall ((o@@40 T@U) (fld@@0 T@U)) (! (let ((a@@78 (FieldTypeInv0 (type fld@@0)))) (=> (and (= (type o@@40) refType) (= (type fld@@0) (FieldType a@@78))) (=> (and (and (and (not (= o@@40 null)) (U_2_bool (MapType1Select h0@@1 o@@40 alloc))) (U_2_bool (MapType1Select h1@@1 o@@40 alloc))) (U_2_bool (MapType0Select (Reads0 t0@@16 f@@6 h1@@1) ($Box o@@40)))) (= (MapType1Select h0@@1 o@@40 fld@@0) (MapType1Select h1@@1 o@@40 fld@@0))))) :qid |unknown.0:0| :skolemid |301| :no-pattern (type o@@40) :no-pattern (type fld@@0) :no-pattern (U_2_int o@@40) :no-pattern (U_2_bool o@@40) :no-pattern (U_2_int fld@@0) :no-pattern (U_2_bool fld@@0))))) (= (Reads0 t0@@16 f@@6 h0@@1) (Reads0 t0@@16 f@@6 h1@@1))) :qid |unknown.0:0| :skolemid |302| :pattern (($HeapSucc h0@@1 h1@@1) (Reads0 t0@@16 f@@6 h1@@1)))))
(assert (forall ((t0@@17 T@U) (h0@@2 T@U) (h1@@2 T@U) (f@@7 T@U)) (! (=> (and (and (and (and (= (type t0@@17) TyType) (= (type h0@@2) (MapType1Type refType))) (= (type h1@@2) (MapType1Type refType))) (= (type f@@7) HandleTypeType)) (and (and (and ($HeapSucc h0@@2 h1@@2) (and ($IsGoodHeap h0@@2) ($IsGoodHeap h1@@2))) (and ($Is f@@7 (Tclass._System.___hFunc0 t0@@17)) ($IsAlloc f@@7 (Tclass._System.___hFunc0 t0@@17) h0@@2))) (forall ((o@@41 T@U) (fld@@1 T@U)) (! (let ((a@@79 (FieldTypeInv0 (type fld@@1)))) (=> (and (= (type o@@41) refType) (= (type fld@@1) (FieldType a@@79))) (=> (and (and (and (not (= o@@41 null)) (U_2_bool (MapType1Select h0@@2 o@@41 alloc))) (U_2_bool (MapType1Select h1@@2 o@@41 alloc))) (U_2_bool (MapType0Select (Reads0 t0@@17 f@@7 h0@@2) ($Box o@@41)))) (= (MapType1Select h0@@2 o@@41 fld@@1) (MapType1Select h1@@2 o@@41 fld@@1))))) :qid |unknown.0:0| :skolemid |303| :no-pattern (type o@@41) :no-pattern (type fld@@1) :no-pattern (U_2_int o@@41) :no-pattern (U_2_bool o@@41) :no-pattern (U_2_int fld@@1) :no-pattern (U_2_bool fld@@1))))) (and (=> (Requires0 t0@@17 f@@7 h0@@2) (Requires0 t0@@17 f@@7 h1@@2)) (=> (Requires0 t0@@17 f@@7 h1@@2) (Requires0 t0@@17 f@@7 h0@@2)))) :qid |unknown.0:0| :skolemid |304| :pattern (($HeapSucc h0@@2 h1@@2) (Requires0 t0@@17 f@@7 h1@@2)))))
(assert (forall ((t0@@18 T@U) (h0@@3 T@U) (h1@@3 T@U) (f@@8 T@U)) (! (=> (and (and (and (and (= (type t0@@18) TyType) (= (type h0@@3) (MapType1Type refType))) (= (type h1@@3) (MapType1Type refType))) (= (type f@@8) HandleTypeType)) (and (and (and ($HeapSucc h0@@3 h1@@3) (and ($IsGoodHeap h0@@3) ($IsGoodHeap h1@@3))) (and ($Is f@@8 (Tclass._System.___hFunc0 t0@@18)) ($IsAlloc f@@8 (Tclass._System.___hFunc0 t0@@18) h0@@3))) (forall ((o@@42 T@U) (fld@@2 T@U)) (! (let ((a@@80 (FieldTypeInv0 (type fld@@2)))) (=> (and (= (type o@@42) refType) (= (type fld@@2) (FieldType a@@80))) (=> (and (and (and (not (= o@@42 null)) (U_2_bool (MapType1Select h0@@3 o@@42 alloc))) (U_2_bool (MapType1Select h1@@3 o@@42 alloc))) (U_2_bool (MapType0Select (Reads0 t0@@18 f@@8 h1@@3) ($Box o@@42)))) (= (MapType1Select h0@@3 o@@42 fld@@2) (MapType1Select h1@@3 o@@42 fld@@2))))) :qid |unknown.0:0| :skolemid |305| :no-pattern (type o@@42) :no-pattern (type fld@@2) :no-pattern (U_2_int o@@42) :no-pattern (U_2_bool o@@42) :no-pattern (U_2_int fld@@2) :no-pattern (U_2_bool fld@@2))))) (and (=> (Requires0 t0@@18 f@@8 h0@@3) (Requires0 t0@@18 f@@8 h1@@3)) (=> (Requires0 t0@@18 f@@8 h1@@3) (Requires0 t0@@18 f@@8 h0@@3)))) :qid |unknown.0:0| :skolemid |306| :pattern (($HeapSucc h0@@3 h1@@3) (Requires0 t0@@18 f@@8 h1@@3)))))
(assert (forall ((t0@@19 T@U) (h0@@4 T@U) (h1@@4 T@U) (f@@9 T@U)) (! (=> (and (and (and (and (= (type t0@@19) TyType) (= (type h0@@4) (MapType1Type refType))) (= (type h1@@4) (MapType1Type refType))) (= (type f@@9) HandleTypeType)) (and (and (and ($HeapSucc h0@@4 h1@@4) (and ($IsGoodHeap h0@@4) ($IsGoodHeap h1@@4))) (and ($Is f@@9 (Tclass._System.___hFunc0 t0@@19)) ($IsAlloc f@@9 (Tclass._System.___hFunc0 t0@@19) h0@@4))) (forall ((o@@43 T@U) (fld@@3 T@U)) (! (let ((a@@81 (FieldTypeInv0 (type fld@@3)))) (=> (and (= (type o@@43) refType) (= (type fld@@3) (FieldType a@@81))) (=> (and (and (and (not (= o@@43 null)) (U_2_bool (MapType1Select h0@@4 o@@43 alloc))) (U_2_bool (MapType1Select h1@@4 o@@43 alloc))) (U_2_bool (MapType0Select (Reads0 t0@@19 f@@9 h0@@4) ($Box o@@43)))) (= (MapType1Select h0@@4 o@@43 fld@@3) (MapType1Select h1@@4 o@@43 fld@@3))))) :qid |unknown.0:0| :skolemid |307| :no-pattern (type o@@43) :no-pattern (type fld@@3) :no-pattern (U_2_int o@@43) :no-pattern (U_2_bool o@@43) :no-pattern (U_2_int fld@@3) :no-pattern (U_2_bool fld@@3))))) (= (Apply0 t0@@19 f@@9 h0@@4) (Apply0 t0@@19 f@@9 h1@@4))) :qid |unknown.0:0| :skolemid |308| :pattern (($HeapSucc h0@@4 h1@@4) (Apply0 t0@@19 f@@9 h1@@4)))))
(assert (forall ((t0@@20 T@U) (h0@@5 T@U) (h1@@5 T@U) (f@@10 T@U)) (! (=> (and (and (and (and (= (type t0@@20) TyType) (= (type h0@@5) (MapType1Type refType))) (= (type h1@@5) (MapType1Type refType))) (= (type f@@10) HandleTypeType)) (and (and (and ($HeapSucc h0@@5 h1@@5) (and ($IsGoodHeap h0@@5) ($IsGoodHeap h1@@5))) (and ($Is f@@10 (Tclass._System.___hFunc0 t0@@20)) ($IsAlloc f@@10 (Tclass._System.___hFunc0 t0@@20) h0@@5))) (forall ((o@@44 T@U) (fld@@4 T@U)) (! (let ((a@@82 (FieldTypeInv0 (type fld@@4)))) (=> (and (= (type o@@44) refType) (= (type fld@@4) (FieldType a@@82))) (=> (and (and (and (not (= o@@44 null)) (U_2_bool (MapType1Select h0@@5 o@@44 alloc))) (U_2_bool (MapType1Select h1@@5 o@@44 alloc))) (U_2_bool (MapType0Select (Reads0 t0@@20 f@@10 h1@@5) ($Box o@@44)))) (= (MapType1Select h0@@5 o@@44 fld@@4) (MapType1Select h1@@5 o@@44 fld@@4))))) :qid |unknown.0:0| :skolemid |309| :no-pattern (type o@@44) :no-pattern (type fld@@4) :no-pattern (U_2_int o@@44) :no-pattern (U_2_bool o@@44) :no-pattern (U_2_int fld@@4) :no-pattern (U_2_bool fld@@4))))) (= (Apply0 t0@@20 f@@10 h0@@5) (Apply0 t0@@20 f@@10 h1@@5))) :qid |unknown.0:0| :skolemid |310| :pattern (($HeapSucc h0@@5 h1@@5) (Apply0 t0@@20 f@@10 h1@@5)))))
(assert (forall ((t0@@21 T@U) (h@@23 T@U) (f@@11 T@U)) (! (=> (and (and (and (= (type t0@@21) TyType) (= (type h@@23) (MapType1Type refType))) (= (type f@@11) HandleTypeType)) (and ($IsGoodHeap h@@23) (and ($Is f@@11 (Tclass._System.___hFunc0 t0@@21)) ($IsAlloc f@@11 (Tclass._System.___hFunc0 t0@@21) h@@23)))) (and ($IsBox (Apply0 t0@@21 f@@11 h@@23) t0@@21) ($IsAllocBox (Apply0 t0@@21 f@@11 h@@23) t0@@21 h@@23))) :qid |unknown.0:0| :skolemid |311| :pattern ((Apply0 t0@@21 f@@11 h@@23)))))
(assert (forall ((arg0@@95 T@U) (arg1@@44 T@U)) (! (= (type (Tclass._System.___hFunc1 arg0@@95 arg1@@44)) TyType) :qid |funType:Tclass._System.___hFunc1| :pattern ((Tclass._System.___hFunc1 arg0@@95 arg1@@44)))))
(assert (forall ((|#$T0@@2| T@U) (|#$T1| T@U)) (! (=> (and (= (type |#$T0@@2|) TyType) (= (type |#$T1|) TyType)) (= (Tag (Tclass._System.___hFunc1 |#$T0@@2| |#$T1|)) Tagclass._System.___hFunc1)) :qid |unknown.0:0| :skolemid |312| :pattern ((Tclass._System.___hFunc1 |#$T0@@2| |#$T1|)))))
(assert (forall ((arg0@@96 T@U)) (! (= (type (Tclass._System.___hFunc1_0 arg0@@96)) TyType) :qid |funType:Tclass._System.___hFunc1_0| :pattern ((Tclass._System.___hFunc1_0 arg0@@96)))))
(assert (forall ((|#$T0@@3| T@U) (|#$T1@@0| T@U)) (! (=> (and (= (type |#$T0@@3|) TyType) (= (type |#$T1@@0|) TyType)) (= (Tclass._System.___hFunc1_0 (Tclass._System.___hFunc1 |#$T0@@3| |#$T1@@0|)) |#$T0@@3|)) :qid |unknown.0:0| :skolemid |313| :pattern ((Tclass._System.___hFunc1 |#$T0@@3| |#$T1@@0|)))))
(assert (forall ((arg0@@97 T@U)) (! (= (type (Tclass._System.___hFunc1_1 arg0@@97)) TyType) :qid |funType:Tclass._System.___hFunc1_1| :pattern ((Tclass._System.___hFunc1_1 arg0@@97)))))
(assert (forall ((|#$T0@@4| T@U) (|#$T1@@1| T@U)) (! (=> (and (= (type |#$T0@@4|) TyType) (= (type |#$T1@@1|) TyType)) (= (Tclass._System.___hFunc1_1 (Tclass._System.___hFunc1 |#$T0@@4| |#$T1@@1|)) |#$T1@@1|)) :qid |unknown.0:0| :skolemid |314| :pattern ((Tclass._System.___hFunc1 |#$T0@@4| |#$T1@@1|)))))
(assert (forall ((|#$T0@@5| T@U) (|#$T1@@2| T@U) (bx@@39 T@U)) (! (=> (and (and (and (= (type |#$T0@@5|) TyType) (= (type |#$T1@@2|) TyType)) (= (type bx@@39) BoxType)) ($IsBox bx@@39 (Tclass._System.___hFunc1 |#$T0@@5| |#$T1@@2|))) (and (= ($Box ($Unbox HandleTypeType bx@@39)) bx@@39) ($Is ($Unbox HandleTypeType bx@@39) (Tclass._System.___hFunc1 |#$T0@@5| |#$T1@@2|)))) :qid |unknown.0:0| :skolemid |315| :pattern (($IsBox bx@@39 (Tclass._System.___hFunc1 |#$T0@@5| |#$T1@@2|))))))
(assert (and (and (and (and (and (and (and (and (and (forall ((arg0@@98 T@T) (arg1@@45 T@T) (arg2@@10 T@T)) (! (= (Ctor (MapType2Type arg0@@98 arg1@@45 arg2@@10)) 19) :qid |ctor:MapType2Type|)) (forall ((arg0@@99 T@T) (arg1@@46 T@T) (arg2@@11 T@T)) (! (= (MapType2TypeInv0 (MapType2Type arg0@@99 arg1@@46 arg2@@11)) arg0@@99) :qid |typeInv:MapType2TypeInv0| :pattern ((MapType2Type arg0@@99 arg1@@46 arg2@@11))))) (forall ((arg0@@100 T@T) (arg1@@47 T@T) (arg2@@12 T@T)) (! (= (MapType2TypeInv1 (MapType2Type arg0@@100 arg1@@47 arg2@@12)) arg1@@47) :qid |typeInv:MapType2TypeInv1| :pattern ((MapType2Type arg0@@100 arg1@@47 arg2@@12))))) (forall ((arg0@@101 T@T) (arg1@@48 T@T) (arg2@@13 T@T)) (! (= (MapType2TypeInv2 (MapType2Type arg0@@101 arg1@@48 arg2@@13)) arg2@@13) :qid |typeInv:MapType2TypeInv2| :pattern ((MapType2Type arg0@@101 arg1@@48 arg2@@13))))) (forall ((arg0@@102 T@U) (arg1@@49 T@U) (arg2@@14 T@U)) (! (let ((aVar2 (MapType2TypeInv2 (type arg0@@102)))) (= (type (MapType2Select arg0@@102 arg1@@49 arg2@@14)) aVar2)) :qid |funType:MapType2Select| :pattern ((MapType2Select arg0@@102 arg1@@49 arg2@@14))))) (forall ((arg0@@103 T@U) (arg1@@50 T@U) (arg2@@15 T@U) (arg3@@0 T@U)) (! (let ((aVar2@@0 (type arg3@@0))) (let ((aVar1@@2 (type arg2@@15))) (let ((aVar0@@1 (type arg1@@50))) (= (type (MapType2Store arg0@@103 arg1@@50 arg2@@15 arg3@@0)) (MapType2Type aVar0@@1 aVar1@@2 aVar2@@0))))) :qid |funType:MapType2Store| :pattern ((MapType2Store arg0@@103 arg1@@50 arg2@@15 arg3@@0))))) (forall ((m@@18 T@U) (x0@@6 T@U) (x1@@3 T@U) (val@@6 T@U)) (! (let ((aVar2@@1 (MapType2TypeInv2 (type m@@18)))) (=> (= (type val@@6) aVar2@@1) (= (MapType2Select (MapType2Store m@@18 x0@@6 x1@@3 val@@6) x0@@6 x1@@3) val@@6))) :qid |mapAx0:MapType2Select| :weight 0))) (and (and (forall ((val@@7 T@U) (m@@19 T@U) (x0@@7 T@U) (x1@@4 T@U) (y0@@4 T@U) (y1@@2 T@U)) (! (or (= x0@@7 y0@@4) (= (MapType2Select (MapType2Store m@@19 x0@@7 x1@@4 val@@7) y0@@4 y1@@2) (MapType2Select m@@19 y0@@4 y1@@2))) :qid |mapAx1:MapType2Select:0| :weight 0)) (forall ((val@@8 T@U) (m@@20 T@U) (x0@@8 T@U) (x1@@5 T@U) (y0@@5 T@U) (y1@@3 T@U)) (! (or (= x1@@5 y1@@3) (= (MapType2Select (MapType2Store m@@20 x0@@8 x1@@5 val@@8) y0@@5 y1@@3) (MapType2Select m@@20 y0@@5 y1@@3))) :qid |mapAx1:MapType2Select:1| :weight 0))) (forall ((val@@9 T@U) (m@@21 T@U) (x0@@9 T@U) (x1@@6 T@U) (y0@@6 T@U) (y1@@4 T@U)) (! (or true (= (MapType2Select (MapType2Store m@@21 x0@@9 x1@@6 val@@9) y0@@6 y1@@4) (MapType2Select m@@21 y0@@6 y1@@4))) :qid |mapAx2:MapType2Select| :weight 0)))) (forall ((arg0@@104 T@U) (arg1@@51 T@U) (arg2@@16 T@U) (arg3@@1 T@U) (arg4 T@U)) (! (= (type (Apply1 arg0@@104 arg1@@51 arg2@@16 arg3@@1 arg4)) BoxType) :qid |funType:Apply1| :pattern ((Apply1 arg0@@104 arg1@@51 arg2@@16 arg3@@1 arg4))))) (forall ((arg0@@105 T@U) (arg1@@52 T@U) (arg2@@17 T@U)) (! (= (type (Handle1 arg0@@105 arg1@@52 arg2@@17)) HandleTypeType) :qid |funType:Handle1| :pattern ((Handle1 arg0@@105 arg1@@52 arg2@@17))))))
(assert (forall ((t0@@22 T@U) (t1@@3 T@U) (heap@@2 T@U) (h@@24 T@U) (r@@8 T@U) (rd@@2 T@U) (bx0 T@U)) (! (=> (and (and (and (and (and (and (= (type t0@@22) TyType) (= (type t1@@3) TyType)) (= (type heap@@2) (MapType1Type refType))) (= (type h@@24) (MapType2Type (MapType1Type refType) BoxType BoxType))) (= (type r@@8) (MapType2Type (MapType1Type refType) BoxType boolType))) (= (type rd@@2) (MapType2Type (MapType1Type refType) BoxType (MapType0Type BoxType boolType)))) (= (type bx0) BoxType)) (= (Apply1 t0@@22 t1@@3 (Handle1 h@@24 r@@8 rd@@2) heap@@2 bx0) (MapType2Select h@@24 heap@@2 bx0))) :qid |unknown.0:0| :skolemid |316| :pattern ((Apply1 t0@@22 t1@@3 (Handle1 h@@24 r@@8 rd@@2) heap@@2 bx0)))))
(assert (forall ((t0@@23 T@U) (t1@@4 T@U) (heap@@3 T@U) (h@@25 T@U) (r@@9 T@U) (rd@@3 T@U) (bx0@@0 T@U)) (! (=> (and (and (and (and (and (and (and (= (type t0@@23) TyType) (= (type t1@@4) TyType)) (= (type heap@@3) (MapType1Type refType))) (= (type h@@25) (MapType2Type (MapType1Type refType) BoxType BoxType))) (= (type r@@9) (MapType2Type (MapType1Type refType) BoxType boolType))) (= (type rd@@3) (MapType2Type (MapType1Type refType) BoxType (MapType0Type BoxType boolType)))) (= (type bx0@@0) BoxType)) (U_2_bool (MapType2Select r@@9 heap@@3 bx0@@0))) (Requires1 t0@@23 t1@@4 (Handle1 h@@25 r@@9 rd@@3) heap@@3 bx0@@0)) :qid |unknown.0:0| :skolemid |317| :pattern ((Requires1 t0@@23 t1@@4 (Handle1 h@@25 r@@9 rd@@3) heap@@3 bx0@@0)))))
(assert (forall ((arg0@@106 T@U) (arg1@@53 T@U) (arg2@@18 T@U) (arg3@@2 T@U) (arg4@@0 T@U)) (! (= (type (Reads1 arg0@@106 arg1@@53 arg2@@18 arg3@@2 arg4@@0)) (MapType0Type BoxType boolType)) :qid |funType:Reads1| :pattern ((Reads1 arg0@@106 arg1@@53 arg2@@18 arg3@@2 arg4@@0)))))
(assert (forall ((t0@@24 T@U) (t1@@5 T@U) (heap@@4 T@U) (h@@26 T@U) (r@@10 T@U) (rd@@4 T@U) (bx0@@1 T@U) (bx@@40 T@U)) (! (=> (and (and (and (and (and (and (and (= (type t0@@24) TyType) (= (type t1@@5) TyType)) (= (type heap@@4) (MapType1Type refType))) (= (type h@@26) (MapType2Type (MapType1Type refType) BoxType BoxType))) (= (type r@@10) (MapType2Type (MapType1Type refType) BoxType boolType))) (= (type rd@@4) (MapType2Type (MapType1Type refType) BoxType (MapType0Type BoxType boolType)))) (= (type bx0@@1) BoxType)) (= (type bx@@40) BoxType)) (and (=> (U_2_bool (MapType0Select (Reads1 t0@@24 t1@@5 (Handle1 h@@26 r@@10 rd@@4) heap@@4 bx0@@1) bx@@40)) (U_2_bool (MapType0Select (MapType2Select rd@@4 heap@@4 bx0@@1) bx@@40))) (=> (U_2_bool (MapType0Select (MapType2Select rd@@4 heap@@4 bx0@@1) bx@@40)) (U_2_bool (MapType0Select (Reads1 t0@@24 t1@@5 (Handle1 h@@26 r@@10 rd@@4) heap@@4 bx0@@1) bx@@40))))) :qid |unknown.0:0| :skolemid |318| :pattern ((MapType0Select (Reads1 t0@@24 t1@@5 (Handle1 h@@26 r@@10 rd@@4) heap@@4 bx0@@1) bx@@40)))))
(assert (forall ((t0@@25 T@U) (t1@@6 T@U) (h0@@6 T@U) (h1@@6 T@U) (f@@12 T@U) (bx0@@2 T@U)) (! (=> (and (and (and (and (and (and (= (type t0@@25) TyType) (= (type t1@@6) TyType)) (= (type h0@@6) (MapType1Type refType))) (= (type h1@@6) (MapType1Type refType))) (= (type f@@12) HandleTypeType)) (= (type bx0@@2) BoxType)) (and (and (and ($HeapSucc h0@@6 h1@@6) (and ($IsGoodHeap h0@@6) ($IsGoodHeap h1@@6))) (and (and ($IsBox bx0@@2 t0@@25) ($IsAllocBox bx0@@2 t0@@25 h0@@6)) (and ($Is f@@12 (Tclass._System.___hFunc1 t0@@25 t1@@6)) ($IsAlloc f@@12 (Tclass._System.___hFunc1 t0@@25 t1@@6) h0@@6)))) (forall ((o@@45 T@U) (fld@@5 T@U)) (! (let ((a@@83 (FieldTypeInv0 (type fld@@5)))) (=> (and (= (type o@@45) refType) (= (type fld@@5) (FieldType a@@83))) (=> (and (and (and (not (= o@@45 null)) (U_2_bool (MapType1Select h0@@6 o@@45 alloc))) (U_2_bool (MapType1Select h1@@6 o@@45 alloc))) (U_2_bool (MapType0Select (Reads1 t0@@25 t1@@6 f@@12 h0@@6 bx0@@2) ($Box o@@45)))) (= (MapType1Select h0@@6 o@@45 fld@@5) (MapType1Select h1@@6 o@@45 fld@@5))))) :qid |unknown.0:0| :skolemid |319| :no-pattern (type o@@45) :no-pattern (type fld@@5) :no-pattern (U_2_int o@@45) :no-pattern (U_2_bool o@@45) :no-pattern (U_2_int fld@@5) :no-pattern (U_2_bool fld@@5))))) (= (Reads1 t0@@25 t1@@6 f@@12 h0@@6 bx0@@2) (Reads1 t0@@25 t1@@6 f@@12 h1@@6 bx0@@2))) :qid |unknown.0:0| :skolemid |320| :pattern (($HeapSucc h0@@6 h1@@6) (Reads1 t0@@25 t1@@6 f@@12 h1@@6 bx0@@2)))))
(assert (forall ((t0@@26 T@U) (t1@@7 T@U) (h0@@7 T@U) (h1@@7 T@U) (f@@13 T@U) (bx0@@3 T@U)) (! (=> (and (and (and (and (and (and (= (type t0@@26) TyType) (= (type t1@@7) TyType)) (= (type h0@@7) (MapType1Type refType))) (= (type h1@@7) (MapType1Type refType))) (= (type f@@13) HandleTypeType)) (= (type bx0@@3) BoxType)) (and (and (and ($HeapSucc h0@@7 h1@@7) (and ($IsGoodHeap h0@@7) ($IsGoodHeap h1@@7))) (and (and ($IsBox bx0@@3 t0@@26) ($IsAllocBox bx0@@3 t0@@26 h0@@7)) (and ($Is f@@13 (Tclass._System.___hFunc1 t0@@26 t1@@7)) ($IsAlloc f@@13 (Tclass._System.___hFunc1 t0@@26 t1@@7) h0@@7)))) (forall ((o@@46 T@U) (fld@@6 T@U)) (! (let ((a@@84 (FieldTypeInv0 (type fld@@6)))) (=> (and (= (type o@@46) refType) (= (type fld@@6) (FieldType a@@84))) (=> (and (and (and (not (= o@@46 null)) (U_2_bool (MapType1Select h0@@7 o@@46 alloc))) (U_2_bool (MapType1Select h1@@7 o@@46 alloc))) (U_2_bool (MapType0Select (Reads1 t0@@26 t1@@7 f@@13 h1@@7 bx0@@3) ($Box o@@46)))) (= (MapType1Select h0@@7 o@@46 fld@@6) (MapType1Select h1@@7 o@@46 fld@@6))))) :qid |unknown.0:0| :skolemid |321| :no-pattern (type o@@46) :no-pattern (type fld@@6) :no-pattern (U_2_int o@@46) :no-pattern (U_2_bool o@@46) :no-pattern (U_2_int fld@@6) :no-pattern (U_2_bool fld@@6))))) (= (Reads1 t0@@26 t1@@7 f@@13 h0@@7 bx0@@3) (Reads1 t0@@26 t1@@7 f@@13 h1@@7 bx0@@3))) :qid |unknown.0:0| :skolemid |322| :pattern (($HeapSucc h0@@7 h1@@7) (Reads1 t0@@26 t1@@7 f@@13 h1@@7 bx0@@3)))))
(assert (forall ((t0@@27 T@U) (t1@@8 T@U) (h0@@8 T@U) (h1@@8 T@U) (f@@14 T@U) (bx0@@4 T@U)) (! (=> (and (and (and (and (and (and (= (type t0@@27) TyType) (= (type t1@@8) TyType)) (= (type h0@@8) (MapType1Type refType))) (= (type h1@@8) (MapType1Type refType))) (= (type f@@14) HandleTypeType)) (= (type bx0@@4) BoxType)) (and (and (and ($HeapSucc h0@@8 h1@@8) (and ($IsGoodHeap h0@@8) ($IsGoodHeap h1@@8))) (and (and ($IsBox bx0@@4 t0@@27) ($IsAllocBox bx0@@4 t0@@27 h0@@8)) (and ($Is f@@14 (Tclass._System.___hFunc1 t0@@27 t1@@8)) ($IsAlloc f@@14 (Tclass._System.___hFunc1 t0@@27 t1@@8) h0@@8)))) (forall ((o@@47 T@U) (fld@@7 T@U)) (! (let ((a@@85 (FieldTypeInv0 (type fld@@7)))) (=> (and (= (type o@@47) refType) (= (type fld@@7) (FieldType a@@85))) (=> (and (and (and (not (= o@@47 null)) (U_2_bool (MapType1Select h0@@8 o@@47 alloc))) (U_2_bool (MapType1Select h1@@8 o@@47 alloc))) (U_2_bool (MapType0Select (Reads1 t0@@27 t1@@8 f@@14 h0@@8 bx0@@4) ($Box o@@47)))) (= (MapType1Select h0@@8 o@@47 fld@@7) (MapType1Select h1@@8 o@@47 fld@@7))))) :qid |unknown.0:0| :skolemid |323| :no-pattern (type o@@47) :no-pattern (type fld@@7) :no-pattern (U_2_int o@@47) :no-pattern (U_2_bool o@@47) :no-pattern (U_2_int fld@@7) :no-pattern (U_2_bool fld@@7))))) (and (=> (Requires1 t0@@27 t1@@8 f@@14 h0@@8 bx0@@4) (Requires1 t0@@27 t1@@8 f@@14 h1@@8 bx0@@4)) (=> (Requires1 t0@@27 t1@@8 f@@14 h1@@8 bx0@@4) (Requires1 t0@@27 t1@@8 f@@14 h0@@8 bx0@@4)))) :qid |unknown.0:0| :skolemid |324| :pattern (($HeapSucc h0@@8 h1@@8) (Requires1 t0@@27 t1@@8 f@@14 h1@@8 bx0@@4)))))
(assert (forall ((t0@@28 T@U) (t1@@9 T@U) (h0@@9 T@U) (h1@@9 T@U) (f@@15 T@U) (bx0@@5 T@U)) (! (=> (and (and (and (and (and (and (= (type t0@@28) TyType) (= (type t1@@9) TyType)) (= (type h0@@9) (MapType1Type refType))) (= (type h1@@9) (MapType1Type refType))) (= (type f@@15) HandleTypeType)) (= (type bx0@@5) BoxType)) (and (and (and ($HeapSucc h0@@9 h1@@9) (and ($IsGoodHeap h0@@9) ($IsGoodHeap h1@@9))) (and (and ($IsBox bx0@@5 t0@@28) ($IsAllocBox bx0@@5 t0@@28 h0@@9)) (and ($Is f@@15 (Tclass._System.___hFunc1 t0@@28 t1@@9)) ($IsAlloc f@@15 (Tclass._System.___hFunc1 t0@@28 t1@@9) h0@@9)))) (forall ((o@@48 T@U) (fld@@8 T@U)) (! (let ((a@@86 (FieldTypeInv0 (type fld@@8)))) (=> (and (= (type o@@48) refType) (= (type fld@@8) (FieldType a@@86))) (=> (and (and (and (not (= o@@48 null)) (U_2_bool (MapType1Select h0@@9 o@@48 alloc))) (U_2_bool (MapType1Select h1@@9 o@@48 alloc))) (U_2_bool (MapType0Select (Reads1 t0@@28 t1@@9 f@@15 h1@@9 bx0@@5) ($Box o@@48)))) (= (MapType1Select h0@@9 o@@48 fld@@8) (MapType1Select h1@@9 o@@48 fld@@8))))) :qid |unknown.0:0| :skolemid |325| :no-pattern (type o@@48) :no-pattern (type fld@@8) :no-pattern (U_2_int o@@48) :no-pattern (U_2_bool o@@48) :no-pattern (U_2_int fld@@8) :no-pattern (U_2_bool fld@@8))))) (and (=> (Requires1 t0@@28 t1@@9 f@@15 h0@@9 bx0@@5) (Requires1 t0@@28 t1@@9 f@@15 h1@@9 bx0@@5)) (=> (Requires1 t0@@28 t1@@9 f@@15 h1@@9 bx0@@5) (Requires1 t0@@28 t1@@9 f@@15 h0@@9 bx0@@5)))) :qid |unknown.0:0| :skolemid |326| :pattern (($HeapSucc h0@@9 h1@@9) (Requires1 t0@@28 t1@@9 f@@15 h1@@9 bx0@@5)))))
(assert (forall ((t0@@29 T@U) (t1@@10 T@U) (h0@@10 T@U) (h1@@10 T@U) (f@@16 T@U) (bx0@@6 T@U)) (! (=> (and (and (and (and (and (and (= (type t0@@29) TyType) (= (type t1@@10) TyType)) (= (type h0@@10) (MapType1Type refType))) (= (type h1@@10) (MapType1Type refType))) (= (type f@@16) HandleTypeType)) (= (type bx0@@6) BoxType)) (and (and (and ($HeapSucc h0@@10 h1@@10) (and ($IsGoodHeap h0@@10) ($IsGoodHeap h1@@10))) (and (and ($IsBox bx0@@6 t0@@29) ($IsAllocBox bx0@@6 t0@@29 h0@@10)) (and ($Is f@@16 (Tclass._System.___hFunc1 t0@@29 t1@@10)) ($IsAlloc f@@16 (Tclass._System.___hFunc1 t0@@29 t1@@10) h0@@10)))) (forall ((o@@49 T@U) (fld@@9 T@U)) (! (let ((a@@87 (FieldTypeInv0 (type fld@@9)))) (=> (and (= (type o@@49) refType) (= (type fld@@9) (FieldType a@@87))) (=> (and (and (and (not (= o@@49 null)) (U_2_bool (MapType1Select h0@@10 o@@49 alloc))) (U_2_bool (MapType1Select h1@@10 o@@49 alloc))) (U_2_bool (MapType0Select (Reads1 t0@@29 t1@@10 f@@16 h0@@10 bx0@@6) ($Box o@@49)))) (= (MapType1Select h0@@10 o@@49 fld@@9) (MapType1Select h1@@10 o@@49 fld@@9))))) :qid |unknown.0:0| :skolemid |327| :no-pattern (type o@@49) :no-pattern (type fld@@9) :no-pattern (U_2_int o@@49) :no-pattern (U_2_bool o@@49) :no-pattern (U_2_int fld@@9) :no-pattern (U_2_bool fld@@9))))) (= (Apply1 t0@@29 t1@@10 f@@16 h0@@10 bx0@@6) (Apply1 t0@@29 t1@@10 f@@16 h1@@10 bx0@@6))) :qid |unknown.0:0| :skolemid |328| :pattern (($HeapSucc h0@@10 h1@@10) (Apply1 t0@@29 t1@@10 f@@16 h1@@10 bx0@@6)))))
(assert (forall ((t0@@30 T@U) (t1@@11 T@U) (h0@@11 T@U) (h1@@11 T@U) (f@@17 T@U) (bx0@@7 T@U)) (! (=> (and (and (and (and (and (and (= (type t0@@30) TyType) (= (type t1@@11) TyType)) (= (type h0@@11) (MapType1Type refType))) (= (type h1@@11) (MapType1Type refType))) (= (type f@@17) HandleTypeType)) (= (type bx0@@7) BoxType)) (and (and (and ($HeapSucc h0@@11 h1@@11) (and ($IsGoodHeap h0@@11) ($IsGoodHeap h1@@11))) (and (and ($IsBox bx0@@7 t0@@30) ($IsAllocBox bx0@@7 t0@@30 h0@@11)) (and ($Is f@@17 (Tclass._System.___hFunc1 t0@@30 t1@@11)) ($IsAlloc f@@17 (Tclass._System.___hFunc1 t0@@30 t1@@11) h0@@11)))) (forall ((o@@50 T@U) (fld@@10 T@U)) (! (let ((a@@88 (FieldTypeInv0 (type fld@@10)))) (=> (and (= (type o@@50) refType) (= (type fld@@10) (FieldType a@@88))) (=> (and (and (and (not (= o@@50 null)) (U_2_bool (MapType1Select h0@@11 o@@50 alloc))) (U_2_bool (MapType1Select h1@@11 o@@50 alloc))) (U_2_bool (MapType0Select (Reads1 t0@@30 t1@@11 f@@17 h1@@11 bx0@@7) ($Box o@@50)))) (= (MapType1Select h0@@11 o@@50 fld@@10) (MapType1Select h1@@11 o@@50 fld@@10))))) :qid |unknown.0:0| :skolemid |329| :no-pattern (type o@@50) :no-pattern (type fld@@10) :no-pattern (U_2_int o@@50) :no-pattern (U_2_bool o@@50) :no-pattern (U_2_int fld@@10) :no-pattern (U_2_bool fld@@10))))) (= (Apply1 t0@@30 t1@@11 f@@17 h0@@11 bx0@@7) (Apply1 t0@@30 t1@@11 f@@17 h1@@11 bx0@@7))) :qid |unknown.0:0| :skolemid |330| :pattern (($HeapSucc h0@@11 h1@@11) (Apply1 t0@@30 t1@@11 f@@17 h1@@11 bx0@@7)))))
(assert (forall ((t0@@31 T@U) (t1@@12 T@U) (h@@27 T@U) (f@@18 T@U) (bx0@@8 T@U)) (! (=> (and (and (and (and (and (= (type t0@@31) TyType) (= (type t1@@12) TyType)) (= (type h@@27) (MapType1Type refType))) (= (type f@@18) HandleTypeType)) (= (type bx0@@8) BoxType)) (and ($IsGoodHeap h@@27) (and (and ($IsBox bx0@@8 t0@@31) ($IsAllocBox bx0@@8 t0@@31 h@@27)) (and ($Is f@@18 (Tclass._System.___hFunc1 t0@@31 t1@@12)) ($IsAlloc f@@18 (Tclass._System.___hFunc1 t0@@31 t1@@12) h@@27))))) (and ($IsBox (Apply1 t0@@31 t1@@12 f@@18 h@@27 bx0@@8) t1@@12) ($IsAllocBox (Apply1 t0@@31 t1@@12 f@@18 h@@27 bx0@@8) t1@@12 h@@27))) :qid |unknown.0:0| :skolemid |331| :pattern ((Apply1 t0@@31 t1@@12 f@@18 h@@27 bx0@@8)))))
(assert (= (type Tclass._module.__default) TyType))
(assert (= (Tag Tclass._module.__default) Tagclass._module.__default))
(assert (forall ((bx@@41 T@U)) (! (=> (and (= (type bx@@41) BoxType) ($IsBox bx@@41 Tclass._module.__default)) (and (= ($Box ($Unbox refType bx@@41)) bx@@41) ($Is ($Unbox refType bx@@41) Tclass._module.__default))) :qid |unknown.0:0| :skolemid |332| :pattern (($IsBox bx@@41 Tclass._module.__default)))))
(assert (forall (($o@@5 T@U)) (! (=> (= (type $o@@5) refType) (and (=> ($Is $o@@5 Tclass._module.__default) (or (= $o@@5 null) (= (dtype $o@@5) Tclass._module.__default))) (=> (or (= $o@@5 null) (= (dtype $o@@5) Tclass._module.__default)) ($Is $o@@5 Tclass._module.__default)))) :qid |unknown.0:0| :skolemid |333| :pattern (($Is $o@@5 Tclass._module.__default)))))
(assert (forall (($o@@6 T@U) ($h@@3 T@U)) (! (=> (and (= (type $o@@6) refType) (= (type $h@@3) (MapType1Type refType))) (and (=> ($IsAlloc $o@@6 Tclass._module.__default $h@@3) (or (= $o@@6 null) (U_2_bool (MapType1Select $h@@3 $o@@6 alloc)))) (=> (or (= $o@@6 null) (U_2_bool (MapType1Select $h@@3 $o@@6 alloc))) ($IsAlloc $o@@6 Tclass._module.__default $h@@3)))) :qid |unknown.0:0| :skolemid |334| :pattern (($IsAlloc $o@@6 Tclass._module.__default $h@@3)))))
(assert (forall (($ly T@U) ($Heap T@U) (|n#0| Int)) (! (=> (and (= (type $ly) LayerTypeType) (= (type $Heap) (MapType1Type refType))) (= (_module.__default.Factorial ($LS $ly) $Heap |n#0|) (_module.__default.Factorial $ly $Heap |n#0|))) :qid |Classics.7:10| :skolemid |335| :pattern ((_module.__default.Factorial ($LS $ly) $Heap |n#0|)))))
(assert (forall (($ly@@0 T@U) ($h0 T@U) ($h1 T@U) (|n#0@@0| Int)) (! (=> (and (and (= (type $ly@@0) LayerTypeType) (= (type $h0) (MapType1Type refType))) (= (type $h1) (MapType1Type refType))) (=> (and (and (and ($IsGoodHeap $h0) ($IsGoodHeap $h1)) (and (or (|_module.__default.Factorial#canCall| $h0 |n#0@@0|) (<= 0 |n#0@@0|)) (or (|_module.__default.Factorial#canCall| $h1 |n#0@@0|) (<= 0 |n#0@@0|)))) (and ($IsHeapAnchor $h0) ($HeapSucc $h0 $h1))) (=> (forall (($o@@7 T@U) ($f T@U)) (! (let ((alpha@@6 (FieldTypeInv0 (type $f)))) (=> (and (and (= (type $o@@7) refType) (= (type $f) (FieldType alpha@@6))) false) (= (MapType1Select $h0 $o@@7 $f) (MapType1Select $h1 $o@@7 $f)))) :qid |unknown.0:0| :skolemid |336| :no-pattern (type $o@@7) :no-pattern (type $f) :no-pattern (U_2_int $o@@7) :no-pattern (U_2_bool $o@@7) :no-pattern (U_2_int $f) :no-pattern (U_2_bool $f))) (= (_module.__default.Factorial $ly@@0 $h0 |n#0@@0|) (_module.__default.Factorial $ly@@0 $h1 |n#0@@0|))))) :qid |unknown.0:0| :skolemid |337| :pattern (($IsHeapAnchor $h0) ($HeapSucc $h0 $h1) (_module.__default.Factorial $ly@@0 $h1 |n#0@@0|)))))
(assert (=> (or (< 0 $ModuleContextHeight) (and (= 0 $ModuleContextHeight) (<= 0 $FunctionContextHeight))) (forall (($ly@@1 T@U) ($Heap@@0 T@U) (|n#0@@1| Int)) (! (=> (and (and (= (type $ly@@1) LayerTypeType) (= (type $Heap@@0) (MapType1Type refType))) (or (|_module.__default.Factorial#canCall| $Heap@@0 |n#0@@1|) (and (or (not (= 0 $ModuleContextHeight)) (not (= 0 $FunctionContextHeight))) (and ($IsGoodHeap $Heap@@0) (<= 0 |n#0@@1|))))) (<= 0 (_module.__default.Factorial ($LS $ly@@1) $Heap@@0 |n#0@@1|))) :qid |Classics.7:10| :skolemid |338| :pattern ((_module.__default.Factorial ($LS $ly@@1) $Heap@@0 |n#0@@1|))))))
(assert (forall (($ly@@2 T@U) ($Heap@@1 T@U) (|n#0@@2| Int)) (! (=> (and (and (= (type $ly@@2) LayerTypeType) (= (type $Heap@@1) (MapType1Type refType))) (and ($IsGoodHeap $Heap@@1) (<= 0 |n#0@@2|))) (and (=> (|_module.__default.Factorial#requires| $ly@@2 $Heap@@1 |n#0@@2|) true) (=> true (|_module.__default.Factorial#requires| $ly@@2 $Heap@@1 |n#0@@2|)))) :qid |Classics.7:10| :skolemid |339| :pattern ((|_module.__default.Factorial#requires| $ly@@2 $Heap@@1 |n#0@@2|)))))
(assert (=> (and (= 0 $ModuleContextHeight) (<= 0 $FunctionContextHeight)) (forall (($ly@@3 T@U) ($Heap@@2 T@U) (|n#0@@3| Int)) (! (=> (and (and (= (type $ly@@3) LayerTypeType) (= (type $Heap@@2) (MapType1Type refType))) (or (|_module.__default.Factorial#canCall| $Heap@@2 |n#0@@3|) (and (not (= 0 $FunctionContextHeight)) (and ($IsGoodHeap $Heap@@2) (<= 0 |n#0@@3|))))) (and (and (=> (= |n#0@@3| (LitInt 0)) true) (=> (not (= |n#0@@3| (LitInt 0))) (|_module.__default.Factorial#canCall| $Heap@@2 (- |n#0@@3| 1)))) (= (_module.__default.Factorial ($LS $ly@@3) $Heap@@2 |n#0@@3|) (ite (= |n#0@@3| (LitInt 0)) 1 (* |n#0@@3| (_module.__default.Factorial $ly@@3 $Heap@@2 (- |n#0@@3| 1))))))) :qid |Classics.7:10| :skolemid |340| :pattern ((_module.__default.Factorial ($LS $ly@@3) $Heap@@2 |n#0@@3|))))))
(assert (=> (and (= 0 $ModuleContextHeight) (<= 0 $FunctionContextHeight)) (forall (($ly@@4 T@U) ($Heap@@3 T@U) (|n#0@@4| Int)) (! (=> (and (and (= (type $ly@@4) LayerTypeType) (= (type $Heap@@3) (MapType1Type refType))) (or (|_module.__default.Factorial#canCall| $Heap@@3 (LitInt |n#0@@4|)) (and (not (= 0 $FunctionContextHeight)) (and ($IsGoodHeap $Heap@@3) (<= 0 |n#0@@4|))))) (and (and (=> (= (LitInt |n#0@@4|) (LitInt 0)) true) (=> (not (= (LitInt |n#0@@4|) (LitInt 0))) (|_module.__default.Factorial#canCall| $Heap@@3 (LitInt (- |n#0@@4| 1))))) (= (_module.__default.Factorial $ly@@4 $Heap@@3 (LitInt |n#0@@4|)) (ite (= (LitInt |n#0@@4|) (LitInt 0)) 1 (* |n#0@@4| (_module.__default.Factorial $ly@@4 $Heap@@3 (LitInt (- |n#0@@4| 1)))))))) :qid |Classics.7:10| :weight 3 :skolemid |341| :pattern ((_module.__default.Factorial $ly@@4 $Heap@@3 (LitInt |n#0@@4|)))))))
(assert (=> (< 0 $ModuleContextHeight) (forall (($ly@@5 T@U) ($Heap@@4 T@U) (|n#0@@5| Int)) (! (=> (and (and (= (type $ly@@5) LayerTypeType) (= (type $Heap@@4) (MapType1Type refType))) (or (|_module.__default.Factorial#canCall| $Heap@@4 |n#0@@5|) (and ($IsGoodHeap $Heap@@4) (<= 0 |n#0@@5|)))) (and (and (=> (= |n#0@@5| (LitInt 0)) true) (=> (not (= |n#0@@5| (LitInt 0))) (|_module.__default.Factorial#canCall| $Heap@@4 (- |n#0@@5| 1)))) (= (_module.__default.Factorial ($LS $ly@@5) $Heap@@4 |n#0@@5|) (ite (= |n#0@@5| (LitInt 0)) 1 (* |n#0@@5| (_module.__default.Factorial $ly@@5 $Heap@@4 (- |n#0@@5| 1))))))) :qid |Classics.7:10| :skolemid |342| :pattern ((_module.__default.Factorial ($LS $ly@@5) $Heap@@4 |n#0@@5|))))))
(assert (=> (< 0 $ModuleContextHeight) (forall (($ly@@6 T@U) ($Heap@@5 T@U) (|n#0@@6| Int)) (! (=> (and (and (= (type $ly@@6) LayerTypeType) (= (type $Heap@@5) (MapType1Type refType))) (or (|_module.__default.Factorial#canCall| $Heap@@5 (LitInt |n#0@@6|)) (and ($IsGoodHeap $Heap@@5) (<= 0 |n#0@@6|)))) (and (and (=> (= (LitInt |n#0@@6|) (LitInt 0)) true) (=> (not (= (LitInt |n#0@@6|) (LitInt 0))) (|_module.__default.Factorial#canCall| $Heap@@5 (LitInt (- |n#0@@6| 1))))) (= (_module.__default.Factorial $ly@@6 $Heap@@5 (LitInt |n#0@@6|)) (ite (= (LitInt |n#0@@6|) (LitInt 0)) 1 (* |n#0@@6| (_module.__default.Factorial $ly@@6 $Heap@@5 (LitInt (- |n#0@@6| 1)))))))) :qid |Classics.7:10| :weight 3 :skolemid |343| :pattern ((_module.__default.Factorial $ly@@6 $Heap@@5 (LitInt |n#0@@6|)))))))
(assert (and (and (and (and (and (and (and (forall ((arg0@@107 T@T) (arg1@@54 T@T)) (! (= (Ctor (MapType3Type arg0@@107 arg1@@54)) 20) :qid |ctor:MapType3Type|)) (forall ((arg0@@108 T@T) (arg1@@55 T@T)) (! (= (MapType3TypeInv0 (MapType3Type arg0@@108 arg1@@55)) arg0@@108) :qid |typeInv:MapType3TypeInv0| :pattern ((MapType3Type arg0@@108 arg1@@55))))) (forall ((arg0@@109 T@T) (arg1@@56 T@T)) (! (= (MapType3TypeInv1 (MapType3Type arg0@@109 arg1@@56)) arg1@@56) :qid |typeInv:MapType3TypeInv1| :pattern ((MapType3Type arg0@@109 arg1@@56))))) (forall ((arg0@@110 T@U) (arg1@@57 T@U) (arg2@@19 T@U)) (! (let ((aVar1@@3 (MapType3TypeInv1 (type arg0@@110)))) (= (type (MapType3Select arg0@@110 arg1@@57 arg2@@19)) aVar1@@3)) :qid |funType:MapType3Select| :pattern ((MapType3Select arg0@@110 arg1@@57 arg2@@19))))) (forall ((arg0@@111 T@U) (arg1@@58 T@U) (arg2@@20 T@U) (arg3@@3 T@U)) (! (let ((aVar1@@4 (type arg3@@3))) (let ((aVar0@@2 (type arg1@@58))) (= (type (MapType3Store arg0@@111 arg1@@58 arg2@@20 arg3@@3)) (MapType3Type aVar0@@2 aVar1@@4)))) :qid |funType:MapType3Store| :pattern ((MapType3Store arg0@@111 arg1@@58 arg2@@20 arg3@@3))))) (forall ((m@@22 T@U) (x0@@10 T@U) (x1@@7 T@U) (val@@10 T@U)) (! (let ((aVar1@@5 (MapType3TypeInv1 (type m@@22)))) (=> (= (type val@@10) aVar1@@5) (= (MapType3Select (MapType3Store m@@22 x0@@10 x1@@7 val@@10) x0@@10 x1@@7) val@@10))) :qid |mapAx0:MapType3Select| :weight 0))) (and (and (forall ((val@@11 T@U) (m@@23 T@U) (x0@@11 T@U) (x1@@8 T@U) (y0@@7 T@U) (y1@@5 T@U)) (! (or (= x0@@11 y0@@7) (= (MapType3Select (MapType3Store m@@23 x0@@11 x1@@8 val@@11) y0@@7 y1@@5) (MapType3Select m@@23 y0@@7 y1@@5))) :qid |mapAx1:MapType3Select:0| :weight 0)) (forall ((val@@12 T@U) (m@@24 T@U) (x0@@12 T@U) (x1@@9 T@U) (y0@@8 T@U) (y1@@6 T@U)) (! (or (= x1@@9 y1@@6) (= (MapType3Select (MapType3Store m@@24 x0@@12 x1@@9 val@@12) y0@@8 y1@@6) (MapType3Select m@@24 y0@@8 y1@@6))) :qid |mapAx1:MapType3Select:1| :weight 0))) (forall ((val@@13 T@U) (m@@25 T@U) (x0@@13 T@U) (x1@@10 T@U) (y0@@9 T@U) (y1@@7 T@U)) (! (or true (= (MapType3Select (MapType3Store m@@25 x0@@13 x1@@10 val@@13) y0@@9 y1@@7) (MapType3Select m@@25 y0@@9 y1@@7))) :qid |mapAx2:MapType3Select| :weight 0)))) (forall ((arg0@@112 T@U) (arg1@@59 T@U) (arg2@@21 T@U)) (! (= (type (|lambda#0| arg0@@112 arg1@@59 arg2@@21)) (MapType3Type refType boolType)) :qid |funType:lambda#0| :pattern ((|lambda#0| arg0@@112 arg1@@59 arg2@@21))))))
(assert (forall (($o@@8 T@U) ($f@@0 T@U) (alloc@@0 T@U) (null@@0 T@U) ($Heap@@6 T@U)) (! (let ((alpha@@7 (FieldTypeInv0 (type $f@@0)))) (=> (and (and (and (and (= (type $o@@8) refType) (= (type $f@@0) (FieldType alpha@@7))) (= (type alloc@@0) (FieldType boolType))) (= (type null@@0) refType)) (= (type $Heap@@6) (MapType1Type refType))) (= (U_2_bool (MapType3Select (|lambda#0| alloc@@0 null@@0 $Heap@@6) $o@@8 $f@@0)) (=> (and (not (= $o@@8 null@@0)) (U_2_bool (MapType1Select $Heap@@6 $o@@8 alloc@@0))) false)))) :qid |Classics.7:10| :skolemid |454| :pattern ((MapType3Select (|lambda#0| alloc@@0 null@@0 $Heap@@6) $o@@8 $f@@0)))))
(assert (forall ((arg0@@113 T@U) (arg1@@60 T@U) (arg2@@22 T@U)) (! (= (type (|lambda#1| arg0@@113 arg1@@60 arg2@@22)) (MapType3Type refType boolType)) :qid |funType:lambda#1| :pattern ((|lambda#1| arg0@@113 arg1@@60 arg2@@22)))))
(assert (forall (($o@@9 T@U) ($f@@1 T@U) (alloc@@1 T@U) (null@@1 T@U) ($Heap@@7 T@U)) (! (let ((alpha@@8 (FieldTypeInv0 (type $f@@1)))) (=> (and (and (and (and (= (type $o@@9) refType) (= (type $f@@1) (FieldType alpha@@8))) (= (type alloc@@1) (FieldType boolType))) (= (type null@@1) refType)) (= (type $Heap@@7) (MapType1Type refType))) (= (U_2_bool (MapType3Select (|lambda#1| alloc@@1 null@@1 $Heap@@7) $o@@9 $f@@1)) (=> (and (not (= $o@@9 null@@1)) (U_2_bool (MapType1Select $Heap@@7 $o@@9 alloc@@1))) false)))) :qid |Classics.7:10| :skolemid |455| :pattern ((MapType3Select (|lambda#1| alloc@@1 null@@1 $Heap@@7) $o@@9 $f@@1)))))
(assert (forall ((arg0@@114 T@U) (arg1@@61 T@U) (arg2@@23 T@U)) (! (= (type (|lambda#2| arg0@@114 arg1@@61 arg2@@23)) (MapType3Type refType boolType)) :qid |funType:lambda#2| :pattern ((|lambda#2| arg0@@114 arg1@@61 arg2@@23)))))
(assert (forall (($o@@10 T@U) ($f@@2 T@U) (alloc@@2 T@U) (null@@2 T@U) ($Heap@@8 T@U)) (! (let ((alpha@@9 (FieldTypeInv0 (type $f@@2)))) (=> (and (and (and (and (= (type $o@@10) refType) (= (type $f@@2) (FieldType alpha@@9))) (= (type alloc@@2) (FieldType boolType))) (= (type null@@2) refType)) (= (type $Heap@@8) (MapType1Type refType))) (= (U_2_bool (MapType3Select (|lambda#2| alloc@@2 null@@2 $Heap@@8) $o@@10 $f@@2)) (=> (and (not (= $o@@10 null@@2)) (U_2_bool (MapType1Select $Heap@@8 $o@@10 alloc@@2))) false)))) :qid |Classics.12:8| :skolemid |456| :pattern ((MapType3Select (|lambda#2| alloc@@2 null@@2 $Heap@@8) $o@@10 $f@@2)))))
(assert (forall ((arg0@@115 T@U) (arg1@@62 T@U) (arg2@@24 T@U)) (! (= (type (|lambda#3| arg0@@115 arg1@@62 arg2@@24)) (MapType3Type refType boolType)) :qid |funType:lambda#3| :pattern ((|lambda#3| arg0@@115 arg1@@62 arg2@@24)))))
(assert (forall (($o@@11 T@U) ($f@@3 T@U) (alloc@@3 T@U) (null@@3 T@U) ($Heap@@9 T@U)) (! (let ((alpha@@10 (FieldTypeInv0 (type $f@@3)))) (=> (and (and (and (and (= (type $o@@11) refType) (= (type $f@@3) (FieldType alpha@@10))) (= (type alloc@@3) (FieldType boolType))) (= (type null@@3) refType)) (= (type $Heap@@9) (MapType1Type refType))) (= (U_2_bool (MapType3Select (|lambda#3| alloc@@3 null@@3 $Heap@@9) $o@@11 $f@@3)) (=> (and (not (= $o@@11 null@@3)) (U_2_bool (MapType1Select $Heap@@9 $o@@11 alloc@@3))) false)))) :qid |Classics.12:8| :skolemid |457| :pattern ((MapType3Select (|lambda#3| alloc@@3 null@@3 $Heap@@9) $o@@11 $f@@3)))))
(assert (forall ((arg0@@116 T@U) (arg1@@63 T@U) (arg2@@25 T@U) (arg3@@4 T@U)) (! (= (type (|lambda#4| arg0@@116 arg1@@63 arg2@@25 arg3@@4)) (MapType3Type refType boolType)) :qid |funType:lambda#4| :pattern ((|lambda#4| arg0@@116 arg1@@63 arg2@@25 arg3@@4)))))
(assert (forall (($o@@12 T@U) ($f@@4 T@U) (|A#0| T@U) (null@@4 T@U) ($Heap@@10 T@U) (alloc@@4 T@U)) (! (let ((alpha@@11 (FieldTypeInv0 (type $f@@4)))) (=> (and (and (and (and (and (= (type $o@@12) refType) (= (type $f@@4) (FieldType alpha@@11))) (= (type |A#0|) refType)) (= (type null@@4) refType)) (= (type $Heap@@10) (MapType1Type refType))) (= (type alloc@@4) (FieldType boolType))) (= (U_2_bool (MapType3Select (|lambda#4| |A#0| null@@4 $Heap@@10 alloc@@4) $o@@12 $f@@4)) (=> (and (not (= $o@@12 null@@4)) (U_2_bool (MapType1Select $Heap@@10 $o@@12 alloc@@4))) (= $o@@12 |A#0|))))) :qid |Classics.47:8| :skolemid |458| :pattern ((MapType3Select (|lambda#4| |A#0| null@@4 $Heap@@10 alloc@@4) $o@@12 $f@@4)))))
(assert (forall ((arg0@@117 T@U) (arg1@@64 T@U) (arg2@@26 T@U) (arg3@@5 T@U)) (! (= (type (|lambda#5| arg0@@117 arg1@@64 arg2@@26 arg3@@5)) (MapType3Type refType boolType)) :qid |funType:lambda#5| :pattern ((|lambda#5| arg0@@117 arg1@@64 arg2@@26 arg3@@5)))))
(assert (forall (($o@@13 T@U) ($f@@5 T@U) (|A#0@@0| T@U) (null@@5 T@U) ($Heap@@11 T@U) (alloc@@5 T@U)) (! (let ((alpha@@12 (FieldTypeInv0 (type $f@@5)))) (=> (and (and (and (and (and (= (type $o@@13) refType) (= (type $f@@5) (FieldType alpha@@12))) (= (type |A#0@@0|) refType)) (= (type null@@5) refType)) (= (type $Heap@@11) (MapType1Type refType))) (= (type alloc@@5) (FieldType boolType))) (= (U_2_bool (MapType3Select (|lambda#5| |A#0@@0| null@@5 $Heap@@11 alloc@@5) $o@@13 $f@@5)) (=> (and (not (= $o@@13 null@@5)) (U_2_bool (MapType1Select $Heap@@11 $o@@13 alloc@@5))) (= $o@@13 |A#0@@0|))))) :qid |Classics.47:8| :skolemid |459| :pattern ((MapType3Select (|lambda#5| |A#0@@0| null@@5 $Heap@@11 alloc@@5) $o@@13 $f@@5)))))
(assert (and (and (and (= (type $LZ) LayerTypeType) (= (type $Heap@@12) (MapType1Type refType))) (= (type $_Frame@0) (MapType3Type refType boolType))) (= (type $_Frame@0@@0) (MapType3Type refType boolType))))
(declare-fun $_Frame@0@@1 () T@U)
(declare-fun $Heap@0 () T@U)
(declare-fun %lbl%+13222 () Bool)
(declare-fun |u#0@0| () Int)
(declare-fun %lbl%@38757 () Bool)
(declare-fun |n#0@@8| () Int)
(declare-fun %lbl%+38617 () Bool)
(declare-fun |u#0| () Int)
(assert (and (= (type $_Frame@0@@1) (MapType3Type refType boolType)) (= (type $Heap@0) (MapType1Type refType))))
(set-option :TIMEOUT 0)
(declare-fun $_Frame@0@@2 () T@U)
(declare-fun %lbl%+14020 () Bool)
(declare-fun |r#0@1| () Int)
(declare-fun |n#0@@9| () Int)
(declare-fun %lbl%@40047 () Bool)
(declare-fun %lbl%+14018 () Bool)
(declare-fun %lbl%+14016 () Bool)
(declare-fun %lbl%+14014 () Bool)
(declare-fun |$w$loop#0@0| () Bool)
(declare-fun %lbl%+38846 () Bool)
(declare-fun %lbl%@40111 () Bool)
(declare-fun |u#0@4| () Int)
(declare-fun %lbl%+14031 () Bool)
(declare-fun |u#0@1| () Int)
(declare-fun %lbl%+14060 () Bool)
(declare-fun |s#0_0@2| () Int)
(declare-fun %lbl%@39965 () Bool)
(declare-fun %lbl%+14058 () Bool)
(declare-fun %lbl%+14056 () Bool)
(declare-fun %lbl%+14054 () Bool)
(declare-fun |$w$loop#0_0@1| () Bool)
(declare-fun %lbl%+14073 () Bool)
(declare-fun |$decr$loop#0_00@2| () Int)
(declare-fun %lbl%@39804 () Bool)
(declare-fun |u#0@2| () Int)
(declare-fun |u#0@3| () Int)
(declare-fun |s#0_0@3| () Int)
(declare-fun %lbl%@39843 () Bool)
(declare-fun %lbl%@39857 () Bool)
(declare-fun %lbl%@39880 () Bool)
(declare-fun %lbl%@39890 () Bool)
(declare-fun %lbl%@39901 () Bool)
(declare-fun %lbl%+14071 () Bool)
(declare-fun |r#0@2| () Int)
(declare-fun %lbl%@39710 () Bool)
(declare-fun |$decr$loop#00@1| () Int)
(declare-fun %lbl%@39725 () Bool)
(declare-fun %lbl%@39749 () Bool)
(declare-fun %lbl%@39759 () Bool)
(declare-fun %lbl%@39767 () Bool)
(declare-fun %lbl%+14062 () Bool)
(declare-fun %lbl%+14047 () Bool)
(declare-fun %lbl%+14077 () Bool)
(declare-fun %lbl%+14041 () Bool)
(declare-fun |$decr_init$loop#0_00@1| () Int)
(declare-fun %lbl%+14033 () Bool)
(declare-fun |s#0_0@1| () Int)
(declare-fun %lbl%@39390 () Bool)
(declare-fun %lbl%@39400 () Bool)
(declare-fun %lbl%@39411 () Bool)
(declare-fun %lbl%+14022 () Bool)
(declare-fun %lbl%+14007 () Bool)
(declare-fun %lbl%+14081 () Bool)
(declare-fun %lbl%+14001 () Bool)
(declare-fun |$decr_init$loop#00@0| () Int)
(declare-fun %lbl%+13999 () Bool)
(declare-fun %lbl%@38989 () Bool)
(declare-fun |u#0@0@@0| () Int)
(declare-fun |r#0@0| () Int)
(declare-fun %lbl%@39044 () Bool)
(declare-fun %lbl%@39054 () Bool)
(declare-fun %lbl%@39062 () Bool)
(declare-fun %lbl%+38866 () Bool)
(declare-fun |u#0@@0| () Int)
(assert (= (type $_Frame@0@@2) (MapType3Type refType boolType)))
(push 1)
(set-info :boogie-vc-id Impl$$_module.__default.AdditiveFactorial)
(assert (not (let ((anon4_correct (=> (! (and %lbl%+14020 true) :lblpos +14020) (=> (=> (<= (LitInt 0) |r#0@1|) true) (=> (and (<= (LitInt 0) |r#0@1|) (<= |r#0@1| |n#0@@9|)) (! (or %lbl%@40047 ($Is (int_2_U |r#0@1|) TNat)) :lblneg @40047)))))) (let ((anon18_Else_correct (=> (! (and %lbl%+14018 true) :lblpos +14018) (=> (< |r#0@1| (LitInt 0)) anon4_correct)))) (let ((anon18_Then_correct (=> (! (and %lbl%+14016 true) :lblpos +14016) (=> (<= (LitInt 0) |r#0@1|) anon4_correct)))) (let ((anon17_Then_correct (=> (! (and %lbl%+14014 true) :lblpos +14014) (=> (not |$w$loop#0@0|) (and anon18_Then_correct anon18_Else_correct))))) (let ((GeneratedUnifiedExit_correct (=> (! (and %lbl%+38846 true) :lblpos +38846) (! (or %lbl%@40111 (= |u#0@4| (_module.__default.Factorial ($LS ($LS $LZ)) $Heap@@12 |n#0@@9|))) :lblneg @40111)))) (let ((anon19_Then_correct (=> (! (and %lbl%+14031 true) :lblpos +14031) (=> (and (<= |n#0@@9| |r#0@1|) (= |u#0@4| |u#0@1|)) GeneratedUnifiedExit_correct)))) (let ((anon11_correct (=> (! (and %lbl%+14060 true) :lblpos +14060) (=> (=> (<= (LitInt 1) |s#0_0@2|) true) (=> (and (<= (LitInt 1) |s#0_0@2|) (<= |s#0_0@2| (+ |r#0@1| 1))) (! (or %lbl%@39965 ($Is (int_2_U |r#0@1|) TNat)) :lblneg @39965)))))) (let ((anon22_Else_correct (=> (! (and %lbl%+14058 true) :lblpos +14058) (=> (< |s#0_0@2| (LitInt 1)) anon11_correct)))) (let ((anon22_Then_correct (=> (! (and %lbl%+14056 true) :lblpos +14056) (=> (<= (LitInt 1) |s#0_0@2|) anon11_correct)))) (let ((anon21_Then_correct (=> (! (and %lbl%+14054 true) :lblpos +14054) (=> (not |$w$loop#0_0@1|) (and anon22_Then_correct anon22_Else_correct))))) (let ((anon23_Else_correct (=> (! (and %lbl%+14073 true) :lblpos +14073) (=> (and (<= |s#0_0@2| |r#0@1|) (= |$decr$loop#0_00@2| (- |r#0@1| |s#0_0@2|))) (and (! (or %lbl%@39804 ($Is (int_2_U (+ |u#0@2| |u#0@1|)) TNat)) :lblneg @39804) (=> ($Is (int_2_U (+ |u#0@2| |u#0@1|)) TNat) (=> (and (= |u#0@3| (+ |u#0@2| |u#0@1|)) (= |s#0_0@3| (+ |s#0_0@2| 1))) (and (! (or %lbl%@39843 (or (<= 0 |$decr$loop#0_00@2|) (= (- |r#0@1| |s#0_0@3|) |$decr$loop#0_00@2|))) :lblneg @39843) (=> (or (<= 0 |$decr$loop#0_00@2|) (= (- |r#0@1| |s#0_0@3|) |$decr$loop#0_00@2|)) (and (! (or %lbl%@39857 (< (- |r#0@1| |s#0_0@3|) |$decr$loop#0_00@2|)) :lblneg @39857) (=> (< (- |r#0@1| |s#0_0@3|) |$decr$loop#0_00@2|) (=> (and (=> (<= (LitInt 1) |s#0_0@3|) true) (|_module.__default.Factorial#canCall| $Heap@@12 |r#0@1|)) (and (! (or %lbl%@39880 (=> |$w$loop#0_0@1| (<= (LitInt 1) |s#0_0@3|))) :lblneg @39880) (=> (=> |$w$loop#0_0@1| (<= (LitInt 1) |s#0_0@3|)) (and (! (or %lbl%@39890 (=> |$w$loop#0_0@1| (<= |s#0_0@3| (+ |r#0@1| 1)))) :lblneg @39890) (=> (=> |$w$loop#0_0@1| (<= |s#0_0@3| (+ |r#0@1| 1))) (! (or %lbl%@39901 (=> |$w$loop#0_0@1| (= |u#0@3| (* |s#0_0@3| (_module.__default.Factorial ($LS ($LS $LZ)) $Heap@@12 |r#0@1|))))) :lblneg @39901))))))))))))))))) (let ((anon23_Then_correct (=> (! (and %lbl%+14071 true) :lblpos +14071) (=> (and (< |r#0@1| |s#0_0@2|) (= |r#0@2| (+ |r#0@1| 1))) (and (! (or %lbl%@39710 (or (<= 0 |$decr$loop#00@1|) (= (- |n#0@@9| |r#0@2|) |$decr$loop#00@1|))) :lblneg @39710) (=> (or (<= 0 |$decr$loop#00@1|) (= (- |n#0@@9| |r#0@2|) |$decr$loop#00@1|)) (and (! (or %lbl%@39725 (< (- |n#0@@9| |r#0@2|) |$decr$loop#00@1|)) :lblneg @39725) (=> (< (- |n#0@@9| |r#0@2|) |$decr$loop#00@1|) (=> (and (=> (<= (LitInt 0) |r#0@2|) true) (|_module.__default.Factorial#canCall| $Heap@@12 |r#0@2|)) (and (! (or %lbl%@39749 (=> |$w$loop#0@0| (<= (LitInt 0) |r#0@2|))) :lblneg @39749) (=> (=> |$w$loop#0@0| (<= (LitInt 0) |r#0@2|)) (and (! (or %lbl%@39759 (=> |$w$loop#0@0| (<= |r#0@2| |n#0@@9|))) :lblneg @39759) (=> (=> |$w$loop#0@0| (<= |r#0@2| |n#0@@9|)) (! (or %lbl%@39767 (=> |$w$loop#0@0| (= |u#0@2| (_module.__default.Factorial ($LS ($LS $LZ)) $Heap@@12 |r#0@2|)))) :lblneg @39767)))))))))))))) (let ((anon21_Else_correct (=> (! (and %lbl%+14062 true) :lblpos +14062) (=> |$w$loop#0_0@1| (and anon23_Then_correct anon23_Else_correct))))) (let ((anon20_LoopBody_correct (=> (! (and %lbl%+14047 true) :lblpos +14047) (and anon21_Then_correct anon21_Else_correct)))) (let ((anon20_LoopDone_correct (=> (! (and %lbl%+14077 true) :lblpos +14077) true))) (let ((anon20_LoopHead_correct (=> (! (and %lbl%+14041 true) :lblpos +14041) (=> (<= 0 |u#0@2|) (=> (and (and (and (and (and (and (and (and (<= 1 |u#0@2|) (not false)) (<= 0 |r#0@1|)) |$w$loop#0@0|) (<= 1 |u#0@1|)) (<= 1 |s#0_0@2|)) (<= (- 0 1) |$decr_init$loop#0_00@1|)) (and (=> |$w$loop#0_0@1| (=> (<= (LitInt 1) |s#0_0@2|) true)) (=> |$w$loop#0_0@1| (<= (LitInt 1) |s#0_0@2|)))) (and (and (and (=> |$w$loop#0_0@1| (<= |s#0_0@2| (+ |r#0@1| 1))) (=> |$w$loop#0_0@1| (|_module.__default.Factorial#canCall| $Heap@@12 |r#0@1|))) (and (=> |$w$loop#0_0@1| (= |u#0@2| (* |s#0_0@2| (_module.__default.Factorial ($LS ($LS $LZ)) $Heap@@12 |r#0@1|)))) (forall (($o@@17 T@U) ($f@@9 T@U)) (! (let ((alpha@@16 (FieldTypeInv0 (type $f@@9)))) (=> (and (and (= (type $o@@17) refType) (= (type $f@@9) (FieldType alpha@@16))) (and (not (= $o@@17 null)) (U_2_bool (MapType1Select $Heap@@12 $o@@17 alloc)))) (= (MapType1Select $Heap@@12 $o@@17 $f@@9) (MapType1Select $Heap@@12 $o@@17 $f@@9)))) :qid |Classics.23:5| :skolemid |351| :pattern ((MapType1Select $Heap@@12 $o@@17 $f@@9)))))) (and (and ($HeapSucc $Heap@@12 $Heap@@12) (forall (($o@@18 T@U) ($f@@10 T@U)) (! (let ((alpha@@17 (FieldTypeInv0 (type $f@@10)))) (=> (and (and (= (type $o@@18) refType) (= (type $f@@10) (FieldType alpha@@17))) (and (not (= $o@@18 null)) (U_2_bool (MapType1Select $Heap@@12 $o@@18 alloc)))) (or (= (MapType1Select $Heap@@12 $o@@18 $f@@10) (MapType1Select $Heap@@12 $o@@18 $f@@10)) (U_2_bool (MapType3Select $_Frame@0@@2 $o@@18 $f@@10))))) :qid |Classics.23:5| :skolemid |352| :pattern ((MapType1Select $Heap@@12 $o@@18 $f@@10))))) (and (<= (- |r#0@1| |s#0_0@2|) |$decr_init$loop#0_00@1|) (=> (= (- |r#0@1| |s#0_0@2|) |$decr_init$loop#0_00@1|) true))))) (and anon20_LoopDone_correct anon20_LoopBody_correct)))))) (let ((anon19_Else_correct (=> (! (and %lbl%+14033 true) :lblpos +14033) (=> (and (and (< |r#0@1| |n#0@@9|) (= |$decr$loop#00@1| (- |n#0@@9| |r#0@1|))) (and (= |s#0_0@1| (LitInt 1)) (= |$decr_init$loop#0_00@1| (- |r#0@1| |s#0_0@1|)))) (and (! (or %lbl%@39390 (=> |$w$loop#0_0@1| (<= (LitInt 1) |s#0_0@1|))) :lblneg @39390) (=> (=> |$w$loop#0_0@1| (<= (LitInt 1) |s#0_0@1|)) (and (! (or %lbl%@39400 (=> |$w$loop#0_0@1| (<= |s#0_0@1| (+ |r#0@1| 1)))) :lblneg @39400) (=> (=> |$w$loop#0_0@1| (<= |s#0_0@1| (+ |r#0@1| 1))) (and (! (or %lbl%@39411 (=> |$w$loop#0_0@1| (= |u#0@1| (* |s#0_0@1| (_module.__default.Factorial ($LS ($LS $LZ)) $Heap@@12 |r#0@1|))))) :lblneg @39411) (=> (=> |$w$loop#0_0@1| (= |u#0@1| (* |s#0_0@1| (_module.__default.Factorial ($LS ($LS $LZ)) $Heap@@12 |r#0@1|)))) anon20_LoopHead_correct)))))))))) (let ((anon17_Else_correct (=> (! (and %lbl%+14022 true) :lblpos +14022) (=> |$w$loop#0@0| (and anon19_Then_correct anon19_Else_correct))))) (let ((anon16_LoopBody_correct (=> (! (and %lbl%+14007 true) :lblpos +14007) (and anon17_Then_correct anon17_Else_correct)))) (let ((anon16_LoopDone_correct (=> (! (and %lbl%+14081 true) :lblpos +14081) true))) (let ((anon16_LoopHead_correct (=> (! (and %lbl%+14001 true) :lblpos +14001) (=> (<= 0 |u#0@1|) (=> (and (and (and (and (<= 1 |u#0@1|) (not false)) (<= 0 |r#0@1|)) (and (=> |$w$loop#0@0| (=> (<= (LitInt 0) |r#0@1|) true)) (=> |$w$loop#0@0| (<= (LitInt 0) |r#0@1|)))) (and (and (and (=> |$w$loop#0@0| (<= |r#0@1| |n#0@@9|)) (=> |$w$loop#0@0| (|_module.__default.Factorial#canCall| $Heap@@12 |r#0@1|))) (and (=> |$w$loop#0@0| (= |u#0@1| (_module.__default.Factorial ($LS ($LS $LZ)) $Heap@@12 |r#0@1|))) (forall (($o@@19 T@U) ($f@@11 T@U)) (! (let ((alpha@@18 (FieldTypeInv0 (type $f@@11)))) (=> (and (and (= (type $o@@19) refType) (= (type $f@@11) (FieldType alpha@@18))) (and (not (= $o@@19 null)) (U_2_bool (MapType1Select $Heap@@12 $o@@19 alloc)))) (= (MapType1Select $Heap@@12 $o@@19 $f@@11) (MapType1Select $Heap@@12 $o@@19 $f@@11)))) :qid |Classics.17:3| :skolemid |349| :pattern ((MapType1Select $Heap@@12 $o@@19 $f@@11)))))) (and (and ($HeapSucc $Heap@@12 $Heap@@12) (forall (($o@@20 T@U) ($f@@12 T@U)) (! (let ((alpha@@19 (FieldTypeInv0 (type $f@@12)))) (=> (and (and (= (type $o@@20) refType) (= (type $f@@12) (FieldType alpha@@19))) (and (not (= $o@@20 null)) (U_2_bool (MapType1Select $Heap@@12 $o@@20 alloc)))) (or (= (MapType1Select $Heap@@12 $o@@20 $f@@12) (MapType1Select $Heap@@12 $o@@20 $f@@12)) (U_2_bool (MapType3Select $_Frame@0@@2 $o@@20 $f@@12))))) :qid |Classics.17:3| :skolemid |350| :pattern ((MapType1Select $Heap@@12 $o@@20 $f@@12))))) (and (<= (- |n#0@@9| |r#0@1|) |$decr_init$loop#00@0|) (=> (= (- |n#0@@9| |r#0@1|) |$decr_init$loop#00@0|) true))))) (and anon16_LoopDone_correct anon16_LoopBody_correct)))))) (let ((anon0_correct@@1 (=> (! (and %lbl%+13999 true) :lblpos +13999) (=> (= $_Frame@0@@2 (|lambda#3| alloc null $Heap@@12)) (and (! (or %lbl%@38989 ($Is (int_2_U (LitInt 1)) TNat)) :lblneg @38989) (=> ($Is (int_2_U (LitInt 1)) TNat) (=> (= |u#0@0@@0| (LitInt 1)) (=> (and (= |r#0@0| (LitInt 0)) (= |$decr_init$loop#00@0| (- |n#0@@9| |r#0@0|))) (and (! (or %lbl%@39044 (=> |$w$loop#0@0| (<= (LitInt 0) |r#0@0|))) :lblneg @39044) (=> (=> |$w$loop#0@0| (<= (LitInt 0) |r#0@0|)) (and (! (or %lbl%@39054 (=> |$w$loop#0@0| (<= |r#0@0| |n#0@@9|))) :lblneg @39054) (=> (=> |$w$loop#0@0| (<= |r#0@0| |n#0@@9|)) (and (! (or %lbl%@39062 (=> |$w$loop#0@0| (= |u#0@0@@0| (_module.__default.Factorial ($LS ($LS $LZ)) $Heap@@12 |r#0@0|)))) :lblneg @39062) (=> (=> |$w$loop#0@0| (= |u#0@0@@0| (_module.__default.Factorial ($LS ($LS $LZ)) $Heap@@12 |r#0@0|))) anon16_LoopHead_correct)))))))))))))) (let ((PreconditionGeneratedEntry_correct@@1 (=> (! (and %lbl%+38866 true) :lblpos +38866) (=> (and ($IsGoodHeap $Heap@@12) ($IsHeapAnchor $Heap@@12)) (=> (and (and (<= 0 |n#0@@9|) (<= 0 |u#0@@0|)) (and (= 0 $ModuleContextHeight) (= 1 $FunctionContextHeight))) anon0_correct@@1))))) PreconditionGeneratedEntry_correct@@1)))))))))))))))))))))))))
(check-sat)
(pop 1)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.0)
(set-option :AUTO_CONFIG false)
(set-option :pp.bv_literals false)
(set-option :MODEL.V2 true)
(set-option :smt.PHASE_SELECTION 0)
(set-option :smt.RESTART_STRATEGY 0)
(set-option :smt.RESTART_FACTOR |1.5|)
(set-option :smt.ARITH.RANDOM_INITIAL_VALUE true)
(set-option :smt.CASE_SPLIT 3)
(set-option :smt.DELAY_UNITS true)
(set-option :NNF.SK_HACK true)
(set-option :smt.MBQI false)
(set-option :smt.QI.EAGER_THRESHOLD 100)
(set-option :TYPE_CHECK true)
(set-option :smt.BV.REFLECT true)
(set-option :TIMEOUT 0)
(set-info :category "industrial")
(declare-sort |T@U| 0)
(declare-sort |T@T| 0)
(declare-fun real_pow (Real Real) Real)
(declare-fun UOrdering2 (|T@U| |T@U|) Bool)
(declare-fun UOrdering3 (|T@T| |T@U| |T@U|) Bool)
(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-fun Ctor (T@T) Int)
(declare-fun intType () T@T)
(declare-fun realType () T@T)
(declare-fun boolType () T@T)
(declare-fun int_2_U (Int) T@U)
(declare-fun U_2_int (T@U) Int)
(declare-fun type (T@U) T@T)
(declare-fun real_2_U (Real) T@U)
(declare-fun U_2_real (T@U) Real)
(declare-fun bool_2_U (Bool) T@U)
(declare-fun U_2_bool (T@U) Bool)
(declare-fun TyType () T@T)
(declare-fun TBool () T@U)
(declare-fun TChar () T@U)
(declare-fun TInt () T@U)
(declare-fun TNat () T@U)
(declare-fun TReal () T@U)
(declare-fun TyTagType () T@T)
(declare-fun TagBool () T@U)
(declare-fun TagChar () T@U)
(declare-fun TagInt () T@U)
(declare-fun TagNat () T@U)
(declare-fun TagReal () T@U)
(declare-fun TagSet () T@U)
(declare-fun TagISet () T@U)
(declare-fun TagMultiSet () T@U)
(declare-fun TagSeq () T@U)
(declare-fun TagMap () T@U)
(declare-fun TagIMap () T@U)
(declare-fun TagClass () T@U)
(declare-fun ClassNameType () T@T)
(declare-fun NoTraitAtAll () T@U)
(declare-fun class._System.int () T@U)
(declare-fun class._System.bool () T@U)
(declare-fun class._System.set () T@U)
(declare-fun class._System.seq () T@U)
(declare-fun class._System.multiset () T@U)
(declare-fun FieldType (T@T) T@T)
(declare-fun FieldTypeInv0 (T@T) T@T)
(declare-fun alloc () T@U)
(declare-fun class._System.object () T@U)
(declare-fun Tagclass._System.object () T@U)
(declare-fun class._System.array () T@U)
(declare-fun Tagclass._System.array () T@U)
(declare-fun Tagclass._System.___hFunc0 () T@U)
(declare-fun Tagclass._System.___hFunc1 () T@U)
(declare-fun class._module.__default () T@U)
(declare-fun Tagclass._module.__default () T@U)
(declare-fun $$Language$Dafny () Bool)
(declare-fun TSet (T@U) T@U)
(declare-fun Inv0_TSet (T@U) T@U)
(declare-fun TISet (T@U) T@U)
(declare-fun Inv0_TISet (T@U) T@U)
(declare-fun TSeq (T@U) T@U)
(declare-fun Inv0_TSeq (T@U) T@U)
(declare-fun TMultiSet (T@U) T@U)
(declare-fun Inv0_TMultiSet (T@U) T@U)
(declare-fun TMap (T@U T@U) T@U)
(declare-fun Inv0_TMap (T@U) T@U)
(declare-fun Inv1_TMap (T@U) T@U)
(declare-fun TIMap (T@U T@U) T@U)
(declare-fun Inv0_TIMap (T@U) T@U)
(declare-fun Inv1_TIMap (T@U) T@U)
(declare-fun Tag (T@U) T@U)
(declare-fun LitInt (Int) Int)
(declare-fun BoxType () T@T)
(declare-fun $Box (T@U) T@U)
(declare-fun Lit (T@U) T@U)
(declare-fun LitReal (Real) Real)
(declare-fun charType () T@T)
(declare-fun |char#FromInt| (Int) T@U)
(declare-fun |char#ToInt| (T@U) Int)
(declare-fun $Unbox (T@T T@U) T@U)
(declare-fun $IsBox (T@U T@U) Bool)
(declare-fun $Is (T@U T@U) Bool)
(declare-fun MapType0Type (T@T T@T) T@T)
(declare-fun MapType0TypeInv0 (T@T) T@T)
(declare-fun MapType0TypeInv1 (T@T) T@T)
(declare-fun MapType0Select (T@U T@U) T@U)
(declare-fun MapType0Store (T@U T@U T@U) T@U)
(declare-fun SeqType (T@T) T@T)
(declare-fun SeqTypeInv0 (T@T) T@T)
(declare-fun MapType (T@T T@T) T@T)
(declare-fun MapTypeInv0 (T@T) T@T)
(declare-fun MapTypeInv1 (T@T) T@T)
(declare-fun IMapType (T@T T@T) T@T)
(declare-fun IMapTypeInv0 (T@T) T@T)
(declare-fun IMapTypeInv1 (T@T) T@T)
(declare-fun MapType1Type (T@T) T@T)
(declare-fun MapType1TypeInv0 (T@T) T@T)
(declare-fun MapType1Select (T@U T@U T@U) T@U)
(declare-fun MapType1Store (T@U T@U T@U T@U) T@U)
(declare-fun refType () T@T)
(declare-fun $IsAllocBox (T@U T@U T@U) Bool)
(declare-fun $IsAlloc (T@U T@U T@U) Bool)
(declare-fun $IsGoodMultiSet (T@U) Bool)
(declare-fun |Seq#Index| (T@U Int) T@U)
(declare-fun |Seq#Length| (T@U) Int)
(declare-fun |Map#Elements| (T@U) T@U)
(declare-fun |Map#Domain| (T@U) T@U)
(declare-fun |IMap#Elements| (T@U) T@U)
(declare-fun |IMap#Domain| (T@U) T@U)
(declare-fun TypeTuple (T@U T@U) T@U)
(declare-fun TypeTupleCar (T@U) T@U)
(declare-fun TypeTupleCdr (T@U) T@U)
(declare-fun SetRef_to_SetBox (T@U) T@U)
(declare-fun Tclass._System.object () T@U)
(declare-fun DatatypeTypeType () T@T)
(declare-fun BoxRank (T@U) Int)
(declare-fun DtRank (T@U) Int)
(declare-fun LayerTypeType () T@T)
(declare-fun AtLayer (T@U T@U) T@U)
(declare-fun $LS (T@U) T@U)
(declare-fun IndexField (Int) T@U)
(declare-fun FDim (T@U) Int)
(declare-fun IndexField_Inverse (T@U) Int)
(declare-fun MultiIndexField (T@U Int) T@U)
(declare-fun MultiIndexField_Inverse0 (T@U) T@U)
(declare-fun MultiIndexField_Inverse1 (T@U) Int)
(declare-fun NameFamilyType () T@T)
(declare-fun FieldOfDecl (T@T T@U T@U) T@U)
(declare-fun DeclType (T@U) T@U)
(declare-fun DeclName (T@U) T@U)
(declare-fun $HeapSucc (T@U T@U) Bool)
(declare-fun $IsGhostField (T@U) Bool)
(declare-fun _System.array.Length (T@U) Int)
(declare-fun q@Int (Real) Int)
(declare-fun q@Real (Int) Real)
(declare-fun $IsGoodHeap (T@U) Bool)
(declare-fun $HeapSuccGhost (T@U T@U) Bool)
(declare-fun |Set#Card| (T@U) Int)
(declare-fun |Set#Empty| (T@T) T@U)
(declare-fun |Set#Singleton| (T@U) T@U)
(declare-fun |Set#UnionOne| (T@U T@U) T@U)
(declare-fun |Set#Union| (T@U T@U) T@U)
(declare-fun |Set#Difference| (T@U T@U) T@U)
(declare-fun |Set#Disjoint| (T@U T@U) Bool)
(declare-fun |Set#Intersection| (T@U T@U) T@U)
(declare-fun |Set#Subset| (T@U T@U) Bool)
(declare-fun |Set#Equal| (T@U T@U) Bool)
(declare-fun |ISet#Empty| (T@T) T@U)
(declare-fun |ISet#UnionOne| (T@U T@U) T@U)
(declare-fun |ISet#Union| (T@U T@U) T@U)
(declare-fun |ISet#Difference| (T@U T@U) T@U)
(declare-fun |ISet#Disjoint| (T@U T@U) Bool)
(declare-fun |ISet#Intersection| (T@U T@U) T@U)
(declare-fun |ISet#Subset| (T@U T@U) Bool)
(declare-fun |ISet#Equal| (T@U T@U) Bool)
(declare-fun |Math#min| (Int Int) Int)
(declare-fun |Math#clip| (Int) Int)
(declare-fun |MultiSet#Card| (T@U) Int)
(declare-fun |MultiSet#Empty| (T@T) T@U)
(declare-fun |MultiSet#Singleton| (T@U) T@U)
(declare-fun |MultiSet#UnionOne| (T@U T@U) T@U)
(declare-fun |MultiSet#Union| (T@U T@U) T@U)
(declare-fun |MultiSet#Intersection| (T@U T@U) T@U)
(declare-fun |MultiSet#Difference| (T@U T@U) T@U)
(declare-fun |MultiSet#Subset| (T@U T@U) Bool)
(declare-fun |MultiSet#Equal| (T@U T@U) Bool)
(declare-fun |MultiSet#Disjoint| (T@U T@U) Bool)
(declare-fun |MultiSet#FromSet| (T@U) T@U)
(declare-fun |MultiSet#FromSeq| (T@U) T@U)
(declare-fun |Seq#Build| (T@U T@U) T@U)
(declare-fun |Seq#Empty| (T@T) T@U)
(declare-fun |Seq#Append| (T@U T@U) T@U)
(declare-fun |Seq#Update| (T@U Int T@U) T@U)
(declare-fun |Seq#Singleton| (T@U) T@U)
(declare-fun |Seq#Contains| (T@U T@U) Bool)
(declare-fun |Seq#Take| (T@U Int) T@U)
(declare-fun |Seq#Drop| (T@U Int) T@U)
(declare-fun |Seq#Equal| (T@U T@U) Bool)
(declare-fun |Seq#SameUntil| (T@U T@U Int) Bool)
(declare-fun |Seq#FromArray| (T@U T@U) T@U)
(declare-fun |Seq#Rank| (T@U) Int)
(declare-fun |Map#Card| (T@U) Int)
(declare-fun |Map#Empty| (T@T T@T) T@U)
(declare-fun |Map#Glue| (T@U T@U T@U) T@U)
(declare-fun |Map#Build| (T@U T@U T@U) T@U)
(declare-fun |Map#Equal| (T@U T@U) Bool)
(declare-fun |Map#Disjoint| (T@U T@U) Bool)
(declare-fun |IMap#Empty| (T@T T@T) T@U)
(declare-fun |IMap#Glue| (T@U T@U T@U) T@U)
(declare-fun |IMap#Build| (T@U T@U T@U) T@U)
(declare-fun |IMap#Equal| (T@U T@U) Bool)
(declare-fun INTERNAL_add_boogie (Int Int) Int)
(declare-fun INTERNAL_sub_boogie (Int Int) Int)
(declare-fun INTERNAL_mul_boogie (Int Int) Int)
(declare-fun INTERNAL_div_boogie (Int Int) Int)
(declare-fun INTERNAL_mod_boogie (Int Int) Int)
(declare-fun INTERNAL_lt_boogie (Int Int) Bool)
(declare-fun INTERNAL_le_boogie (Int Int) Bool)
(declare-fun INTERNAL_gt_boogie (Int Int) Bool)
(declare-fun INTERNAL_ge_boogie (Int Int) Bool)
(declare-fun null () T@U)
(declare-fun Tclass._System.array (T@U) T@U)
(declare-fun Tclass._System.array_0 (T@U) T@U)
(declare-fun dtype (T@U) T@U)
(declare-fun Tclass._System.___hFunc0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc0_0 (T@U) T@U)
(declare-fun HandleTypeType () T@T)
(declare-fun Apply0 (T@U T@U T@U) T@U)
(declare-fun Handle0 (T@U T@U T@U) T@U)
(declare-fun Requires0 (T@U T@U T@U) Bool)
(declare-fun Reads0 (T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hFunc1 (T@U T@U) T@U)
(declare-fun Tclass._System.___hFunc1_0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc1_1 (T@U) T@U)
(declare-fun MapType2Type (T@T T@T T@T) T@T)
(declare-fun MapType2TypeInv0 (T@T) T@T)
(declare-fun MapType2TypeInv1 (T@T) T@T)
(declare-fun MapType2TypeInv2 (T@T) T@T)
(declare-fun MapType2Select (T@U T@U T@U) T@U)
(declare-fun MapType2Store (T@U T@U T@U T@U) T@U)
(declare-fun Apply1 (T@U T@U T@U T@U T@U) T@U)
(declare-fun Handle1 (T@U T@U T@U) T@U)
(declare-fun Requires1 (T@U T@U T@U T@U T@U) Bool)
(declare-fun Reads1 (T@U T@U T@U T@U T@U) T@U)
(declare-fun Tclass._module.__default () T@U)
(declare-fun _module.__default.Factorial (T@U T@U Int) Int)
(declare-fun $IsHeapAnchor (T@U) Bool)
(declare-fun |_module.__default.Factorial#canCall| (T@U Int) Bool)
(declare-fun $ModuleContextHeight () Int)
(declare-fun $FunctionContextHeight () Int)
(declare-fun |_module.__default.Factorial#requires| (T@U T@U Int) Bool)
(declare-fun MapType3Type (T@T T@T) T@T)
(declare-fun MapType3TypeInv0 (T@T) T@T)
(declare-fun MapType3TypeInv1 (T@T) T@T)
(declare-fun MapType3Select (T@U T@U T@U) T@U)
(declare-fun MapType3Store (T@U T@U T@U T@U) T@U)
(declare-fun |lambda#0| (T@U T@U T@U) T@U)
(declare-fun |lambda#1| (T@U T@U T@U) T@U)
(declare-fun |lambda#2| (T@U T@U T@U) T@U)
(declare-fun |lambda#3| (T@U T@U T@U) T@U)
(declare-fun |lambda#4| (T@U T@U T@U T@U) T@U)
(declare-fun |lambda#5| (T@U T@U T@U T@U) T@U)
(declare-fun $LZ () T@U)
(declare-fun $Heap@@12 () T@U)
(declare-fun $_Frame@0 () T@U)
(declare-fun $_Frame@0@@0 () T@U)
(declare-fun %lbl%+13101 () Bool)
(declare-fun %lbl%@34767 () Bool)
(declare-fun |b$reqreads#0@1| () Bool)
(declare-fun %lbl%+13099 () Bool)
(declare-fun |n#0@@7| () Int)
(declare-fun %lbl%@34589 () Bool)
(declare-fun |##n#0@0| () Int)
(declare-fun |b$reqreads#0@0| () Bool)
(declare-fun %lbl%@34638 () Bool)
(declare-fun %lbl%@34651 () Bool)
(declare-fun %lbl%@34666 () Bool)
(declare-fun %lbl%+13097 () Bool)
(declare-fun %lbl%@34525 () Bool)
(declare-fun %lbl%+13095 () Bool)
(declare-fun %lbl%+13088 () Bool)
(declare-fun %lbl%+13084 () Bool)
(declare-fun %lbl%+34404 () Bool)
(assert (and (and (and (and (and (and (and (and (and (and (and (= (Ctor intType) 0) (= (Ctor realType) 1)) (= (Ctor boolType) 2)) (forall ((arg0 Int)) (! (= (U_2_int (int_2_U arg0)) arg0) :qid |typeInv:U_2_int| :pattern ((int_2_U arg0))))) (forall ((x T@U)) (! (=> (= (type x) intType) (= (int_2_U (U_2_int x)) x)) :qid |cast:U_2_int| :pattern ((U_2_int x))))) (forall ((arg0@@0 Int)) (! (= (type (int_2_U arg0@@0)) intType) :qid |funType:int_2_U| :pattern ((int_2_U arg0@@0))))) (forall ((arg0@@1 Real)) (! (= (U_2_real (real_2_U arg0@@1)) arg0@@1) :qid |typeInv:U_2_real| :pattern ((real_2_U arg0@@1))))) (forall ((x@@0 T@U)) (! (=> (= (type x@@0) realType) (= (real_2_U (U_2_real x@@0)) x@@0)) :qid |cast:U_2_real| :pattern ((U_2_real x@@0))))) (forall ((arg0@@2 Real)) (! (= (type (real_2_U arg0@@2)) realType) :qid |funType:real_2_U| :pattern ((real_2_U arg0@@2))))) (forall ((arg0@@3 Bool)) (! (= (U_2_bool (bool_2_U arg0@@3)) arg0@@3) :qid |typeInv:U_2_bool| :pattern ((bool_2_U arg0@@3))))) (forall ((x@@1 T@U)) (! (=> (= (type x@@1) boolType) (= (bool_2_U (U_2_bool x@@1)) x@@1)) :qid |cast:U_2_bool| :pattern ((U_2_bool x@@1))))) (forall ((arg0@@4 Bool)) (! (= (type (bool_2_U arg0@@4)) boolType) :qid |funType:bool_2_U| :pattern ((bool_2_U arg0@@4))))))
(assert (forall ((x@@2 T@U)) (! (UOrdering2 x@@2 x@@2) :qid |bg:subtype-refl| :no-pattern (U_2_int x@@2) :no-pattern (U_2_bool x@@2))))
(assert (forall ((x@@3 T@U) (y T@U) (z T@U)) (! (let ((alpha (type x@@3))) (=> (and (and (= (type y) alpha) (= (type z) alpha)) (and (UOrdering2 x@@3 y) (UOrdering2 y z))) (UOrdering2 x@@3 z))) :qid |bg:subtype-trans| :pattern ((UOrdering2 x@@3 y) (UOrdering2 y z)))))
(assert (forall ((x@@4 T@U) (y@@0 T@U)) (! (let ((alpha@@0 (type x@@4))) (=> (= (type y@@0) alpha@@0) (=> (and (UOrdering2 x@@4 y@@0) (UOrdering2 y@@0 x@@4)) (= x@@4 y@@0)))) :qid |bg:subtype-antisymm| :pattern ((UOrdering2 x@@4 y@@0) (UOrdering2 y@@0 x@@4)))))
(assert (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (= (Ctor TyType) 3) (= (type TBool) TyType)) (= (type TChar) TyType)) (= (type TInt) TyType)) (= (type TNat) TyType)) (= (type TReal) TyType)) (= (Ctor TyTagType) 4)) (= (type TagBool) TyTagType)) (= (type TagChar) TyTagType)) (= (type TagInt) TyTagType)) (= (type TagNat) TyTagType)) (= (type TagReal) TyTagType)) (= (type TagSet) TyTagType)) (= (type TagISet) TyTagType)) (= (type TagMultiSet) TyTagType)) (= (type TagSeq) TyTagType)) (= (type TagMap) TyTagType)) (= (type TagIMap) TyTagType)) (= (type TagClass) TyTagType)) (= (Ctor ClassNameType) 5)) (= (type NoTraitAtAll) ClassNameType)) (= (type class._System.int) ClassNameType)) (= (type class._System.bool) ClassNameType)) (= (type class._System.set) ClassNameType)) (= (type class._System.seq) ClassNameType)) (= (type class._System.multiset) ClassNameType)) (forall ((arg0@@5 T@T)) (! (= (Ctor (FieldType arg0@@5)) 6) :qid |ctor:FieldType|))) (forall ((arg0@@6 T@T)) (! (= (FieldTypeInv0 (FieldType arg0@@6)) arg0@@6) :qid |typeInv:FieldTypeInv0| :pattern ((FieldType arg0@@6))))) (= (type alloc) (FieldType boolType))) (= (type class._System.object) ClassNameType)) (= (type Tagclass._System.object) TyTagType)) (= (type class._System.array) ClassNameType)) (= (type Tagclass._System.array) TyTagType)) (= (type Tagclass._System.___hFunc0) TyTagType)) (= (type Tagclass._System.___hFunc1) TyTagType)) (= (type class._module.__default) ClassNameType)) (= (type Tagclass._module.__default) TyTagType)))
(assert (distinct TBool TChar TInt TNat TReal TagBool TagChar TagInt TagNat TagReal TagSet TagISet TagMultiSet TagSeq TagMap TagIMap TagClass NoTraitAtAll class._System.int class._System.bool class._System.set class._System.seq class._System.multiset alloc class._System.object Tagclass._System.object class._System.array Tagclass._System.array Tagclass._System.___hFunc0 Tagclass._System.___hFunc1 class._module.__default Tagclass._module.__default))
(assert $$Language$Dafny)
(assert (and (forall ((arg0@@7 T@U)) (! (= (type (TSet arg0@@7)) TyType) :qid |funType:TSet| :pattern ((TSet arg0@@7)))) (forall ((arg0@@8 T@U)) (! (= (type (Inv0_TSet arg0@@8)) TyType) :qid |funType:Inv0_TSet| :pattern ((Inv0_TSet arg0@@8))))))
(assert (forall ((t T@U)) (! (=> (= (type t) TyType) (= (Inv0_TSet (TSet t)) t)) :qid |DafnyPre.30:15| :skolemid |0| :pattern ((TSet t)))))
(assert (and (forall ((arg0@@9 T@U)) (! (= (type (TISet arg0@@9)) TyType) :qid |funType:TISet| :pattern ((TISet arg0@@9)))) (forall ((arg0@@10 T@U)) (! (= (type (Inv0_TISet arg0@@10)) TyType) :qid |funType:Inv0_TISet| :pattern ((Inv0_TISet arg0@@10))))))
(assert (forall ((t@@0 T@U)) (! (=> (= (type t@@0) TyType) (= (Inv0_TISet (TISet t@@0)) t@@0)) :qid |DafnyPre.32:15| :skolemid |1| :pattern ((TISet t@@0)))))
(assert (and (forall ((arg0@@11 T@U)) (! (= (type (TSeq arg0@@11)) TyType) :qid |funType:TSeq| :pattern ((TSeq arg0@@11)))) (forall ((arg0@@12 T@U)) (! (= (type (Inv0_TSeq arg0@@12)) TyType) :qid |funType:Inv0_TSeq| :pattern ((Inv0_TSeq arg0@@12))))))
(assert (forall ((t@@1 T@U)) (! (=> (= (type t@@1) TyType) (= (Inv0_TSeq (TSeq t@@1)) t@@1)) :qid |DafnyPre.34:15| :skolemid |2| :pattern ((TSeq t@@1)))))
(assert (and (forall ((arg0@@13 T@U)) (! (= (type (TMultiSet arg0@@13)) TyType) :qid |funType:TMultiSet| :pattern ((TMultiSet arg0@@13)))) (forall ((arg0@@14 T@U)) (! (= (type (Inv0_TMultiSet arg0@@14)) TyType) :qid |funType:Inv0_TMultiSet| :pattern ((Inv0_TMultiSet arg0@@14))))))
(assert (forall ((t@@2 T@U)) (! (=> (= (type t@@2) TyType) (= (Inv0_TMultiSet (TMultiSet t@@2)) t@@2)) :qid |DafnyPre.36:15| :skolemid |3| :pattern ((TMultiSet t@@2)))))
(assert (and (forall ((arg0@@15 T@U) (arg1 T@U)) (! (= (type (TMap arg0@@15 arg1)) TyType) :qid |funType:TMap| :pattern ((TMap arg0@@15 arg1)))) (forall ((arg0@@16 T@U)) (! (= (type (Inv0_TMap arg0@@16)) TyType) :qid |funType:Inv0_TMap| :pattern ((Inv0_TMap arg0@@16))))))
(assert (forall ((t@@3 T@U) (u T@U)) (! (=> (and (= (type t@@3) TyType) (= (type u) TyType)) (= (Inv0_TMap (TMap t@@3 u)) t@@3)) :qid |DafnyPre.39:15| :skolemid |4| :pattern ((TMap t@@3 u)))))
(assert (forall ((arg0@@17 T@U)) (! (= (type (Inv1_TMap arg0@@17)) TyType) :qid |funType:Inv1_TMap| :pattern ((Inv1_TMap arg0@@17)))))
(assert (forall ((t@@4 T@U) (u@@0 T@U)) (! (=> (and (= (type t@@4) TyType) (= (type u@@0) TyType)) (= (Inv1_TMap (TMap t@@4 u@@0)) u@@0)) :qid |DafnyPre.40:15| :skolemid |5| :pattern ((TMap t@@4 u@@0)))))
(assert (and (forall ((arg0@@18 T@U) (arg1@@0 T@U)) (! (= (type (TIMap arg0@@18 arg1@@0)) TyType) :qid |funType:TIMap| :pattern ((TIMap arg0@@18 arg1@@0)))) (forall ((arg0@@19 T@U)) (! (= (type (Inv0_TIMap arg0@@19)) TyType) :qid |funType:Inv0_TIMap| :pattern ((Inv0_TIMap arg0@@19))))))
(assert (forall ((t@@5 T@U) (u@@1 T@U)) (! (=> (and (= (type t@@5) TyType) (= (type u@@1) TyType)) (= (Inv0_TIMap (TIMap t@@5 u@@1)) t@@5)) :qid |DafnyPre.43:15| :skolemid |6| :pattern ((TIMap t@@5 u@@1)))))
(assert (forall ((arg0@@20 T@U)) (! (= (type (Inv1_TIMap arg0@@20)) TyType) :qid |funType:Inv1_TIMap| :pattern ((Inv1_TIMap arg0@@20)))))
(assert (forall ((t@@6 T@U) (u@@2 T@U)) (! (=> (and (= (type t@@6) TyType) (= (type u@@2) TyType)) (= (Inv1_TIMap (TIMap t@@6 u@@2)) u@@2)) :qid |DafnyPre.44:15| :skolemid |7| :pattern ((TIMap t@@6 u@@2)))))
(assert (forall ((arg0@@21 T@U)) (! (= (type (Tag arg0@@21)) TyTagType) :qid |funType:Tag| :pattern ((Tag arg0@@21)))))
(assert (= (Tag TBool) TagBool))
(assert (= (Tag TChar) TagChar))
(assert (= (Tag TInt) TagInt))
(assert (= (Tag TNat) TagNat))
(assert (= (Tag TReal) TagReal))
(assert (forall ((t@@7 T@U)) (! (=> (= (type t@@7) TyType) (= (Tag (TSet t@@7)) TagSet)) :qid |DafnyPre.70:15| :skolemid |8| :pattern ((TSet t@@7)))))
(assert (forall ((t@@8 T@U)) (! (=> (= (type t@@8) TyType) (= (Tag (TISet t@@8)) TagISet)) :qid |DafnyPre.71:15| :skolemid |9| :pattern ((TISet t@@8)))))
(assert (forall ((t@@9 T@U)) (! (=> (= (type t@@9) TyType) (= (Tag (TMultiSet t@@9)) TagMultiSet)) :qid |DafnyPre.72:15| :skolemid |10| :pattern ((TMultiSet t@@9)))))
(assert (forall ((t@@10 T@U)) (! (=> (= (type t@@10) TyType) (= (Tag (TSeq t@@10)) TagSeq)) :qid |DafnyPre.73:15| :skolemid |11| :pattern ((TSeq t@@10)))))
(assert (forall ((t@@11 T@U) (u@@3 T@U)) (! (=> (and (= (type t@@11) TyType) (= (type u@@3) TyType)) (= (Tag (TMap t@@11 u@@3)) TagMap)) :qid |DafnyPre.74:15| :skolemid |12| :pattern ((TMap t@@11 u@@3)))))
(assert (forall ((t@@12 T@U) (u@@4 T@U)) (! (=> (and (= (type t@@12) TyType) (= (type u@@4) TyType)) (= (Tag (TIMap t@@12 u@@4)) TagIMap)) :qid |DafnyPre.75:15| :skolemid |13| :pattern ((TIMap t@@12 u@@4)))))
(assert (forall ((x@@5 Int)) (! (= (LitInt x@@5) x@@5) :qid |DafnyPre.80:29| :skolemid |14| :pattern ((LitInt x@@5)))))
(assert (and (and (= (Ctor BoxType) 7) (forall ((arg0@@22 T@U)) (! (= (type ($Box arg0@@22)) BoxType) :qid |funType:$Box| :pattern (($Box arg0@@22))))) (forall ((arg0@@23 T@U)) (! (let ((T (type arg0@@23))) (= (type (Lit arg0@@23)) T)) :qid |funType:Lit| :pattern ((Lit arg0@@23))))))
(assert (forall ((x@@6 Int)) (! (= ($Box (int_2_U (LitInt x@@6))) (Lit ($Box (int_2_U x@@6)))) :qid |DafnyPre.81:15| :skolemid |15| :pattern (($Box (int_2_U (LitInt x@@6)))))))
(assert (forall ((x@@7 Real)) (! (= (LitReal x@@7) x@@7) :qid |DafnyPre.82:30| :skolemid |16| :pattern ((LitReal x@@7)))))
(assert (forall ((x@@8 Real)) (! (= ($Box (real_2_U (LitReal x@@8))) (Lit ($Box (real_2_U x@@8)))) :qid |DafnyPre.83:15| :skolemid |17| :pattern (($Box (real_2_U (LitReal x@@8)))))))
(assert (forall ((x@@9 T@U)) (! (= (Lit x@@9) x@@9) :qid |DafnyPre.84:29| :skolemid |18| :pattern ((Lit x@@9)))))
(assert (forall ((x@@10 T@U)) (! (= ($Box (Lit x@@10)) (Lit ($Box x@@10))) :qid |DafnyPre.85:18| :skolemid |19| :pattern (($Box (Lit x@@10))))))
(assert (and (= (Ctor charType) 8) (forall ((arg0@@24 Int)) (! (= (type (|char#FromInt| arg0@@24)) charType) :qid |funType:char#FromInt| :pattern ((|char#FromInt| arg0@@24))))))
(assert (forall ((ch T@U)) (! (=> (= (type ch) charType) (= (|char#FromInt| (|char#ToInt| ch)) ch)) :qid |DafnyPre.94:15| :skolemid |20| :pattern ((|char#ToInt| ch)))))
(assert (forall ((n Int)) (! (=> (and (<= 0 n) (< n 65536)) (= (|char#ToInt| (|char#FromInt| n)) n)) :qid |DafnyPre.97:15| :skolemid |21| :pattern ((|char#FromInt| n)))))
(assert (forall ((T@@0 T@T) (arg0@@25 T@U)) (! (= (type ($Unbox T@@0 arg0@@25)) T@@0) :qid |funType:$Unbox| :pattern (($Unbox T@@0 arg0@@25)))))
(assert (forall ((x@@11 T@U)) (! (let ((T@@1 (type x@@11))) (= ($Unbox T@@1 ($Box x@@11)) x@@11)) :qid |DafnyPre.125:18| :skolemid |22| :pattern (($Box x@@11)))))
(assert (forall ((bx T@U)) (! (=> (and (= (type bx) BoxType) ($IsBox bx TInt)) (and (= ($Box ($Unbox intType bx)) bx) ($Is ($Unbox intType bx) TInt))) :qid |DafnyPre.127:15| :skolemid |23| :pattern (($IsBox bx TInt)))))
(assert (forall ((bx@@0 T@U)) (! (=> (and (= (type bx@@0) BoxType) ($IsBox bx@@0 TNat)) (and (= ($Box ($Unbox intType bx@@0)) bx@@0) ($Is ($Unbox intType bx@@0) TNat))) :qid |DafnyPre.130:15| :skolemid |24| :pattern (($IsBox bx@@0 TNat)))))
(assert (forall ((bx@@1 T@U)) (! (=> (and (= (type bx@@1) BoxType) ($IsBox bx@@1 TReal)) (and (= ($Box ($Unbox realType bx@@1)) bx@@1) ($Is ($Unbox realType bx@@1) TReal))) :qid |DafnyPre.133:15| :skolemid |25| :pattern (($IsBox bx@@1 TReal)))))
(assert (forall ((bx@@2 T@U)) (! (=> (and (= (type bx@@2) BoxType) ($IsBox bx@@2 TBool)) (and (= ($Box ($Unbox boolType bx@@2)) bx@@2) ($Is ($Unbox boolType bx@@2) TBool))) :qid |DafnyPre.136:15| :skolemid |26| :pattern (($IsBox bx@@2 TBool)))))
(assert (forall ((bx@@3 T@U)) (! (=> (and (= (type bx@@3) BoxType) ($IsBox bx@@3 TChar)) (and (= ($Box ($Unbox charType bx@@3)) bx@@3) ($Is ($Unbox charType bx@@3) TChar))) :qid |DafnyPre.139:15| :skolemid |27| :pattern (($IsBox bx@@3 TChar)))))
(assert (and (and (and (and (and (and (forall ((arg0@@26 T@T) (arg1@@1 T@T)) (! (= (Ctor (MapType0Type arg0@@26 arg1@@1)) 9) :qid |ctor:MapType0Type|)) (forall ((arg0@@27 T@T) (arg1@@2 T@T)) (! (= (MapType0TypeInv0 (MapType0Type arg0@@27 arg1@@2)) arg0@@27) :qid |typeInv:MapType0TypeInv0| :pattern ((MapType0Type arg0@@27 arg1@@2))))) (forall ((arg0@@28 T@T) (arg1@@3 T@T)) (! (= (MapType0TypeInv1 (MapType0Type arg0@@28 arg1@@3)) arg1@@3) :qid |typeInv:MapType0TypeInv1| :pattern ((MapType0Type arg0@@28 arg1@@3))))) (forall ((arg0@@29 T@U) (arg1@@4 T@U)) (! (let ((aVar1 (MapType0TypeInv1 (type arg0@@29)))) (= (type (MapType0Select arg0@@29 arg1@@4)) aVar1)) :qid |funType:MapType0Select| :pattern ((MapType0Select arg0@@29 arg1@@4))))) (forall ((arg0@@30 T@U) (arg1@@5 T@U) (arg2 T@U)) (! (let ((aVar1@@0 (type arg2))) (let ((aVar0 (type arg1@@5))) (= (type (MapType0Store arg0@@30 arg1@@5 arg2)) (MapType0Type aVar0 aVar1@@0)))) :qid |funType:MapType0Store| :pattern ((MapType0Store arg0@@30 arg1@@5 arg2))))) (forall ((m T@U) (x0 T@U) (val T@U)) (! (let ((aVar1@@1 (MapType0TypeInv1 (type m)))) (=> (= (type val) aVar1@@1) (= (MapType0Select (MapType0Store m x0 val) x0) val))) :qid |mapAx0:MapType0Select| :weight 0))) (and (forall ((val@@0 T@U) (m@@0 T@U) (x0@@0 T@U) (y0 T@U)) (! (or (= x0@@0 y0) (= (MapType0Select (MapType0Store m@@0 x0@@0 val@@0) y0) (MapType0Select m@@0 y0))) :qid |mapAx1:MapType0Select:0| :weight 0)) (forall ((val@@1 T@U) (m@@1 T@U) (x0@@1 T@U) (y0@@0 T@U)) (! (or true (= (MapType0Select (MapType0Store m@@1 x0@@1 val@@1) y0@@0) (MapType0Select m@@1 y0@@0))) :qid |mapAx2:MapType0Select| :weight 0)))))
(assert (forall ((bx@@4 T@U) (t@@13 T@U)) (! (=> (and (and (= (type bx@@4) BoxType) (= (type t@@13) TyType)) ($IsBox bx@@4 (TSet t@@13))) (and (= ($Box ($Unbox (MapType0Type BoxType boolType) bx@@4)) bx@@4) ($Is ($Unbox (MapType0Type BoxType boolType) bx@@4) (TSet t@@13)))) :qid |DafnyPre.142:15| :skolemid |28| :pattern (($IsBox bx@@4 (TSet t@@13))))))
(assert (forall ((bx@@5 T@U) (t@@14 T@U)) (! (=> (and (and (= (type bx@@5) BoxType) (= (type t@@14) TyType)) ($IsBox bx@@5 (TISet t@@14))) (and (= ($Box ($Unbox (MapType0Type BoxType boolType) bx@@5)) bx@@5) ($Is ($Unbox (MapType0Type BoxType boolType) bx@@5) (TISet t@@14)))) :qid |DafnyPre.145:15| :skolemid |29| :pattern (($IsBox bx@@5 (TISet t@@14))))))
(assert (forall ((bx@@6 T@U) (t@@15 T@U)) (! (=> (and (and (= (type bx@@6) BoxType) (= (type t@@15) TyType)) ($IsBox bx@@6 (TMultiSet t@@15))) (and (= ($Box ($Unbox (MapType0Type BoxType intType) bx@@6)) bx@@6) ($Is ($Unbox (MapType0Type BoxType intType) bx@@6) (TMultiSet t@@15)))) :qid |DafnyPre.148:15| :skolemid |30| :pattern (($IsBox bx@@6 (TMultiSet t@@15))))))
(assert (and (forall ((arg0@@31 T@T)) (! (= (Ctor (SeqType arg0@@31)) 10) :qid |ctor:SeqType|)) (forall ((arg0@@32 T@T)) (! (= (SeqTypeInv0 (SeqType arg0@@32)) arg0@@32) :qid |typeInv:SeqTypeInv0| :pattern ((SeqType arg0@@32))))))
(assert (forall ((bx@@7 T@U) (t@@16 T@U)) (! (=> (and (and (= (type bx@@7) BoxType) (= (type t@@16) TyType)) ($IsBox bx@@7 (TSeq t@@16))) (and (= ($Box ($Unbox (SeqType BoxType) bx@@7)) bx@@7) ($Is ($Unbox (SeqType BoxType) bx@@7) (TSeq t@@16)))) :qid |DafnyPre.151:15| :skolemid |31| :pattern (($IsBox bx@@7 (TSeq t@@16))))))
(assert (and (and (forall ((arg0@@33 T@T) (arg1@@6 T@T)) (! (= (Ctor (MapType arg0@@33 arg1@@6)) 11) :qid |ctor:MapType|)) (forall ((arg0@@34 T@T) (arg1@@7 T@T)) (! (= (MapTypeInv0 (MapType arg0@@34 arg1@@7)) arg0@@34) :qid |typeInv:MapTypeInv0| :pattern ((MapType arg0@@34 arg1@@7))))) (forall ((arg0@@35 T@T) (arg1@@8 T@T)) (! (= (MapTypeInv1 (MapType arg0@@35 arg1@@8)) arg1@@8) :qid |typeInv:MapTypeInv1| :pattern ((MapType arg0@@35 arg1@@8))))))
(assert (forall ((bx@@8 T@U) (s T@U) (t@@17 T@U)) (! (=> (and (and (and (= (type bx@@8) BoxType) (= (type s) TyType)) (= (type t@@17) TyType)) ($IsBox bx@@8 (TMap s t@@17))) (and (= ($Box ($Unbox (MapType BoxType BoxType) bx@@8)) bx@@8) ($Is ($Unbox (MapType BoxType BoxType) bx@@8) (TMap s t@@17)))) :qid |DafnyPre.154:15| :skolemid |32| :pattern (($IsBox bx@@8 (TMap s t@@17))))))
(assert (and (and (forall ((arg0@@36 T@T) (arg1@@9 T@T)) (! (= (Ctor (IMapType arg0@@36 arg1@@9)) 12) :qid |ctor:IMapType|)) (forall ((arg0@@37 T@T) (arg1@@10 T@T)) (! (= (IMapTypeInv0 (IMapType arg0@@37 arg1@@10)) arg0@@37) :qid |typeInv:IMapTypeInv0| :pattern ((IMapType arg0@@37 arg1@@10))))) (forall ((arg0@@38 T@T) (arg1@@11 T@T)) (! (= (IMapTypeInv1 (IMapType arg0@@38 arg1@@11)) arg1@@11) :qid |typeInv:IMapTypeInv1| :pattern ((IMapType arg0@@38 arg1@@11))))))
(assert (forall ((bx@@9 T@U) (s@@0 T@U) (t@@18 T@U)) (! (=> (and (and (and (= (type bx@@9) BoxType) (= (type s@@0) TyType)) (= (type t@@18) TyType)) ($IsBox bx@@9 (TIMap s@@0 t@@18))) (and (= ($Box ($Unbox (IMapType BoxType BoxType) bx@@9)) bx@@9) ($Is ($Unbox (IMapType BoxType BoxType) bx@@9) (TIMap s@@0 t@@18)))) :qid |DafnyPre.157:15| :skolemid |33| :pattern (($IsBox bx@@9 (TIMap s@@0 t@@18))))))
(assert (forall ((v T@U) (t@@19 T@U)) (! (=> (= (type t@@19) TyType) (and (=> ($IsBox ($Box v) t@@19) ($Is v t@@19)) (=> ($Is v t@@19) ($IsBox ($Box v) t@@19)))) :qid |DafnyPre.161:18| :skolemid |34| :pattern (($IsBox ($Box v) t@@19)))))
(assert (and (and (and (and (and (and (forall ((arg0@@39 T@T)) (! (= (Ctor (MapType1Type arg0@@39)) 13) :qid |ctor:MapType1Type|)) (forall ((arg0@@40 T@T)) (! (= (MapType1TypeInv0 (MapType1Type arg0@@40)) arg0@@40) :qid |typeInv:MapType1TypeInv0| :pattern ((MapType1Type arg0@@40))))) (forall ((arg0@@41 T@U) (arg1@@12 T@U) (arg2@@0 T@U)) (! (let ((alpha@@1 (FieldTypeInv0 (type arg2@@0)))) (= (type (MapType1Select arg0@@41 arg1@@12 arg2@@0)) alpha@@1)) :qid |funType:MapType1Select| :pattern ((MapType1Select arg0@@41 arg1@@12 arg2@@0))))) (forall ((arg0@@42 T@U) (arg1@@13 T@U) (arg2@@1 T@U) (arg3 T@U)) (! (let ((aVar0@@0 (type arg1@@13))) (= (type (MapType1Store arg0@@42 arg1@@13 arg2@@1 arg3)) (MapType1Type aVar0@@0))) :qid |funType:MapType1Store| :pattern ((MapType1Store arg0@@42 arg1@@13 arg2@@1 arg3))))) (forall ((m@@2 T@U) (x0@@2 T@U) (x1 T@U) (val@@2 T@U)) (! (let ((alpha@@2 (FieldTypeInv0 (type x1)))) (=> (= (type val@@2) alpha@@2) (= (MapType1Select (MapType1Store m@@2 x0@@2 x1 val@@2) x0@@2 x1) val@@2))) :qid |mapAx0:MapType1Select| :weight 0))) (and (and (forall ((val@@3 T@U) (m@@3 T@U) (x0@@3 T@U) (x1@@0 T@U) (y0@@1 T@U) (y1 T@U)) (! (or (= x0@@3 y0@@1) (= (MapType1Select (MapType1Store m@@3 x0@@3 x1@@0 val@@3) y0@@1 y1) (MapType1Select m@@3 y0@@1 y1))) :qid |mapAx1:MapType1Select:0| :weight 0)) (forall ((val@@4 T@U) (m@@4 T@U) (x0@@4 T@U) (x1@@1 T@U) (y0@@2 T@U) (y1@@0 T@U)) (! (or (= x1@@1 y1@@0) (= (MapType1Select (MapType1Store m@@4 x0@@4 x1@@1 val@@4) y0@@2 y1@@0) (MapType1Select m@@4 y0@@2 y1@@0))) :qid |mapAx1:MapType1Select:1| :weight 0))) (forall ((val@@5 T@U) (m@@5 T@U) (x0@@5 T@U) (x1@@2 T@U) (y0@@3 T@U) (y1@@1 T@U)) (! (or true (= (MapType1Select (MapType1Store m@@5 x0@@5 x1@@2 val@@5) y0@@3 y1@@1) (MapType1Select m@@5 y0@@3 y1@@1))) :qid |mapAx2:MapType1Select| :weight 0)))) (= (Ctor refType) 14)))
(assert (forall ((v@@0 T@U) (t@@20 T@U) (h T@U)) (! (=> (and (= (type t@@20) TyType) (= (type h) (MapType1Type refType))) (and (=> ($IsAllocBox ($Box v@@0) t@@20 h) ($IsAlloc v@@0 t@@20 h)) (=> ($IsAlloc v@@0 t@@20 h) ($IsAllocBox ($Box v@@0) t@@20 h)))) :qid |DafnyPre.164:18| :skolemid |35| :pattern (($IsAllocBox ($Box v@@0) t@@20 h)))))
(assert (forall ((v@@1 T@U)) (! (=> (= (type v@@1) intType) ($Is v@@1 TInt)) :qid |DafnyPre.182:14| :skolemid |36| :pattern (($Is v@@1 TInt)))))
(assert (forall ((v@@2 T@U)) (! (=> (= (type v@@2) intType) (and (=> ($Is v@@2 TNat) (>= (U_2_int v@@2) 0)) (=> (>= (U_2_int v@@2) 0) ($Is v@@2 TNat)))) :qid |DafnyPre.183:14| :skolemid |37| :pattern (($Is v@@2 TNat)))))
(assert (forall ((v@@3 T@U)) (! (=> (= (type v@@3) realType) ($Is v@@3 TReal)) :qid |DafnyPre.184:14| :skolemid |38| :pattern (($Is v@@3 TReal)))))
(assert (forall ((v@@4 T@U)) (! (=> (= (type v@@4) boolType) ($Is v@@4 TBool)) :qid |DafnyPre.185:14| :skolemid |39| :pattern (($Is v@@4 TBool)))))
(assert (forall ((v@@5 T@U)) (! (=> (= (type v@@5) charType) ($Is v@@5 TChar)) :qid |DafnyPre.186:14| :skolemid |40| :pattern (($Is v@@5 TChar)))))
(assert (forall ((h@@0 T@U) (v@@6 T@U)) (! (=> (and (= (type h@@0) (MapType1Type refType)) (= (type v@@6) intType)) ($IsAlloc v@@6 TInt h@@0)) :qid |DafnyPre.188:14| :skolemid |41| :pattern (($IsAlloc v@@6 TInt h@@0)))))
(assert (forall ((h@@1 T@U) (v@@7 T@U)) (! (=> (and (= (type h@@1) (MapType1Type refType)) (= (type v@@7) intType)) ($IsAlloc v@@7 TNat h@@1)) :qid |DafnyPre.189:14| :skolemid |42| :pattern (($IsAlloc v@@7 TNat h@@1)))))
(assert (forall ((h@@2 T@U) (v@@8 T@U)) (! (=> (and (= (type h@@2) (MapType1Type refType)) (= (type v@@8) realType)) ($IsAlloc v@@8 TReal h@@2)) :qid |DafnyPre.190:14| :skolemid |43| :pattern (($IsAlloc v@@8 TReal h@@2)))))
(assert (forall ((h@@3 T@U) (v@@9 T@U)) (! (=> (and (= (type h@@3) (MapType1Type refType)) (= (type v@@9) boolType)) ($IsAlloc v@@9 TBool h@@3)) :qid |DafnyPre.191:14| :skolemid |44| :pattern (($IsAlloc v@@9 TBool h@@3)))))
(assert (forall ((h@@4 T@U) (v@@10 T@U)) (! (=> (and (= (type h@@4) (MapType1Type refType)) (= (type v@@10) charType)) ($IsAlloc v@@10 TChar h@@4)) :qid |DafnyPre.192:14| :skolemid |45| :pattern (($IsAlloc v@@10 TChar h@@4)))))
(assert (forall ((v@@11 T@U) (t0 T@U)) (! (=> (and (= (type v@@11) (MapType0Type BoxType boolType)) (= (type t0) TyType)) (and (=> ($Is v@@11 (TSet t0)) (forall ((bx@@10 T@U)) (! (=> (and (= (type bx@@10) BoxType) (U_2_bool (MapType0Select v@@11 bx@@10))) ($IsBox bx@@10 t0)) :qid |DafnyPre.196:11| :skolemid |46| :pattern ((MapType0Select v@@11 bx@@10))))) (=> (forall ((bx@@11 T@U)) (! (=> (and (= (type bx@@11) BoxType) (U_2_bool (MapType0Select v@@11 bx@@11))) ($IsBox bx@@11 t0)) :qid |DafnyPre.196:11| :skolemid |46| :pattern ((MapType0Select v@@11 bx@@11)))) ($Is v@@11 (TSet t0))))) :qid |DafnyPre.194:15| :skolemid |47| :pattern (($Is v@@11 (TSet t0))))))
(assert (forall ((v@@12 T@U) (t0@@0 T@U)) (! (=> (and (= (type v@@12) (MapType0Type BoxType boolType)) (= (type t0@@0) TyType)) (and (=> ($Is v@@12 (TISet t0@@0)) (forall ((bx@@12 T@U)) (! (=> (and (= (type bx@@12) BoxType) (U_2_bool (MapType0Select v@@12 bx@@12))) ($IsBox bx@@12 t0@@0)) :qid |DafnyPre.200:11| :skolemid |48| :pattern ((MapType0Select v@@12 bx@@12))))) (=> (forall ((bx@@13 T@U)) (! (=> (and (= (type bx@@13) BoxType) (U_2_bool (MapType0Select v@@12 bx@@13))) ($IsBox bx@@13 t0@@0)) :qid |DafnyPre.200:11| :skolemid |48| :pattern ((MapType0Select v@@12 bx@@13)))) ($Is v@@12 (TISet t0@@0))))) :qid |DafnyPre.198:15| :skolemid |49| :pattern (($Is v@@12 (TISet t0@@0))))))
(assert (forall ((v@@13 T@U) (t0@@1 T@U)) (! (=> (and (= (type v@@13) (MapType0Type BoxType intType)) (= (type t0@@1) TyType)) (and (=> ($Is v@@13 (TMultiSet t0@@1)) (forall ((bx@@14 T@U)) (! (=> (and (= (type bx@@14) BoxType) (< 0 (U_2_int (MapType0Select v@@13 bx@@14)))) ($IsBox bx@@14 t0@@1)) :qid |DafnyPre.204:11| :skolemid |50| :pattern ((MapType0Select v@@13 bx@@14))))) (=> (forall ((bx@@15 T@U)) (! (=> (and (= (type bx@@15) BoxType) (< 0 (U_2_int (MapType0Select v@@13 bx@@15)))) ($IsBox bx@@15 t0@@1)) :qid |DafnyPre.204:11| :skolemid |50| :pattern ((MapType0Select v@@13 bx@@15)))) ($Is v@@13 (TMultiSet t0@@1))))) :qid |DafnyPre.202:15| :skolemid |51| :pattern (($Is v@@13 (TMultiSet t0@@1))))))
(assert (forall ((v@@14 T@U) (t0@@2 T@U)) (! (=> (and (and (= (type v@@14) (MapType0Type BoxType intType)) (= (type t0@@2) TyType)) ($Is v@@14 (TMultiSet t0@@2))) ($IsGoodMultiSet v@@14)) :qid |DafnyPre.206:15| :skolemid |52| :pattern (($Is v@@14 (TMultiSet t0@@2))))))
(assert (forall ((arg0@@43 T@U) (arg1@@14 Int)) (! (let ((T@@2 (SeqTypeInv0 (type arg0@@43)))) (= (type (|Seq#Index| arg0@@43 arg1@@14)) T@@2)) :qid |funType:Seq#Index| :pattern ((|Seq#Index| arg0@@43 arg1@@14)))))
(assert (forall ((v@@15 T@U) (t0@@3 T@U)) (! (=> (and (= (type v@@15) (SeqType BoxType)) (= (type t0@@3) TyType)) (and (=> ($Is v@@15 (TSeq t0@@3)) (forall ((i Int)) (! (=> (and (<= 0 i) (< i (|Seq#Length| v@@15))) ($IsBox (|Seq#Index| v@@15 i) t0@@3)) :qid |DafnyPre.210:11| :skolemid |53| :pattern ((|Seq#Index| v@@15 i))))) (=> (forall ((i@@0 Int)) (! (=> (and (<= 0 i@@0) (< i@@0 (|Seq#Length| v@@15))) ($IsBox (|Seq#Index| v@@15 i@@0) t0@@3)) :qid |DafnyPre.210:11| :skolemid |53| :pattern ((|Seq#Index| v@@15 i@@0)))) ($Is v@@15 (TSeq t0@@3))))) :qid |DafnyPre.208:15| :skolemid |54| :pattern (($Is v@@15 (TSeq t0@@3))))))
(assert (forall ((v@@16 T@U) (t0@@4 T@U) (h@@5 T@U)) (! (=> (and (and (= (type v@@16) (MapType0Type BoxType boolType)) (= (type t0@@4) TyType)) (= (type h@@5) (MapType1Type refType))) (and (=> ($IsAlloc v@@16 (TSet t0@@4) h@@5) (forall ((bx@@16 T@U)) (! (=> (and (= (type bx@@16) BoxType) (U_2_bool (MapType0Select v@@16 bx@@16))) ($IsAllocBox bx@@16 t0@@4 h@@5)) :qid |DafnyPre.215:11| :skolemid |55| :pattern ((MapType0Select v@@16 bx@@16))))) (=> (forall ((bx@@17 T@U)) (! (=> (and (= (type bx@@17) BoxType) (U_2_bool (MapType0Select v@@16 bx@@17))) ($IsAllocBox bx@@17 t0@@4 h@@5)) :qid |DafnyPre.215:11| :skolemid |55| :pattern ((MapType0Select v@@16 bx@@17)))) ($IsAlloc v@@16 (TSet t0@@4) h@@5)))) :qid |DafnyPre.213:15| :skolemid |56| :pattern (($IsAlloc v@@16 (TSet t0@@4) h@@5)))))
(assert (forall ((v@@17 T@U) (t0@@5 T@U) (h@@6 T@U)) (! (=> (and (and (= (type v@@17) (MapType0Type BoxType boolType)) (= (type t0@@5) TyType)) (= (type h@@6) (MapType1Type refType))) (and (=> ($IsAlloc v@@17 (TISet t0@@5) h@@6) (forall ((bx@@18 T@U)) (! (=> (and (= (type bx@@18) BoxType) (U_2_bool (MapType0Select v@@17 bx@@18))) ($IsAllocBox bx@@18 t0@@5 h@@6)) :qid |DafnyPre.219:11| :skolemid |57| :pattern ((MapType0Select v@@17 bx@@18))))) (=> (forall ((bx@@19 T@U)) (! (=> (and (= (type bx@@19) BoxType) (U_2_bool (MapType0Select v@@17 bx@@19))) ($IsAllocBox bx@@19 t0@@5 h@@6)) :qid |DafnyPre.219:11| :skolemid |57| :pattern ((MapType0Select v@@17 bx@@19)))) ($IsAlloc v@@17 (TISet t0@@5) h@@6)))) :qid |DafnyPre.217:15| :skolemid |58| :pattern (($IsAlloc v@@17 (TISet t0@@5) h@@6)))))
(assert (forall ((v@@18 T@U) (t0@@6 T@U) (h@@7 T@U)) (! (=> (and (and (= (type v@@18) (MapType0Type BoxType intType)) (= (type t0@@6) TyType)) (= (type h@@7) (MapType1Type refType))) (and (=> ($IsAlloc v@@18 (TMultiSet t0@@6) h@@7) (forall ((bx@@20 T@U)) (! (=> (and (= (type bx@@20) BoxType) (< 0 (U_2_int (MapType0Select v@@18 bx@@20)))) ($IsAllocBox bx@@20 t0@@6 h@@7)) :qid |DafnyPre.223:11| :skolemid |59| :pattern ((MapType0Select v@@18 bx@@20))))) (=> (forall ((bx@@21 T@U)) (! (=> (and (= (type bx@@21) BoxType) (< 0 (U_2_int (MapType0Select v@@18 bx@@21)))) ($IsAllocBox bx@@21 t0@@6 h@@7)) :qid |DafnyPre.223:11| :skolemid |59| :pattern ((MapType0Select v@@18 bx@@21)))) ($IsAlloc v@@18 (TMultiSet t0@@6) h@@7)))) :qid |DafnyPre.221:15| :skolemid |60| :pattern (($IsAlloc v@@18 (TMultiSet t0@@6) h@@7)))))
(assert (forall ((v@@19 T@U) (t0@@7 T@U) (h@@8 T@U)) (! (=> (and (and (= (type v@@19) (SeqType BoxType)) (= (type t0@@7) TyType)) (= (type h@@8) (MapType1Type refType))) (and (=> ($IsAlloc v@@19 (TSeq t0@@7) h@@8) (forall ((i@@1 Int)) (! (=> (and (<= 0 i@@1) (< i@@1 (|Seq#Length| v@@19))) ($IsAllocBox (|Seq#Index| v@@19 i@@1) t0@@7 h@@8)) :qid |DafnyPre.227:11| :skolemid |61| :pattern ((|Seq#Index| v@@19 i@@1))))) (=> (forall ((i@@2 Int)) (! (=> (and (<= 0 i@@2) (< i@@2 (|Seq#Length| v@@19))) ($IsAllocBox (|Seq#Index| v@@19 i@@2) t0@@7 h@@8)) :qid |DafnyPre.227:11| :skolemid |61| :pattern ((|Seq#Index| v@@19 i@@2)))) ($IsAlloc v@@19 (TSeq t0@@7) h@@8)))) :qid |DafnyPre.225:15| :skolemid |62| :pattern (($IsAlloc v@@19 (TSeq t0@@7) h@@8)))))
(assert (and (forall ((arg0@@44 T@U)) (! (let ((V (MapTypeInv1 (type arg0@@44)))) (let ((U (MapTypeInv0 (type arg0@@44)))) (= (type (|Map#Elements| arg0@@44)) (MapType0Type U V)))) :qid |funType:Map#Elements| :pattern ((|Map#Elements| arg0@@44)))) (forall ((arg0@@45 T@U)) (! (let ((U@@0 (MapTypeInv0 (type arg0@@45)))) (= (type (|Map#Domain| arg0@@45)) (MapType0Type U@@0 boolType))) :qid |funType:Map#Domain| :pattern ((|Map#Domain| arg0@@45))))))
(assert (forall ((v@@20 T@U) (t0@@8 T@U) (t1 T@U)) (! (=> (and (and (= (type v@@20) (MapType BoxType BoxType)) (= (type t0@@8) TyType)) (= (type t1) TyType)) (and (=> ($Is v@@20 (TMap t0@@8 t1)) (forall ((bx@@22 T@U)) (! (=> (and (= (type bx@@22) BoxType) (U_2_bool (MapType0Select (|Map#Domain| v@@20) bx@@22))) (and ($IsBox (MapType0Select (|Map#Elements| v@@20) bx@@22) t1) ($IsBox bx@@22 t0@@8))) :qid |DafnyPre.234:19| :skolemid |63| :pattern ((MapType0Select (|Map#Elements| v@@20) bx@@22)) :pattern ((MapType0Select (|Map#Domain| v@@20) bx@@22))))) (=> (forall ((bx@@23 T@U)) (! (=> (and (= (type bx@@23) BoxType) (U_2_bool (MapType0Select (|Map#Domain| v@@20) bx@@23))) (and ($IsBox (MapType0Select (|Map#Elements| v@@20) bx@@23) t1) ($IsBox bx@@23 t0@@8))) :qid |DafnyPre.234:19| :skolemid |63| :pattern ((MapType0Select (|Map#Elements| v@@20) bx@@23)) :pattern ((MapType0Select (|Map#Domain| v@@20) bx@@23)))) ($Is v@@20 (TMap t0@@8 t1))))) :qid |DafnyPre.231:15| :skolemid |64| :pattern (($Is v@@20 (TMap t0@@8 t1))))))
(assert (forall ((v@@21 T@U) (t0@@9 T@U) (t1@@0 T@U) (h@@9 T@U)) (! (=> (and (and (and (= (type v@@21) (MapType BoxType BoxType)) (= (type t0@@9) TyType)) (= (type t1@@0) TyType)) (= (type h@@9) (MapType1Type refType))) (and (=> ($IsAlloc v@@21 (TMap t0@@9 t1@@0) h@@9) (forall ((bx@@24 T@U)) (! (=> (and (= (type bx@@24) BoxType) (U_2_bool (MapType0Select (|Map#Domain| v@@21) bx@@24))) (and ($IsAllocBox (MapType0Select (|Map#Elements| v@@21) bx@@24) t1@@0 h@@9) ($IsAllocBox bx@@24 t0@@9 h@@9))) :qid |DafnyPre.242:19| :skolemid |65| :pattern ((MapType0Select (|Map#Elements| v@@21) bx@@24)) :pattern ((MapType0Select (|Map#Domain| v@@21) bx@@24))))) (=> (forall ((bx@@25 T@U)) (! (=> (and (= (type bx@@25) BoxType) (U_2_bool (MapType0Select (|Map#Domain| v@@21) bx@@25))) (and ($IsAllocBox (MapType0Select (|Map#Elements| v@@21) bx@@25) t1@@0 h@@9) ($IsAllocBox bx@@25 t0@@9 h@@9))) :qid |DafnyPre.242:19| :skolemid |65| :pattern ((MapType0Select (|Map#Elements| v@@21) bx@@25)) :pattern ((MapType0Select (|Map#Domain| v@@21) bx@@25)))) ($IsAlloc v@@21 (TMap t0@@9 t1@@0) h@@9)))) :qid |DafnyPre.239:15| :skolemid |66| :pattern (($IsAlloc v@@21 (TMap t0@@9 t1@@0) h@@9)))))
(assert (and (forall ((arg0@@46 T@U)) (! (let ((V@@0 (IMapTypeInv1 (type arg0@@46)))) (let ((U@@1 (IMapTypeInv0 (type arg0@@46)))) (= (type (|IMap#Elements| arg0@@46)) (MapType0Type U@@1 V@@0)))) :qid |funType:IMap#Elements| :pattern ((|IMap#Elements| arg0@@46)))) (forall ((arg0@@47 T@U)) (! (let ((U@@2 (IMapTypeInv0 (type arg0@@47)))) (= (type (|IMap#Domain| arg0@@47)) (MapType0Type U@@2 boolType))) :qid |funType:IMap#Domain| :pattern ((|IMap#Domain| arg0@@47))))))
(assert (forall ((v@@22 T@U) (t0@@10 T@U) (t1@@1 T@U)) (! (=> (and (and (= (type v@@22) (IMapType BoxType BoxType)) (= (type t0@@10) TyType)) (= (type t1@@1) TyType)) (and (=> ($Is v@@22 (TIMap t0@@10 t1@@1)) (forall ((bx@@26 T@U)) (! (=> (and (= (type bx@@26) BoxType) (U_2_bool (MapType0Select (|IMap#Domain| v@@22) bx@@26))) (and ($IsBox (MapType0Select (|IMap#Elements| v@@22) bx@@26) t1@@1) ($IsBox bx@@26 t0@@10))) :qid |DafnyPre.251:19| :skolemid |67| :pattern ((MapType0Select (|IMap#Elements| v@@22) bx@@26)) :pattern ((MapType0Select (|IMap#Domain| v@@22) bx@@26))))) (=> (forall ((bx@@27 T@U)) (! (=> (and (= (type bx@@27) BoxType) (U_2_bool (MapType0Select (|IMap#Domain| v@@22) bx@@27))) (and ($IsBox (MapType0Select (|IMap#Elements| v@@22) bx@@27) t1@@1) ($IsBox bx@@27 t0@@10))) :qid |DafnyPre.251:19| :skolemid |67| :pattern ((MapType0Select (|IMap#Elements| v@@22) bx@@27)) :pattern ((MapType0Select (|IMap#Domain| v@@22) bx@@27)))) ($Is v@@22 (TIMap t0@@10 t1@@1))))) :qid |DafnyPre.248:15| :skolemid |68| :pattern (($Is v@@22 (TIMap t0@@10 t1@@1))))))
(assert (forall ((v@@23 T@U) (t0@@11 T@U) (t1@@2 T@U) (h@@10 T@U)) (! (=> (and (and (and (= (type v@@23) (IMapType BoxType BoxType)) (= (type t0@@11) TyType)) (= (type t1@@2) TyType)) (= (type h@@10) (MapType1Type refType))) (and (=> ($IsAlloc v@@23 (TIMap t0@@11 t1@@2) h@@10) (forall ((bx@@28 T@U)) (! (=> (and (= (type bx@@28) BoxType) (U_2_bool (MapType0Select (|IMap#Domain| v@@23) bx@@28))) (and ($IsAllocBox (MapType0Select (|IMap#Elements| v@@23) bx@@28) t1@@2 h@@10) ($IsAllocBox bx@@28 t0@@11 h@@10))) :qid |DafnyPre.259:19| :skolemid |69| :pattern ((MapType0Select (|IMap#Elements| v@@23) bx@@28)) :pattern ((MapType0Select (|IMap#Domain| v@@23) bx@@28))))) (=> (forall ((bx@@29 T@U)) (! (=> (and (= (type bx@@29) BoxType) (U_2_bool (MapType0Select (|IMap#Domain| v@@23) bx@@29))) (and ($IsAllocBox (MapType0Select (|IMap#Elements| v@@23) bx@@29) t1@@2 h@@10) ($IsAllocBox bx@@29 t0@@11 h@@10))) :qid |DafnyPre.259:19| :skolemid |69| :pattern ((MapType0Select (|IMap#Elements| v@@23) bx@@29)) :pattern ((MapType0Select (|IMap#Domain| v@@23) bx@@29)))) ($IsAlloc v@@23 (TIMap t0@@11 t1@@2) h@@10)))) :qid |DafnyPre.256:15| :skolemid |70| :pattern (($IsAlloc v@@23 (TIMap t0@@11 t1@@2) h@@10)))))
(assert (and (and (forall ((arg0@@48 T@U) (arg1@@15 T@U)) (! (= (type (TypeTuple arg0@@48 arg1@@15)) ClassNameType) :qid |funType:TypeTuple| :pattern ((TypeTuple arg0@@48 arg1@@15)))) (forall ((arg0@@49 T@U)) (! (= (type (TypeTupleCar arg0@@49)) ClassNameType) :qid |funType:TypeTupleCar| :pattern ((TypeTupleCar arg0@@49))))) (forall ((arg0@@50 T@U)) (! (= (type (TypeTupleCdr arg0@@50)) ClassNameType) :qid |funType:TypeTupleCdr| :pattern ((TypeTupleCdr arg0@@50))))))
(assert (forall ((a T@U) (b T@U)) (! (=> (and (= (type a) ClassNameType) (= (type b) ClassNameType)) (and (= (TypeTupleCar (TypeTuple a b)) a) (= (TypeTupleCdr (TypeTuple a b)) b))) :qid |DafnyPre.284:15| :skolemid |71| :pattern ((TypeTuple a b)))))
(assert (forall ((arg0@@51 T@U)) (! (= (type (SetRef_to_SetBox arg0@@51)) (MapType0Type BoxType boolType)) :qid |funType:SetRef_to_SetBox| :pattern ((SetRef_to_SetBox arg0@@51)))))
(assert (forall ((s@@1 T@U) (bx@@30 T@U)) (! (=> (and (= (type s@@1) (MapType0Type refType boolType)) (= (type bx@@30) BoxType)) (and (=> (U_2_bool (MapType0Select (SetRef_to_SetBox s@@1) bx@@30)) (U_2_bool (MapType0Select s@@1 ($Unbox refType bx@@30)))) (=> (U_2_bool (MapType0Select s@@1 ($Unbox refType bx@@30))) (U_2_bool (MapType0Select (SetRef_to_SetBox s@@1) bx@@30))))) :qid |DafnyPre.293:15| :skolemid |72| :pattern ((MapType0Select (SetRef_to_SetBox s@@1) bx@@30)))))
(assert (= (type Tclass._System.object) TyType))
(assert (forall ((s@@2 T@U)) (! (=> (= (type s@@2) (MapType0Type refType boolType)) ($Is (SetRef_to_SetBox s@@2) (TSet Tclass._System.object))) :qid |DafnyPre.295:15| :skolemid |73| :pattern ((SetRef_to_SetBox s@@2)))))
(assert (= (Ctor DatatypeTypeType) 15))
(assert (forall ((d T@U)) (! (=> (= (type d) DatatypeTypeType) (= (BoxRank ($Box d)) (DtRank d))) :qid |DafnyPre.310:15| :skolemid |74| :pattern ((BoxRank ($Box d))))))
(assert (and (= (Ctor LayerTypeType) 16) (forall ((arg0@@52 T@U) (arg1@@16 T@U)) (! (let ((A (MapType0TypeInv1 (type arg0@@52)))) (= (type (AtLayer arg0@@52 arg1@@16)) A)) :qid |funType:AtLayer| :pattern ((AtLayer arg0@@52 arg1@@16))))))
(assert (forall ((f T@U) (ly T@U)) (! (let ((A@@0 (MapType0TypeInv1 (type f)))) (=> (and (= (type f) (MapType0Type LayerTypeType A@@0)) (= (type ly) LayerTypeType)) (= (AtLayer f ly) (MapType0Select f ly)))) :qid |DafnyPre.329:18| :skolemid |75| :pattern ((AtLayer f ly)))))
(assert (forall ((arg0@@53 T@U)) (! (= (type ($LS arg0@@53)) LayerTypeType) :qid |funType:$LS| :pattern (($LS arg0@@53)))))
(assert (forall ((f@@0 T@U) (ly@@0 T@U)) (! (let ((A@@1 (MapType0TypeInv1 (type f@@0)))) (=> (and (= (type f@@0) (MapType0Type LayerTypeType A@@1)) (= (type ly@@0) LayerTypeType)) (= (AtLayer f@@0 ($LS ly@@0)) (AtLayer f@@0 ly@@0)))) :qid |DafnyPre.330:18| :skolemid |76| :pattern ((AtLayer f@@0 ($LS ly@@0))))))
(assert (forall ((arg0@@54 Int)) (! (= (type (IndexField arg0@@54)) (FieldType BoxType)) :qid |funType:IndexField| :pattern ((IndexField arg0@@54)))))
(assert (forall ((i@@3 Int)) (! (= (FDim (IndexField i@@3)) 1) :qid |DafnyPre.341:15| :skolemid |77| :pattern ((IndexField i@@3)))))
(assert (forall ((i@@4 Int)) (! (= (IndexField_Inverse (IndexField i@@4)) i@@4) :qid |DafnyPre.343:15| :skolemid |78| :pattern ((IndexField i@@4)))))
(assert (forall ((arg0@@55 T@U) (arg1@@17 Int)) (! (= (type (MultiIndexField arg0@@55 arg1@@17)) (FieldType BoxType)) :qid |funType:MultiIndexField| :pattern ((MultiIndexField arg0@@55 arg1@@17)))))
(assert (forall ((f@@1 T@U) (i@@5 Int)) (! (=> (= (type f@@1) (FieldType BoxType)) (= (FDim (MultiIndexField f@@1 i@@5)) (+ (FDim f@@1) 1))) :qid |DafnyPre.346:15| :skolemid |79| :pattern ((MultiIndexField f@@1 i@@5)))))
(assert (forall ((arg0@@56 T@U)) (! (let ((T@@3 (FieldTypeInv0 (type arg0@@56)))) (= (type (MultiIndexField_Inverse0 arg0@@56)) (FieldType T@@3))) :qid |funType:MultiIndexField_Inverse0| :pattern ((MultiIndexField_Inverse0 arg0@@56)))))
(assert (forall ((f@@2 T@U) (i@@6 Int)) (! (=> (= (type f@@2) (FieldType BoxType)) (and (= (MultiIndexField_Inverse0 (MultiIndexField f@@2 i@@6)) f@@2) (= (MultiIndexField_Inverse1 (MultiIndexField f@@2 i@@6)) i@@6))) :qid |DafnyPre.349:15| :skolemid |80| :pattern ((MultiIndexField f@@2 i@@6)))))
(assert (and (and (and (= (Ctor NameFamilyType) 17) (forall ((alpha@@3 T@T) (arg0@@57 T@U) (arg1@@18 T@U)) (! (= (type (FieldOfDecl alpha@@3 arg0@@57 arg1@@18)) (FieldType alpha@@3)) :qid |funType:FieldOfDecl| :pattern ((FieldOfDecl alpha@@3 arg0@@57 arg1@@18))))) (forall ((arg0@@58 T@U)) (! (= (type (DeclType arg0@@58)) ClassNameType) :qid |funType:DeclType| :pattern ((DeclType arg0@@58))))) (forall ((arg0@@59 T@U)) (! (= (type (DeclName arg0@@59)) NameFamilyType) :qid |funType:DeclName| :pattern ((DeclName arg0@@59))))))
(assert (forall ((cl T@U) (nm T@U) (T@@4 T@T)) (! (=> (and (= (type cl) ClassNameType) (= (type nm) NameFamilyType)) (and (= (DeclType (FieldOfDecl T@@4 cl nm)) cl) (= (DeclName (FieldOfDecl T@@4 cl nm)) nm))) :qid |DafnyPre.358:18| :skolemid |81| :pattern ((FieldOfDecl T@@4 cl nm)))))
(assert (forall ((h@@11 T@U) (k T@U) (v@@24 T@U) (t@@21 T@U)) (! (=> (and (and (and (and (= (type h@@11) (MapType1Type refType)) (= (type k) (MapType1Type refType))) (= (type t@@21) TyType)) ($HeapSucc h@@11 k)) ($IsAlloc v@@24 t@@21 h@@11)) ($IsAlloc v@@24 t@@21 k)) :qid |DafnyPre.371:17| :skolemid |82| :pattern (($HeapSucc h@@11 k) ($IsAlloc v@@24 t@@21 h@@11)))))
(assert (forall ((h@@12 T@U) (k@@0 T@U) (bx@@31 T@U) (t@@22 T@U)) (! (=> (and (and (and (and (and (= (type h@@12) (MapType1Type refType)) (= (type k@@0) (MapType1Type refType))) (= (type bx@@31) BoxType)) (= (type t@@22) TyType)) ($HeapSucc h@@12 k@@0)) ($IsAllocBox bx@@31 t@@22 h@@12)) ($IsAllocBox bx@@31 t@@22 k@@0)) :qid |DafnyPre.374:14| :skolemid |83| :pattern (($HeapSucc h@@12 k@@0) ($IsAllocBox bx@@31 t@@22 h@@12)))))
(assert (= (FDim alloc) 0))
(assert (not ($IsGhostField alloc)))
(assert (forall ((o T@U)) (! (=> (= (type o) refType) (<= 0 (_System.array.Length o))) :qid |DafnyPre.388:15| :skolemid |84| :no-pattern (type o) :no-pattern (U_2_int o) :no-pattern (U_2_bool o))))
(assert (forall ((x@@12 Real)) (! (= (q@Int x@@12) (to_int x@@12)) :qid |DafnyPre.394:14| :skolemid |85| :pattern ((q@Int x@@12)))))
(assert (forall ((x@@13 Int)) (! (= (q@Real x@@13) (to_real x@@13)) :qid |DafnyPre.395:15| :skolemid |86| :pattern ((q@Real x@@13)))))
(assert (forall ((i@@7 Int)) (! (= (q@Int (q@Real i@@7)) i@@7) :qid |DafnyPre.396:15| :skolemid |87| :pattern ((q@Int (q@Real i@@7))))))
(assert (forall ((h@@13 T@U) (r T@U) (f@@3 T@U) (x@@14 T@U)) (! (let ((alpha@@4 (type x@@14))) (=> (and (and (and (= (type h@@13) (MapType1Type refType)) (= (type r) refType)) (= (type f@@3) (FieldType alpha@@4))) ($IsGoodHeap (MapType1Store h@@13 r f@@3 x@@14))) ($HeapSucc h@@13 (MapType1Store h@@13 r f@@3 x@@14)))) :qid |DafnyPre.413:22| :skolemid |88| :pattern ((MapType1Store h@@13 r f@@3 x@@14)))))
(assert (forall ((a@@0 T@U) (b@@0 T@U) (c T@U)) (! (=> (and (and (and (= (type a@@0) (MapType1Type refType)) (= (type b@@0) (MapType1Type refType))) (= (type c) (MapType1Type refType))) (and ($HeapSucc a@@0 b@@0) ($HeapSucc b@@0 c))) ($HeapSucc a@@0 c)) :qid |DafnyPre.416:15| :skolemid |89| :pattern (($HeapSucc a@@0 b@@0) ($HeapSucc b@@0 c)))))
(assert (forall ((h@@14 T@U) (k@@1 T@U)) (! (=> (and (and (= (type h@@14) (MapType1Type refType)) (= (type k@@1) (MapType1Type refType))) ($HeapSucc h@@14 k@@1)) (forall ((o@@0 T@U)) (! (=> (and (= (type o@@0) refType) (U_2_bool (MapType1Select h@@14 o@@0 alloc))) (U_2_bool (MapType1Select k@@1 o@@0 alloc))) :qid |DafnyPre.419:30| :skolemid |90| :pattern ((MapType1Select k@@1 o@@0 alloc))))) :qid |DafnyPre.418:15| :skolemid |91| :pattern (($HeapSucc h@@14 k@@1)))))
(assert (forall ((h@@15 T@U) (k@@2 T@U)) (! (=> (and (and (= (type h@@15) (MapType1Type refType)) (= (type k@@2) (MapType1Type refType))) ($HeapSuccGhost h@@15 k@@2)) (and ($HeapSucc h@@15 k@@2) (forall ((o@@1 T@U) (f@@4 T@U)) (! (let ((alpha@@5 (FieldTypeInv0 (type f@@4)))) (=> (and (and (= (type o@@1) refType) (= (type f@@4) (FieldType alpha@@5))) (not ($IsGhostField f@@4))) (= (MapType1Select h@@15 o@@1 f@@4) (MapType1Select k@@2 o@@1 f@@4)))) :qid |DafnyPre.425:20| :skolemid |92| :pattern ((MapType1Select k@@2 o@@1 f@@4)))))) :qid |DafnyPre.422:15| :skolemid |93| :pattern (($HeapSuccGhost h@@15 k@@2)))))
(assert (forall ((s@@3 T@U)) (! (let ((T@@5 (MapType0TypeInv0 (type s@@3)))) (=> (= (type s@@3) (MapType0Type T@@5 boolType)) (<= 0 (|Set#Card| s@@3)))) :qid |DafnyPre.483:18| :skolemid |98| :pattern ((|Set#Card| s@@3)))))
(assert (forall ((T@@6 T@T)) (! (= (type (|Set#Empty| T@@6)) (MapType0Type T@@6 boolType)) :qid |funType:Set#Empty| :pattern ((|Set#Empty| T@@6)))))
(assert (forall ((o@@2 T@U)) (! (let ((T@@7 (type o@@2))) (not (U_2_bool (MapType0Select (|Set#Empty| T@@7) o@@2)))) :qid |DafnyPre.486:18| :skolemid |99| :pattern ((let ((T@@7 (type o@@2))) (MapType0Select (|Set#Empty| T@@7) o@@2))))))
(assert (forall ((s@@4 T@U)) (! (let ((T@@8 (MapType0TypeInv0 (type s@@4)))) (=> (= (type s@@4) (MapType0Type T@@8 boolType)) (and (and (=> (= (|Set#Card| s@@4) 0) (= s@@4 (|Set#Empty| T@@8))) (=> (= s@@4 (|Set#Empty| T@@8)) (= (|Set#Card| s@@4) 0))) (=> (not (= (|Set#Card| s@@4) 0)) (exists ((x@@15 T@U)) (! (and (= (type x@@15) T@@8) (U_2_bool (MapType0Select s@@4 x@@15))) :qid |DafnyPre.489:33| :skolemid |100| :no-pattern (type x@@15) :no-pattern (U_2_int x@@15) :no-pattern (U_2_bool x@@15))))))) :qid |DafnyPre.487:18| :skolemid |101| :pattern ((|Set#Card| s@@4)))))
(assert (forall ((arg0@@60 T@U)) (! (let ((T@@9 (type arg0@@60))) (= (type (|Set#Singleton| arg0@@60)) (MapType0Type T@@9 boolType))) :qid |funType:Set#Singleton| :pattern ((|Set#Singleton| arg0@@60)))))
(assert (forall ((r@@0 T@U)) (! (U_2_bool (MapType0Select (|Set#Singleton| r@@0) r@@0)) :qid |DafnyPre.495:18| :skolemid |102| :pattern ((|Set#Singleton| r@@0)))))
(assert (forall ((r@@1 T@U) (o@@3 T@U)) (! (let ((T@@10 (type r@@1))) (=> (= (type o@@3) T@@10) (and (=> (U_2_bool (MapType0Select (|Set#Singleton| r@@1) o@@3)) (= r@@1 o@@3)) (=> (= r@@1 o@@3) (U_2_bool (MapType0Select (|Set#Singleton| r@@1) o@@3)))))) :qid |DafnyPre.496:18| :skolemid |103| :pattern ((MapType0Select (|Set#Singleton| r@@1) o@@3)))))
(assert (forall ((r@@2 T@U)) (! (= (|Set#Card| (|Set#Singleton| r@@2)) 1) :qid |DafnyPre.497:18| :skolemid |104| :pattern ((|Set#Card| (|Set#Singleton| r@@2))))))
(assert (forall ((arg0@@61 T@U) (arg1@@19 T@U)) (! (let ((T@@11 (type arg1@@19))) (= (type (|Set#UnionOne| arg0@@61 arg1@@19)) (MapType0Type T@@11 boolType))) :qid |funType:Set#UnionOne| :pattern ((|Set#UnionOne| arg0@@61 arg1@@19)))))
(assert (forall ((a@@1 T@U) (x@@16 T@U) (o@@4 T@U)) (! (let ((T@@12 (type x@@16))) (=> (and (= (type a@@1) (MapType0Type T@@12 boolType)) (= (type o@@4) T@@12)) (and (=> (U_2_bool (MapType0Select (|Set#UnionOne| a@@1 x@@16) o@@4)) (or (= o@@4 x@@16) (U_2_bool (MapType0Select a@@1 o@@4)))) (=> (or (= o@@4 x@@16) (U_2_bool (MapType0Select a@@1 o@@4))) (U_2_bool (MapType0Select (|Set#UnionOne| a@@1 x@@16) o@@4)))))) :qid |DafnyPre.500:18| :skolemid |105| :pattern ((MapType0Select (|Set#UnionOne| a@@1 x@@16) o@@4)))))
(assert (forall ((a@@2 T@U) (x@@17 T@U)) (! (let ((T@@13 (type x@@17))) (=> (= (type a@@2) (MapType0Type T@@13 boolType)) (U_2_bool (MapType0Select (|Set#UnionOne| a@@2 x@@17) x@@17)))) :qid |DafnyPre.502:18| :skolemid |106| :pattern ((|Set#UnionOne| a@@2 x@@17)))))
(assert (forall ((a@@3 T@U) (x@@18 T@U) (y@@1 T@U)) (! (let ((T@@14 (type x@@18))) (=> (and (and (= (type a@@3) (MapType0Type T@@14 boolType)) (= (type y@@1) T@@14)) (U_2_bool (MapType0Select a@@3 y@@1))) (U_2_bool (MapType0Select (|Set#UnionOne| a@@3 x@@18) y@@1)))) :qid |DafnyPre.504:18| :skolemid |107| :pattern ((|Set#UnionOne| a@@3 x@@18) (MapType0Select a@@3 y@@1)))))
(assert (forall ((a@@4 T@U) (x@@19 T@U)) (! (let ((T@@15 (type x@@19))) (=> (and (= (type a@@4) (MapType0Type T@@15 boolType)) (U_2_bool (MapType0Select a@@4 x@@19))) (= (|Set#Card| (|Set#UnionOne| a@@4 x@@19)) (|Set#Card| a@@4)))) :qid |DafnyPre.506:18| :skolemid |108| :pattern ((|Set#Card| (|Set#UnionOne| a@@4 x@@19))))))
(assert (forall ((a@@5 T@U) (x@@20 T@U)) (! (let ((T@@16 (type x@@20))) (=> (and (= (type a@@5) (MapType0Type T@@16 boolType)) (not (U_2_bool (MapType0Select a@@5 x@@20)))) (= (|Set#Card| (|Set#UnionOne| a@@5 x@@20)) (+ (|Set#Card| a@@5) 1)))) :qid |DafnyPre.508:18| :skolemid |109| :pattern ((|Set#Card| (|Set#UnionOne| a@@5 x@@20))))))
(assert (forall ((arg0@@62 T@U) (arg1@@20 T@U)) (! (let ((T@@17 (MapType0TypeInv0 (type arg0@@62)))) (= (type (|Set#Union| arg0@@62 arg1@@20)) (MapType0Type T@@17 boolType))) :qid |funType:Set#Union| :pattern ((|Set#Union| arg0@@62 arg1@@20)))))
(assert (forall ((a@@6 T@U) (b@@1 T@U) (o@@5 T@U)) (! (let ((T@@18 (type o@@5))) (=> (and (= (type a@@6) (MapType0Type T@@18 boolType)) (= (type b@@1) (MapType0Type T@@18 boolType))) (and (=> (U_2_bool (MapType0Select (|Set#Union| a@@6 b@@1) o@@5)) (or (U_2_bool (MapType0Select a@@6 o@@5)) (U_2_bool (MapType0Select b@@1 o@@5)))) (=> (or (U_2_bool (MapType0Select a@@6 o@@5)) (U_2_bool (MapType0Select b@@1 o@@5))) (U_2_bool (MapType0Select (|Set#Union| a@@6 b@@1) o@@5)))))) :qid |DafnyPre.512:18| :skolemid |110| :pattern ((MapType0Select (|Set#Union| a@@6 b@@1) o@@5)))))
(assert (forall ((a@@7 T@U) (b@@2 T@U) (y@@2 T@U)) (! (let ((T@@19 (type y@@2))) (=> (and (and (= (type a@@7) (MapType0Type T@@19 boolType)) (= (type b@@2) (MapType0Type T@@19 boolType))) (U_2_bool (MapType0Select a@@7 y@@2))) (U_2_bool (MapType0Select (|Set#Union| a@@7 b@@2) y@@2)))) :qid |DafnyPre.514:18| :skolemid |111| :pattern ((|Set#Union| a@@7 b@@2) (MapType0Select a@@7 y@@2)))))
(assert (forall ((a@@8 T@U) (b@@3 T@U) (y@@3 T@U)) (! (let ((T@@20 (type y@@3))) (=> (and (and (= (type a@@8) (MapType0Type T@@20 boolType)) (= (type b@@3) (MapType0Type T@@20 boolType))) (U_2_bool (MapType0Select b@@3 y@@3))) (U_2_bool (MapType0Select (|Set#Union| a@@8 b@@3) y@@3)))) :qid |DafnyPre.516:18| :skolemid |112| :pattern ((|Set#Union| a@@8 b@@3) (MapType0Select b@@3 y@@3)))))
(assert (forall ((arg0@@63 T@U) (arg1@@21 T@U)) (! (let ((T@@21 (MapType0TypeInv0 (type arg0@@63)))) (= (type (|Set#Difference| arg0@@63 arg1@@21)) (MapType0Type T@@21 boolType))) :qid |funType:Set#Difference| :pattern ((|Set#Difference| arg0@@63 arg1@@21)))))
(assert (forall ((a@@9 T@U) (b@@4 T@U)) (! (let ((T@@22 (MapType0TypeInv0 (type a@@9)))) (=> (and (and (= (type a@@9) (MapType0Type T@@22 boolType)) (= (type b@@4) (MapType0Type T@@22 boolType))) (|Set#Disjoint| a@@9 b@@4)) (and (= (|Set#Difference| (|Set#Union| a@@9 b@@4) a@@9) b@@4) (= (|Set#Difference| (|Set#Union| a@@9 b@@4) b@@4) a@@9)))) :qid |DafnyPre.518:18| :skolemid |113| :pattern ((|Set#Union| a@@9 b@@4)))))
(assert (forall ((arg0@@64 T@U) (arg1@@22 T@U)) (! (let ((T@@23 (MapType0TypeInv0 (type arg0@@64)))) (= (type (|Set#Intersection| arg0@@64 arg1@@22)) (MapType0Type T@@23 boolType))) :qid |funType:Set#Intersection| :pattern ((|Set#Intersection| arg0@@64 arg1@@22)))))
(assert (forall ((a@@10 T@U) (b@@5 T@U) (o@@6 T@U)) (! (let ((T@@24 (type o@@6))) (=> (and (= (type a@@10) (MapType0Type T@@24 boolType)) (= (type b@@5) (MapType0Type T@@24 boolType))) (and (=> (U_2_bool (MapType0Select (|Set#Intersection| a@@10 b@@5) o@@6)) (and (U_2_bool (MapType0Select a@@10 o@@6)) (U_2_bool (MapType0Select b@@5 o@@6)))) (=> (and (U_2_bool (MapType0Select a@@10 o@@6)) (U_2_bool (MapType0Select b@@5 o@@6))) (U_2_bool (MapType0Select (|Set#Intersection| a@@10 b@@5) o@@6)))))) :qid |DafnyPre.528:18| :skolemid |114| :pattern ((MapType0Select (|Set#Intersection| a@@10 b@@5) o@@6)))))
(assert (forall ((a@@11 T@U) (b@@6 T@U)) (! (let ((T@@25 (MapType0TypeInv0 (type a@@11)))) (=> (and (= (type a@@11) (MapType0Type T@@25 boolType)) (= (type b@@6) (MapType0Type T@@25 boolType))) (= (|Set#Union| (|Set#Union| a@@11 b@@6) b@@6) (|Set#Union| a@@11 b@@6)))) :qid |DafnyPre.531:18| :skolemid |115| :pattern ((|Set#Union| (|Set#Union| a@@11 b@@6) b@@6)))))
(assert (forall ((a@@12 T@U) (b@@7 T@U)) (! (let ((T@@26 (MapType0TypeInv0 (type a@@12)))) (=> (and (= (type a@@12) (MapType0Type T@@26 boolType)) (= (type b@@7) (MapType0Type T@@26 boolType))) (= (|Set#Union| a@@12 (|Set#Union| a@@12 b@@7)) (|Set#Union| a@@12 b@@7)))) :qid |DafnyPre.533:18| :skolemid |116| :pattern ((|Set#Union| a@@12 (|Set#Union| a@@12 b@@7))))))
(assert (forall ((a@@13 T@U) (b@@8 T@U)) (! (let ((T@@27 (MapType0TypeInv0 (type a@@13)))) (=> (and (= (type a@@13) (MapType0Type T@@27 boolType)) (= (type b@@8) (MapType0Type T@@27 boolType))) (= (|Set#Intersection| (|Set#Intersection| a@@13 b@@8) b@@8) (|Set#Intersection| a@@13 b@@8)))) :qid |DafnyPre.535:18| :skolemid |117| :pattern ((|Set#Intersection| (|Set#Intersection| a@@13 b@@8) b@@8)))))
(assert (forall ((a@@14 T@U) (b@@9 T@U)) (! (let ((T@@28 (MapType0TypeInv0 (type a@@14)))) (=> (and (= (type a@@14) (MapType0Type T@@28 boolType)) (= (type b@@9) (MapType0Type T@@28 boolType))) (= (|Set#Intersection| a@@14 (|Set#Intersection| a@@14 b@@9)) (|Set#Intersection| a@@14 b@@9)))) :qid |DafnyPre.537:18| :skolemid |118| :pattern ((|Set#Intersection| a@@14 (|Set#Intersection| a@@14 b@@9))))))
(assert (forall ((a@@15 T@U) (b@@10 T@U)) (! (let ((T@@29 (MapType0TypeInv0 (type a@@15)))) (=> (and (= (type a@@15) (MapType0Type T@@29 boolType)) (= (type b@@10) (MapType0Type T@@29 boolType))) (= (+ (|Set#Card| (|Set#Union| a@@15 b@@10)) (|Set#Card| (|Set#Intersection| a@@15 b@@10))) (+ (|Set#Card| a@@15) (|Set#Card| b@@10))))) :qid |DafnyPre.539:18| :skolemid |119| :pattern ((|Set#Card| (|Set#Union| a@@15 b@@10))) :pattern ((|Set#Card| (|Set#Intersection| a@@15 b@@10))))))
(assert (forall ((a@@16 T@U) (b@@11 T@U) (o@@7 T@U)) (! (let ((T@@30 (type o@@7))) (=> (and (= (type a@@16) (MapType0Type T@@30 boolType)) (= (type b@@11) (MapType0Type T@@30 boolType))) (and (=> (U_2_bool (MapType0Select (|Set#Difference| a@@16 b@@11) o@@7)) (and (U_2_bool (MapType0Select a@@16 o@@7)) (not (U_2_bool (MapType0Select b@@11 o@@7))))) (=> (and (U_2_bool (MapType0Select a@@16 o@@7)) (not (U_2_bool (MapType0Select b@@11 o@@7)))) (U_2_bool (MapType0Select (|Set#Difference| a@@16 b@@11) o@@7)))))) :qid |DafnyPre.543:18| :skolemid |120| :pattern ((MapType0Select (|Set#Difference| a@@16 b@@11) o@@7)))))
(assert (forall ((a@@17 T@U) (b@@12 T@U) (y@@4 T@U)) (! (let ((T@@31 (type y@@4))) (=> (and (and (= (type a@@17) (MapType0Type T@@31 boolType)) (= (type b@@12) (MapType0Type T@@31 boolType))) (U_2_bool (MapType0Select b@@12 y@@4))) (not (U_2_bool (MapType0Select (|Set#Difference| a@@17 b@@12) y@@4))))) :qid |DafnyPre.545:18| :skolemid |121| :pattern ((|Set#Difference| a@@17 b@@12) (MapType0Select b@@12 y@@4)))))
(assert (forall ((a@@18 T@U) (b@@13 T@U)) (! (let ((T@@32 (MapType0TypeInv0 (type a@@18)))) (=> (and (= (type a@@18) (MapType0Type T@@32 boolType)) (= (type b@@13) (MapType0Type T@@32 boolType))) (and (= (+ (+ (|Set#Card| (|Set#Difference| a@@18 b@@13)) (|Set#Card| (|Set#Difference| b@@13 a@@18))) (|Set#Card| (|Set#Intersection| a@@18 b@@13))) (|Set#Card| (|Set#Union| a@@18 b@@13))) (= (|Set#Card| (|Set#Difference| a@@18 b@@13)) (- (|Set#Card| a@@18) (|Set#Card| (|Set#Intersection| a@@18 b@@13))))))) :qid |DafnyPre.547:18| :skolemid |122| :pattern ((|Set#Card| (|Set#Difference| a@@18 b@@13))))))
(assert (forall ((a@@19 T@U) (b@@14 T@U)) (! (let ((T@@33 (MapType0TypeInv0 (type a@@19)))) (=> (and (= (type a@@19) (MapType0Type T@@33 boolType)) (= (type b@@14) (MapType0Type T@@33 boolType))) (and (=> (|Set#Subset| a@@19 b@@14) (forall ((o@@8 T@U)) (! (=> (and (= (type o@@8) T@@33) (U_2_bool (MapType0Select a@@19 o@@8))) (U_2_bool (MapType0Select b@@14 o@@8))) :qid |DafnyPre.556:32| :skolemid |123| :pattern ((MapType0Select a@@19 o@@8)) :pattern ((MapType0Select b@@14 o@@8))))) (=> (forall ((o@@9 T@U)) (! (=> (and (= (type o@@9) T@@33) (U_2_bool (MapType0Select a@@19 o@@9))) (U_2_bool (MapType0Select b@@14 o@@9))) :qid |DafnyPre.556:32| :skolemid |123| :pattern ((MapType0Select a@@19 o@@9)) :pattern ((MapType0Select b@@14 o@@9)))) (|Set#Subset| a@@19 b@@14))))) :qid |DafnyPre.555:17| :skolemid |124| :pattern ((|Set#Subset| a@@19 b@@14)))))
(assert (forall ((a@@20 T@U) (b@@15 T@U)) (! (let ((T@@34 (MapType0TypeInv0 (type a@@20)))) (=> (and (= (type a@@20) (MapType0Type T@@34 boolType)) (= (type b@@15) (MapType0Type T@@34 boolType))) (and (=> (|Set#Equal| a@@20 b@@15) (forall ((o@@10 T@U)) (! (=> (= (type o@@10) T@@34) (and (=> (U_2_bool (MapType0Select a@@20 o@@10)) (U_2_bool (MapType0Select b@@15 o@@10))) (=> (U_2_bool (MapType0Select b@@15 o@@10)) (U_2_bool (MapType0Select a@@20 o@@10))))) :qid |DafnyPre.564:31| :skolemid |125| :pattern ((MapType0Select a@@20 o@@10)) :pattern ((MapType0Select b@@15 o@@10))))) (=> (forall ((o@@11 T@U)) (! (=> (= (type o@@11) T@@34) (and (=> (U_2_bool (MapType0Select a@@20 o@@11)) (U_2_bool (MapType0Select b@@15 o@@11))) (=> (U_2_bool (MapType0Select b@@15 o@@11)) (U_2_bool (MapType0Select a@@20 o@@11))))) :qid |DafnyPre.564:31| :skolemid |125| :pattern ((MapType0Select a@@20 o@@11)) :pattern ((MapType0Select b@@15 o@@11)))) (|Set#Equal| a@@20 b@@15))))) :qid |DafnyPre.563:17| :skolemid |126| :pattern ((|Set#Equal| a@@20 b@@15)))))
(assert (forall ((a@@21 T@U) (b@@16 T@U)) (! (let ((T@@35 (MapType0TypeInv0 (type a@@21)))) (=> (and (and (= (type a@@21) (MapType0Type T@@35 boolType)) (= (type b@@16) (MapType0Type T@@35 boolType))) (|Set#Equal| a@@21 b@@16)) (= a@@21 b@@16))) :qid |DafnyPre.565:17| :skolemid |127| :pattern ((|Set#Equal| a@@21 b@@16)))))
(assert (forall ((a@@22 T@U) (b@@17 T@U)) (! (let ((T@@36 (MapType0TypeInv0 (type a@@22)))) (=> (and (= (type a@@22) (MapType0Type T@@36 boolType)) (= (type b@@17) (MapType0Type T@@36 boolType))) (and (=> (|Set#Disjoint| a@@22 b@@17) (forall ((o@@12 T@U)) (! (=> (= (type o@@12) T@@36) (or (not (U_2_bool (MapType0Select a@@22 o@@12))) (not (U_2_bool (MapType0Select b@@17 o@@12))))) :qid |DafnyPre.570:34| :skolemid |128| :pattern ((MapType0Select a@@22 o@@12)) :pattern ((MapType0Select b@@17 o@@12))))) (=> (forall ((o@@13 T@U)) (! (=> (= (type o@@13) T@@36) (or (not (U_2_bool (MapType0Select a@@22 o@@13))) (not (U_2_bool (MapType0Select b@@17 o@@13))))) :qid |DafnyPre.570:34| :skolemid |128| :pattern ((MapType0Select a@@22 o@@13)) :pattern ((MapType0Select b@@17 o@@13)))) (|Set#Disjoint| a@@22 b@@17))))) :qid |DafnyPre.569:18| :skolemid |129| :pattern ((|Set#Disjoint| a@@22 b@@17)))))
(assert (forall ((T@@37 T@T)) (! (= (type (|ISet#Empty| T@@37)) (MapType0Type T@@37 boolType)) :qid |funType:ISet#Empty| :pattern ((|ISet#Empty| T@@37)))))
(assert (forall ((o@@14 T@U)) (! (let ((T@@38 (type o@@14))) (not (U_2_bool (MapType0Select (|ISet#Empty| T@@38) o@@14)))) :qid |DafnyPre.579:18| :skolemid |130| :pattern ((let ((T@@38 (type o@@14))) (MapType0Select (|ISet#Empty| T@@38) o@@14))))))
(assert (forall ((arg0@@65 T@U) (arg1@@23 T@U)) (! (let ((T@@39 (type arg1@@23))) (= (type (|ISet#UnionOne| arg0@@65 arg1@@23)) (MapType0Type T@@39 boolType))) :qid |funType:ISet#UnionOne| :pattern ((|ISet#UnionOne| arg0@@65 arg1@@23)))))
(assert (forall ((a@@23 T@U) (x@@21 T@U) (o@@15 T@U)) (! (let ((T@@40 (type x@@21))) (=> (and (= (type a@@23) (MapType0Type T@@40 boolType)) (= (type o@@15) T@@40)) (and (=> (U_2_bool (MapType0Select (|ISet#UnionOne| a@@23 x@@21) o@@15)) (or (= o@@15 x@@21) (U_2_bool (MapType0Select a@@23 o@@15)))) (=> (or (= o@@15 x@@21) (U_2_bool (MapType0Select a@@23 o@@15))) (U_2_bool (MapType0Select (|ISet#UnionOne| a@@23 x@@21) o@@15)))))) :qid |DafnyPre.586:18| :skolemid |131| :pattern ((MapType0Select (|ISet#UnionOne| a@@23 x@@21) o@@15)))))
(assert (forall ((a@@24 T@U) (x@@22 T@U)) (! (let ((T@@41 (type x@@22))) (=> (= (type a@@24) (MapType0Type T@@41 boolType)) (U_2_bool (MapType0Select (|ISet#UnionOne| a@@24 x@@22) x@@22)))) :qid |DafnyPre.588:18| :skolemid |132| :pattern ((|ISet#UnionOne| a@@24 x@@22)))))
(assert (forall ((a@@25 T@U) (x@@23 T@U) (y@@5 T@U)) (! (let ((T@@42 (type x@@23))) (=> (and (and (= (type a@@25) (MapType0Type T@@42 boolType)) (= (type y@@5) T@@42)) (U_2_bool (MapType0Select a@@25 y@@5))) (U_2_bool (MapType0Select (|ISet#UnionOne| a@@25 x@@23) y@@5)))) :qid |DafnyPre.590:18| :skolemid |133| :pattern ((|ISet#UnionOne| a@@25 x@@23) (MapType0Select a@@25 y@@5)))))
(assert (forall ((arg0@@66 T@U) (arg1@@24 T@U)) (! (let ((T@@43 (MapType0TypeInv0 (type arg0@@66)))) (= (type (|ISet#Union| arg0@@66 arg1@@24)) (MapType0Type T@@43 boolType))) :qid |funType:ISet#Union| :pattern ((|ISet#Union| arg0@@66 arg1@@24)))))
(assert (forall ((a@@26 T@U) (b@@18 T@U) (o@@16 T@U)) (! (let ((T@@44 (type o@@16))) (=> (and (= (type a@@26) (MapType0Type T@@44 boolType)) (= (type b@@18) (MapType0Type T@@44 boolType))) (and (=> (U_2_bool (MapType0Select (|ISet#Union| a@@26 b@@18) o@@16)) (or (U_2_bool (MapType0Select a@@26 o@@16)) (U_2_bool (MapType0Select b@@18 o@@16)))) (=> (or (U_2_bool (MapType0Select a@@26 o@@16)) (U_2_bool (MapType0Select b@@18 o@@16))) (U_2_bool (MapType0Select (|ISet#Union| a@@26 b@@18) o@@16)))))) :qid |DafnyPre.594:18| :skolemid |134| :pattern ((MapType0Select (|ISet#Union| a@@26 b@@18) o@@16)))))
(assert (forall ((a@@27 T@U) (b@@19 T@U) (y@@6 T@U)) (! (let ((T@@45 (type y@@6))) (=> (and (and (= (type a@@27) (MapType0Type T@@45 boolType)) (= (type b@@19) (MapType0Type T@@45 boolType))) (U_2_bool (MapType0Select a@@27 y@@6))) (U_2_bool (MapType0Select (|ISet#Union| a@@27 b@@19) y@@6)))) :qid |DafnyPre.596:18| :skolemid |135| :pattern ((|ISet#Union| a@@27 b@@19) (MapType0Select a@@27 y@@6)))))
(assert (forall ((a@@28 T@U) (b@@20 T@U) (y@@7 T@U)) (! (let ((T@@46 (type y@@7))) (=> (and (and (= (type a@@28) (MapType0Type T@@46 boolType)) (= (type b@@20) (MapType0Type T@@46 boolType))) (U_2_bool (MapType0Select b@@20 y@@7))) (U_2_bool (MapType0Select (|ISet#Union| a@@28 b@@20) y@@7)))) :qid |DafnyPre.598:18| :skolemid |136| :pattern ((|ISet#Union| a@@28 b@@20) (MapType0Select b@@20 y@@7)))))
(assert (forall ((arg0@@67 T@U) (arg1@@25 T@U)) (! (let ((T@@47 (MapType0TypeInv0 (type arg0@@67)))) (= (type (|ISet#Difference| arg0@@67 arg1@@25)) (MapType0Type T@@47 boolType))) :qid |funType:ISet#Difference| :pattern ((|ISet#Difference| arg0@@67 arg1@@25)))))
(assert (forall ((a@@29 T@U) (b@@21 T@U)) (! (let ((T@@48 (MapType0TypeInv0 (type a@@29)))) (=> (and (and (= (type a@@29) (MapType0Type T@@48 boolType)) (= (type b@@21) (MapType0Type T@@48 boolType))) (|ISet#Disjoint| a@@29 b@@21)) (and (= (|ISet#Difference| (|ISet#Union| a@@29 b@@21) a@@29) b@@21) (= (|ISet#Difference| (|ISet#Union| a@@29 b@@21) b@@21) a@@29)))) :qid |DafnyPre.600:18| :skolemid |137| :pattern ((|ISet#Union| a@@29 b@@21)))))
(assert (forall ((arg0@@68 T@U) (arg1@@26 T@U)) (! (let ((T@@49 (MapType0TypeInv0 (type arg0@@68)))) (= (type (|ISet#Intersection| arg0@@68 arg1@@26)) (MapType0Type T@@49 boolType))) :qid |funType:ISet#Intersection| :pattern ((|ISet#Intersection| arg0@@68 arg1@@26)))))
(assert (forall ((a@@30 T@U) (b@@22 T@U) (o@@17 T@U)) (! (let ((T@@50 (type o@@17))) (=> (and (= (type a@@30) (MapType0Type T@@50 boolType)) (= (type b@@22) (MapType0Type T@@50 boolType))) (and (=> (U_2_bool (MapType0Select (|ISet#Intersection| a@@30 b@@22) o@@17)) (and (U_2_bool (MapType0Select a@@30 o@@17)) (U_2_bool (MapType0Select b@@22 o@@17)))) (=> (and (U_2_bool (MapType0Select a@@30 o@@17)) (U_2_bool (MapType0Select b@@22 o@@17))) (U_2_bool (MapType0Select (|ISet#Intersection| a@@30 b@@22) o@@17)))))) :qid |DafnyPre.610:18| :skolemid |138| :pattern ((MapType0Select (|ISet#Intersection| a@@30 b@@22) o@@17)))))
(assert (forall ((a@@31 T@U) (b@@23 T@U)) (! (let ((T@@51 (MapType0TypeInv0 (type a@@31)))) (=> (and (= (type a@@31) (MapType0Type T@@51 boolType)) (= (type b@@23) (MapType0Type T@@51 boolType))) (= (|ISet#Union| (|ISet#Union| a@@31 b@@23) b@@23) (|ISet#Union| a@@31 b@@23)))) :qid |DafnyPre.613:18| :skolemid |139| :pattern ((|ISet#Union| (|ISet#Union| a@@31 b@@23) b@@23)))))
(assert (forall ((a@@32 T@U) (b@@24 T@U)) (! (let ((T@@52 (MapType0TypeInv0 (type a@@32)))) (=> (and (= (type a@@32) (MapType0Type T@@52 boolType)) (= (type b@@24) (MapType0Type T@@52 boolType))) (= (|ISet#Union| a@@32 (|ISet#Union| a@@32 b@@24)) (|ISet#Union| a@@32 b@@24)))) :qid |DafnyPre.615:18| :skolemid |140| :pattern ((|ISet#Union| a@@32 (|ISet#Union| a@@32 b@@24))))))
(assert (forall ((a@@33 T@U) (b@@25 T@U)) (! (let ((T@@53 (MapType0TypeInv0 (type a@@33)))) (=> (and (= (type a@@33) (MapType0Type T@@53 boolType)) (= (type b@@25) (MapType0Type T@@53 boolType))) (= (|ISet#Intersection| (|ISet#Intersection| a@@33 b@@25) b@@25) (|ISet#Intersection| a@@33 b@@25)))) :qid |DafnyPre.617:18| :skolemid |141| :pattern ((|ISet#Intersection| (|ISet#Intersection| a@@33 b@@25) b@@25)))))
(assert (forall ((a@@34 T@U) (b@@26 T@U)) (! (let ((T@@54 (MapType0TypeInv0 (type a@@34)))) (=> (and (= (type a@@34) (MapType0Type T@@54 boolType)) (= (type b@@26) (MapType0Type T@@54 boolType))) (= (|ISet#Intersection| a@@34 (|ISet#Intersection| a@@34 b@@26)) (|ISet#Intersection| a@@34 b@@26)))) :qid |DafnyPre.619:18| :skolemid |142| :pattern ((|ISet#Intersection| a@@34 (|ISet#Intersection| a@@34 b@@26))))))
(assert (forall ((a@@35 T@U) (b@@27 T@U) (o@@18 T@U)) (! (let ((T@@55 (type o@@18))) (=> (and (= (type a@@35) (MapType0Type T@@55 boolType)) (= (type b@@27) (MapType0Type T@@55 boolType))) (and (=> (U_2_bool (MapType0Select (|ISet#Difference| a@@35 b@@27) o@@18)) (and (U_2_bool (MapType0Select a@@35 o@@18)) (not (U_2_bool (MapType0Select b@@27 o@@18))))) (=> (and (U_2_bool (MapType0Select a@@35 o@@18)) (not (U_2_bool (MapType0Select b@@27 o@@18)))) (U_2_bool (MapType0Select (|ISet#Difference| a@@35 b@@27) o@@18)))))) :qid |DafnyPre.624:18| :skolemid |143| :pattern ((MapType0Select (|ISet#Difference| a@@35 b@@27) o@@18)))))
(assert (forall ((a@@36 T@U) (b@@28 T@U) (y@@8 T@U)) (! (let ((T@@56 (type y@@8))) (=> (and (and (= (type a@@36) (MapType0Type T@@56 boolType)) (= (type b@@28) (MapType0Type T@@56 boolType))) (U_2_bool (MapType0Select b@@28 y@@8))) (not (U_2_bool (MapType0Select (|ISet#Difference| a@@36 b@@28) y@@8))))) :qid |DafnyPre.626:18| :skolemid |144| :pattern ((|ISet#Difference| a@@36 b@@28) (MapType0Select b@@28 y@@8)))))
(assert (forall ((a@@37 T@U) (b@@29 T@U)) (! (let ((T@@57 (MapType0TypeInv0 (type a@@37)))) (=> (and (= (type a@@37) (MapType0Type T@@57 boolType)) (= (type b@@29) (MapType0Type T@@57 boolType))) (and (=> (|ISet#Subset| a@@37 b@@29) (forall ((o@@19 T@U)) (! (=> (and (= (type o@@19) T@@57) (U_2_bool (MapType0Select a@@37 o@@19))) (U_2_bool (MapType0Select b@@29 o@@19))) :qid |DafnyPre.631:33| :skolemid |145| :pattern ((MapType0Select a@@37 o@@19)) :pattern ((MapType0Select b@@29 o@@19))))) (=> (forall ((o@@20 T@U)) (! (=> (and (= (type o@@20) T@@57) (U_2_bool (MapType0Select a@@37 o@@20))) (U_2_bool (MapType0Select b@@29 o@@20))) :qid |DafnyPre.631:33| :skolemid |145| :pattern ((MapType0Select a@@37 o@@20)) :pattern ((MapType0Select b@@29 o@@20)))) (|ISet#Subset| a@@37 b@@29))))) :qid |DafnyPre.630:17| :skolemid |146| :pattern ((|ISet#Subset| a@@37 b@@29)))))
(assert (forall ((a@@38 T@U) (b@@30 T@U)) (! (let ((T@@58 (MapType0TypeInv0 (type a@@38)))) (=> (and (= (type a@@38) (MapType0Type T@@58 boolType)) (= (type b@@30) (MapType0Type T@@58 boolType))) (and (=> (|ISet#Equal| a@@38 b@@30) (forall ((o@@21 T@U)) (! (=> (= (type o@@21) T@@58) (and (=> (U_2_bool (MapType0Select a@@38 o@@21)) (U_2_bool (MapType0Select b@@30 o@@21))) (=> (U_2_bool (MapType0Select b@@30 o@@21)) (U_2_bool (MapType0Select a@@38 o@@21))))) :qid |DafnyPre.639:32| :skolemid |147| :pattern ((MapType0Select a@@38 o@@21)) :pattern ((MapType0Select b@@30 o@@21))))) (=> (forall ((o@@22 T@U)) (! (=> (= (type o@@22) T@@58) (and (=> (U_2_bool (MapType0Select a@@38 o@@22)) (U_2_bool (MapType0Select b@@30 o@@22))) (=> (U_2_bool (MapType0Select b@@30 o@@22)) (U_2_bool (MapType0Select a@@38 o@@22))))) :qid |DafnyPre.639:32| :skolemid |147| :pattern ((MapType0Select a@@38 o@@22)) :pattern ((MapType0Select b@@30 o@@22)))) (|ISet#Equal| a@@38 b@@30))))) :qid |DafnyPre.638:17| :skolemid |148| :pattern ((|ISet#Equal| a@@38 b@@30)))))
(assert (forall ((a@@39 T@U) (b@@31 T@U)) (! (let ((T@@59 (MapType0TypeInv0 (type a@@39)))) (=> (and (and (= (type a@@39) (MapType0Type T@@59 boolType)) (= (type b@@31) (MapType0Type T@@59 boolType))) (|ISet#Equal| a@@39 b@@31)) (= a@@39 b@@31))) :qid |DafnyPre.640:17| :skolemid |149| :pattern ((|ISet#Equal| a@@39 b@@31)))))
(assert (forall ((a@@40 T@U) (b@@32 T@U)) (! (let ((T@@60 (MapType0TypeInv0 (type a@@40)))) (=> (and (= (type a@@40) (MapType0Type T@@60 boolType)) (= (type b@@32) (MapType0Type T@@60 boolType))) (and (=> (|ISet#Disjoint| a@@40 b@@32) (forall ((o@@23 T@U)) (! (=> (= (type o@@23) T@@60) (or (not (U_2_bool (MapType0Select a@@40 o@@23))) (not (U_2_bool (MapType0Select b@@32 o@@23))))) :qid |DafnyPre.645:35| :skolemid |150| :pattern ((MapType0Select a@@40 o@@23)) :pattern ((MapType0Select b@@32 o@@23))))) (=> (forall ((o@@24 T@U)) (! (=> (= (type o@@24) T@@60) (or (not (U_2_bool (MapType0Select a@@40 o@@24))) (not (U_2_bool (MapType0Select b@@32 o@@24))))) :qid |DafnyPre.645:35| :skolemid |150| :pattern ((MapType0Select a@@40 o@@24)) :pattern ((MapType0Select b@@32 o@@24)))) (|ISet#Disjoint| a@@40 b@@32))))) :qid |DafnyPre.644:18| :skolemid |151| :pattern ((|ISet#Disjoint| a@@40 b@@32)))))
(assert (forall ((a@@41 Int) (b@@33 Int)) (! (and (=> (<= a@@41 b@@33) (= (|Math#min| a@@41 b@@33) a@@41)) (=> (= (|Math#min| a@@41 b@@33) a@@41) (<= a@@41 b@@33))) :qid |DafnyPre.652:15| :skolemid |152| :pattern ((|Math#min| a@@41 b@@33)))))
(assert (forall ((a@@42 Int) (b@@34 Int)) (! (and (=> (<= b@@34 a@@42) (= (|Math#min| a@@42 b@@34) b@@34)) (=> (= (|Math#min| a@@42 b@@34) b@@34) (<= b@@34 a@@42))) :qid |DafnyPre.653:15| :skolemid |153| :pattern ((|Math#min| a@@42 b@@34)))))
(assert (forall ((a@@43 Int) (b@@35 Int)) (! (or (= (|Math#min| a@@43 b@@35) a@@43) (= (|Math#min| a@@43 b@@35) b@@35)) :qid |DafnyPre.654:15| :skolemid |154| :pattern ((|Math#min| a@@43 b@@35)))))
(assert (forall ((a@@44 Int)) (! (=> (<= 0 a@@44) (= (|Math#clip| a@@44) a@@44)) :qid |DafnyPre.657:15| :skolemid |155| :pattern ((|Math#clip| a@@44)))))
(assert (forall ((a@@45 Int)) (! (=> (< a@@45 0) (= (|Math#clip| a@@45) 0)) :qid |DafnyPre.658:15| :skolemid |156| :pattern ((|Math#clip| a@@45)))))
(assert (forall ((ms T@U)) (! (let ((T@@61 (MapType0TypeInv0 (type ms)))) (=> (= (type ms) (MapType0Type T@@61 intType)) (and (=> ($IsGoodMultiSet ms) (forall ((bx@@32 T@U)) (! (=> (= (type bx@@32) T@@61) (and (<= 0 (U_2_int (MapType0Select ms bx@@32))) (<= (U_2_int (MapType0Select ms bx@@32)) (|MultiSet#Card| ms)))) :qid |DafnyPre.666:11| :skolemid |157| :pattern ((MapType0Select ms bx@@32))))) (=> (forall ((bx@@33 T@U)) (! (=> (= (type bx@@33) T@@61) (and (<= 0 (U_2_int (MapType0Select ms bx@@33))) (<= (U_2_int (MapType0Select ms bx@@33)) (|MultiSet#Card| ms)))) :qid |DafnyPre.666:11| :skolemid |157| :pattern ((MapType0Select ms bx@@33)))) ($IsGoodMultiSet ms))))) :qid |DafnyPre.664:18| :skolemid |158| :pattern (($IsGoodMultiSet ms)))))
(assert (forall ((s@@5 T@U)) (! (let ((T@@62 (MapType0TypeInv0 (type s@@5)))) (=> (= (type s@@5) (MapType0Type T@@62 intType)) (<= 0 (|MultiSet#Card| s@@5)))) :qid |DafnyPre.669:18| :skolemid |159| :pattern ((|MultiSet#Card| s@@5)))))
(assert (forall ((s@@6 T@U) (x@@24 T@U) (n@@0 T@U)) (! (let ((T@@63 (type x@@24))) (=> (and (and (= (type s@@6) (MapType0Type T@@63 intType)) (= (type n@@0) intType)) (<= 0 (U_2_int n@@0))) (= (|MultiSet#Card| (MapType0Store s@@6 x@@24 n@@0)) (+ (- (|MultiSet#Card| s@@6) (U_2_int (MapType0Select s@@6 x@@24))) (U_2_int n@@0))))) :qid |DafnyPre.670:18| :skolemid |160| :pattern ((|MultiSet#Card| (MapType0Store s@@6 x@@24 n@@0))))))
(assert (forall ((T@@64 T@T)) (! (= (type (|MultiSet#Empty| T@@64)) (MapType0Type T@@64 intType)) :qid |funType:MultiSet#Empty| :pattern ((|MultiSet#Empty| T@@64)))))
(assert (forall ((o@@25 T@U)) (! (let ((T@@65 (type o@@25))) (= (U_2_int (MapType0Select (|MultiSet#Empty| T@@65) o@@25)) 0)) :qid |DafnyPre.674:18| :skolemid |161| :pattern ((let ((T@@65 (type o@@25))) (MapType0Select (|MultiSet#Empty| T@@65) o@@25))))))
(assert (forall ((s@@7 T@U)) (! (let ((T@@66 (MapType0TypeInv0 (type s@@7)))) (=> (= (type s@@7) (MapType0Type T@@66 intType)) (and (and (=> (= (|MultiSet#Card| s@@7) 0) (= s@@7 (|MultiSet#Empty| T@@66))) (=> (= s@@7 (|MultiSet#Empty| T@@66)) (= (|MultiSet#Card| s@@7) 0))) (=> (not (= (|MultiSet#Card| s@@7) 0)) (exists ((x@@25 T@U)) (! (and (= (type x@@25) T@@66) (< 0 (U_2_int (MapType0Select s@@7 x@@25)))) :qid |DafnyPre.677:38| :skolemid |162| :no-pattern (type x@@25) :no-pattern (U_2_int x@@25) :no-pattern (U_2_bool x@@25))))))) :qid |DafnyPre.675:18| :skolemid |163| :pattern ((|MultiSet#Card| s@@7)))))
(assert (forall ((arg0@@69 T@U)) (! (let ((T@@67 (type arg0@@69))) (= (type (|MultiSet#Singleton| arg0@@69)) (MapType0Type T@@67 intType))) :qid |funType:MultiSet#Singleton| :pattern ((|MultiSet#Singleton| arg0@@69)))))
(assert (forall ((r@@3 T@U) (o@@26 T@U)) (! (let ((T@@68 (type r@@3))) (=> (= (type o@@26) T@@68) (and (and (=> (= (U_2_int (MapType0Select (|MultiSet#Singleton| r@@3) o@@26)) 1) (= r@@3 o@@26)) (=> (= r@@3 o@@26) (= (U_2_int (MapType0Select (|MultiSet#Singleton| r@@3) o@@26)) 1))) (and (=> (= (U_2_int (MapType0Select (|MultiSet#Singleton| r@@3) o@@26)) 0) (not (= r@@3 o@@26))) (=> (not (= r@@3 o@@26)) (= (U_2_int (MapType0Select (|MultiSet#Singleton| r@@3) o@@26)) 0)))))) :qid |DafnyPre.680:18| :skolemid |164| :pattern ((MapType0Select (|MultiSet#Singleton| r@@3) o@@26)))))
(assert (forall ((arg0@@70 T@U) (arg1@@27 T@U)) (! (let ((T@@69 (type arg1@@27))) (= (type (|MultiSet#UnionOne| arg0@@70 arg1@@27)) (MapType0Type T@@69 intType))) :qid |funType:MultiSet#UnionOne| :pattern ((|MultiSet#UnionOne| arg0@@70 arg1@@27)))))
(assert (forall ((r@@4 T@U)) (! (let ((T@@70 (type r@@4))) (= (|MultiSet#Singleton| r@@4) (|MultiSet#UnionOne| (|MultiSet#Empty| T@@70) r@@4))) :qid |DafnyPre.682:18| :skolemid |165| :pattern ((|MultiSet#Singleton| r@@4)))))
(assert (forall ((a@@46 T@U) (x@@26 T@U) (o@@27 T@U)) (! (let ((T@@71 (type x@@26))) (=> (and (= (type a@@46) (MapType0Type T@@71 intType)) (= (type o@@27) T@@71)) (and (=> (< 0 (U_2_int (MapType0Select (|MultiSet#UnionOne| a@@46 x@@26) o@@27))) (or (= o@@27 x@@26) (< 0 (U_2_int (MapType0Select a@@46 o@@27))))) (=> (or (= o@@27 x@@26) (< 0 (U_2_int (MapType0Select a@@46 o@@27)))) (< 0 (U_2_int (MapType0Select (|MultiSet#UnionOne| a@@46 x@@26) o@@27))))))) :qid |DafnyPre.686:18| :skolemid |166| :pattern ((MapType0Select (|MultiSet#UnionOne| a@@46 x@@26) o@@27)))))
(assert (forall ((a@@47 T@U) (x@@27 T@U)) (! (let ((T@@72 (type x@@27))) (=> (= (type a@@47) (MapType0Type T@@72 intType)) (= (U_2_int (MapType0Select (|MultiSet#UnionOne| a@@47 x@@27) x@@27)) (+ (U_2_int (MapType0Select a@@47 x@@27)) 1)))) :qid |DafnyPre.689:18| :skolemid |167| :pattern ((|MultiSet#UnionOne| a@@47 x@@27)))))
(assert (forall ((a@@48 T@U) (x@@28 T@U) (y@@9 T@U)) (! (let ((T@@73 (type x@@28))) (=> (and (and (= (type a@@48) (MapType0Type T@@73 intType)) (= (type y@@9) T@@73)) (< 0 (U_2_int (MapType0Select a@@48 y@@9)))) (< 0 (U_2_int (MapType0Select (|MultiSet#UnionOne| a@@48 x@@28) y@@9))))) :qid |DafnyPre.692:18| :skolemid |168| :pattern ((|MultiSet#UnionOne| a@@48 x@@28) (MapType0Select a@@48 y@@9)))))
(assert (forall ((a@@49 T@U) (x@@29 T@U) (y@@10 T@U)) (! (let ((T@@74 (type x@@29))) (=> (and (and (= (type a@@49) (MapType0Type T@@74 intType)) (= (type y@@10) T@@74)) (not (= x@@29 y@@10))) (= (U_2_int (MapType0Select a@@49 y@@10)) (U_2_int (MapType0Select (|MultiSet#UnionOne| a@@49 x@@29) y@@10))))) :qid |DafnyPre.695:18| :skolemid |169| :pattern ((|MultiSet#UnionOne| a@@49 x@@29) (MapType0Select a@@49 y@@10)))))
(assert (forall ((a@@50 T@U) (x@@30 T@U)) (! (let ((T@@75 (type x@@30))) (=> (= (type a@@50) (MapType0Type T@@75 intType)) (= (|MultiSet#Card| (|MultiSet#UnionOne| a@@50 x@@30)) (+ (|MultiSet#Card| a@@50) 1)))) :qid |DafnyPre.697:18| :skolemid |170| :pattern ((|MultiSet#Card| (|MultiSet#UnionOne| a@@50 x@@30))))))
(assert (forall ((arg0@@71 T@U) (arg1@@28 T@U)) (! (let ((T@@76 (MapType0TypeInv0 (type arg0@@71)))) (= (type (|MultiSet#Union| arg0@@71 arg1@@28)) (MapType0Type T@@76 intType))) :qid |funType:MultiSet#Union| :pattern ((|MultiSet#Union| arg0@@71 arg1@@28)))))
(assert (forall ((a@@51 T@U) (b@@36 T@U) (o@@28 T@U)) (! (let ((T@@77 (type o@@28))) (=> (and (= (type a@@51) (MapType0Type T@@77 intType)) (= (type b@@36) (MapType0Type T@@77 intType))) (= (U_2_int (MapType0Select (|MultiSet#Union| a@@51 b@@36) o@@28)) (+ (U_2_int (MapType0Select a@@51 o@@28)) (U_2_int (MapType0Select b@@36 o@@28)))))) :qid |DafnyPre.703:18| :skolemid |171| :pattern ((MapType0Select (|MultiSet#Union| a@@51 b@@36) o@@28)))))
(assert (forall ((a@@52 T@U) (b@@37 T@U)) (! (let ((T@@78 (MapType0TypeInv0 (type a@@52)))) (=> (and (= (type a@@52) (MapType0Type T@@78 intType)) (= (type b@@37) (MapType0Type T@@78 intType))) (= (|MultiSet#Card| (|MultiSet#Union| a@@52 b@@37)) (+ (|MultiSet#Card| a@@52) (|MultiSet#Card| b@@37))))) :qid |DafnyPre.705:18| :skolemid |172| :pattern ((|MultiSet#Card| (|MultiSet#Union| a@@52 b@@37))))))
(assert (forall ((arg0@@72 T@U) (arg1@@29 T@U)) (! (let ((T@@79 (MapType0TypeInv0 (type arg0@@72)))) (= (type (|MultiSet#Intersection| arg0@@72 arg1@@29)) (MapType0Type T@@79 intType))) :qid |funType:MultiSet#Intersection| :pattern ((|MultiSet#Intersection| arg0@@72 arg1@@29)))))
(assert (forall ((a@@53 T@U) (b@@38 T@U) (o@@29 T@U)) (! (let ((T@@80 (type o@@29))) (=> (and (= (type a@@53) (MapType0Type T@@80 intType)) (= (type b@@38) (MapType0Type T@@80 intType))) (= (U_2_int (MapType0Select (|MultiSet#Intersection| a@@53 b@@38) o@@29)) (|Math#min| (U_2_int (MapType0Select a@@53 o@@29)) (U_2_int (MapType0Select b@@38 o@@29)))))) :qid |DafnyPre.709:18| :skolemid |173| :pattern ((MapType0Select (|MultiSet#Intersection| a@@53 b@@38) o@@29)))))
(assert (forall ((a@@54 T@U) (b@@39 T@U)) (! (let ((T@@81 (MapType0TypeInv0 (type a@@54)))) (=> (and (= (type a@@54) (MapType0Type T@@81 intType)) (= (type b@@39) (MapType0Type T@@81 intType))) (= (|MultiSet#Intersection| (|MultiSet#Intersection| a@@54 b@@39) b@@39) (|MultiSet#Intersection| a@@54 b@@39)))) :qid |DafnyPre.713:18| :skolemid |174| :pattern ((|MultiSet#Intersection| (|MultiSet#Intersection| a@@54 b@@39) b@@39)))))
(assert (forall ((a@@55 T@U) (b@@40 T@U)) (! (let ((T@@82 (MapType0TypeInv0 (type a@@55)))) (=> (and (= (type a@@55) (MapType0Type T@@82 intType)) (= (type b@@40) (MapType0Type T@@82 intType))) (= (|MultiSet#Intersection| a@@55 (|MultiSet#Intersection| a@@55 b@@40)) (|MultiSet#Intersection| a@@55 b@@40)))) :qid |DafnyPre.715:18| :skolemid |175| :pattern ((|MultiSet#Intersection| a@@55 (|MultiSet#Intersection| a@@55 b@@40))))))
(assert (forall ((arg0@@73 T@U) (arg1@@30 T@U)) (! (let ((T@@83 (MapType0TypeInv0 (type arg0@@73)))) (= (type (|MultiSet#Difference| arg0@@73 arg1@@30)) (MapType0Type T@@83 intType))) :qid |funType:MultiSet#Difference| :pattern ((|MultiSet#Difference| arg0@@73 arg1@@30)))))
(assert (forall ((a@@56 T@U) (b@@41 T@U) (o@@30 T@U)) (! (let ((T@@84 (type o@@30))) (=> (and (= (type a@@56) (MapType0Type T@@84 intType)) (= (type b@@41) (MapType0Type T@@84 intType))) (= (U_2_int (MapType0Select (|MultiSet#Difference| a@@56 b@@41) o@@30)) (|Math#clip| (- (U_2_int (MapType0Select a@@56 o@@30)) (U_2_int (MapType0Select b@@41 o@@30))))))) :qid |DafnyPre.720:18| :skolemid |176| :pattern ((MapType0Select (|MultiSet#Difference| a@@56 b@@41) o@@30)))))
(assert (forall ((a@@57 T@U) (b@@42 T@U) (y@@11 T@U)) (! (let ((T@@85 (type y@@11))) (=> (and (and (= (type a@@57) (MapType0Type T@@85 intType)) (= (type b@@42) (MapType0Type T@@85 intType))) (<= (U_2_int (MapType0Select a@@57 y@@11)) (U_2_int (MapType0Select b@@42 y@@11)))) (= (U_2_int (MapType0Select (|MultiSet#Difference| a@@57 b@@42) y@@11)) 0))) :qid |DafnyPre.722:18| :skolemid |177| :pattern ((|MultiSet#Difference| a@@57 b@@42) (MapType0Select b@@42 y@@11) (MapType0Select a@@57 y@@11)))))
(assert (forall ((a@@58 T@U) (b@@43 T@U)) (! (let ((T@@86 (MapType0TypeInv0 (type a@@58)))) (=> (and (= (type a@@58) (MapType0Type T@@86 intType)) (= (type b@@43) (MapType0Type T@@86 intType))) (and (= (+ (+ (|MultiSet#Card| (|MultiSet#Difference| a@@58 b@@43)) (|MultiSet#Card| (|MultiSet#Difference| b@@43 a@@58))) (* 2 (|MultiSet#Card| (|MultiSet#Intersection| a@@58 b@@43)))) (|MultiSet#Card| (|MultiSet#Union| a@@58 b@@43))) (= (|MultiSet#Card| (|MultiSet#Difference| a@@58 b@@43)) (- (|MultiSet#Card| a@@58) (|MultiSet#Card| (|MultiSet#Intersection| a@@58 b@@43))))))) :qid |DafnyPre.724:18| :skolemid |178| :pattern ((|MultiSet#Card| (|MultiSet#Difference| a@@58 b@@43))))))
(assert (forall ((a@@59 T@U) (b@@44 T@U)) (! (let ((T@@87 (MapType0TypeInv0 (type a@@59)))) (=> (and (= (type a@@59) (MapType0Type T@@87 intType)) (= (type b@@44) (MapType0Type T@@87 intType))) (and (=> (|MultiSet#Subset| a@@59 b@@44) (forall ((o@@31 T@U)) (! (=> (= (type o@@31) T@@87) (<= (U_2_int (MapType0Select a@@59 o@@31)) (U_2_int (MapType0Select b@@44 o@@31)))) :qid |DafnyPre.734:37| :skolemid |179| :pattern ((MapType0Select a@@59 o@@31)) :pattern ((MapType0Select b@@44 o@@31))))) (=> (forall ((o@@32 T@U)) (! (=> (= (type o@@32) T@@87) (<= (U_2_int (MapType0Select a@@59 o@@32)) (U_2_int (MapType0Select b@@44 o@@32)))) :qid |DafnyPre.734:37| :skolemid |179| :pattern ((MapType0Select a@@59 o@@32)) :pattern ((MapType0Select b@@44 o@@32)))) (|MultiSet#Subset| a@@59 b@@44))))) :qid |DafnyPre.733:17| :skolemid |180| :pattern ((|MultiSet#Subset| a@@59 b@@44)))))
(assert (forall ((a@@60 T@U) (b@@45 T@U)) (! (let ((T@@88 (MapType0TypeInv0 (type a@@60)))) (=> (and (= (type a@@60) (MapType0Type T@@88 intType)) (= (type b@@45) (MapType0Type T@@88 intType))) (and (=> (|MultiSet#Equal| a@@60 b@@45) (forall ((o@@33 T@U)) (! (=> (= (type o@@33) T@@88) (= (U_2_int (MapType0Select a@@60 o@@33)) (U_2_int (MapType0Select b@@45 o@@33)))) :qid |DafnyPre.738:36| :skolemid |181| :pattern ((MapType0Select a@@60 o@@33)) :pattern ((MapType0Select b@@45 o@@33))))) (=> (forall ((o@@34 T@U)) (! (=> (= (type o@@34) T@@88) (= (U_2_int (MapType0Select a@@60 o@@34)) (U_2_int (MapType0Select b@@45 o@@34)))) :qid |DafnyPre.738:36| :skolemid |181| :pattern ((MapType0Select a@@60 o@@34)) :pattern ((MapType0Select b@@45 o@@34)))) (|MultiSet#Equal| a@@60 b@@45))))) :qid |DafnyPre.737:17| :skolemid |182| :pattern ((|MultiSet#Equal| a@@60 b@@45)))))
(assert (forall ((a@@61 T@U) (b@@46 T@U)) (! (let ((T@@89 (MapType0TypeInv0 (type a@@61)))) (=> (and (and (= (type a@@61) (MapType0Type T@@89 intType)) (= (type b@@46) (MapType0Type T@@89 intType))) (|MultiSet#Equal| a@@61 b@@46)) (= a@@61 b@@46))) :qid |DafnyPre.740:17| :skolemid |183| :pattern ((|MultiSet#Equal| a@@61 b@@46)))))
(assert (forall ((a@@62 T@U) (b@@47 T@U)) (! (let ((T@@90 (MapType0TypeInv0 (type a@@62)))) (=> (and (= (type a@@62) (MapType0Type T@@90 intType)) (= (type b@@47) (MapType0Type T@@90 intType))) (and (=> (|MultiSet#Disjoint| a@@62 b@@47) (forall ((o@@35 T@U)) (! (=> (= (type o@@35) T@@90) (or (= (U_2_int (MapType0Select a@@62 o@@35)) 0) (= (U_2_int (MapType0Select b@@47 o@@35)) 0))) :qid |DafnyPre.745:39| :skolemid |184| :pattern ((MapType0Select a@@62 o@@35)) :pattern ((MapType0Select b@@47 o@@35))))) (=> (forall ((o@@36 T@U)) (! (=> (= (type o@@36) T@@90) (or (= (U_2_int (MapType0Select a@@62 o@@36)) 0) (= (U_2_int (MapType0Select b@@47 o@@36)) 0))) :qid |DafnyPre.745:39| :skolemid |184| :pattern ((MapType0Select a@@62 o@@36)) :pattern ((MapType0Select b@@47 o@@36)))) (|MultiSet#Disjoint| a@@62 b@@47))))) :qid |DafnyPre.744:18| :skolemid |185| :pattern ((|MultiSet#Disjoint| a@@62 b@@47)))))
(assert (forall ((arg0@@74 T@U)) (! (let ((T@@91 (MapType0TypeInv0 (type arg0@@74)))) (= (type (|MultiSet#FromSet| arg0@@74)) (MapType0Type T@@91 intType))) :qid |funType:MultiSet#FromSet| :pattern ((|MultiSet#FromSet| arg0@@74)))))
(assert (forall ((s@@8 T@U) (a@@63 T@U)) (! (let ((T@@92 (type a@@63))) (=> (= (type s@@8) (MapType0Type T@@92 boolType)) (and (and (=> (= (U_2_int (MapType0Select (|MultiSet#FromSet| s@@8) a@@63)) 0) (not (U_2_bool (MapType0Select s@@8 a@@63)))) (=> (not (U_2_bool (MapType0Select s@@8 a@@63))) (= (U_2_int (MapType0Select (|MultiSet#FromSet| s@@8) a@@63)) 0))) (and (=> (= (U_2_int (MapType0Select (|MultiSet#FromSet| s@@8) a@@63)) 1) (U_2_bool (MapType0Select s@@8 a@@63))) (=> (U_2_bool (MapType0Select s@@8 a@@63)) (= (U_2_int (MapType0Select (|MultiSet#FromSet| s@@8) a@@63)) 1)))))) :qid |DafnyPre.749:18| :skolemid |186| :pattern ((MapType0Select (|MultiSet#FromSet| s@@8) a@@63)))))
(assert (forall ((s@@9 T@U)) (! (let ((T@@93 (MapType0TypeInv0 (type s@@9)))) (=> (= (type s@@9) (MapType0Type T@@93 boolType)) (= (|MultiSet#Card| (|MultiSet#FromSet| s@@9)) (|Set#Card| s@@9)))) :qid |DafnyPre.752:18| :skolemid |187| :pattern ((|MultiSet#Card| (|MultiSet#FromSet| s@@9))))))
(assert (forall ((arg0@@75 T@U)) (! (let ((T@@94 (SeqTypeInv0 (type arg0@@75)))) (= (type (|MultiSet#FromSeq| arg0@@75)) (MapType0Type T@@94 intType))) :qid |funType:MultiSet#FromSeq| :pattern ((|MultiSet#FromSeq| arg0@@75)))))
(assert (forall ((s@@10 T@U)) (! (let ((T@@95 (SeqTypeInv0 (type s@@10)))) (=> (= (type s@@10) (SeqType T@@95)) ($IsGoodMultiSet (|MultiSet#FromSeq| s@@10)))) :qid |DafnyPre.758:18| :skolemid |188| :pattern ((|MultiSet#FromSeq| s@@10)))))
(assert (forall ((s@@11 T@U)) (! (let ((T@@96 (SeqTypeInv0 (type s@@11)))) (=> (= (type s@@11) (SeqType T@@96)) (= (|MultiSet#Card| (|MultiSet#FromSeq| s@@11)) (|Seq#Length| s@@11)))) :qid |DafnyPre.760:18| :skolemid |189| :pattern ((|MultiSet#Card| (|MultiSet#FromSeq| s@@11))))))
(assert (forall ((arg0@@76 T@U) (arg1@@31 T@U)) (! (let ((T@@97 (type arg1@@31))) (= (type (|Seq#Build| arg0@@76 arg1@@31)) (SeqType T@@97))) :qid |funType:Seq#Build| :pattern ((|Seq#Build| arg0@@76 arg1@@31)))))
(assert (forall ((s@@12 T@U) (v@@25 T@U)) (! (let ((T@@98 (type v@@25))) (=> (= (type s@@12) (SeqType T@@98)) (= (|MultiSet#FromSeq| (|Seq#Build| s@@12 v@@25)) (|MultiSet#UnionOne| (|MultiSet#FromSeq| s@@12) v@@25)))) :qid |DafnyPre.764:18| :skolemid |190| :pattern ((|MultiSet#FromSeq| (|Seq#Build| s@@12 v@@25))))))
(assert (forall ((T@@99 T@T)) (! (= (type (|Seq#Empty| T@@99)) (SeqType T@@99)) :qid |funType:Seq#Empty| :pattern ((|Seq#Empty| T@@99)))))
(assert (forall ((T@@100 T@T)) (! (= (|MultiSet#FromSeq| (|Seq#Empty| T@@100)) (|MultiSet#Empty| T@@100)) :skolemid |191|)))
(assert (forall ((arg0@@77 T@U) (arg1@@32 T@U)) (! (let ((T@@101 (SeqTypeInv0 (type arg0@@77)))) (= (type (|Seq#Append| arg0@@77 arg1@@32)) (SeqType T@@101))) :qid |funType:Seq#Append| :pattern ((|Seq#Append| arg0@@77 arg1@@32)))))
(assert (forall ((a@@64 T@U) (b@@48 T@U)) (! (let ((T@@102 (SeqTypeInv0 (type a@@64)))) (=> (and (= (type a@@64) (SeqType T@@102)) (= (type b@@48) (SeqType T@@102))) (= (|MultiSet#FromSeq| (|Seq#Append| a@@64 b@@48)) (|MultiSet#Union| (|MultiSet#FromSeq| a@@64) (|MultiSet#FromSeq| b@@48))))) :qid |DafnyPre.771:18| :skolemid |192| :pattern ((|MultiSet#FromSeq| (|Seq#Append| a@@64 b@@48))))))
(assert (forall ((arg0@@78 T@U) (arg1@@33 Int) (arg2@@2 T@U)) (! (let ((T@@103 (type arg2@@2))) (= (type (|Seq#Update| arg0@@78 arg1@@33 arg2@@2)) (SeqType T@@103))) :qid |funType:Seq#Update| :pattern ((|Seq#Update| arg0@@78 arg1@@33 arg2@@2)))))
(assert (forall ((s@@13 T@U) (i@@8 Int) (v@@26 T@U) (x@@31 T@U)) (! (let ((T@@104 (type v@@26))) (=> (and (and (= (type s@@13) (SeqType T@@104)) (= (type x@@31) T@@104)) (and (<= 0 i@@8) (< i@@8 (|Seq#Length| s@@13)))) (= (U_2_int (MapType0Select (|MultiSet#FromSeq| (|Seq#Update| s@@13 i@@8 v@@26)) x@@31)) (U_2_int (MapType0Select (|MultiSet#Union| (|MultiSet#Difference| (|MultiSet#FromSeq| s@@13) (|MultiSet#Singleton| (|Seq#Index| s@@13 i@@8))) (|MultiSet#Singleton| v@@26)) x@@31))))) :qid |DafnyPre.776:18| :skolemid |193| :pattern ((MapType0Select (|MultiSet#FromSeq| (|Seq#Update| s@@13 i@@8 v@@26)) x@@31)))))
(assert (forall ((s@@14 T@U) (x@@32 T@U)) (! (let ((T@@105 (type x@@32))) (=> (= (type s@@14) (SeqType T@@105)) (and (=> (exists ((i@@9 Int)) (! (and (and (<= 0 i@@9) (< i@@9 (|Seq#Length| s@@14))) (= x@@32 (|Seq#Index| s@@14 i@@9))) :qid |DafnyPre.783:11| :skolemid |194| :pattern ((|Seq#Index| s@@14 i@@9)))) (< 0 (U_2_int (MapType0Select (|MultiSet#FromSeq| s@@14) x@@32)))) (=> (< 0 (U_2_int (MapType0Select (|MultiSet#FromSeq| s@@14) x@@32))) (exists ((i@@10 Int)) (! (and (and (<= 0 i@@10) (< i@@10 (|Seq#Length| s@@14))) (= x@@32 (|Seq#Index| s@@14 i@@10))) :qid |DafnyPre.783:11| :skolemid |194| :pattern ((|Seq#Index| s@@14 i@@10)))))))) :qid |DafnyPre.782:18| :skolemid |195| :pattern ((MapType0Select (|MultiSet#FromSeq| s@@14) x@@32)))))
(assert (forall ((s@@15 T@U)) (! (let ((T@@106 (SeqTypeInv0 (type s@@15)))) (=> (= (type s@@15) (SeqType T@@106)) (<= 0 (|Seq#Length| s@@15)))) :qid |DafnyPre.792:18| :skolemid |196| :pattern ((|Seq#Length| s@@15)))))
(assert (forall ((T@@107 T@T)) (! (= (|Seq#Length| (|Seq#Empty| T@@107)) 0) :skolemid |197|)))
(assert (forall ((s@@16 T@U)) (! (let ((T@@108 (SeqTypeInv0 (type s@@16)))) (=> (and (= (type s@@16) (SeqType T@@108)) (= (|Seq#Length| s@@16) 0)) (= s@@16 (|Seq#Empty| T@@108)))) :qid |DafnyPre.796:18| :skolemid |198| :pattern ((|Seq#Length| s@@16)))))
(assert (forall ((t@@23 T@U) (T@@109 T@T)) (! (=> (= (type t@@23) TyType) ($Is (|Seq#Empty| T@@109) t@@23)) :qid |DafnyPre.806:18| :skolemid |199| :pattern (($Is (|Seq#Empty| T@@109) t@@23)))))
(assert (forall ((arg0@@79 T@U)) (! (let ((T@@110 (type arg0@@79))) (= (type (|Seq#Singleton| arg0@@79)) (SeqType T@@110))) :qid |funType:Seq#Singleton| :pattern ((|Seq#Singleton| arg0@@79)))))
(assert (forall ((t@@24 T@U)) (! (= (|Seq#Length| (|Seq#Singleton| t@@24)) 1) :qid |DafnyPre.809:18| :skolemid |200| :pattern ((|Seq#Length| (|Seq#Singleton| t@@24))))))
(assert (forall ((s@@17 T@U) (v@@27 T@U)) (! (let ((T@@111 (type v@@27))) (=> (= (type s@@17) (SeqType T@@111)) (= (|Seq#Length| (|Seq#Build| s@@17 v@@27)) (+ 1 (|Seq#Length| s@@17))))) :qid |DafnyPre.812:18| :skolemid |201| :pattern ((|Seq#Length| (|Seq#Build| s@@17 v@@27))))))
(assert (forall ((s@@18 T@U) (i@@11 Int) (v@@28 T@U)) (! (let ((T@@112 (type v@@28))) (=> (= (type s@@18) (SeqType T@@112)) (and (=> (= i@@11 (|Seq#Length| s@@18)) (= (|Seq#Index| (|Seq#Build| s@@18 v@@28) i@@11) v@@28)) (=> (not (= i@@11 (|Seq#Length| s@@18))) (= (|Seq#Index| (|Seq#Build| s@@18 v@@28) i@@11) (|Seq#Index| s@@18 i@@11)))))) :qid |DafnyPre.814:18| :skolemid |202| :pattern ((|Seq#Index| (|Seq#Build| s@@18 v@@28) i@@11)))))
(assert (forall ((s@@19 T@U) (bx@@34 T@U) (t@@25 T@U)) (! (=> (and (and (and (= (type s@@19) (SeqType BoxType)) (= (type bx@@34) BoxType)) (= (type t@@25) TyType)) (and ($Is s@@19 (TSeq t@@25)) ($IsBox bx@@34 t@@25))) ($Is (|Seq#Build| s@@19 bx@@34) (TSeq t@@25))) :qid |DafnyPre.819:15| :skolemid |203| :pattern (($Is (|Seq#Build| s@@19 bx@@34) (TSeq t@@25))))))
(assert (forall ((s0 T@U) (s1 T@U)) (! (let ((T@@113 (SeqTypeInv0 (type s0)))) (=> (and (= (type s0) (SeqType T@@113)) (= (type s1) (SeqType T@@113))) (= (|Seq#Length| (|Seq#Append| s0 s1)) (+ (|Seq#Length| s0) (|Seq#Length| s1))))) :qid |DafnyPre.823:18| :skolemid |204| :pattern ((|Seq#Length| (|Seq#Append| s0 s1))))))
(assert (forall ((s0@@0 T@U) (s1@@0 T@U) (t@@26 T@U)) (! (=> (and (and (and (= (type s0@@0) (SeqType BoxType)) (= (type s1@@0) (SeqType BoxType))) (= (type t@@26) TyType)) (and ($Is s0@@0 t@@26) ($Is s1@@0 t@@26))) ($Is (|Seq#Append| s0@@0 s1@@0) t@@26)) :qid |DafnyPre.827:15| :skolemid |205| :pattern (($Is (|Seq#Append| s0@@0 s1@@0) t@@26)))))
(assert (forall ((t@@27 T@U)) (! (= (|Seq#Index| (|Seq#Singleton| t@@27) 0) t@@27) :qid |DafnyPre.831:18| :skolemid |206| :pattern ((|Seq#Index| (|Seq#Singleton| t@@27) 0)))))
(assert (forall ((s0@@1 T@U) (s1@@1 T@U) (n@@1 Int)) (! (let ((T@@114 (SeqTypeInv0 (type s0@@1)))) (=> (and (= (type s0@@1) (SeqType T@@114)) (= (type s1@@1) (SeqType T@@114))) (and (=> (< n@@1 (|Seq#Length| s0@@1)) (= (|Seq#Index| (|Seq#Append| s0@@1 s1@@1) n@@1) (|Seq#Index| s0@@1 n@@1))) (=> (<= (|Seq#Length| s0@@1) n@@1) (= (|Seq#Index| (|Seq#Append| s0@@1 s1@@1) n@@1) (|Seq#Index| s1@@1 (- n@@1 (|Seq#Length| s0@@1)))))))) :qid |DafnyPre.832:18| :skolemid |207| :pattern ((|Seq#Index| (|Seq#Append| s0@@1 s1@@1) n@@1)))))
(assert (forall ((s@@20 T@U) (i@@12 Int) (v@@29 T@U)) (! (let ((T@@115 (type v@@29))) (=> (= (type s@@20) (SeqType T@@115)) (=> (and (<= 0 i@@12) (< i@@12 (|Seq#Length| s@@20))) (= (|Seq#Length| (|Seq#Update| s@@20 i@@12 v@@29)) (|Seq#Length| s@@20))))) :qid |DafnyPre.837:18| :skolemid |208| :pattern ((|Seq#Length| (|Seq#Update| s@@20 i@@12 v@@29))))))
(assert (forall ((s@@21 T@U) (i@@13 Int) (v@@30 T@U) (n@@2 Int)) (! (let ((T@@116 (type v@@30))) (=> (= (type s@@21) (SeqType T@@116)) (=> (and (<= 0 n@@2) (< n@@2 (|Seq#Length| s@@21))) (and (=> (= i@@13 n@@2) (= (|Seq#Index| (|Seq#Update| s@@21 i@@13 v@@30) n@@2) v@@30)) (=> (not (= i@@13 n@@2)) (= (|Seq#Index| (|Seq#Update| s@@21 i@@13 v@@30) n@@2) (|Seq#Index| s@@21 n@@2))))))) :qid |DafnyPre.839:18| :skolemid |209| :pattern ((|Seq#Index| (|Seq#Update| s@@21 i@@13 v@@30) n@@2)))))
(assert (forall ((s@@22 T@U) (x@@33 T@U)) (! (let ((T@@117 (type x@@33))) (=> (= (type s@@22) (SeqType T@@117)) (and (=> (|Seq#Contains| s@@22 x@@33) (exists ((i@@14 Int)) (! (and (and (<= 0 i@@14) (< i@@14 (|Seq#Length| s@@22))) (= (|Seq#Index| s@@22 i@@14) x@@33)) :qid |DafnyPre.847:13| :skolemid |210| :pattern ((|Seq#Index| s@@22 i@@14))))) (=> (exists ((i@@15 Int)) (! (and (and (<= 0 i@@15) (< i@@15 (|Seq#Length| s@@22))) (= (|Seq#Index| s@@22 i@@15) x@@33)) :qid |DafnyPre.847:13| :skolemid |210| :pattern ((|Seq#Index| s@@22 i@@15)))) (|Seq#Contains| s@@22 x@@33))))) :qid |DafnyPre.845:18| :skolemid |211| :pattern ((|Seq#Contains| s@@22 x@@33)))))
(assert (forall ((x@@34 T@U)) (! (let ((T@@118 (type x@@34))) (not (|Seq#Contains| (|Seq#Empty| T@@118) x@@34))) :qid |DafnyPre.848:18| :skolemid |212| :pattern ((let ((T@@118 (type x@@34))) (|Seq#Contains| (|Seq#Empty| T@@118) x@@34))))))
(assert (forall ((s0@@2 T@U) (s1@@2 T@U) (x@@35 T@U)) (! (let ((T@@119 (type x@@35))) (=> (and (= (type s0@@2) (SeqType T@@119)) (= (type s1@@2) (SeqType T@@119))) (and (=> (|Seq#Contains| (|Seq#Append| s0@@2 s1@@2) x@@35) (or (|Seq#Contains| s0@@2 x@@35) (|Seq#Contains| s1@@2 x@@35))) (=> (or (|Seq#Contains| s0@@2 x@@35) (|Seq#Contains| s1@@2 x@@35)) (|Seq#Contains| (|Seq#Append| s0@@2 s1@@2) x@@35))))) :qid |DafnyPre.852:18| :skolemid |213| :pattern ((|Seq#Contains| (|Seq#Append| s0@@2 s1@@2) x@@35)))))
(assert (forall ((s@@23 T@U) (v@@31 T@U) (x@@36 T@U)) (! (let ((T@@120 (type v@@31))) (=> (and (= (type s@@23) (SeqType T@@120)) (= (type x@@36) T@@120)) (and (=> (|Seq#Contains| (|Seq#Build| s@@23 v@@31) x@@36) (or (= v@@31 x@@36) (|Seq#Contains| s@@23 x@@36))) (=> (or (= v@@31 x@@36) (|Seq#Contains| s@@23 x@@36)) (|Seq#Contains| (|Seq#Build| s@@23 v@@31) x@@36))))) :qid |DafnyPre.857:18| :skolemid |214| :pattern ((|Seq#Contains| (|Seq#Build| s@@23 v@@31) x@@36)))))
(assert (forall ((arg0@@80 T@U) (arg1@@34 Int)) (! (let ((T@@121 (SeqTypeInv0 (type arg0@@80)))) (= (type (|Seq#Take| arg0@@80 arg1@@34)) (SeqType T@@121))) :qid |funType:Seq#Take| :pattern ((|Seq#Take| arg0@@80 arg1@@34)))))
(assert (forall ((s@@24 T@U) (n@@3 Int) (x@@37 T@U)) (! (let ((T@@122 (type x@@37))) (=> (= (type s@@24) (SeqType T@@122)) (and (=> (|Seq#Contains| (|Seq#Take| s@@24 n@@3) x@@37) (exists ((i@@16 Int)) (! (and (and (and (<= 0 i@@16) (< i@@16 n@@3)) (< i@@16 (|Seq#Length| s@@24))) (= (|Seq#Index| s@@24 i@@16) x@@37)) :qid |DafnyPre.864:13| :skolemid |215| :pattern ((|Seq#Index| s@@24 i@@16))))) (=> (exists ((i@@17 Int)) (! (and (and (and (<= 0 i@@17) (< i@@17 n@@3)) (< i@@17 (|Seq#Length| s@@24))) (= (|Seq#Index| s@@24 i@@17) x@@37)) :qid |DafnyPre.864:13| :skolemid |215| :pattern ((|Seq#Index| s@@24 i@@17)))) (|Seq#Contains| (|Seq#Take| s@@24 n@@3) x@@37))))) :qid |DafnyPre.861:18| :skolemid |216| :pattern ((|Seq#Contains| (|Seq#Take| s@@24 n@@3) x@@37)))))
(assert (forall ((arg0@@81 T@U) (arg1@@35 Int)) (! (let ((T@@123 (SeqTypeInv0 (type arg0@@81)))) (= (type (|Seq#Drop| arg0@@81 arg1@@35)) (SeqType T@@123))) :qid |funType:Seq#Drop| :pattern ((|Seq#Drop| arg0@@81 arg1@@35)))))
(assert (forall ((s@@25 T@U) (n@@4 Int) (x@@38 T@U)) (! (let ((T@@124 (type x@@38))) (=> (= (type s@@25) (SeqType T@@124)) (and (=> (|Seq#Contains| (|Seq#Drop| s@@25 n@@4) x@@38) (exists ((i@@18 Int)) (! (and (and (and (<= 0 n@@4) (<= n@@4 i@@18)) (< i@@18 (|Seq#Length| s@@25))) (= (|Seq#Index| s@@25 i@@18) x@@38)) :qid |DafnyPre.869:13| :skolemid |217| :pattern ((|Seq#Index| s@@25 i@@18))))) (=> (exists ((i@@19 Int)) (! (and (and (and (<= 0 n@@4) (<= n@@4 i@@19)) (< i@@19 (|Seq#Length| s@@25))) (= (|Seq#Index| s@@25 i@@19) x@@38)) :qid |DafnyPre.869:13| :skolemid |217| :pattern ((|Seq#Index| s@@25 i@@19)))) (|Seq#Contains| (|Seq#Drop| s@@25 n@@4) x@@38))))) :qid |DafnyPre.866:18| :skolemid |218| :pattern ((|Seq#Contains| (|Seq#Drop| s@@25 n@@4) x@@38)))))
(assert (forall ((s0@@3 T@U) (s1@@3 T@U)) (! (let ((T@@125 (SeqTypeInv0 (type s0@@3)))) (=> (and (= (type s0@@3) (SeqType T@@125)) (= (type s1@@3) (SeqType T@@125))) (and (=> (|Seq#Equal| s0@@3 s1@@3) (and (= (|Seq#Length| s0@@3) (|Seq#Length| s1@@3)) (forall ((j Int)) (! (=> (and (<= 0 j) (< j (|Seq#Length| s0@@3))) (= (|Seq#Index| s0@@3 j) (|Seq#Index| s1@@3 j))) :qid |DafnyPre.876:13| :skolemid |219| :pattern ((|Seq#Index| s0@@3 j)) :pattern ((|Seq#Index| s1@@3 j)))))) (=> (and (= (|Seq#Length| s0@@3) (|Seq#Length| s1@@3)) (forall ((j@@0 Int)) (! (=> (and (<= 0 j@@0) (< j@@0 (|Seq#Length| s0@@3))) (= (|Seq#Index| s0@@3 j@@0) (|Seq#Index| s1@@3 j@@0))) :qid |DafnyPre.876:13| :skolemid |219| :pattern ((|Seq#Index| s0@@3 j@@0)) :pattern ((|Seq#Index| s1@@3 j@@0))))) (|Seq#Equal| s0@@3 s1@@3))))) :qid |DafnyPre.873:18| :skolemid |220| :pattern ((|Seq#Equal| s0@@3 s1@@3)))))
(assert (forall ((a@@65 T@U) (b@@49 T@U)) (! (let ((T@@126 (SeqTypeInv0 (type a@@65)))) (=> (and (and (= (type a@@65) (SeqType T@@126)) (= (type b@@49) (SeqType T@@126))) (|Seq#Equal| a@@65 b@@49)) (= a@@65 b@@49))) :qid |DafnyPre.878:18| :skolemid |221| :pattern ((|Seq#Equal| a@@65 b@@49)))))
(assert (forall ((s0@@4 T@U) (s1@@4 T@U) (n@@5 Int)) (! (let ((T@@127 (SeqTypeInv0 (type s0@@4)))) (=> (and (= (type s0@@4) (SeqType T@@127)) (= (type s1@@4) (SeqType T@@127))) (and (=> (|Seq#SameUntil| s0@@4 s1@@4 n@@5) (forall ((j@@1 Int)) (! (=> (and (<= 0 j@@1) (< j@@1 n@@5)) (= (|Seq#Index| s0@@4 j@@1) (|Seq#Index| s1@@4 j@@1))) :qid |DafnyPre.884:13| :skolemid |222| :pattern ((|Seq#Index| s0@@4 j@@1)) :pattern ((|Seq#Index| s1@@4 j@@1))))) (=> (forall ((j@@2 Int)) (! (=> (and (<= 0 j@@2) (< j@@2 n@@5)) (= (|Seq#Index| s0@@4 j@@2) (|Seq#Index| s1@@4 j@@2))) :qid |DafnyPre.884:13| :skolemid |222| :pattern ((|Seq#Index| s0@@4 j@@2)) :pattern ((|Seq#Index| s1@@4 j@@2)))) (|Seq#SameUntil| s0@@4 s1@@4 n@@5))))) :qid |DafnyPre.882:18| :skolemid |223| :pattern ((|Seq#SameUntil| s0@@4 s1@@4 n@@5)))))
(assert (forall ((s@@26 T@U) (n@@6 Int)) (! (let ((T@@128 (SeqTypeInv0 (type s@@26)))) (=> (= (type s@@26) (SeqType T@@128)) (=> (and (<= 0 n@@6) (<= n@@6 (|Seq#Length| s@@26))) (= (|Seq#Length| (|Seq#Take| s@@26 n@@6)) n@@6)))) :qid |DafnyPre.888:18| :skolemid |224| :pattern ((|Seq#Length| (|Seq#Take| s@@26 n@@6))))))
(assert (forall ((s@@27 T@U) (n@@7 Int) (j@@3 Int)) (! (let ((T@@129 (SeqTypeInv0 (type s@@27)))) (=> (= (type s@@27) (SeqType T@@129)) (=> (and (and (<= 0 j@@3) (< j@@3 n@@7)) (< j@@3 (|Seq#Length| s@@27))) (= (|Seq#Index| (|Seq#Take| s@@27 n@@7) j@@3) (|Seq#Index| s@@27 j@@3))))) :qid |DafnyPre.890:18| :weight 25 :skolemid |225| :pattern ((|Seq#Index| (|Seq#Take| s@@27 n@@7) j@@3)) :pattern ((|Seq#Index| s@@27 j@@3) (|Seq#Take| s@@27 n@@7)))))
(assert (forall ((s@@28 T@U) (n@@8 Int)) (! (let ((T@@130 (SeqTypeInv0 (type s@@28)))) (=> (= (type s@@28) (SeqType T@@130)) (=> (and (<= 0 n@@8) (<= n@@8 (|Seq#Length| s@@28))) (= (|Seq#Length| (|Seq#Drop| s@@28 n@@8)) (- (|Seq#Length| s@@28) n@@8))))) :qid |DafnyPre.898:18| :skolemid |226| :pattern ((|Seq#Length| (|Seq#Drop| s@@28 n@@8))))))
(assert (forall ((s@@29 T@U) (n@@9 Int) (j@@4 Int)) (! (let ((T@@131 (SeqTypeInv0 (type s@@29)))) (=> (= (type s@@29) (SeqType T@@131)) (=> (and (and (<= 0 n@@9) (<= 0 j@@4)) (< j@@4 (- (|Seq#Length| s@@29) n@@9))) (= (|Seq#Index| (|Seq#Drop| s@@29 n@@9) j@@4) (|Seq#Index| s@@29 (+ j@@4 n@@9)))))) :qid |DafnyPre.900:18| :weight 25 :skolemid |227| :pattern ((|Seq#Index| (|Seq#Drop| s@@29 n@@9) j@@4)))))
(assert (forall ((s@@30 T@U) (n@@10 Int) (k@@3 Int)) (! (let ((T@@132 (SeqTypeInv0 (type s@@30)))) (=> (= (type s@@30) (SeqType T@@132)) (=> (and (and (<= 0 n@@10) (<= n@@10 k@@3)) (< k@@3 (|Seq#Length| s@@30))) (= (|Seq#Index| (|Seq#Drop| s@@30 n@@10) (- k@@3 n@@10)) (|Seq#Index| s@@30 k@@3))))) :qid |DafnyPre.905:18| :weight 25 :skolemid |228| :pattern ((|Seq#Index| s@@30 k@@3) (|Seq#Drop| s@@30 n@@10)))))
(assert (forall ((s@@31 T@U) (t@@28 T@U)) (! (let ((T@@133 (SeqTypeInv0 (type s@@31)))) (=> (and (= (type s@@31) (SeqType T@@133)) (= (type t@@28) (SeqType T@@133))) (and (= (|Seq#Take| (|Seq#Append| s@@31 t@@28) (|Seq#Length| s@@31)) s@@31) (= (|Seq#Drop| (|Seq#Append| s@@31 t@@28) (|Seq#Length| s@@31)) t@@28)))) :qid |DafnyPre.911:18| :skolemid |229| :pattern ((|Seq#Append| s@@31 t@@28)))))
(assert (forall ((arg0@@82 T@U) (arg1@@36 T@U)) (! (= (type (|Seq#FromArray| arg0@@82 arg1@@36)) (SeqType BoxType)) :qid |funType:Seq#FromArray| :pattern ((|Seq#FromArray| arg0@@82 arg1@@36)))))
(assert (forall ((h@@16 T@U) (a@@66 T@U)) (! (=> (and (= (type h@@16) (MapType1Type refType)) (= (type a@@66) refType)) (= (|Seq#Length| (|Seq#FromArray| h@@16 a@@66)) (_System.array.Length a@@66))) :qid |DafnyPre.917:15| :skolemid |230| :pattern ((|Seq#Length| (|Seq#FromArray| h@@16 a@@66))))))
(assert (forall ((h@@17 T@U) (a@@67 T@U)) (! (=> (and (= (type h@@17) (MapType1Type refType)) (= (type a@@67) refType)) (forall ((i@@20 Int)) (! (=> (and (<= 0 i@@20) (< i@@20 (|Seq#Length| (|Seq#FromArray| h@@17 a@@67)))) (= (|Seq#Index| (|Seq#FromArray| h@@17 a@@67) i@@20) (MapType1Select h@@17 a@@67 (IndexField i@@20)))) :qid |DafnyPre.922:11| :skolemid |231| :pattern ((MapType1Select h@@17 a@@67 (IndexField i@@20))) :pattern ((|Seq#Index| (|Seq#FromArray| h@@17 a@@67) i@@20))))) :qid |DafnyPre.920:15| :skolemid |232| :pattern ((|Seq#FromArray| h@@17 a@@67)))))
(assert (forall ((h0 T@U) (h1 T@U) (a@@68 T@U)) (! (=> (and (and (= (type h0) (MapType1Type refType)) (= (type h1) (MapType1Type refType))) (= (type a@@68) refType)) (=> (and (and (and ($IsGoodHeap h0) ($IsGoodHeap h1)) ($HeapSucc h0 h1)) (forall ((i@@21 Int)) (! (=> (and (<= 0 i@@21) (< i@@21 (_System.array.Length a@@68))) (= (MapType1Select h0 a@@68 (IndexField i@@21)) (MapType1Select h1 a@@68 (IndexField i@@21)))) :qid |DafnyPre.935:11| :skolemid |233|))) (= (|Seq#FromArray| h0 a@@68) (|Seq#FromArray| h1 a@@68)))) :qid |DafnyPre.932:15| :skolemid |234| :pattern ((|Seq#FromArray| h1 a@@68) ($HeapSucc h0 h1)))))
(assert (forall ((h@@18 T@U) (i@@22 Int) (v@@32 T@U) (a@@69 T@U)) (! (=> (and (and (and (= (type h@@18) (MapType1Type refType)) (= (type v@@32) BoxType)) (= (type a@@69) refType)) (and (<= 0 i@@22) (< i@@22 (_System.array.Length a@@69)))) (= (|Seq#FromArray| (MapType1Store h@@18 a@@69 (IndexField i@@22) v@@32) a@@69) (|Seq#Update| (|Seq#FromArray| h@@18 a@@69) i@@22 v@@32))) :qid |DafnyPre.939:15| :skolemid |235| :pattern ((|Seq#FromArray| (MapType1Store h@@18 a@@69 (IndexField i@@22) v@@32) a@@69)))))
(assert (forall ((s@@32 T@U) (i@@23 Int) (v@@33 T@U) (n@@11 Int)) (! (let ((T@@134 (type v@@33))) (=> (= (type s@@32) (SeqType T@@134)) (=> (and (and (<= 0 i@@23) (< i@@23 n@@11)) (<= n@@11 (|Seq#Length| s@@32))) (= (|Seq#Take| (|Seq#Update| s@@32 i@@23 v@@33) n@@11) (|Seq#Update| (|Seq#Take| s@@32 n@@11) i@@23 v@@33))))) :qid |DafnyPre.944:18| :skolemid |236| :pattern ((|Seq#Take| (|Seq#Update| s@@32 i@@23 v@@33) n@@11)))))
(assert (forall ((s@@33 T@U) (i@@24 Int) (v@@34 T@U) (n@@12 Int)) (! (let ((T@@135 (type v@@34))) (=> (= (type s@@33) (SeqType T@@135)) (=> (and (<= n@@12 i@@24) (< i@@24 (|Seq#Length| s@@33))) (= (|Seq#Take| (|Seq#Update| s@@33 i@@24 v@@34) n@@12) (|Seq#Take| s@@33 n@@12))))) :qid |DafnyPre.947:18| :skolemid |237| :pattern ((|Seq#Take| (|Seq#Update| s@@33 i@@24 v@@34) n@@12)))))
(assert (forall ((s@@34 T@U) (i@@25 Int) (v@@35 T@U) (n@@13 Int)) (! (let ((T@@136 (type v@@35))) (=> (= (type s@@34) (SeqType T@@136)) (=> (and (and (<= 0 n@@13) (<= n@@13 i@@25)) (< i@@25 (|Seq#Length| s@@34))) (= (|Seq#Drop| (|Seq#Update| s@@34 i@@25 v@@35) n@@13) (|Seq#Update| (|Seq#Drop| s@@34 n@@13) (- i@@25 n@@13) v@@35))))) :qid |DafnyPre.950:18| :skolemid |238| :pattern ((|Seq#Drop| (|Seq#Update| s@@34 i@@25 v@@35) n@@13)))))
(assert (forall ((s@@35 T@U) (i@@26 Int) (v@@36 T@U) (n@@14 Int)) (! (let ((T@@137 (type v@@36))) (=> (= (type s@@35) (SeqType T@@137)) (=> (and (and (<= 0 i@@26) (< i@@26 n@@14)) (< n@@14 (|Seq#Length| s@@35))) (= (|Seq#Drop| (|Seq#Update| s@@35 i@@26 v@@36) n@@14) (|Seq#Drop| s@@35 n@@14))))) :qid |DafnyPre.953:18| :skolemid |239| :pattern ((|Seq#Drop| (|Seq#Update| s@@35 i@@26 v@@36) n@@14)))))
(assert (forall ((h@@19 T@U) (a@@70 T@U) (n0 Int) (n1 Int)) (! (=> (and (= (type h@@19) (MapType1Type refType)) (= (type a@@70) refType)) (=> (and (and (= (+ n0 1) n1) (<= 0 n0)) (<= n1 (_System.array.Length a@@70))) (= (|Seq#Take| (|Seq#FromArray| h@@19 a@@70) n1) (|Seq#Build| (|Seq#Take| (|Seq#FromArray| h@@19 a@@70) n0) (MapType1Select h@@19 a@@70 (IndexField n0)))))) :qid |DafnyPre.957:15| :skolemid |240| :pattern ((|Seq#Take| (|Seq#FromArray| h@@19 a@@70) n0) (|Seq#Take| (|Seq#FromArray| h@@19 a@@70) n1)))))
(assert (forall ((s@@36 T@U) (v@@37 T@U) (n@@15 Int)) (! (let ((T@@138 (type v@@37))) (=> (= (type s@@36) (SeqType T@@138)) (=> (and (<= 0 n@@15) (<= n@@15 (|Seq#Length| s@@36))) (= (|Seq#Drop| (|Seq#Build| s@@36 v@@37) n@@15) (|Seq#Build| (|Seq#Drop| s@@36 n@@15) v@@37))))) :qid |DafnyPre.961:18| :skolemid |241| :pattern ((|Seq#Drop| (|Seq#Build| s@@36 v@@37) n@@15)))))
(assert (forall ((s@@37 T@U) (i@@27 Int)) (! (=> (= (type s@@37) (SeqType BoxType)) (=> (and (<= 0 i@@27) (< i@@27 (|Seq#Length| s@@37))) (< (DtRank ($Unbox DatatypeTypeType (|Seq#Index| s@@37 i@@27))) (|Seq#Rank| s@@37)))) :qid |DafnyPre.966:15| :skolemid |242| :pattern ((DtRank ($Unbox DatatypeTypeType (|Seq#Index| s@@37 i@@27)))))))
(assert (forall ((s@@38 T@U) (i@@28 Int)) (! (let ((T@@139 (SeqTypeInv0 (type s@@38)))) (=> (= (type s@@38) (SeqType T@@139)) (=> (and (< 0 i@@28) (<= i@@28 (|Seq#Length| s@@38))) (< (|Seq#Rank| (|Seq#Drop| s@@38 i@@28)) (|Seq#Rank| s@@38))))) :qid |DafnyPre.969:18| :skolemid |243| :pattern ((|Seq#Rank| (|Seq#Drop| s@@38 i@@28))))))
(assert (forall ((s@@39 T@U) (i@@29 Int)) (! (let ((T@@140 (SeqTypeInv0 (type s@@39)))) (=> (= (type s@@39) (SeqType T@@140)) (=> (and (<= 0 i@@29) (< i@@29 (|Seq#Length| s@@39))) (< (|Seq#Rank| (|Seq#Take| s@@39 i@@29)) (|Seq#Rank| s@@39))))) :qid |DafnyPre.972:18| :skolemid |244| :pattern ((|Seq#Rank| (|Seq#Take| s@@39 i@@29))))))
(assert (forall ((s@@40 T@U) (i@@30 Int) (j@@5 Int)) (! (let ((T@@141 (SeqTypeInv0 (type s@@40)))) (=> (= (type s@@40) (SeqType T@@141)) (=> (and (and (<= 0 i@@30) (< i@@30 j@@5)) (<= j@@5 (|Seq#Length| s@@40))) (< (|Seq#Rank| (|Seq#Append| (|Seq#Take| s@@40 i@@30) (|Seq#Drop| s@@40 j@@5))) (|Seq#Rank| s@@40))))) :qid |DafnyPre.975:18| :skolemid |245| :pattern ((|Seq#Rank| (|Seq#Append| (|Seq#Take| s@@40 i@@30) (|Seq#Drop| s@@40 j@@5)))))))
(assert (forall ((s@@41 T@U) (n@@16 Int)) (! (let ((T@@142 (SeqTypeInv0 (type s@@41)))) (=> (and (= (type s@@41) (SeqType T@@142)) (= n@@16 0)) (= (|Seq#Drop| s@@41 n@@16) s@@41))) :qid |DafnyPre.980:18| :skolemid |246| :pattern ((|Seq#Drop| s@@41 n@@16)))))
(assert (forall ((s@@42 T@U) (n@@17 Int)) (! (let ((T@@143 (SeqTypeInv0 (type s@@42)))) (=> (and (= (type s@@42) (SeqType T@@143)) (= n@@17 0)) (= (|Seq#Take| s@@42 n@@17) (|Seq#Empty| T@@143)))) :qid |DafnyPre.982:18| :skolemid |247| :pattern ((|Seq#Take| s@@42 n@@17)))))
(assert (forall ((s@@43 T@U) (m@@6 Int) (n@@18 Int)) (! (let ((T@@144 (SeqTypeInv0 (type s@@43)))) (=> (= (type s@@43) (SeqType T@@144)) (=> (and (and (<= 0 m@@6) (<= 0 n@@18)) (<= (+ m@@6 n@@18) (|Seq#Length| s@@43))) (= (|Seq#Drop| (|Seq#Drop| s@@43 m@@6) n@@18) (|Seq#Drop| s@@43 (+ m@@6 n@@18)))))) :qid |DafnyPre.984:18| :skolemid |248| :pattern ((|Seq#Drop| (|Seq#Drop| s@@43 m@@6) n@@18)))))
(assert (forall ((m@@7 T@U)) (! (let ((V@@1 (MapTypeInv1 (type m@@7)))) (let ((U@@3 (MapTypeInv0 (type m@@7)))) (=> (= (type m@@7) (MapType U@@3 V@@1)) (<= 0 (|Map#Card| m@@7))))) :qid |DafnyPre.998:21| :skolemid |249| :pattern ((|Map#Card| m@@7)))))
(assert (forall ((U@@4 T@T) (V@@2 T@T)) (! (= (type (|Map#Empty| U@@4 V@@2)) (MapType U@@4 V@@2)) :qid |funType:Map#Empty| :pattern ((|Map#Empty| U@@4 V@@2)))))
(assert (forall ((u@@5 T@U) (V@@3 T@T)) (! (let ((U@@5 (type u@@5))) (not (U_2_bool (MapType0Select (|Map#Domain| (|Map#Empty| U@@5 V@@3)) u@@5)))) :qid |DafnyPre.1001:21| :skolemid |250| :pattern ((let ((U@@5 (type u@@5))) (MapType0Select (|Map#Domain| (|Map#Empty| U@@5 V@@3)) u@@5))))))
(assert (forall ((m@@8 T@U)) (! (let ((V@@4 (MapTypeInv1 (type m@@8)))) (let ((U@@6 (MapTypeInv0 (type m@@8)))) (=> (= (type m@@8) (MapType U@@6 V@@4)) (and (and (=> (= (|Map#Card| m@@8) 0) (= m@@8 (|Map#Empty| U@@6 V@@4))) (=> (= m@@8 (|Map#Empty| U@@6 V@@4)) (= (|Map#Card| m@@8) 0))) (=> (not (= (|Map#Card| m@@8) 0)) (exists ((x@@39 T@U)) (! (and (= (type x@@39) U@@6) (U_2_bool (MapType0Select (|Map#Domain| m@@8) x@@39))) :qid |DafnyPre.1006:32| :skolemid |251| :no-pattern (type x@@39) :no-pattern (U_2_int x@@39) :no-pattern (U_2_bool x@@39)))))))) :qid |DafnyPre.1004:21| :skolemid |252| :pattern ((|Map#Card| m@@8)))))
(assert (forall ((arg0@@83 T@U) (arg1@@37 T@U) (arg2@@3 T@U)) (! (let ((V@@5 (MapType0TypeInv1 (type arg1@@37)))) (let ((U@@7 (MapType0TypeInv0 (type arg0@@83)))) (= (type (|Map#Glue| arg0@@83 arg1@@37 arg2@@3)) (MapType U@@7 V@@5)))) :qid |funType:Map#Glue| :pattern ((|Map#Glue| arg0@@83 arg1@@37 arg2@@3)))))
(assert (forall ((a@@71 T@U) (b@@50 T@U) (t@@29 T@U)) (! (let ((V@@6 (MapType0TypeInv1 (type b@@50)))) (let ((U@@8 (MapType0TypeInv0 (type a@@71)))) (=> (and (and (= (type a@@71) (MapType0Type U@@8 boolType)) (= (type b@@50) (MapType0Type U@@8 V@@6))) (= (type t@@29) TyType)) (= (|Map#Domain| (|Map#Glue| a@@71 b@@50 t@@29)) a@@71)))) :qid |DafnyPre.1009:21| :skolemid |253| :pattern ((|Map#Domain| (|Map#Glue| a@@71 b@@50 t@@29))))))
(assert (forall ((a@@72 T@U) (b@@51 T@U) (t@@30 T@U)) (! (let ((V@@7 (MapType0TypeInv1 (type b@@51)))) (let ((U@@9 (MapType0TypeInv0 (type a@@72)))) (=> (and (and (= (type a@@72) (MapType0Type U@@9 boolType)) (= (type b@@51) (MapType0Type U@@9 V@@7))) (= (type t@@30) TyType)) (= (|Map#Elements| (|Map#Glue| a@@72 b@@51 t@@30)) b@@51)))) :qid |DafnyPre.1012:21| :skolemid |254| :pattern ((|Map#Elements| (|Map#Glue| a@@72 b@@51 t@@30))))))
(assert (forall ((a@@73 T@U) (b@@52 T@U) (t@@31 T@U)) (! (let ((V@@8 (MapType0TypeInv1 (type b@@52)))) (let ((U@@10 (MapType0TypeInv0 (type a@@73)))) (=> (and (and (= (type a@@73) (MapType0Type U@@10 boolType)) (= (type b@@52) (MapType0Type U@@10 V@@8))) (= (type t@@31) TyType)) ($Is (|Map#Glue| a@@73 b@@52 t@@31) t@@31)))) :qid |DafnyPre.1015:21| :skolemid |255| :pattern (($Is (|Map#Glue| a@@73 b@@52 t@@31) t@@31)))))
(assert (forall ((arg0@@84 T@U) (arg1@@38 T@U) (arg2@@4 T@U)) (! (let ((V@@9 (type arg2@@4))) (let ((U@@11 (type arg1@@38))) (= (type (|Map#Build| arg0@@84 arg1@@38 arg2@@4)) (MapType U@@11 V@@9)))) :qid |funType:Map#Build| :pattern ((|Map#Build| arg0@@84 arg1@@38 arg2@@4)))))
(assert (forall ((m@@9 T@U) (u@@6 T@U) (|u'| T@U) (v@@38 T@U)) (! (let ((V@@10 (type v@@38))) (let ((U@@12 (type u@@6))) (=> (and (= (type m@@9) (MapType U@@12 V@@10)) (= (type |u'|) U@@12)) (and (=> (= |u'| u@@6) (and (U_2_bool (MapType0Select (|Map#Domain| (|Map#Build| m@@9 u@@6 v@@38)) |u'|)) (= (MapType0Select (|Map#Elements| (|Map#Build| m@@9 u@@6 v@@38)) |u'|) v@@38))) (=> (not (= |u'| u@@6)) (and (and (=> (U_2_bool (MapType0Select (|Map#Domain| (|Map#Build| m@@9 u@@6 v@@38)) |u'|)) (U_2_bool (MapType0Select (|Map#Domain| m@@9) |u'|))) (=> (U_2_bool (MapType0Select (|Map#Domain| m@@9) |u'|)) (U_2_bool (MapType0Select (|Map#Domain| (|Map#Build| m@@9 u@@6 v@@38)) |u'|)))) (= (MapType0Select (|Map#Elements| (|Map#Build| m@@9 u@@6 v@@38)) |u'|) (MapType0Select (|Map#Elements| m@@9) |u'|)))))))) :qid |DafnyPre.1026:21| :skolemid |256| :pattern ((MapType0Select (|Map#Domain| (|Map#Build| m@@9 u@@6 v@@38)) |u'|)) :pattern ((MapType0Select (|Map#Elements| (|Map#Build| m@@9 u@@6 v@@38)) |u'|)))))
(assert (forall ((m@@10 T@U) (u@@7 T@U) (v@@39 T@U)) (! (let ((V@@11 (type v@@39))) (let ((U@@13 (type u@@7))) (=> (and (= (type m@@10) (MapType U@@13 V@@11)) (U_2_bool (MapType0Select (|Map#Domain| m@@10) u@@7))) (= (|Map#Card| (|Map#Build| m@@10 u@@7 v@@39)) (|Map#Card| m@@10))))) :qid |DafnyPre.1032:21| :skolemid |257| :pattern ((|Map#Card| (|Map#Build| m@@10 u@@7 v@@39))))))
(assert (forall ((m@@11 T@U) (u@@8 T@U) (v@@40 T@U)) (! (let ((V@@12 (type v@@40))) (let ((U@@14 (type u@@8))) (=> (and (= (type m@@11) (MapType U@@14 V@@12)) (not (U_2_bool (MapType0Select (|Map#Domain| m@@11) u@@8)))) (= (|Map#Card| (|Map#Build| m@@11 u@@8 v@@40)) (+ (|Map#Card| m@@11) 1))))) :qid |DafnyPre.1034:21| :skolemid |258| :pattern ((|Map#Card| (|Map#Build| m@@11 u@@8 v@@40))))))
(assert (forall ((m@@12 T@U) (|m'| T@U)) (! (let ((V@@13 (MapTypeInv1 (type m@@12)))) (let ((U@@15 (MapTypeInv0 (type m@@12)))) (=> (and (= (type m@@12) (MapType U@@15 V@@13)) (= (type |m'|) (MapType U@@15 V@@13))) (and (=> (|Map#Equal| m@@12 |m'|) (and (forall ((u@@9 T@U)) (! (=> (= (type u@@9) U@@15) (and (=> (U_2_bool (MapType0Select (|Map#Domain| m@@12) u@@9)) (U_2_bool (MapType0Select (|Map#Domain| |m'|) u@@9))) (=> (U_2_bool (MapType0Select (|Map#Domain| |m'|) u@@9)) (U_2_bool (MapType0Select (|Map#Domain| m@@12) u@@9))))) :qid |DafnyPre.1042:35| :skolemid |259| :no-pattern (type u@@9) :no-pattern (U_2_int u@@9) :no-pattern (U_2_bool u@@9))) (forall ((u@@10 T@U)) (! (=> (and (= (type u@@10) U@@15) (U_2_bool (MapType0Select (|Map#Domain| m@@12) u@@10))) (= (MapType0Select (|Map#Elements| m@@12) u@@10) (MapType0Select (|Map#Elements| |m'|) u@@10))) :qid |DafnyPre.1043:35| :skolemid |260| :no-pattern (type u@@10) :no-pattern (U_2_int u@@10) :no-pattern (U_2_bool u@@10))))) (=> (and (forall ((u@@11 T@U)) (! (=> (= (type u@@11) U@@15) (and (=> (U_2_bool (MapType0Select (|Map#Domain| m@@12) u@@11)) (U_2_bool (MapType0Select (|Map#Domain| |m'|) u@@11))) (=> (U_2_bool (MapType0Select (|Map#Domain| |m'|) u@@11)) (U_2_bool (MapType0Select (|Map#Domain| m@@12) u@@11))))) :qid |DafnyPre.1042:35| :skolemid |259| :no-pattern (type u@@11) :no-pattern (U_2_int u@@11) :no-pattern (U_2_bool u@@11))) (forall ((u@@12 T@U)) (! (=> (and (= (type u@@12) U@@15) (U_2_bool (MapType0Select (|Map#Domain| m@@12) u@@12))) (= (MapType0Select (|Map#Elements| m@@12) u@@12) (MapType0Select (|Map#Elements| |m'|) u@@12))) :qid |DafnyPre.1043:35| :skolemid |260| :no-pattern (type u@@12) :no-pattern (U_2_int u@@12) :no-pattern (U_2_bool u@@12)))) (|Map#Equal| m@@12 |m'|)))))) :qid |DafnyPre.1040:21| :skolemid |261| :pattern ((|Map#Equal| m@@12 |m'|)))))
(assert (forall ((m@@13 T@U) (|m'@@0| T@U)) (! (let ((V@@14 (MapTypeInv1 (type m@@13)))) (let ((U@@16 (MapTypeInv0 (type m@@13)))) (=> (and (and (= (type m@@13) (MapType U@@16 V@@14)) (= (type |m'@@0|) (MapType U@@16 V@@14))) (|Map#Equal| m@@13 |m'@@0|)) (= m@@13 |m'@@0|)))) :qid |DafnyPre.1045:21| :skolemid |262| :pattern ((|Map#Equal| m@@13 |m'@@0|)))))
(assert (forall ((m@@14 T@U) (|m'@@1| T@U)) (! (let ((V@@15 (MapTypeInv1 (type m@@14)))) (let ((U@@17 (MapTypeInv0 (type m@@14)))) (=> (and (= (type m@@14) (MapType U@@17 V@@15)) (= (type |m'@@1|) (MapType U@@17 V@@15))) (and (=> (|Map#Disjoint| m@@14 |m'@@1|) (forall ((o@@37 T@U)) (! (=> (= (type o@@37) U@@17) (or (not (U_2_bool (MapType0Select (|Map#Domain| m@@14) o@@37))) (not (U_2_bool (MapType0Select (|Map#Domain| |m'@@1|) o@@37))))) :qid |DafnyPre.1052:38| :skolemid |263| :pattern ((MapType0Select (|Map#Domain| m@@14) o@@37)) :pattern ((MapType0Select (|Map#Domain| |m'@@1|) o@@37))))) (=> (forall ((o@@38 T@U)) (! (=> (= (type o@@38) U@@17) (or (not (U_2_bool (MapType0Select (|Map#Domain| m@@14) o@@38))) (not (U_2_bool (MapType0Select (|Map#Domain| |m'@@1|) o@@38))))) :qid |DafnyPre.1052:38| :skolemid |263| :pattern ((MapType0Select (|Map#Domain| m@@14) o@@38)) :pattern ((MapType0Select (|Map#Domain| |m'@@1|) o@@38)))) (|Map#Disjoint| m@@14 |m'@@1|)))))) :qid |DafnyPre.1050:21| :skolemid |264| :pattern ((|Map#Disjoint| m@@14 |m'@@1|)))))
(assert (forall ((U@@18 T@T) (V@@16 T@T)) (! (= (type (|IMap#Empty| U@@18 V@@16)) (IMapType U@@18 V@@16)) :qid |funType:IMap#Empty| :pattern ((|IMap#Empty| U@@18 V@@16)))))
(assert (forall ((u@@13 T@U) (V@@17 T@T)) (! (let ((U@@19 (type u@@13))) (not (U_2_bool (MapType0Select (|IMap#Domain| (|IMap#Empty| U@@19 V@@17)) u@@13)))) :qid |DafnyPre.1064:21| :skolemid |265| :pattern ((let ((U@@19 (type u@@13))) (MapType0Select (|IMap#Domain| (|IMap#Empty| U@@19 V@@17)) u@@13))))))
(assert (forall ((arg0@@85 T@U) (arg1@@39 T@U) (arg2@@5 T@U)) (! (let ((V@@18 (MapType0TypeInv1 (type arg1@@39)))) (let ((U@@20 (MapType0TypeInv0 (type arg0@@85)))) (= (type (|IMap#Glue| arg0@@85 arg1@@39 arg2@@5)) (IMapType U@@20 V@@18)))) :qid |funType:IMap#Glue| :pattern ((|IMap#Glue| arg0@@85 arg1@@39 arg2@@5)))))
(assert (forall ((a@@74 T@U) (b@@53 T@U) (t@@32 T@U)) (! (let ((V@@19 (MapType0TypeInv1 (type b@@53)))) (let ((U@@21 (MapType0TypeInv0 (type a@@74)))) (=> (and (and (= (type a@@74) (MapType0Type U@@21 boolType)) (= (type b@@53) (MapType0Type U@@21 V@@19))) (= (type t@@32) TyType)) (= (|IMap#Domain| (|IMap#Glue| a@@74 b@@53 t@@32)) a@@74)))) :qid |DafnyPre.1069:21| :skolemid |266| :pattern ((|IMap#Domain| (|IMap#Glue| a@@74 b@@53 t@@32))))))
(assert (forall ((a@@75 T@U) (b@@54 T@U) (t@@33 T@U)) (! (let ((V@@20 (MapType0TypeInv1 (type b@@54)))) (let ((U@@22 (MapType0TypeInv0 (type a@@75)))) (=> (and (and (= (type a@@75) (MapType0Type U@@22 boolType)) (= (type b@@54) (MapType0Type U@@22 V@@20))) (= (type t@@33) TyType)) (= (|IMap#Elements| (|IMap#Glue| a@@75 b@@54 t@@33)) b@@54)))) :qid |DafnyPre.1072:21| :skolemid |267| :pattern ((|IMap#Elements| (|IMap#Glue| a@@75 b@@54 t@@33))))))
(assert (forall ((a@@76 T@U) (b@@55 T@U) (t@@34 T@U)) (! (let ((V@@21 (MapType0TypeInv1 (type b@@55)))) (let ((U@@23 (MapType0TypeInv0 (type a@@76)))) (=> (and (and (= (type a@@76) (MapType0Type U@@23 boolType)) (= (type b@@55) (MapType0Type U@@23 V@@21))) (= (type t@@34) TyType)) ($Is (|IMap#Glue| a@@76 b@@55 t@@34) t@@34)))) :qid |DafnyPre.1075:21| :skolemid |268| :pattern (($Is (|IMap#Glue| a@@76 b@@55 t@@34) t@@34)))))
(assert (forall ((arg0@@86 T@U) (arg1@@40 T@U) (arg2@@6 T@U)) (! (let ((V@@22 (type arg2@@6))) (let ((U@@24 (type arg1@@40))) (= (type (|IMap#Build| arg0@@86 arg1@@40 arg2@@6)) (IMapType U@@24 V@@22)))) :qid |funType:IMap#Build| :pattern ((|IMap#Build| arg0@@86 arg1@@40 arg2@@6)))))
(assert (forall ((m@@15 T@U) (u@@14 T@U) (|u'@@0| T@U) (v@@41 T@U)) (! (let ((V@@23 (type v@@41))) (let ((U@@25 (type u@@14))) (=> (and (= (type m@@15) (IMapType U@@25 V@@23)) (= (type |u'@@0|) U@@25)) (and (=> (= |u'@@0| u@@14) (and (U_2_bool (MapType0Select (|IMap#Domain| (|IMap#Build| m@@15 u@@14 v@@41)) |u'@@0|)) (= (MapType0Select (|IMap#Elements| (|IMap#Build| m@@15 u@@14 v@@41)) |u'@@0|) v@@41))) (=> (not (= |u'@@0| u@@14)) (and (and (=> (U_2_bool (MapType0Select (|IMap#Domain| (|IMap#Build| m@@15 u@@14 v@@41)) |u'@@0|)) (U_2_bool (MapType0Select (|IMap#Domain| m@@15) |u'@@0|))) (=> (U_2_bool (MapType0Select (|IMap#Domain| m@@15) |u'@@0|)) (U_2_bool (MapType0Select (|IMap#Domain| (|IMap#Build| m@@15 u@@14 v@@41)) |u'@@0|)))) (= (MapType0Select (|IMap#Elements| (|IMap#Build| m@@15 u@@14 v@@41)) |u'@@0|) (MapType0Select (|IMap#Elements| m@@15) |u'@@0|)))))))) :qid |DafnyPre.1085:21| :skolemid |269| :pattern ((MapType0Select (|IMap#Domain| (|IMap#Build| m@@15 u@@14 v@@41)) |u'@@0|)) :pattern ((MapType0Select (|IMap#Elements| (|IMap#Build| m@@15 u@@14 v@@41)) |u'@@0|)))))
(assert (forall ((m@@16 T@U) (|m'@@2| T@U)) (! (let ((V@@24 (IMapTypeInv1 (type m@@16)))) (let ((U@@26 (IMapTypeInv0 (type m@@16)))) (=> (and (= (type m@@16) (IMapType U@@26 V@@24)) (= (type |m'@@2|) (IMapType U@@26 V@@24))) (and (=> (|IMap#Equal| m@@16 |m'@@2|) (and (forall ((u@@15 T@U)) (! (=> (= (type u@@15) U@@26) (and (=> (U_2_bool (MapType0Select (|IMap#Domain| m@@16) u@@15)) (U_2_bool (MapType0Select (|IMap#Domain| |m'@@2|) u@@15))) (=> (U_2_bool (MapType0Select (|IMap#Domain| |m'@@2|) u@@15)) (U_2_bool (MapType0Select (|IMap#Domain| m@@16) u@@15))))) :qid |DafnyPre.1096:36| :skolemid |270| :no-pattern (type u@@15) :no-pattern (U_2_int u@@15) :no-pattern (U_2_bool u@@15))) (forall ((u@@16 T@U)) (! (=> (and (= (type u@@16) U@@26) (U_2_bool (MapType0Select (|IMap#Domain| m@@16) u@@16))) (= (MapType0Select (|IMap#Elements| m@@16) u@@16) (MapType0Select (|IMap#Elements| |m'@@2|) u@@16))) :qid |DafnyPre.1097:35| :skolemid |271| :no-pattern (type u@@16) :no-pattern (U_2_int u@@16) :no-pattern (U_2_bool u@@16))))) (=> (and (forall ((u@@17 T@U)) (! (=> (= (type u@@17) U@@26) (and (=> (U_2_bool (MapType0Select (|IMap#Domain| m@@16) u@@17)) (U_2_bool (MapType0Select (|IMap#Domain| |m'@@2|) u@@17))) (=> (U_2_bool (MapType0Select (|IMap#Domain| |m'@@2|) u@@17)) (U_2_bool (MapType0Select (|IMap#Domain| m@@16) u@@17))))) :qid |DafnyPre.1096:36| :skolemid |270| :no-pattern (type u@@17) :no-pattern (U_2_int u@@17) :no-pattern (U_2_bool u@@17))) (forall ((u@@18 T@U)) (! (=> (and (= (type u@@18) U@@26) (U_2_bool (MapType0Select (|IMap#Domain| m@@16) u@@18))) (= (MapType0Select (|IMap#Elements| m@@16) u@@18) (MapType0Select (|IMap#Elements| |m'@@2|) u@@18))) :qid |DafnyPre.1097:35| :skolemid |271| :no-pattern (type u@@18) :no-pattern (U_2_int u@@18) :no-pattern (U_2_bool u@@18)))) (|IMap#Equal| m@@16 |m'@@2|)))))) :qid |DafnyPre.1094:21| :skolemid |272| :pattern ((|IMap#Equal| m@@16 |m'@@2|)))))
(assert (forall ((m@@17 T@U) (|m'@@3| T@U)) (! (let ((V@@25 (IMapTypeInv1 (type m@@17)))) (let ((U@@27 (IMapTypeInv0 (type m@@17)))) (=> (and (and (= (type m@@17) (IMapType U@@27 V@@25)) (= (type |m'@@3|) (IMapType U@@27 V@@25))) (|IMap#Equal| m@@17 |m'@@3|)) (= m@@17 |m'@@3|)))) :qid |DafnyPre.1099:21| :skolemid |273| :pattern ((|IMap#Equal| m@@17 |m'@@3|)))))
(assert (forall ((x@@40 Int) (y@@12 Int)) (! (= (INTERNAL_add_boogie x@@40 y@@12) (+ x@@40 y@@12)) :qid |DafnyPre.1107:30| :skolemid |274| :pattern ((INTERNAL_add_boogie x@@40 y@@12)))))
(assert (forall ((x@@41 Int) (y@@13 Int)) (! (= (INTERNAL_sub_boogie x@@41 y@@13) (- x@@41 y@@13)) :qid |DafnyPre.1108:30| :skolemid |275| :pattern ((INTERNAL_sub_boogie x@@41 y@@13)))))
(assert (forall ((x@@42 Int) (y@@14 Int)) (! (= (INTERNAL_mul_boogie x@@42 y@@14) (* x@@42 y@@14)) :qid |DafnyPre.1109:30| :skolemid |276| :pattern ((INTERNAL_mul_boogie x@@42 y@@14)))))
(assert (forall ((x@@43 Int) (y@@15 Int)) (! (= (INTERNAL_div_boogie x@@43 y@@15) (div x@@43 y@@15)) :qid |DafnyPre.1110:30| :skolemid |277| :pattern ((INTERNAL_div_boogie x@@43 y@@15)))))
(assert (forall ((x@@44 Int) (y@@16 Int)) (! (= (INTERNAL_mod_boogie x@@44 y@@16) (mod x@@44 y@@16)) :qid |DafnyPre.1111:30| :skolemid |278| :pattern ((INTERNAL_mod_boogie x@@44 y@@16)))))
(assert (forall ((x@@45 Int) (y@@17 Int)) (! (and (=> (INTERNAL_lt_boogie x@@45 y@@17) (< x@@45 y@@17)) (=> (< x@@45 y@@17) (INTERNAL_lt_boogie x@@45 y@@17))) :qid |DafnyPre.1112:51| :skolemid |279| :pattern ((INTERNAL_lt_boogie x@@45 y@@17)))))
(assert (forall ((x@@46 Int) (y@@18 Int)) (! (and (=> (INTERNAL_le_boogie x@@46 y@@18) (<= x@@46 y@@18)) (=> (<= x@@46 y@@18) (INTERNAL_le_boogie x@@46 y@@18))) :qid |DafnyPre.1113:51| :skolemid |280| :pattern ((INTERNAL_le_boogie x@@46 y@@18)))))
(assert (forall ((x@@47 Int) (y@@19 Int)) (! (and (=> (INTERNAL_gt_boogie x@@47 y@@19) (> x@@47 y@@19)) (=> (> x@@47 y@@19) (INTERNAL_gt_boogie x@@47 y@@19))) :qid |DafnyPre.1114:51| :skolemid |281| :pattern ((INTERNAL_gt_boogie x@@47 y@@19)))))
(assert (forall ((x@@48 Int) (y@@20 Int)) (! (and (=> (INTERNAL_ge_boogie x@@48 y@@20) (>= x@@48 y@@20)) (=> (>= x@@48 y@@20) (INTERNAL_ge_boogie x@@48 y@@20))) :qid |DafnyPre.1115:51| :skolemid |282| :pattern ((INTERNAL_ge_boogie x@@48 y@@20)))))
(assert (= (Tag Tclass._System.object) Tagclass._System.object))
(assert (forall ((bx@@35 T@U)) (! (=> (and (= (type bx@@35) BoxType) ($IsBox bx@@35 Tclass._System.object)) (and (= ($Box ($Unbox refType bx@@35)) bx@@35) ($Is ($Unbox refType bx@@35) Tclass._System.object))) :qid |unknown.0:0| :skolemid |283| :pattern (($IsBox bx@@35 Tclass._System.object)))))
(assert (forall (($o T@U)) (! (=> (= (type $o) refType) ($Is $o Tclass._System.object)) :qid |unknown.0:0| :skolemid |284| :pattern (($Is $o Tclass._System.object)))))
(assert (= (type null) refType))
(assert (forall (($o@@0 T@U) ($h T@U)) (! (=> (and (= (type $o@@0) refType) (= (type $h) (MapType1Type refType))) (and (=> ($IsAlloc $o@@0 Tclass._System.object $h) (or (= $o@@0 null) (U_2_bool (MapType1Select $h $o@@0 alloc)))) (=> (or (= $o@@0 null) (U_2_bool (MapType1Select $h $o@@0 alloc))) ($IsAlloc $o@@0 Tclass._System.object $h)))) :qid |unknown.0:0| :skolemid |285| :pattern (($IsAlloc $o@@0 Tclass._System.object $h)))))
(assert (forall ((arg0@@87 T@U)) (! (= (type (Tclass._System.array arg0@@87)) TyType) :qid |funType:Tclass._System.array| :pattern ((Tclass._System.array arg0@@87)))))
(assert (forall ((|#$arg| T@U)) (! (=> (= (type |#$arg|) TyType) (= (Tag (Tclass._System.array |#$arg|)) Tagclass._System.array)) :qid |unknown.0:0| :skolemid |286| :pattern ((Tclass._System.array |#$arg|)))))
(assert (forall ((arg0@@88 T@U)) (! (= (type (Tclass._System.array_0 arg0@@88)) TyType) :qid |funType:Tclass._System.array_0| :pattern ((Tclass._System.array_0 arg0@@88)))))
(assert (forall ((|#$arg@@0| T@U)) (! (=> (= (type |#$arg@@0|) TyType) (= (Tclass._System.array_0 (Tclass._System.array |#$arg@@0|)) |#$arg@@0|)) :qid |unknown.0:0| :skolemid |287| :pattern ((Tclass._System.array |#$arg@@0|)))))
(assert (forall ((|#$arg@@1| T@U) (bx@@36 T@U)) (! (=> (and (and (= (type |#$arg@@1|) TyType) (= (type bx@@36) BoxType)) ($IsBox bx@@36 (Tclass._System.array |#$arg@@1|))) (and (= ($Box ($Unbox refType bx@@36)) bx@@36) ($Is ($Unbox refType bx@@36) (Tclass._System.array |#$arg@@1|)))) :qid |unknown.0:0| :skolemid |288| :pattern (($IsBox bx@@36 (Tclass._System.array |#$arg@@1|))))))
(assert (forall ((arg0@@89 T@U)) (! (= (type (dtype arg0@@89)) TyType) :qid |funType:dtype| :pattern ((dtype arg0@@89)))))
(assert (forall ((|#$arg@@2| T@U) ($i0 Int) ($h@@0 T@U) ($o@@1 T@U)) (! (=> (and (and (= (type |#$arg@@2|) TyType) (= (type $h@@0) (MapType1Type refType))) (= (type $o@@1) refType)) (=> (and (and (and ($IsGoodHeap $h@@0) (not (= $o@@1 null))) (= (dtype $o@@1) (Tclass._System.array |#$arg@@2|))) (and (<= 0 $i0) (< $i0 (_System.array.Length $o@@1)))) (and ($IsBox (MapType1Select $h@@0 $o@@1 (IndexField $i0)) |#$arg@@2|) (=> (U_2_bool (MapType1Select $h@@0 $o@@1 alloc)) ($IsAllocBox (MapType1Select $h@@0 $o@@1 (IndexField $i0)) |#$arg@@2| $h@@0))))) :qid |unknown.0:0| :skolemid |289| :pattern ((MapType1Select $h@@0 $o@@1 (IndexField $i0)) (Tclass._System.array |#$arg@@2|)))))
(assert (forall ((|#$arg@@3| T@U) ($o@@2 T@U)) (! (=> (and (= (type |#$arg@@3|) TyType) (= (type $o@@2) refType)) (and (=> ($Is $o@@2 (Tclass._System.array |#$arg@@3|)) (or (= $o@@2 null) (= (dtype $o@@2) (Tclass._System.array |#$arg@@3|)))) (=> (or (= $o@@2 null) (= (dtype $o@@2) (Tclass._System.array |#$arg@@3|))) ($Is $o@@2 (Tclass._System.array |#$arg@@3|))))) :qid |unknown.0:0| :skolemid |290| :pattern (($Is $o@@2 (Tclass._System.array |#$arg@@3|))))))
(assert (forall ((|#$arg@@4| T@U) ($o@@3 T@U) ($h@@1 T@U)) (! (=> (and (and (= (type |#$arg@@4|) TyType) (= (type $o@@3) refType)) (= (type $h@@1) (MapType1Type refType))) (and (=> ($IsAlloc $o@@3 (Tclass._System.array |#$arg@@4|) $h@@1) (or (= $o@@3 null) (U_2_bool (MapType1Select $h@@1 $o@@3 alloc)))) (=> (or (= $o@@3 null) (U_2_bool (MapType1Select $h@@1 $o@@3 alloc))) ($IsAlloc $o@@3 (Tclass._System.array |#$arg@@4|) $h@@1)))) :qid |unknown.0:0| :skolemid |291| :pattern (($IsAlloc $o@@3 (Tclass._System.array |#$arg@@4|) $h@@1)))))
(assert (forall ((|#$arg@@5| T@U) ($h@@2 T@U) ($o@@4 T@U)) (! (=> (and (and (and (= (type |#$arg@@5|) TyType) (= (type $h@@2) (MapType1Type refType))) (= (type $o@@4) refType)) (and (and ($IsGoodHeap $h@@2) (not (= $o@@4 null))) (= (dtype $o@@4) (Tclass._System.array |#$arg@@5|)))) (and ($Is (int_2_U (_System.array.Length $o@@4)) TInt) (=> (U_2_bool (MapType1Select $h@@2 $o@@4 alloc)) ($IsAlloc (int_2_U (_System.array.Length $o@@4)) TInt $h@@2)))) :qid |unknown.0:0| :skolemid |292| :no-pattern (type |#$arg@@5|) :no-pattern (type $h@@2) :no-pattern (type $o@@4) :no-pattern (U_2_int |#$arg@@5|) :no-pattern (U_2_bool |#$arg@@5|) :no-pattern (U_2_int $h@@2) :no-pattern (U_2_bool $h@@2) :no-pattern (U_2_int $o@@4) :no-pattern (U_2_bool $o@@4))))
(assert (forall ((arg0@@90 T@U)) (! (= (type (Tclass._System.___hFunc0 arg0@@90)) TyType) :qid |funType:Tclass._System.___hFunc0| :pattern ((Tclass._System.___hFunc0 arg0@@90)))))
(assert (forall ((|#$T0| T@U)) (! (=> (= (type |#$T0|) TyType) (= (Tag (Tclass._System.___hFunc0 |#$T0|)) Tagclass._System.___hFunc0)) :qid |unknown.0:0| :skolemid |293| :pattern ((Tclass._System.___hFunc0 |#$T0|)))))
(assert (forall ((arg0@@91 T@U)) (! (= (type (Tclass._System.___hFunc0_0 arg0@@91)) TyType) :qid |funType:Tclass._System.___hFunc0_0| :pattern ((Tclass._System.___hFunc0_0 arg0@@91)))))
(assert (forall ((|#$T0@@0| T@U)) (! (=> (= (type |#$T0@@0|) TyType) (= (Tclass._System.___hFunc0_0 (Tclass._System.___hFunc0 |#$T0@@0|)) |#$T0@@0|)) :qid |unknown.0:0| :skolemid |294| :pattern ((Tclass._System.___hFunc0 |#$T0@@0|)))))
(assert (= (Ctor HandleTypeType) 18))
(assert (forall ((|#$T0@@1| T@U) (bx@@37 T@U)) (! (=> (and (and (= (type |#$T0@@1|) TyType) (= (type bx@@37) BoxType)) ($IsBox bx@@37 (Tclass._System.___hFunc0 |#$T0@@1|))) (and (= ($Box ($Unbox HandleTypeType bx@@37)) bx@@37) ($Is ($Unbox HandleTypeType bx@@37) (Tclass._System.___hFunc0 |#$T0@@1|)))) :qid |unknown.0:0| :skolemid |295| :pattern (($IsBox bx@@37 (Tclass._System.___hFunc0 |#$T0@@1|))))))
(assert (and (forall ((arg0@@92 T@U) (arg1@@41 T@U) (arg2@@7 T@U)) (! (= (type (Apply0 arg0@@92 arg1@@41 arg2@@7)) BoxType) :qid |funType:Apply0| :pattern ((Apply0 arg0@@92 arg1@@41 arg2@@7)))) (forall ((arg0@@93 T@U) (arg1@@42 T@U) (arg2@@8 T@U)) (! (= (type (Handle0 arg0@@93 arg1@@42 arg2@@8)) HandleTypeType) :qid |funType:Handle0| :pattern ((Handle0 arg0@@93 arg1@@42 arg2@@8))))))
(assert (forall ((t0@@12 T@U) (heap T@U) (h@@20 T@U) (r@@5 T@U) (rd T@U)) (! (=> (and (and (and (and (= (type t0@@12) TyType) (= (type heap) (MapType1Type refType))) (= (type h@@20) (MapType0Type (MapType1Type refType) BoxType))) (= (type r@@5) (MapType0Type (MapType1Type refType) boolType))) (= (type rd) (MapType0Type (MapType1Type refType) (MapType0Type BoxType boolType)))) (= (Apply0 t0@@12 (Handle0 h@@20 r@@5 rd) heap) (MapType0Select h@@20 heap))) :qid |unknown.0:0| :skolemid |296| :pattern ((Apply0 t0@@12 (Handle0 h@@20 r@@5 rd) heap)))))
(assert (forall ((t0@@13 T@U) (heap@@0 T@U) (h@@21 T@U) (r@@6 T@U) (rd@@0 T@U)) (! (=> (and (and (and (and (and (= (type t0@@13) TyType) (= (type heap@@0) (MapType1Type refType))) (= (type h@@21) (MapType0Type (MapType1Type refType) BoxType))) (= (type r@@6) (MapType0Type (MapType1Type refType) boolType))) (= (type rd@@0) (MapType0Type (MapType1Type refType) (MapType0Type BoxType boolType)))) (U_2_bool (MapType0Select r@@6 heap@@0))) (Requires0 t0@@13 (Handle0 h@@21 r@@6 rd@@0) heap@@0)) :qid |unknown.0:0| :skolemid |297| :pattern ((Requires0 t0@@13 (Handle0 h@@21 r@@6 rd@@0) heap@@0)))))
(assert (forall ((arg0@@94 T@U) (arg1@@43 T@U) (arg2@@9 T@U)) (! (= (type (Reads0 arg0@@94 arg1@@43 arg2@@9)) (MapType0Type BoxType boolType)) :qid |funType:Reads0| :pattern ((Reads0 arg0@@94 arg1@@43 arg2@@9)))))
(assert (forall ((t0@@14 T@U) (heap@@1 T@U) (h@@22 T@U) (r@@7 T@U) (rd@@1 T@U) (bx@@38 T@U)) (! (=> (and (and (and (and (and (= (type t0@@14) TyType) (= (type heap@@1) (MapType1Type refType))) (= (type h@@22) (MapType0Type (MapType1Type refType) BoxType))) (= (type r@@7) (MapType0Type (MapType1Type refType) boolType))) (= (type rd@@1) (MapType0Type (MapType1Type refType) (MapType0Type BoxType boolType)))) (= (type bx@@38) BoxType)) (and (=> (U_2_bool (MapType0Select (Reads0 t0@@14 (Handle0 h@@22 r@@7 rd@@1) heap@@1) bx@@38)) (U_2_bool (MapType0Select (MapType0Select rd@@1 heap@@1) bx@@38))) (=> (U_2_bool (MapType0Select (MapType0Select rd@@1 heap@@1) bx@@38)) (U_2_bool (MapType0Select (Reads0 t0@@14 (Handle0 h@@22 r@@7 rd@@1) heap@@1) bx@@38))))) :qid |unknown.0:0| :skolemid |298| :pattern ((MapType0Select (Reads0 t0@@14 (Handle0 h@@22 r@@7 rd@@1) heap@@1) bx@@38)))))
(assert (forall ((t0@@15 T@U) (h0@@0 T@U) (h1@@0 T@U) (f@@5 T@U)) (! (=> (and (and (and (and (= (type t0@@15) TyType) (= (type h0@@0) (MapType1Type refType))) (= (type h1@@0) (MapType1Type refType))) (= (type f@@5) HandleTypeType)) (and (and (and ($HeapSucc h0@@0 h1@@0) (and ($IsGoodHeap h0@@0) ($IsGoodHeap h1@@0))) (and ($Is f@@5 (Tclass._System.___hFunc0 t0@@15)) ($IsAlloc f@@5 (Tclass._System.___hFunc0 t0@@15) h0@@0))) (forall ((o@@39 T@U) (fld T@U)) (! (let ((a@@77 (FieldTypeInv0 (type fld)))) (=> (and (= (type o@@39) refType) (= (type fld) (FieldType a@@77))) (=> (and (and (and (not (= o@@39 null)) (U_2_bool (MapType1Select h0@@0 o@@39 alloc))) (U_2_bool (MapType1Select h1@@0 o@@39 alloc))) (U_2_bool (MapType0Select (Reads0 t0@@15 f@@5 h0@@0) ($Box o@@39)))) (= (MapType1Select h0@@0 o@@39 fld) (MapType1Select h1@@0 o@@39 fld))))) :qid |unknown.0:0| :skolemid |299| :no-pattern (type o@@39) :no-pattern (type fld) :no-pattern (U_2_int o@@39) :no-pattern (U_2_bool o@@39) :no-pattern (U_2_int fld) :no-pattern (U_2_bool fld))))) (= (Reads0 t0@@15 f@@5 h0@@0) (Reads0 t0@@15 f@@5 h1@@0))) :qid |unknown.0:0| :skolemid |300| :pattern (($HeapSucc h0@@0 h1@@0) (Reads0 t0@@15 f@@5 h1@@0)))))
(assert (forall ((t0@@16 T@U) (h0@@1 T@U) (h1@@1 T@U) (f@@6 T@U)) (! (=> (and (and (and (and (= (type t0@@16) TyType) (= (type h0@@1) (MapType1Type refType))) (= (type h1@@1) (MapType1Type refType))) (= (type f@@6) HandleTypeType)) (and (and (and ($HeapSucc h0@@1 h1@@1) (and ($IsGoodHeap h0@@1) ($IsGoodHeap h1@@1))) (and ($Is f@@6 (Tclass._System.___hFunc0 t0@@16)) ($IsAlloc f@@6 (Tclass._System.___hFunc0 t0@@16) h0@@1))) (forall ((o@@40 T@U) (fld@@0 T@U)) (! (let ((a@@78 (FieldTypeInv0 (type fld@@0)))) (=> (and (= (type o@@40) refType) (= (type fld@@0) (FieldType a@@78))) (=> (and (and (and (not (= o@@40 null)) (U_2_bool (MapType1Select h0@@1 o@@40 alloc))) (U_2_bool (MapType1Select h1@@1 o@@40 alloc))) (U_2_bool (MapType0Select (Reads0 t0@@16 f@@6 h1@@1) ($Box o@@40)))) (= (MapType1Select h0@@1 o@@40 fld@@0) (MapType1Select h1@@1 o@@40 fld@@0))))) :qid |unknown.0:0| :skolemid |301| :no-pattern (type o@@40) :no-pattern (type fld@@0) :no-pattern (U_2_int o@@40) :no-pattern (U_2_bool o@@40) :no-pattern (U_2_int fld@@0) :no-pattern (U_2_bool fld@@0))))) (= (Reads0 t0@@16 f@@6 h0@@1) (Reads0 t0@@16 f@@6 h1@@1))) :qid |unknown.0:0| :skolemid |302| :pattern (($HeapSucc h0@@1 h1@@1) (Reads0 t0@@16 f@@6 h1@@1)))))
(assert (forall ((t0@@17 T@U) (h0@@2 T@U) (h1@@2 T@U) (f@@7 T@U)) (! (=> (and (and (and (and (= (type t0@@17) TyType) (= (type h0@@2) (MapType1Type refType))) (= (type h1@@2) (MapType1Type refType))) (= (type f@@7) HandleTypeType)) (and (and (and ($HeapSucc h0@@2 h1@@2) (and ($IsGoodHeap h0@@2) ($IsGoodHeap h1@@2))) (and ($Is f@@7 (Tclass._System.___hFunc0 t0@@17)) ($IsAlloc f@@7 (Tclass._System.___hFunc0 t0@@17) h0@@2))) (forall ((o@@41 T@U) (fld@@1 T@U)) (! (let ((a@@79 (FieldTypeInv0 (type fld@@1)))) (=> (and (= (type o@@41) refType) (= (type fld@@1) (FieldType a@@79))) (=> (and (and (and (not (= o@@41 null)) (U_2_bool (MapType1Select h0@@2 o@@41 alloc))) (U_2_bool (MapType1Select h1@@2 o@@41 alloc))) (U_2_bool (MapType0Select (Reads0 t0@@17 f@@7 h0@@2) ($Box o@@41)))) (= (MapType1Select h0@@2 o@@41 fld@@1) (MapType1Select h1@@2 o@@41 fld@@1))))) :qid |unknown.0:0| :skolemid |303| :no-pattern (type o@@41) :no-pattern (type fld@@1) :no-pattern (U_2_int o@@41) :no-pattern (U_2_bool o@@41) :no-pattern (U_2_int fld@@1) :no-pattern (U_2_bool fld@@1))))) (and (=> (Requires0 t0@@17 f@@7 h0@@2) (Requires0 t0@@17 f@@7 h1@@2)) (=> (Requires0 t0@@17 f@@7 h1@@2) (Requires0 t0@@17 f@@7 h0@@2)))) :qid |unknown.0:0| :skolemid |304| :pattern (($HeapSucc h0@@2 h1@@2) (Requires0 t0@@17 f@@7 h1@@2)))))
(assert (forall ((t0@@18 T@U) (h0@@3 T@U) (h1@@3 T@U) (f@@8 T@U)) (! (=> (and (and (and (and (= (type t0@@18) TyType) (= (type h0@@3) (MapType1Type refType))) (= (type h1@@3) (MapType1Type refType))) (= (type f@@8) HandleTypeType)) (and (and (and ($HeapSucc h0@@3 h1@@3) (and ($IsGoodHeap h0@@3) ($IsGoodHeap h1@@3))) (and ($Is f@@8 (Tclass._System.___hFunc0 t0@@18)) ($IsAlloc f@@8 (Tclass._System.___hFunc0 t0@@18) h0@@3))) (forall ((o@@42 T@U) (fld@@2 T@U)) (! (let ((a@@80 (FieldTypeInv0 (type fld@@2)))) (=> (and (= (type o@@42) refType) (= (type fld@@2) (FieldType a@@80))) (=> (and (and (and (not (= o@@42 null)) (U_2_bool (MapType1Select h0@@3 o@@42 alloc))) (U_2_bool (MapType1Select h1@@3 o@@42 alloc))) (U_2_bool (MapType0Select (Reads0 t0@@18 f@@8 h1@@3) ($Box o@@42)))) (= (MapType1Select h0@@3 o@@42 fld@@2) (MapType1Select h1@@3 o@@42 fld@@2))))) :qid |unknown.0:0| :skolemid |305| :no-pattern (type o@@42) :no-pattern (type fld@@2) :no-pattern (U_2_int o@@42) :no-pattern (U_2_bool o@@42) :no-pattern (U_2_int fld@@2) :no-pattern (U_2_bool fld@@2))))) (and (=> (Requires0 t0@@18 f@@8 h0@@3) (Requires0 t0@@18 f@@8 h1@@3)) (=> (Requires0 t0@@18 f@@8 h1@@3) (Requires0 t0@@18 f@@8 h0@@3)))) :qid |unknown.0:0| :skolemid |306| :pattern (($HeapSucc h0@@3 h1@@3) (Requires0 t0@@18 f@@8 h1@@3)))))
(assert (forall ((t0@@19 T@U) (h0@@4 T@U) (h1@@4 T@U) (f@@9 T@U)) (! (=> (and (and (and (and (= (type t0@@19) TyType) (= (type h0@@4) (MapType1Type refType))) (= (type h1@@4) (MapType1Type refType))) (= (type f@@9) HandleTypeType)) (and (and (and ($HeapSucc h0@@4 h1@@4) (and ($IsGoodHeap h0@@4) ($IsGoodHeap h1@@4))) (and ($Is f@@9 (Tclass._System.___hFunc0 t0@@19)) ($IsAlloc f@@9 (Tclass._System.___hFunc0 t0@@19) h0@@4))) (forall ((o@@43 T@U) (fld@@3 T@U)) (! (let ((a@@81 (FieldTypeInv0 (type fld@@3)))) (=> (and (= (type o@@43) refType) (= (type fld@@3) (FieldType a@@81))) (=> (and (and (and (not (= o@@43 null)) (U_2_bool (MapType1Select h0@@4 o@@43 alloc))) (U_2_bool (MapType1Select h1@@4 o@@43 alloc))) (U_2_bool (MapType0Select (Reads0 t0@@19 f@@9 h0@@4) ($Box o@@43)))) (= (MapType1Select h0@@4 o@@43 fld@@3) (MapType1Select h1@@4 o@@43 fld@@3))))) :qid |unknown.0:0| :skolemid |307| :no-pattern (type o@@43) :no-pattern (type fld@@3) :no-pattern (U_2_int o@@43) :no-pattern (U_2_bool o@@43) :no-pattern (U_2_int fld@@3) :no-pattern (U_2_bool fld@@3))))) (= (Apply0 t0@@19 f@@9 h0@@4) (Apply0 t0@@19 f@@9 h1@@4))) :qid |unknown.0:0| :skolemid |308| :pattern (($HeapSucc h0@@4 h1@@4) (Apply0 t0@@19 f@@9 h1@@4)))))
(assert (forall ((t0@@20 T@U) (h0@@5 T@U) (h1@@5 T@U) (f@@10 T@U)) (! (=> (and (and (and (and (= (type t0@@20) TyType) (= (type h0@@5) (MapType1Type refType))) (= (type h1@@5) (MapType1Type refType))) (= (type f@@10) HandleTypeType)) (and (and (and ($HeapSucc h0@@5 h1@@5) (and ($IsGoodHeap h0@@5) ($IsGoodHeap h1@@5))) (and ($Is f@@10 (Tclass._System.___hFunc0 t0@@20)) ($IsAlloc f@@10 (Tclass._System.___hFunc0 t0@@20) h0@@5))) (forall ((o@@44 T@U) (fld@@4 T@U)) (! (let ((a@@82 (FieldTypeInv0 (type fld@@4)))) (=> (and (= (type o@@44) refType) (= (type fld@@4) (FieldType a@@82))) (=> (and (and (and (not (= o@@44 null)) (U_2_bool (MapType1Select h0@@5 o@@44 alloc))) (U_2_bool (MapType1Select h1@@5 o@@44 alloc))) (U_2_bool (MapType0Select (Reads0 t0@@20 f@@10 h1@@5) ($Box o@@44)))) (= (MapType1Select h0@@5 o@@44 fld@@4) (MapType1Select h1@@5 o@@44 fld@@4))))) :qid |unknown.0:0| :skolemid |309| :no-pattern (type o@@44) :no-pattern (type fld@@4) :no-pattern (U_2_int o@@44) :no-pattern (U_2_bool o@@44) :no-pattern (U_2_int fld@@4) :no-pattern (U_2_bool fld@@4))))) (= (Apply0 t0@@20 f@@10 h0@@5) (Apply0 t0@@20 f@@10 h1@@5))) :qid |unknown.0:0| :skolemid |310| :pattern (($HeapSucc h0@@5 h1@@5) (Apply0 t0@@20 f@@10 h1@@5)))))
(assert (forall ((t0@@21 T@U) (h@@23 T@U) (f@@11 T@U)) (! (=> (and (and (and (= (type t0@@21) TyType) (= (type h@@23) (MapType1Type refType))) (= (type f@@11) HandleTypeType)) (and ($IsGoodHeap h@@23) (and ($Is f@@11 (Tclass._System.___hFunc0 t0@@21)) ($IsAlloc f@@11 (Tclass._System.___hFunc0 t0@@21) h@@23)))) (and ($IsBox (Apply0 t0@@21 f@@11 h@@23) t0@@21) ($IsAllocBox (Apply0 t0@@21 f@@11 h@@23) t0@@21 h@@23))) :qid |unknown.0:0| :skolemid |311| :pattern ((Apply0 t0@@21 f@@11 h@@23)))))
(assert (forall ((arg0@@95 T@U) (arg1@@44 T@U)) (! (= (type (Tclass._System.___hFunc1 arg0@@95 arg1@@44)) TyType) :qid |funType:Tclass._System.___hFunc1| :pattern ((Tclass._System.___hFunc1 arg0@@95 arg1@@44)))))
(assert (forall ((|#$T0@@2| T@U) (|#$T1| T@U)) (! (=> (and (= (type |#$T0@@2|) TyType) (= (type |#$T1|) TyType)) (= (Tag (Tclass._System.___hFunc1 |#$T0@@2| |#$T1|)) Tagclass._System.___hFunc1)) :qid |unknown.0:0| :skolemid |312| :pattern ((Tclass._System.___hFunc1 |#$T0@@2| |#$T1|)))))
(assert (forall ((arg0@@96 T@U)) (! (= (type (Tclass._System.___hFunc1_0 arg0@@96)) TyType) :qid |funType:Tclass._System.___hFunc1_0| :pattern ((Tclass._System.___hFunc1_0 arg0@@96)))))
(assert (forall ((|#$T0@@3| T@U) (|#$T1@@0| T@U)) (! (=> (and (= (type |#$T0@@3|) TyType) (= (type |#$T1@@0|) TyType)) (= (Tclass._System.___hFunc1_0 (Tclass._System.___hFunc1 |#$T0@@3| |#$T1@@0|)) |#$T0@@3|)) :qid |unknown.0:0| :skolemid |313| :pattern ((Tclass._System.___hFunc1 |#$T0@@3| |#$T1@@0|)))))
(assert (forall ((arg0@@97 T@U)) (! (= (type (Tclass._System.___hFunc1_1 arg0@@97)) TyType) :qid |funType:Tclass._System.___hFunc1_1| :pattern ((Tclass._System.___hFunc1_1 arg0@@97)))))
(assert (forall ((|#$T0@@4| T@U) (|#$T1@@1| T@U)) (! (=> (and (= (type |#$T0@@4|) TyType) (= (type |#$T1@@1|) TyType)) (= (Tclass._System.___hFunc1_1 (Tclass._System.___hFunc1 |#$T0@@4| |#$T1@@1|)) |#$T1@@1|)) :qid |unknown.0:0| :skolemid |314| :pattern ((Tclass._System.___hFunc1 |#$T0@@4| |#$T1@@1|)))))
(assert (forall ((|#$T0@@5| T@U) (|#$T1@@2| T@U) (bx@@39 T@U)) (! (=> (and (and (and (= (type |#$T0@@5|) TyType) (= (type |#$T1@@2|) TyType)) (= (type bx@@39) BoxType)) ($IsBox bx@@39 (Tclass._System.___hFunc1 |#$T0@@5| |#$T1@@2|))) (and (= ($Box ($Unbox HandleTypeType bx@@39)) bx@@39) ($Is ($Unbox HandleTypeType bx@@39) (Tclass._System.___hFunc1 |#$T0@@5| |#$T1@@2|)))) :qid |unknown.0:0| :skolemid |315| :pattern (($IsBox bx@@39 (Tclass._System.___hFunc1 |#$T0@@5| |#$T1@@2|))))))
(assert (and (and (and (and (and (and (and (and (and (forall ((arg0@@98 T@T) (arg1@@45 T@T) (arg2@@10 T@T)) (! (= (Ctor (MapType2Type arg0@@98 arg1@@45 arg2@@10)) 19) :qid |ctor:MapType2Type|)) (forall ((arg0@@99 T@T) (arg1@@46 T@T) (arg2@@11 T@T)) (! (= (MapType2TypeInv0 (MapType2Type arg0@@99 arg1@@46 arg2@@11)) arg0@@99) :qid |typeInv:MapType2TypeInv0| :pattern ((MapType2Type arg0@@99 arg1@@46 arg2@@11))))) (forall ((arg0@@100 T@T) (arg1@@47 T@T) (arg2@@12 T@T)) (! (= (MapType2TypeInv1 (MapType2Type arg0@@100 arg1@@47 arg2@@12)) arg1@@47) :qid |typeInv:MapType2TypeInv1| :pattern ((MapType2Type arg0@@100 arg1@@47 arg2@@12))))) (forall ((arg0@@101 T@T) (arg1@@48 T@T) (arg2@@13 T@T)) (! (= (MapType2TypeInv2 (MapType2Type arg0@@101 arg1@@48 arg2@@13)) arg2@@13) :qid |typeInv:MapType2TypeInv2| :pattern ((MapType2Type arg0@@101 arg1@@48 arg2@@13))))) (forall ((arg0@@102 T@U) (arg1@@49 T@U) (arg2@@14 T@U)) (! (let ((aVar2 (MapType2TypeInv2 (type arg0@@102)))) (= (type (MapType2Select arg0@@102 arg1@@49 arg2@@14)) aVar2)) :qid |funType:MapType2Select| :pattern ((MapType2Select arg0@@102 arg1@@49 arg2@@14))))) (forall ((arg0@@103 T@U) (arg1@@50 T@U) (arg2@@15 T@U) (arg3@@0 T@U)) (! (let ((aVar2@@0 (type arg3@@0))) (let ((aVar1@@2 (type arg2@@15))) (let ((aVar0@@1 (type arg1@@50))) (= (type (MapType2Store arg0@@103 arg1@@50 arg2@@15 arg3@@0)) (MapType2Type aVar0@@1 aVar1@@2 aVar2@@0))))) :qid |funType:MapType2Store| :pattern ((MapType2Store arg0@@103 arg1@@50 arg2@@15 arg3@@0))))) (forall ((m@@18 T@U) (x0@@6 T@U) (x1@@3 T@U) (val@@6 T@U)) (! (let ((aVar2@@1 (MapType2TypeInv2 (type m@@18)))) (=> (= (type val@@6) aVar2@@1) (= (MapType2Select (MapType2Store m@@18 x0@@6 x1@@3 val@@6) x0@@6 x1@@3) val@@6))) :qid |mapAx0:MapType2Select| :weight 0))) (and (and (forall ((val@@7 T@U) (m@@19 T@U) (x0@@7 T@U) (x1@@4 T@U) (y0@@4 T@U) (y1@@2 T@U)) (! (or (= x0@@7 y0@@4) (= (MapType2Select (MapType2Store m@@19 x0@@7 x1@@4 val@@7) y0@@4 y1@@2) (MapType2Select m@@19 y0@@4 y1@@2))) :qid |mapAx1:MapType2Select:0| :weight 0)) (forall ((val@@8 T@U) (m@@20 T@U) (x0@@8 T@U) (x1@@5 T@U) (y0@@5 T@U) (y1@@3 T@U)) (! (or (= x1@@5 y1@@3) (= (MapType2Select (MapType2Store m@@20 x0@@8 x1@@5 val@@8) y0@@5 y1@@3) (MapType2Select m@@20 y0@@5 y1@@3))) :qid |mapAx1:MapType2Select:1| :weight 0))) (forall ((val@@9 T@U) (m@@21 T@U) (x0@@9 T@U) (x1@@6 T@U) (y0@@6 T@U) (y1@@4 T@U)) (! (or true (= (MapType2Select (MapType2Store m@@21 x0@@9 x1@@6 val@@9) y0@@6 y1@@4) (MapType2Select m@@21 y0@@6 y1@@4))) :qid |mapAx2:MapType2Select| :weight 0)))) (forall ((arg0@@104 T@U) (arg1@@51 T@U) (arg2@@16 T@U) (arg3@@1 T@U) (arg4 T@U)) (! (= (type (Apply1 arg0@@104 arg1@@51 arg2@@16 arg3@@1 arg4)) BoxType) :qid |funType:Apply1| :pattern ((Apply1 arg0@@104 arg1@@51 arg2@@16 arg3@@1 arg4))))) (forall ((arg0@@105 T@U) (arg1@@52 T@U) (arg2@@17 T@U)) (! (= (type (Handle1 arg0@@105 arg1@@52 arg2@@17)) HandleTypeType) :qid |funType:Handle1| :pattern ((Handle1 arg0@@105 arg1@@52 arg2@@17))))))
(assert (forall ((t0@@22 T@U) (t1@@3 T@U) (heap@@2 T@U) (h@@24 T@U) (r@@8 T@U) (rd@@2 T@U) (bx0 T@U)) (! (=> (and (and (and (and (and (and (= (type t0@@22) TyType) (= (type t1@@3) TyType)) (= (type heap@@2) (MapType1Type refType))) (= (type h@@24) (MapType2Type (MapType1Type refType) BoxType BoxType))) (= (type r@@8) (MapType2Type (MapType1Type refType) BoxType boolType))) (= (type rd@@2) (MapType2Type (MapType1Type refType) BoxType (MapType0Type BoxType boolType)))) (= (type bx0) BoxType)) (= (Apply1 t0@@22 t1@@3 (Handle1 h@@24 r@@8 rd@@2) heap@@2 bx0) (MapType2Select h@@24 heap@@2 bx0))) :qid |unknown.0:0| :skolemid |316| :pattern ((Apply1 t0@@22 t1@@3 (Handle1 h@@24 r@@8 rd@@2) heap@@2 bx0)))))
(assert (forall ((t0@@23 T@U) (t1@@4 T@U) (heap@@3 T@U) (h@@25 T@U) (r@@9 T@U) (rd@@3 T@U) (bx0@@0 T@U)) (! (=> (and (and (and (and (and (and (and (= (type t0@@23) TyType) (= (type t1@@4) TyType)) (= (type heap@@3) (MapType1Type refType))) (= (type h@@25) (MapType2Type (MapType1Type refType) BoxType BoxType))) (= (type r@@9) (MapType2Type (MapType1Type refType) BoxType boolType))) (= (type rd@@3) (MapType2Type (MapType1Type refType) BoxType (MapType0Type BoxType boolType)))) (= (type bx0@@0) BoxType)) (U_2_bool (MapType2Select r@@9 heap@@3 bx0@@0))) (Requires1 t0@@23 t1@@4 (Handle1 h@@25 r@@9 rd@@3) heap@@3 bx0@@0)) :qid |unknown.0:0| :skolemid |317| :pattern ((Requires1 t0@@23 t1@@4 (Handle1 h@@25 r@@9 rd@@3) heap@@3 bx0@@0)))))
(assert (forall ((arg0@@106 T@U) (arg1@@53 T@U) (arg2@@18 T@U) (arg3@@2 T@U) (arg4@@0 T@U)) (! (= (type (Reads1 arg0@@106 arg1@@53 arg2@@18 arg3@@2 arg4@@0)) (MapType0Type BoxType boolType)) :qid |funType:Reads1| :pattern ((Reads1 arg0@@106 arg1@@53 arg2@@18 arg3@@2 arg4@@0)))))
(assert (forall ((t0@@24 T@U) (t1@@5 T@U) (heap@@4 T@U) (h@@26 T@U) (r@@10 T@U) (rd@@4 T@U) (bx0@@1 T@U) (bx@@40 T@U)) (! (=> (and (and (and (and (and (and (and (= (type t0@@24) TyType) (= (type t1@@5) TyType)) (= (type heap@@4) (MapType1Type refType))) (= (type h@@26) (MapType2Type (MapType1Type refType) BoxType BoxType))) (= (type r@@10) (MapType2Type (MapType1Type refType) BoxType boolType))) (= (type rd@@4) (MapType2Type (MapType1Type refType) BoxType (MapType0Type BoxType boolType)))) (= (type bx0@@1) BoxType)) (= (type bx@@40) BoxType)) (and (=> (U_2_bool (MapType0Select (Reads1 t0@@24 t1@@5 (Handle1 h@@26 r@@10 rd@@4) heap@@4 bx0@@1) bx@@40)) (U_2_bool (MapType0Select (MapType2Select rd@@4 heap@@4 bx0@@1) bx@@40))) (=> (U_2_bool (MapType0Select (MapType2Select rd@@4 heap@@4 bx0@@1) bx@@40)) (U_2_bool (MapType0Select (Reads1 t0@@24 t1@@5 (Handle1 h@@26 r@@10 rd@@4) heap@@4 bx0@@1) bx@@40))))) :qid |unknown.0:0| :skolemid |318| :pattern ((MapType0Select (Reads1 t0@@24 t1@@5 (Handle1 h@@26 r@@10 rd@@4) heap@@4 bx0@@1) bx@@40)))))
(assert (forall ((t0@@25 T@U) (t1@@6 T@U) (h0@@6 T@U) (h1@@6 T@U) (f@@12 T@U) (bx0@@2 T@U)) (! (=> (and (and (and (and (and (and (= (type t0@@25) TyType) (= (type t1@@6) TyType)) (= (type h0@@6) (MapType1Type refType))) (= (type h1@@6) (MapType1Type refType))) (= (type f@@12) HandleTypeType)) (= (type bx0@@2) BoxType)) (and (and (and ($HeapSucc h0@@6 h1@@6) (and ($IsGoodHeap h0@@6) ($IsGoodHeap h1@@6))) (and (and ($IsBox bx0@@2 t0@@25) ($IsAllocBox bx0@@2 t0@@25 h0@@6)) (and ($Is f@@12 (Tclass._System.___hFunc1 t0@@25 t1@@6)) ($IsAlloc f@@12 (Tclass._System.___hFunc1 t0@@25 t1@@6) h0@@6)))) (forall ((o@@45 T@U) (fld@@5 T@U)) (! (let ((a@@83 (FieldTypeInv0 (type fld@@5)))) (=> (and (= (type o@@45) refType) (= (type fld@@5) (FieldType a@@83))) (=> (and (and (and (not (= o@@45 null)) (U_2_bool (MapType1Select h0@@6 o@@45 alloc))) (U_2_bool (MapType1Select h1@@6 o@@45 alloc))) (U_2_bool (MapType0Select (Reads1 t0@@25 t1@@6 f@@12 h0@@6 bx0@@2) ($Box o@@45)))) (= (MapType1Select h0@@6 o@@45 fld@@5) (MapType1Select h1@@6 o@@45 fld@@5))))) :qid |unknown.0:0| :skolemid |319| :no-pattern (type o@@45) :no-pattern (type fld@@5) :no-pattern (U_2_int o@@45) :no-pattern (U_2_bool o@@45) :no-pattern (U_2_int fld@@5) :no-pattern (U_2_bool fld@@5))))) (= (Reads1 t0@@25 t1@@6 f@@12 h0@@6 bx0@@2) (Reads1 t0@@25 t1@@6 f@@12 h1@@6 bx0@@2))) :qid |unknown.0:0| :skolemid |320| :pattern (($HeapSucc h0@@6 h1@@6) (Reads1 t0@@25 t1@@6 f@@12 h1@@6 bx0@@2)))))
(assert (forall ((t0@@26 T@U) (t1@@7 T@U) (h0@@7 T@U) (h1@@7 T@U) (f@@13 T@U) (bx0@@3 T@U)) (! (=> (and (and (and (and (and (and (= (type t0@@26) TyType) (= (type t1@@7) TyType)) (= (type h0@@7) (MapType1Type refType))) (= (type h1@@7) (MapType1Type refType))) (= (type f@@13) HandleTypeType)) (= (type bx0@@3) BoxType)) (and (and (and ($HeapSucc h0@@7 h1@@7) (and ($IsGoodHeap h0@@7) ($IsGoodHeap h1@@7))) (and (and ($IsBox bx0@@3 t0@@26) ($IsAllocBox bx0@@3 t0@@26 h0@@7)) (and ($Is f@@13 (Tclass._System.___hFunc1 t0@@26 t1@@7)) ($IsAlloc f@@13 (Tclass._System.___hFunc1 t0@@26 t1@@7) h0@@7)))) (forall ((o@@46 T@U) (fld@@6 T@U)) (! (let ((a@@84 (FieldTypeInv0 (type fld@@6)))) (=> (and (= (type o@@46) refType) (= (type fld@@6) (FieldType a@@84))) (=> (and (and (and (not (= o@@46 null)) (U_2_bool (MapType1Select h0@@7 o@@46 alloc))) (U_2_bool (MapType1Select h1@@7 o@@46 alloc))) (U_2_bool (MapType0Select (Reads1 t0@@26 t1@@7 f@@13 h1@@7 bx0@@3) ($Box o@@46)))) (= (MapType1Select h0@@7 o@@46 fld@@6) (MapType1Select h1@@7 o@@46 fld@@6))))) :qid |unknown.0:0| :skolemid |321| :no-pattern (type o@@46) :no-pattern (type fld@@6) :no-pattern (U_2_int o@@46) :no-pattern (U_2_bool o@@46) :no-pattern (U_2_int fld@@6) :no-pattern (U_2_bool fld@@6))))) (= (Reads1 t0@@26 t1@@7 f@@13 h0@@7 bx0@@3) (Reads1 t0@@26 t1@@7 f@@13 h1@@7 bx0@@3))) :qid |unknown.0:0| :skolemid |322| :pattern (($HeapSucc h0@@7 h1@@7) (Reads1 t0@@26 t1@@7 f@@13 h1@@7 bx0@@3)))))
(assert (forall ((t0@@27 T@U) (t1@@8 T@U) (h0@@8 T@U) (h1@@8 T@U) (f@@14 T@U) (bx0@@4 T@U)) (! (=> (and (and (and (and (and (and (= (type t0@@27) TyType) (= (type t1@@8) TyType)) (= (type h0@@8) (MapType1Type refType))) (= (type h1@@8) (MapType1Type refType))) (= (type f@@14) HandleTypeType)) (= (type bx0@@4) BoxType)) (and (and (and ($HeapSucc h0@@8 h1@@8) (and ($IsGoodHeap h0@@8) ($IsGoodHeap h1@@8))) (and (and ($IsBox bx0@@4 t0@@27) ($IsAllocBox bx0@@4 t0@@27 h0@@8)) (and ($Is f@@14 (Tclass._System.___hFunc1 t0@@27 t1@@8)) ($IsAlloc f@@14 (Tclass._System.___hFunc1 t0@@27 t1@@8) h0@@8)))) (forall ((o@@47 T@U) (fld@@7 T@U)) (! (let ((a@@85 (FieldTypeInv0 (type fld@@7)))) (=> (and (= (type o@@47) refType) (= (type fld@@7) (FieldType a@@85))) (=> (and (and (and (not (= o@@47 null)) (U_2_bool (MapType1Select h0@@8 o@@47 alloc))) (U_2_bool (MapType1Select h1@@8 o@@47 alloc))) (U_2_bool (MapType0Select (Reads1 t0@@27 t1@@8 f@@14 h0@@8 bx0@@4) ($Box o@@47)))) (= (MapType1Select h0@@8 o@@47 fld@@7) (MapType1Select h1@@8 o@@47 fld@@7))))) :qid |unknown.0:0| :skolemid |323| :no-pattern (type o@@47) :no-pattern (type fld@@7) :no-pattern (U_2_int o@@47) :no-pattern (U_2_bool o@@47) :no-pattern (U_2_int fld@@7) :no-pattern (U_2_bool fld@@7))))) (and (=> (Requires1 t0@@27 t1@@8 f@@14 h0@@8 bx0@@4) (Requires1 t0@@27 t1@@8 f@@14 h1@@8 bx0@@4)) (=> (Requires1 t0@@27 t1@@8 f@@14 h1@@8 bx0@@4) (Requires1 t0@@27 t1@@8 f@@14 h0@@8 bx0@@4)))) :qid |unknown.0:0| :skolemid |324| :pattern (($HeapSucc h0@@8 h1@@8) (Requires1 t0@@27 t1@@8 f@@14 h1@@8 bx0@@4)))))
(assert (forall ((t0@@28 T@U) (t1@@9 T@U) (h0@@9 T@U) (h1@@9 T@U) (f@@15 T@U) (bx0@@5 T@U)) (! (=> (and (and (and (and (and (and (= (type t0@@28) TyType) (= (type t1@@9) TyType)) (= (type h0@@9) (MapType1Type refType))) (= (type h1@@9) (MapType1Type refType))) (= (type f@@15) HandleTypeType)) (= (type bx0@@5) BoxType)) (and (and (and ($HeapSucc h0@@9 h1@@9) (and ($IsGoodHeap h0@@9) ($IsGoodHeap h1@@9))) (and (and ($IsBox bx0@@5 t0@@28) ($IsAllocBox bx0@@5 t0@@28 h0@@9)) (and ($Is f@@15 (Tclass._System.___hFunc1 t0@@28 t1@@9)) ($IsAlloc f@@15 (Tclass._System.___hFunc1 t0@@28 t1@@9) h0@@9)))) (forall ((o@@48 T@U) (fld@@8 T@U)) (! (let ((a@@86 (FieldTypeInv0 (type fld@@8)))) (=> (and (= (type o@@48) refType) (= (type fld@@8) (FieldType a@@86))) (=> (and (and (and (not (= o@@48 null)) (U_2_bool (MapType1Select h0@@9 o@@48 alloc))) (U_2_bool (MapType1Select h1@@9 o@@48 alloc))) (U_2_bool (MapType0Select (Reads1 t0@@28 t1@@9 f@@15 h1@@9 bx0@@5) ($Box o@@48)))) (= (MapType1Select h0@@9 o@@48 fld@@8) (MapType1Select h1@@9 o@@48 fld@@8))))) :qid |unknown.0:0| :skolemid |325| :no-pattern (type o@@48) :no-pattern (type fld@@8) :no-pattern (U_2_int o@@48) :no-pattern (U_2_bool o@@48) :no-pattern (U_2_int fld@@8) :no-pattern (U_2_bool fld@@8))))) (and (=> (Requires1 t0@@28 t1@@9 f@@15 h0@@9 bx0@@5) (Requires1 t0@@28 t1@@9 f@@15 h1@@9 bx0@@5)) (=> (Requires1 t0@@28 t1@@9 f@@15 h1@@9 bx0@@5) (Requires1 t0@@28 t1@@9 f@@15 h0@@9 bx0@@5)))) :qid |unknown.0:0| :skolemid |326| :pattern (($HeapSucc h0@@9 h1@@9) (Requires1 t0@@28 t1@@9 f@@15 h1@@9 bx0@@5)))))
(assert (forall ((t0@@29 T@U) (t1@@10 T@U) (h0@@10 T@U) (h1@@10 T@U) (f@@16 T@U) (bx0@@6 T@U)) (! (=> (and (and (and (and (and (and (= (type t0@@29) TyType) (= (type t1@@10) TyType)) (= (type h0@@10) (MapType1Type refType))) (= (type h1@@10) (MapType1Type refType))) (= (type f@@16) HandleTypeType)) (= (type bx0@@6) BoxType)) (and (and (and ($HeapSucc h0@@10 h1@@10) (and ($IsGoodHeap h0@@10) ($IsGoodHeap h1@@10))) (and (and ($IsBox bx0@@6 t0@@29) ($IsAllocBox bx0@@6 t0@@29 h0@@10)) (and ($Is f@@16 (Tclass._System.___hFunc1 t0@@29 t1@@10)) ($IsAlloc f@@16 (Tclass._System.___hFunc1 t0@@29 t1@@10) h0@@10)))) (forall ((o@@49 T@U) (fld@@9 T@U)) (! (let ((a@@87 (FieldTypeInv0 (type fld@@9)))) (=> (and (= (type o@@49) refType) (= (type fld@@9) (FieldType a@@87))) (=> (and (and (and (not (= o@@49 null)) (U_2_bool (MapType1Select h0@@10 o@@49 alloc))) (U_2_bool (MapType1Select h1@@10 o@@49 alloc))) (U_2_bool (MapType0Select (Reads1 t0@@29 t1@@10 f@@16 h0@@10 bx0@@6) ($Box o@@49)))) (= (MapType1Select h0@@10 o@@49 fld@@9) (MapType1Select h1@@10 o@@49 fld@@9))))) :qid |unknown.0:0| :skolemid |327| :no-pattern (type o@@49) :no-pattern (type fld@@9) :no-pattern (U_2_int o@@49) :no-pattern (U_2_bool o@@49) :no-pattern (U_2_int fld@@9) :no-pattern (U_2_bool fld@@9))))) (= (Apply1 t0@@29 t1@@10 f@@16 h0@@10 bx0@@6) (Apply1 t0@@29 t1@@10 f@@16 h1@@10 bx0@@6))) :qid |unknown.0:0| :skolemid |328| :pattern (($HeapSucc h0@@10 h1@@10) (Apply1 t0@@29 t1@@10 f@@16 h1@@10 bx0@@6)))))
(assert (forall ((t0@@30 T@U) (t1@@11 T@U) (h0@@11 T@U) (h1@@11 T@U) (f@@17 T@U) (bx0@@7 T@U)) (! (=> (and (and (and (and (and (and (= (type t0@@30) TyType) (= (type t1@@11) TyType)) (= (type h0@@11) (MapType1Type refType))) (= (type h1@@11) (MapType1Type refType))) (= (type f@@17) HandleTypeType)) (= (type bx0@@7) BoxType)) (and (and (and ($HeapSucc h0@@11 h1@@11) (and ($IsGoodHeap h0@@11) ($IsGoodHeap h1@@11))) (and (and ($IsBox bx0@@7 t0@@30) ($IsAllocBox bx0@@7 t0@@30 h0@@11)) (and ($Is f@@17 (Tclass._System.___hFunc1 t0@@30 t1@@11)) ($IsAlloc f@@17 (Tclass._System.___hFunc1 t0@@30 t1@@11) h0@@11)))) (forall ((o@@50 T@U) (fld@@10 T@U)) (! (let ((a@@88 (FieldTypeInv0 (type fld@@10)))) (=> (and (= (type o@@50) refType) (= (type fld@@10) (FieldType a@@88))) (=> (and (and (and (not (= o@@50 null)) (U_2_bool (MapType1Select h0@@11 o@@50 alloc))) (U_2_bool (MapType1Select h1@@11 o@@50 alloc))) (U_2_bool (MapType0Select (Reads1 t0@@30 t1@@11 f@@17 h1@@11 bx0@@7) ($Box o@@50)))) (= (MapType1Select h0@@11 o@@50 fld@@10) (MapType1Select h1@@11 o@@50 fld@@10))))) :qid |unknown.0:0| :skolemid |329| :no-pattern (type o@@50) :no-pattern (type fld@@10) :no-pattern (U_2_int o@@50) :no-pattern (U_2_bool o@@50) :no-pattern (U_2_int fld@@10) :no-pattern (U_2_bool fld@@10))))) (= (Apply1 t0@@30 t1@@11 f@@17 h0@@11 bx0@@7) (Apply1 t0@@30 t1@@11 f@@17 h1@@11 bx0@@7))) :qid |unknown.0:0| :skolemid |330| :pattern (($HeapSucc h0@@11 h1@@11) (Apply1 t0@@30 t1@@11 f@@17 h1@@11 bx0@@7)))))
(assert (forall ((t0@@31 T@U) (t1@@12 T@U) (h@@27 T@U) (f@@18 T@U) (bx0@@8 T@U)) (! (=> (and (and (and (and (and (= (type t0@@31) TyType) (= (type t1@@12) TyType)) (= (type h@@27) (MapType1Type refType))) (= (type f@@18) HandleTypeType)) (= (type bx0@@8) BoxType)) (and ($IsGoodHeap h@@27) (and (and ($IsBox bx0@@8 t0@@31) ($IsAllocBox bx0@@8 t0@@31 h@@27)) (and ($Is f@@18 (Tclass._System.___hFunc1 t0@@31 t1@@12)) ($IsAlloc f@@18 (Tclass._System.___hFunc1 t0@@31 t1@@12) h@@27))))) (and ($IsBox (Apply1 t0@@31 t1@@12 f@@18 h@@27 bx0@@8) t1@@12) ($IsAllocBox (Apply1 t0@@31 t1@@12 f@@18 h@@27 bx0@@8) t1@@12 h@@27))) :qid |unknown.0:0| :skolemid |331| :pattern ((Apply1 t0@@31 t1@@12 f@@18 h@@27 bx0@@8)))))
(assert (= (type Tclass._module.__default) TyType))
(assert (= (Tag Tclass._module.__default) Tagclass._module.__default))
(assert (forall ((bx@@41 T@U)) (! (=> (and (= (type bx@@41) BoxType) ($IsBox bx@@41 Tclass._module.__default)) (and (= ($Box ($Unbox refType bx@@41)) bx@@41) ($Is ($Unbox refType bx@@41) Tclass._module.__default))) :qid |unknown.0:0| :skolemid |332| :pattern (($IsBox bx@@41 Tclass._module.__default)))))
(assert (forall (($o@@5 T@U)) (! (=> (= (type $o@@5) refType) (and (=> ($Is $o@@5 Tclass._module.__default) (or (= $o@@5 null) (= (dtype $o@@5) Tclass._module.__default))) (=> (or (= $o@@5 null) (= (dtype $o@@5) Tclass._module.__default)) ($Is $o@@5 Tclass._module.__default)))) :qid |unknown.0:0| :skolemid |333| :pattern (($Is $o@@5 Tclass._module.__default)))))
(assert (forall (($o@@6 T@U) ($h@@3 T@U)) (! (=> (and (= (type $o@@6) refType) (= (type $h@@3) (MapType1Type refType))) (and (=> ($IsAlloc $o@@6 Tclass._module.__default $h@@3) (or (= $o@@6 null) (U_2_bool (MapType1Select $h@@3 $o@@6 alloc)))) (=> (or (= $o@@6 null) (U_2_bool (MapType1Select $h@@3 $o@@6 alloc))) ($IsAlloc $o@@6 Tclass._module.__default $h@@3)))) :qid |unknown.0:0| :skolemid |334| :pattern (($IsAlloc $o@@6 Tclass._module.__default $h@@3)))))
(assert (forall (($ly T@U) ($Heap T@U) (|n#0| Int)) (! (=> (and (= (type $ly) LayerTypeType) (= (type $Heap) (MapType1Type refType))) (= (_module.__default.Factorial ($LS $ly) $Heap |n#0|) (_module.__default.Factorial $ly $Heap |n#0|))) :qid |Classics.7:10| :skolemid |335| :pattern ((_module.__default.Factorial ($LS $ly) $Heap |n#0|)))))
(assert (forall (($ly@@0 T@U) ($h0 T@U) ($h1 T@U) (|n#0@@0| Int)) (! (=> (and (and (= (type $ly@@0) LayerTypeType) (= (type $h0) (MapType1Type refType))) (= (type $h1) (MapType1Type refType))) (=> (and (and (and ($IsGoodHeap $h0) ($IsGoodHeap $h1)) (and (or (|_module.__default.Factorial#canCall| $h0 |n#0@@0|) (<= 0 |n#0@@0|)) (or (|_module.__default.Factorial#canCall| $h1 |n#0@@0|) (<= 0 |n#0@@0|)))) (and ($IsHeapAnchor $h0) ($HeapSucc $h0 $h1))) (=> (forall (($o@@7 T@U) ($f T@U)) (! (let ((alpha@@6 (FieldTypeInv0 (type $f)))) (=> (and (and (= (type $o@@7) refType) (= (type $f) (FieldType alpha@@6))) false) (= (MapType1Select $h0 $o@@7 $f) (MapType1Select $h1 $o@@7 $f)))) :qid |unknown.0:0| :skolemid |336| :no-pattern (type $o@@7) :no-pattern (type $f) :no-pattern (U_2_int $o@@7) :no-pattern (U_2_bool $o@@7) :no-pattern (U_2_int $f) :no-pattern (U_2_bool $f))) (= (_module.__default.Factorial $ly@@0 $h0 |n#0@@0|) (_module.__default.Factorial $ly@@0 $h1 |n#0@@0|))))) :qid |unknown.0:0| :skolemid |337| :pattern (($IsHeapAnchor $h0) ($HeapSucc $h0 $h1) (_module.__default.Factorial $ly@@0 $h1 |n#0@@0|)))))
(assert (=> (or (< 0 $ModuleContextHeight) (and (= 0 $ModuleContextHeight) (<= 0 $FunctionContextHeight))) (forall (($ly@@1 T@U) ($Heap@@0 T@U) (|n#0@@1| Int)) (! (=> (and (and (= (type $ly@@1) LayerTypeType) (= (type $Heap@@0) (MapType1Type refType))) (or (|_module.__default.Factorial#canCall| $Heap@@0 |n#0@@1|) (and (or (not (= 0 $ModuleContextHeight)) (not (= 0 $FunctionContextHeight))) (and ($IsGoodHeap $Heap@@0) (<= 0 |n#0@@1|))))) (<= 0 (_module.__default.Factorial ($LS $ly@@1) $Heap@@0 |n#0@@1|))) :qid |Classics.7:10| :skolemid |338| :pattern ((_module.__default.Factorial ($LS $ly@@1) $Heap@@0 |n#0@@1|))))))
(assert (forall (($ly@@2 T@U) ($Heap@@1 T@U) (|n#0@@2| Int)) (! (=> (and (and (= (type $ly@@2) LayerTypeType) (= (type $Heap@@1) (MapType1Type refType))) (and ($IsGoodHeap $Heap@@1) (<= 0 |n#0@@2|))) (and (=> (|_module.__default.Factorial#requires| $ly@@2 $Heap@@1 |n#0@@2|) true) (=> true (|_module.__default.Factorial#requires| $ly@@2 $Heap@@1 |n#0@@2|)))) :qid |Classics.7:10| :skolemid |339| :pattern ((|_module.__default.Factorial#requires| $ly@@2 $Heap@@1 |n#0@@2|)))))
(assert (=> (and (= 0 $ModuleContextHeight) (<= 0 $FunctionContextHeight)) (forall (($ly@@3 T@U) ($Heap@@2 T@U) (|n#0@@3| Int)) (! (=> (and (and (= (type $ly@@3) LayerTypeType) (= (type $Heap@@2) (MapType1Type refType))) (or (|_module.__default.Factorial#canCall| $Heap@@2 |n#0@@3|) (and (not (= 0 $FunctionContextHeight)) (and ($IsGoodHeap $Heap@@2) (<= 0 |n#0@@3|))))) (and (and (=> (= |n#0@@3| (LitInt 0)) true) (=> (not (= |n#0@@3| (LitInt 0))) (|_module.__default.Factorial#canCall| $Heap@@2 (- |n#0@@3| 1)))) (= (_module.__default.Factorial ($LS $ly@@3) $Heap@@2 |n#0@@3|) (ite (= |n#0@@3| (LitInt 0)) 1 (* |n#0@@3| (_module.__default.Factorial $ly@@3 $Heap@@2 (- |n#0@@3| 1))))))) :qid |Classics.7:10| :skolemid |340| :pattern ((_module.__default.Factorial ($LS $ly@@3) $Heap@@2 |n#0@@3|))))))
(assert (=> (and (= 0 $ModuleContextHeight) (<= 0 $FunctionContextHeight)) (forall (($ly@@4 T@U) ($Heap@@3 T@U) (|n#0@@4| Int)) (! (=> (and (and (= (type $ly@@4) LayerTypeType) (= (type $Heap@@3) (MapType1Type refType))) (or (|_module.__default.Factorial#canCall| $Heap@@3 (LitInt |n#0@@4|)) (and (not (= 0 $FunctionContextHeight)) (and ($IsGoodHeap $Heap@@3) (<= 0 |n#0@@4|))))) (and (and (=> (= (LitInt |n#0@@4|) (LitInt 0)) true) (=> (not (= (LitInt |n#0@@4|) (LitInt 0))) (|_module.__default.Factorial#canCall| $Heap@@3 (LitInt (- |n#0@@4| 1))))) (= (_module.__default.Factorial $ly@@4 $Heap@@3 (LitInt |n#0@@4|)) (ite (= (LitInt |n#0@@4|) (LitInt 0)) 1 (* |n#0@@4| (_module.__default.Factorial $ly@@4 $Heap@@3 (LitInt (- |n#0@@4| 1)))))))) :qid |Classics.7:10| :weight 3 :skolemid |341| :pattern ((_module.__default.Factorial $ly@@4 $Heap@@3 (LitInt |n#0@@4|)))))))
(assert (=> (< 0 $ModuleContextHeight) (forall (($ly@@5 T@U) ($Heap@@4 T@U) (|n#0@@5| Int)) (! (=> (and (and (= (type $ly@@5) LayerTypeType) (= (type $Heap@@4) (MapType1Type refType))) (or (|_module.__default.Factorial#canCall| $Heap@@4 |n#0@@5|) (and ($IsGoodHeap $Heap@@4) (<= 0 |n#0@@5|)))) (and (and (=> (= |n#0@@5| (LitInt 0)) true) (=> (not (= |n#0@@5| (LitInt 0))) (|_module.__default.Factorial#canCall| $Heap@@4 (- |n#0@@5| 1)))) (= (_module.__default.Factorial ($LS $ly@@5) $Heap@@4 |n#0@@5|) (ite (= |n#0@@5| (LitInt 0)) 1 (* |n#0@@5| (_module.__default.Factorial $ly@@5 $Heap@@4 (- |n#0@@5| 1))))))) :qid |Classics.7:10| :skolemid |342| :pattern ((_module.__default.Factorial ($LS $ly@@5) $Heap@@4 |n#0@@5|))))))
(assert (=> (< 0 $ModuleContextHeight) (forall (($ly@@6 T@U) ($Heap@@5 T@U) (|n#0@@6| Int)) (! (=> (and (and (= (type $ly@@6) LayerTypeType) (= (type $Heap@@5) (MapType1Type refType))) (or (|_module.__default.Factorial#canCall| $Heap@@5 (LitInt |n#0@@6|)) (and ($IsGoodHeap $Heap@@5) (<= 0 |n#0@@6|)))) (and (and (=> (= (LitInt |n#0@@6|) (LitInt 0)) true) (=> (not (= (LitInt |n#0@@6|) (LitInt 0))) (|_module.__default.Factorial#canCall| $Heap@@5 (LitInt (- |n#0@@6| 1))))) (= (_module.__default.Factorial $ly@@6 $Heap@@5 (LitInt |n#0@@6|)) (ite (= (LitInt |n#0@@6|) (LitInt 0)) 1 (* |n#0@@6| (_module.__default.Factorial $ly@@6 $Heap@@5 (LitInt (- |n#0@@6| 1)))))))) :qid |Classics.7:10| :weight 3 :skolemid |343| :pattern ((_module.__default.Factorial $ly@@6 $Heap@@5 (LitInt |n#0@@6|)))))))
(assert (and (and (and (and (and (and (and (forall ((arg0@@107 T@T) (arg1@@54 T@T)) (! (= (Ctor (MapType3Type arg0@@107 arg1@@54)) 20) :qid |ctor:MapType3Type|)) (forall ((arg0@@108 T@T) (arg1@@55 T@T)) (! (= (MapType3TypeInv0 (MapType3Type arg0@@108 arg1@@55)) arg0@@108) :qid |typeInv:MapType3TypeInv0| :pattern ((MapType3Type arg0@@108 arg1@@55))))) (forall ((arg0@@109 T@T) (arg1@@56 T@T)) (! (= (MapType3TypeInv1 (MapType3Type arg0@@109 arg1@@56)) arg1@@56) :qid |typeInv:MapType3TypeInv1| :pattern ((MapType3Type arg0@@109 arg1@@56))))) (forall ((arg0@@110 T@U) (arg1@@57 T@U) (arg2@@19 T@U)) (! (let ((aVar1@@3 (MapType3TypeInv1 (type arg0@@110)))) (= (type (MapType3Select arg0@@110 arg1@@57 arg2@@19)) aVar1@@3)) :qid |funType:MapType3Select| :pattern ((MapType3Select arg0@@110 arg1@@57 arg2@@19))))) (forall ((arg0@@111 T@U) (arg1@@58 T@U) (arg2@@20 T@U) (arg3@@3 T@U)) (! (let ((aVar1@@4 (type arg3@@3))) (let ((aVar0@@2 (type arg1@@58))) (= (type (MapType3Store arg0@@111 arg1@@58 arg2@@20 arg3@@3)) (MapType3Type aVar0@@2 aVar1@@4)))) :qid |funType:MapType3Store| :pattern ((MapType3Store arg0@@111 arg1@@58 arg2@@20 arg3@@3))))) (forall ((m@@22 T@U) (x0@@10 T@U) (x1@@7 T@U) (val@@10 T@U)) (! (let ((aVar1@@5 (MapType3TypeInv1 (type m@@22)))) (=> (= (type val@@10) aVar1@@5) (= (MapType3Select (MapType3Store m@@22 x0@@10 x1@@7 val@@10) x0@@10 x1@@7) val@@10))) :qid |mapAx0:MapType3Select| :weight 0))) (and (and (forall ((val@@11 T@U) (m@@23 T@U) (x0@@11 T@U) (x1@@8 T@U) (y0@@7 T@U) (y1@@5 T@U)) (! (or (= x0@@11 y0@@7) (= (MapType3Select (MapType3Store m@@23 x0@@11 x1@@8 val@@11) y0@@7 y1@@5) (MapType3Select m@@23 y0@@7 y1@@5))) :qid |mapAx1:MapType3Select:0| :weight 0)) (forall ((val@@12 T@U) (m@@24 T@U) (x0@@12 T@U) (x1@@9 T@U) (y0@@8 T@U) (y1@@6 T@U)) (! (or (= x1@@9 y1@@6) (= (MapType3Select (MapType3Store m@@24 x0@@12 x1@@9 val@@12) y0@@8 y1@@6) (MapType3Select m@@24 y0@@8 y1@@6))) :qid |mapAx1:MapType3Select:1| :weight 0))) (forall ((val@@13 T@U) (m@@25 T@U) (x0@@13 T@U) (x1@@10 T@U) (y0@@9 T@U) (y1@@7 T@U)) (! (or true (= (MapType3Select (MapType3Store m@@25 x0@@13 x1@@10 val@@13) y0@@9 y1@@7) (MapType3Select m@@25 y0@@9 y1@@7))) :qid |mapAx2:MapType3Select| :weight 0)))) (forall ((arg0@@112 T@U) (arg1@@59 T@U) (arg2@@21 T@U)) (! (= (type (|lambda#0| arg0@@112 arg1@@59 arg2@@21)) (MapType3Type refType boolType)) :qid |funType:lambda#0| :pattern ((|lambda#0| arg0@@112 arg1@@59 arg2@@21))))))
(assert (forall (($o@@8 T@U) ($f@@0 T@U) (alloc@@0 T@U) (null@@0 T@U) ($Heap@@6 T@U)) (! (let ((alpha@@7 (FieldTypeInv0 (type $f@@0)))) (=> (and (and (and (and (= (type $o@@8) refType) (= (type $f@@0) (FieldType alpha@@7))) (= (type alloc@@0) (FieldType boolType))) (= (type null@@0) refType)) (= (type $Heap@@6) (MapType1Type refType))) (= (U_2_bool (MapType3Select (|lambda#0| alloc@@0 null@@0 $Heap@@6) $o@@8 $f@@0)) (=> (and (not (= $o@@8 null@@0)) (U_2_bool (MapType1Select $Heap@@6 $o@@8 alloc@@0))) false)))) :qid |Classics.7:10| :skolemid |454| :pattern ((MapType3Select (|lambda#0| alloc@@0 null@@0 $Heap@@6) $o@@8 $f@@0)))))
(assert (forall ((arg0@@113 T@U) (arg1@@60 T@U) (arg2@@22 T@U)) (! (= (type (|lambda#1| arg0@@113 arg1@@60 arg2@@22)) (MapType3Type refType boolType)) :qid |funType:lambda#1| :pattern ((|lambda#1| arg0@@113 arg1@@60 arg2@@22)))))
(assert (forall (($o@@9 T@U) ($f@@1 T@U) (alloc@@1 T@U) (null@@1 T@U) ($Heap@@7 T@U)) (! (let ((alpha@@8 (FieldTypeInv0 (type $f@@1)))) (=> (and (and (and (and (= (type $o@@9) refType) (= (type $f@@1) (FieldType alpha@@8))) (= (type alloc@@1) (FieldType boolType))) (= (type null@@1) refType)) (= (type $Heap@@7) (MapType1Type refType))) (= (U_2_bool (MapType3Select (|lambda#1| alloc@@1 null@@1 $Heap@@7) $o@@9 $f@@1)) (=> (and (not (= $o@@9 null@@1)) (U_2_bool (MapType1Select $Heap@@7 $o@@9 alloc@@1))) false)))) :qid |Classics.7:10| :skolemid |455| :pattern ((MapType3Select (|lambda#1| alloc@@1 null@@1 $Heap@@7) $o@@9 $f@@1)))))
(assert (forall ((arg0@@114 T@U) (arg1@@61 T@U) (arg2@@23 T@U)) (! (= (type (|lambda#2| arg0@@114 arg1@@61 arg2@@23)) (MapType3Type refType boolType)) :qid |funType:lambda#2| :pattern ((|lambda#2| arg0@@114 arg1@@61 arg2@@23)))))
(assert (forall (($o@@10 T@U) ($f@@2 T@U) (alloc@@2 T@U) (null@@2 T@U) ($Heap@@8 T@U)) (! (let ((alpha@@9 (FieldTypeInv0 (type $f@@2)))) (=> (and (and (and (and (= (type $o@@10) refType) (= (type $f@@2) (FieldType alpha@@9))) (= (type alloc@@2) (FieldType boolType))) (= (type null@@2) refType)) (= (type $Heap@@8) (MapType1Type refType))) (= (U_2_bool (MapType3Select (|lambda#2| alloc@@2 null@@2 $Heap@@8) $o@@10 $f@@2)) (=> (and (not (= $o@@10 null@@2)) (U_2_bool (MapType1Select $Heap@@8 $o@@10 alloc@@2))) false)))) :qid |Classics.12:8| :skolemid |456| :pattern ((MapType3Select (|lambda#2| alloc@@2 null@@2 $Heap@@8) $o@@10 $f@@2)))))
(assert (forall ((arg0@@115 T@U) (arg1@@62 T@U) (arg2@@24 T@U)) (! (= (type (|lambda#3| arg0@@115 arg1@@62 arg2@@24)) (MapType3Type refType boolType)) :qid |funType:lambda#3| :pattern ((|lambda#3| arg0@@115 arg1@@62 arg2@@24)))))
(assert (forall (($o@@11 T@U) ($f@@3 T@U) (alloc@@3 T@U) (null@@3 T@U) ($Heap@@9 T@U)) (! (let ((alpha@@10 (FieldTypeInv0 (type $f@@3)))) (=> (and (and (and (and (= (type $o@@11) refType) (= (type $f@@3) (FieldType alpha@@10))) (= (type alloc@@3) (FieldType boolType))) (= (type null@@3) refType)) (= (type $Heap@@9) (MapType1Type refType))) (= (U_2_bool (MapType3Select (|lambda#3| alloc@@3 null@@3 $Heap@@9) $o@@11 $f@@3)) (=> (and (not (= $o@@11 null@@3)) (U_2_bool (MapType1Select $Heap@@9 $o@@11 alloc@@3))) false)))) :qid |Classics.12:8| :skolemid |457| :pattern ((MapType3Select (|lambda#3| alloc@@3 null@@3 $Heap@@9) $o@@11 $f@@3)))))
(assert (forall ((arg0@@116 T@U) (arg1@@63 T@U) (arg2@@25 T@U) (arg3@@4 T@U)) (! (= (type (|lambda#4| arg0@@116 arg1@@63 arg2@@25 arg3@@4)) (MapType3Type refType boolType)) :qid |funType:lambda#4| :pattern ((|lambda#4| arg0@@116 arg1@@63 arg2@@25 arg3@@4)))))
(assert (forall (($o@@12 T@U) ($f@@4 T@U) (|A#0| T@U) (null@@4 T@U) ($Heap@@10 T@U) (alloc@@4 T@U)) (! (let ((alpha@@11 (FieldTypeInv0 (type $f@@4)))) (=> (and (and (and (and (and (= (type $o@@12) refType) (= (type $f@@4) (FieldType alpha@@11))) (= (type |A#0|) refType)) (= (type null@@4) refType)) (= (type $Heap@@10) (MapType1Type refType))) (= (type alloc@@4) (FieldType boolType))) (= (U_2_bool (MapType3Select (|lambda#4| |A#0| null@@4 $Heap@@10 alloc@@4) $o@@12 $f@@4)) (=> (and (not (= $o@@12 null@@4)) (U_2_bool (MapType1Select $Heap@@10 $o@@12 alloc@@4))) (= $o@@12 |A#0|))))) :qid |Classics.47:8| :skolemid |458| :pattern ((MapType3Select (|lambda#4| |A#0| null@@4 $Heap@@10 alloc@@4) $o@@12 $f@@4)))))
(assert (forall ((arg0@@117 T@U) (arg1@@64 T@U) (arg2@@26 T@U) (arg3@@5 T@U)) (! (= (type (|lambda#5| arg0@@117 arg1@@64 arg2@@26 arg3@@5)) (MapType3Type refType boolType)) :qid |funType:lambda#5| :pattern ((|lambda#5| arg0@@117 arg1@@64 arg2@@26 arg3@@5)))))
(assert (forall (($o@@13 T@U) ($f@@5 T@U) (|A#0@@0| T@U) (null@@5 T@U) ($Heap@@11 T@U) (alloc@@5 T@U)) (! (let ((alpha@@12 (FieldTypeInv0 (type $f@@5)))) (=> (and (and (and (and (and (= (type $o@@13) refType) (= (type $f@@5) (FieldType alpha@@12))) (= (type |A#0@@0|) refType)) (= (type null@@5) refType)) (= (type $Heap@@11) (MapType1Type refType))) (= (type alloc@@5) (FieldType boolType))) (= (U_2_bool (MapType3Select (|lambda#5| |A#0@@0| null@@5 $Heap@@11 alloc@@5) $o@@13 $f@@5)) (=> (and (not (= $o@@13 null@@5)) (U_2_bool (MapType1Select $Heap@@11 $o@@13 alloc@@5))) (= $o@@13 |A#0@@0|))))) :qid |Classics.47:8| :skolemid |459| :pattern ((MapType3Select (|lambda#5| |A#0@@0| null@@5 $Heap@@11 alloc@@5) $o@@13 $f@@5)))))
(assert (and (and (and (= (type $LZ) LayerTypeType) (= (type $Heap@@12) (MapType1Type refType))) (= (type $_Frame@0) (MapType3Type refType boolType))) (= (type $_Frame@0@@0) (MapType3Type refType boolType))))
(declare-fun $_Frame@0@@1 () T@U)
(declare-fun $Heap@0 () T@U)
(declare-fun %lbl%+13222 () Bool)
(declare-fun |u#0@0| () Int)
(declare-fun %lbl%@38757 () Bool)
(declare-fun |n#0@@8| () Int)
(declare-fun %lbl%+38617 () Bool)
(declare-fun |u#0| () Int)
(assert (and (= (type $_Frame@0@@1) (MapType3Type refType boolType)) (= (type $Heap@0) (MapType1Type refType))))
(declare-fun $_Frame@0@@2 () T@U)
(declare-fun %lbl%+14020 () Bool)
(declare-fun |r#0@1| () Int)
(declare-fun |n#0@@9| () Int)
(declare-fun %lbl%@40047 () Bool)
(declare-fun %lbl%+14018 () Bool)
(declare-fun %lbl%+14016 () Bool)
(declare-fun %lbl%+14014 () Bool)
(declare-fun |$w$loop#0@0| () Bool)
(declare-fun %lbl%+38846 () Bool)
(declare-fun %lbl%@40111 () Bool)
(declare-fun |u#0@4| () Int)
(declare-fun %lbl%+14031 () Bool)
(declare-fun |u#0@1| () Int)
(declare-fun %lbl%+14060 () Bool)
(declare-fun |s#0_0@2| () Int)
(declare-fun %lbl%@39965 () Bool)
(declare-fun %lbl%+14058 () Bool)
(declare-fun %lbl%+14056 () Bool)
(declare-fun %lbl%+14054 () Bool)
(declare-fun |$w$loop#0_0@1| () Bool)
(declare-fun %lbl%+14073 () Bool)
(declare-fun |$decr$loop#0_00@2| () Int)
(declare-fun %lbl%@39804 () Bool)
(declare-fun |u#0@2| () Int)
(declare-fun |u#0@3| () Int)
(declare-fun |s#0_0@3| () Int)
(declare-fun %lbl%@39843 () Bool)
(declare-fun %lbl%@39857 () Bool)
(declare-fun %lbl%@39880 () Bool)
(declare-fun %lbl%@39890 () Bool)
(declare-fun %lbl%@39901 () Bool)
(declare-fun %lbl%+14071 () Bool)
(declare-fun |r#0@2| () Int)
(declare-fun %lbl%@39710 () Bool)
(declare-fun |$decr$loop#00@1| () Int)
(declare-fun %lbl%@39725 () Bool)
(declare-fun %lbl%@39749 () Bool)
(declare-fun %lbl%@39759 () Bool)
(declare-fun %lbl%@39767 () Bool)
(declare-fun %lbl%+14062 () Bool)
(declare-fun %lbl%+14047 () Bool)
(declare-fun %lbl%+14077 () Bool)
(declare-fun %lbl%+14041 () Bool)
(declare-fun |$decr_init$loop#0_00@1| () Int)
(declare-fun %lbl%+14033 () Bool)
(declare-fun |s#0_0@1| () Int)
(declare-fun %lbl%@39390 () Bool)
(declare-fun %lbl%@39400 () Bool)
(declare-fun %lbl%@39411 () Bool)
(declare-fun %lbl%+14022 () Bool)
(declare-fun %lbl%+14007 () Bool)
(declare-fun %lbl%+14081 () Bool)
(declare-fun %lbl%+14001 () Bool)
(declare-fun |$decr_init$loop#00@0| () Int)
(declare-fun %lbl%+13999 () Bool)
(declare-fun %lbl%@38989 () Bool)
(declare-fun |u#0@0@@0| () Int)
(declare-fun |r#0@0| () Int)
(declare-fun %lbl%@39044 () Bool)
(declare-fun %lbl%@39054 () Bool)
(declare-fun %lbl%@39062 () Bool)
(declare-fun %lbl%+38866 () Bool)
(declare-fun |u#0@@0| () Int)
(assert (= (type $_Frame@0@@2) (MapType3Type refType boolType)))
(set-option :TIMEOUT 0)
(declare-fun |A#0@@1| () T@U)
(declare-fun $Heap@0@@0 () T@U)
(declare-fun $_Frame@0@@3 () T@U)
(declare-fun %lbl%+14397 () Bool)
(declare-fun %lbl%+14395 () Bool)
(declare-fun |p#0@0| () Int)
(declare-fun |f#0| () Int)
(declare-fun |q#0@0| () Int)
(declare-fun |N#0| () Int)
(declare-fun %lbl%+14393 () Bool)
(declare-fun %lbl%@40421 () Bool)
(declare-fun %lbl%@40427 () Bool)
(declare-fun %lbl%@40441 () Bool)
(declare-fun %lbl%@40447 () Bool)
(declare-fun %lbl%+14391 () Bool)
(declare-fun %lbl%+14389 () Bool)
(declare-fun %lbl%+14387 () Bool)
(declare-fun %lbl%+14385 () Bool)
(declare-fun %lbl%@40278 () Bool)
(declare-fun %lbl%+40193 () Bool)
(assert (and (and (= (type |A#0@@1|) refType) (= (type $Heap@0@@0) (MapType1Type refType))) (= (type $_Frame@0@@3) (MapType3Type refType boolType))))
(push 1)
(set-info :boogie-vc-id CheckWellformed$$_module.__default.FIND)
(assert (not (let ((anon5_correct (=> (! (and %lbl%+14397 true) :lblpos +14397) true))) (let ((anon7_Else_correct@@0 (=> (! (and %lbl%+14395 true) :lblpos +14395) (=> (=> (and (and (and (<= (LitInt 0) |p#0@0|) (<= |p#0@0| |f#0|)) (<= |f#0| |q#0@0|)) (< |q#0@0| |N#0|)) (<= (U_2_int ($Unbox intType (MapType1Select $Heap@0@@0 |A#0@@1| (IndexField |p#0@0|)))) (U_2_int ($Unbox intType (MapType1Select $Heap@0@@0 |A#0@@1| (IndexField |q#0@0|)))))) anon5_correct)))) (let ((anon7_Then_correct@@0 (=> (! (and %lbl%+14393 true) :lblpos +14393) (=> (and (and (<= (LitInt 0) |p#0@0|) (<= |p#0@0| |f#0|)) (and (<= |f#0| |q#0@0|) (< |q#0@0| |N#0|))) (and (! (or %lbl%@40421 (not (= |A#0@@1| null))) :lblneg @40421) (=> (not (= |A#0@@1| null)) (and (! (or %lbl%@40427 (and (<= 0 |p#0@0|) (< |p#0@0| (_System.array.Length |A#0@@1|)))) :lblneg @40427) (=> (and (<= 0 |p#0@0|) (< |p#0@0| (_System.array.Length |A#0@@1|))) (and (! (or %lbl%@40441 (not (= |A#0@@1| null))) :lblneg @40441) (=> (not (= |A#0@@1| null)) (and (! (or %lbl%@40447 (and (<= 0 |q#0@0|) (< |q#0@0| (_System.array.Length |A#0@@1|)))) :lblneg @40447) (=> (and (<= 0 |q#0@0|) (< |q#0@0| (_System.array.Length |A#0@@1|))) (=> (<= (U_2_int ($Unbox intType (MapType1Select $Heap@0@@0 |A#0@@1| (IndexField |p#0@0|)))) (U_2_int ($Unbox intType (MapType1Select $Heap@0@@0 |A#0@@1| (IndexField |q#0@0|))))) anon5_correct))))))))))))) (let ((anon2_correct (=> (! (and %lbl%+14391 true) :lblpos +14391) (=> (and (<= (LitInt 0) |f#0|) (< |f#0| |N#0|)) (=> (and (and ($IsGoodHeap $Heap@0@@0) ($IsHeapAnchor $Heap@0@@0)) (and (forall (($o@@21 T@U) ($f@@13 T@U)) (! (let ((alpha@@20 (FieldTypeInv0 (type $f@@13)))) (=> (and (and (= (type $o@@21) refType) (= (type $f@@13) (FieldType alpha@@20))) (and (not (= $o@@21 null)) (U_2_bool (MapType1Select $Heap@@12 $o@@21 alloc)))) (or (= (MapType1Select $Heap@0@@0 $o@@21 $f@@13) (MapType1Select $Heap@@12 $o@@21 $f@@13)) (= $o@@21 |A#0@@1|)))) :qid |Classics.47:8| :skolemid |353| :pattern ((MapType1Select $Heap@0@@0 $o@@21 $f@@13)))) ($HeapSucc $Heap@@12 $Heap@0@@0))) (and anon7_Then_correct@@0 anon7_Else_correct@@0)))))) (let ((anon6_Else_correct (=> (! (and %lbl%+14389 true) :lblpos +14389) (=> (< |f#0| (LitInt 0)) anon2_correct)))) (let ((anon6_Then_correct (=> (! (and %lbl%+14387 true) :lblpos +14387) (=> (<= (LitInt 0) |f#0|) anon2_correct)))) (let ((anon0_correct@@2 (=> (! (and %lbl%+14385 true) :lblpos +14385) (=> (and (= $_Frame@0@@3 (|lambda#4| |A#0@@1| null $Heap@@12 alloc)) (not (= |A#0@@1| null))) (and (! (or %lbl%@40278 (not (= |A#0@@1| null))) :lblneg @40278) (=> (not (= |A#0@@1| null)) (=> (= (_System.array.Length |A#0@@1|) |N#0|) (and anon6_Then_correct anon6_Else_correct)))))))) (let ((PreconditionGeneratedEntry_correct@@2 (=> (! (and %lbl%+40193 true) :lblpos +40193) (=> (and ($IsGoodHeap $Heap@@12) ($IsHeapAnchor $Heap@@12)) (=> (and (and ($Is |A#0@@1| (Tclass._System.array TInt)) ($IsAlloc |A#0@@1| (Tclass._System.array TInt) $Heap@@12)) (and (= 0 $ModuleContextHeight) (= 2 $FunctionContextHeight))) anon0_correct@@2))))) PreconditionGeneratedEntry_correct@@2))))))))))
(check-sat)
(pop 1)
(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.0)
(set-option :AUTO_CONFIG false)
(set-option :pp.bv_literals false)
(set-option :MODEL.V2 true)
(set-option :smt.PHASE_SELECTION 0)
(set-option :smt.RESTART_STRATEGY 0)
(set-option :smt.RESTART_FACTOR |1.5|)
(set-option :smt.ARITH.RANDOM_INITIAL_VALUE true)
(set-option :smt.CASE_SPLIT 3)
(set-option :smt.DELAY_UNITS true)
(set-option :NNF.SK_HACK true)
(set-option :smt.MBQI false)
(set-option :smt.QI.EAGER_THRESHOLD 100)
(set-option :TYPE_CHECK true)
(set-option :smt.BV.REFLECT true)
(set-option :TIMEOUT 0)
(set-info :category "industrial")
(declare-sort |T@U| 0)
(declare-sort |T@T| 0)
(declare-fun real_pow (Real Real) Real)
(declare-fun UOrdering2 (|T@U| |T@U|) Bool)
(declare-fun UOrdering3 (|T@T| |T@U| |T@U|) Bool)
(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-fun Ctor (T@T) Int)
(declare-fun intType () T@T)
(declare-fun realType () T@T)
(declare-fun boolType () T@T)
(declare-fun int_2_U (Int) T@U)
(declare-fun U_2_int (T@U) Int)
(declare-fun type (T@U) T@T)
(declare-fun real_2_U (Real) T@U)
(declare-fun U_2_real (T@U) Real)
(declare-fun bool_2_U (Bool) T@U)
(declare-fun U_2_bool (T@U) Bool)
(declare-fun TyType () T@T)
(declare-fun TBool () T@U)
(declare-fun TChar () T@U)
(declare-fun TInt () T@U)
(declare-fun TNat () T@U)
(declare-fun TReal () T@U)
(declare-fun TyTagType () T@T)
(declare-fun TagBool () T@U)
(declare-fun TagChar () T@U)
(declare-fun TagInt () T@U)
(declare-fun TagNat () T@U)
(declare-fun TagReal () T@U)
(declare-fun TagSet () T@U)
(declare-fun TagISet () T@U)
(declare-fun TagMultiSet () T@U)
(declare-fun TagSeq () T@U)
(declare-fun TagMap () T@U)
(declare-fun TagIMap () T@U)
(declare-fun TagClass () T@U)
(declare-fun ClassNameType () T@T)
(declare-fun NoTraitAtAll () T@U)
(declare-fun class._System.int () T@U)
(declare-fun class._System.bool () T@U)
(declare-fun class._System.set () T@U)
(declare-fun class._System.seq () T@U)
(declare-fun class._System.multiset () T@U)
(declare-fun FieldType (T@T) T@T)
(declare-fun FieldTypeInv0 (T@T) T@T)
(declare-fun alloc () T@U)
(declare-fun class._System.object () T@U)
(declare-fun Tagclass._System.object () T@U)
(declare-fun class._System.array () T@U)
(declare-fun Tagclass._System.array () T@U)
(declare-fun Tagclass._System.___hFunc0 () T@U)
(declare-fun Tagclass._System.___hFunc1 () T@U)
(declare-fun class._module.__default () T@U)
(declare-fun Tagclass._module.__default () T@U)
(declare-fun $$Language$Dafny () Bool)
(declare-fun TSet (T@U) T@U)
(declare-fun Inv0_TSet (T@U) T@U)
(declare-fun TISet (T@U) T@U)
(declare-fun Inv0_TISet (T@U) T@U)
(declare-fun TSeq (T@U) T@U)
(declare-fun Inv0_TSeq (T@U) T@U)
(declare-fun TMultiSet (T@U) T@U)
(declare-fun Inv0_TMultiSet (T@U) T@U)
(declare-fun TMap (T@U T@U) T@U)
(declare-fun Inv0_TMap (T@U) T@U)
(declare-fun Inv1_TMap (T@U) T@U)
(declare-fun TIMap (T@U T@U) T@U)
(declare-fun Inv0_TIMap (T@U) T@U)
(declare-fun Inv1_TIMap (T@U) T@U)
(declare-fun Tag (T@U) T@U)
(declare-fun LitInt (Int) Int)
(declare-fun BoxType () T@T)
(declare-fun $Box (T@U) T@U)
(declare-fun Lit (T@U) T@U)
(declare-fun LitReal (Real) Real)
(declare-fun charType () T@T)
(declare-fun |char#FromInt| (Int) T@U)
(declare-fun |char#ToInt| (T@U) Int)
(declare-fun $Unbox (T@T T@U) T@U)
(declare-fun $IsBox (T@U T@U) Bool)
(declare-fun $Is (T@U T@U) Bool)
(declare-fun MapType0Type (T@T T@T) T@T)
(declare-fun MapType0TypeInv0 (T@T) T@T)
(declare-fun MapType0TypeInv1 (T@T) T@T)
(declare-fun MapType0Select (T@U T@U) T@U)
(declare-fun MapType0Store (T@U T@U T@U) T@U)
(declare-fun SeqType (T@T) T@T)
(declare-fun SeqTypeInv0 (T@T) T@T)
(declare-fun MapType (T@T T@T) T@T)
(declare-fun MapTypeInv0 (T@T) T@T)
(declare-fun MapTypeInv1 (T@T) T@T)
(declare-fun IMapType (T@T T@T) T@T)
(declare-fun IMapTypeInv0 (T@T) T@T)
(declare-fun IMapTypeInv1 (T@T) T@T)
(declare-fun MapType1Type (T@T) T@T)
(declare-fun MapType1TypeInv0 (T@T) T@T)
(declare-fun MapType1Select (T@U T@U T@U) T@U)
(declare-fun MapType1Store (T@U T@U T@U T@U) T@U)
(declare-fun refType () T@T)
(declare-fun $IsAllocBox (T@U T@U T@U) Bool)
(declare-fun $IsAlloc (T@U T@U T@U) Bool)
(declare-fun $IsGoodMultiSet (T@U) Bool)
(declare-fun |Seq#Index| (T@U Int) T@U)
(declare-fun |Seq#Length| (T@U) Int)
(declare-fun |Map#Elements| (T@U) T@U)
(declare-fun |Map#Domain| (T@U) T@U)
(declare-fun |IMap#Elements| (T@U) T@U)
(declare-fun |IMap#Domain| (T@U) T@U)
(declare-fun TypeTuple (T@U T@U) T@U)
(declare-fun TypeTupleCar (T@U) T@U)
(declare-fun TypeTupleCdr (T@U) T@U)
(declare-fun SetRef_to_SetBox (T@U) T@U)
(declare-fun Tclass._System.object () T@U)
(declare-fun DatatypeTypeType () T@T)
(declare-fun BoxRank (T@U) Int)
(declare-fun DtRank (T@U) Int)
(declare-fun LayerTypeType () T@T)
(declare-fun AtLayer (T@U T@U) T@U)
(declare-fun $LS (T@U) T@U)
(declare-fun IndexField (Int) T@U)
(declare-fun FDim (T@U) Int)
(declare-fun IndexField_Inverse (T@U) Int)
(declare-fun MultiIndexField (T@U Int) T@U)
(declare-fun MultiIndexField_Inverse0 (T@U) T@U)
(declare-fun MultiIndexField_Inverse1 (T@U) Int)
(declare-fun NameFamilyType () T@T)
(declare-fun FieldOfDecl (T@T T@U T@U) T@U)
(declare-fun DeclType (T@U) T@U)
(declare-fun DeclName (T@U) T@U)
(declare-fun $HeapSucc (T@U T@U) Bool)
(declare-fun $IsGhostField (T@U) Bool)
(declare-fun _System.array.Length (T@U) Int)
(declare-fun q@Int (Real) Int)
(declare-fun q@Real (Int) Real)
(declare-fun $IsGoodHeap (T@U) Bool)
(declare-fun $HeapSuccGhost (T@U T@U) Bool)
(declare-fun |Set#Card| (T@U) Int)
(declare-fun |Set#Empty| (T@T) T@U)
(declare-fun |Set#Singleton| (T@U) T@U)
(declare-fun |Set#UnionOne| (T@U T@U) T@U)
(declare-fun |Set#Union| (T@U T@U) T@U)
(declare-fun |Set#Difference| (T@U T@U) T@U)
(declare-fun |Set#Disjoint| (T@U T@U) Bool)
(declare-fun |Set#Intersection| (T@U T@U) T@U)
(declare-fun |Set#Subset| (T@U T@U) Bool)
(declare-fun |Set#Equal| (T@U T@U) Bool)
(declare-fun |ISet#Empty| (T@T) T@U)
(declare-fun |ISet#UnionOne| (T@U T@U) T@U)
(declare-fun |ISet#Union| (T@U T@U) T@U)
(declare-fun |ISet#Difference| (T@U T@U) T@U)
(declare-fun |ISet#Disjoint| (T@U T@U) Bool)
(declare-fun |ISet#Intersection| (T@U T@U) T@U)
(declare-fun |ISet#Subset| (T@U T@U) Bool)
(declare-fun |ISet#Equal| (T@U T@U) Bool)
(declare-fun |Math#min| (Int Int) Int)
(declare-fun |Math#clip| (Int) Int)
(declare-fun |MultiSet#Card| (T@U) Int)
(declare-fun |MultiSet#Empty| (T@T) T@U)
(declare-fun |MultiSet#Singleton| (T@U) T@U)
(declare-fun |MultiSet#UnionOne| (T@U T@U) T@U)
(declare-fun |MultiSet#Union| (T@U T@U) T@U)
(declare-fun |MultiSet#Intersection| (T@U T@U) T@U)
(declare-fun |MultiSet#Difference| (T@U T@U) T@U)
(declare-fun |MultiSet#Subset| (T@U T@U) Bool)
(declare-fun |MultiSet#Equal| (T@U T@U) Bool)
(declare-fun |MultiSet#Disjoint| (T@U T@U) Bool)
(declare-fun |MultiSet#FromSet| (T@U) T@U)
(declare-fun |MultiSet#FromSeq| (T@U) T@U)
(declare-fun |Seq#Build| (T@U T@U) T@U)
(declare-fun |Seq#Empty| (T@T) T@U)
(declare-fun |Seq#Append| (T@U T@U) T@U)
(declare-fun |Seq#Update| (T@U Int T@U) T@U)
(declare-fun |Seq#Singleton| (T@U) T@U)
(declare-fun |Seq#Contains| (T@U T@U) Bool)
(declare-fun |Seq#Take| (T@U Int) T@U)
(declare-fun |Seq#Drop| (T@U Int) T@U)
(declare-fun |Seq#Equal| (T@U T@U) Bool)
(declare-fun |Seq#SameUntil| (T@U T@U Int) Bool)
(declare-fun |Seq#FromArray| (T@U T@U) T@U)
(declare-fun |Seq#Rank| (T@U) Int)
(declare-fun |Map#Card| (T@U) Int)
(declare-fun |Map#Empty| (T@T T@T) T@U)
(declare-fun |Map#Glue| (T@U T@U T@U) T@U)
(declare-fun |Map#Build| (T@U T@U T@U) T@U)
(declare-fun |Map#Equal| (T@U T@U) Bool)
(declare-fun |Map#Disjoint| (T@U T@U) Bool)
(declare-fun |IMap#Empty| (T@T T@T) T@U)
(declare-fun |IMap#Glue| (T@U T@U T@U) T@U)
(declare-fun |IMap#Build| (T@U T@U T@U) T@U)
(declare-fun |IMap#Equal| (T@U T@U) Bool)
(declare-fun INTERNAL_add_boogie (Int Int) Int)
(declare-fun INTERNAL_sub_boogie (Int Int) Int)
(declare-fun INTERNAL_mul_boogie (Int Int) Int)
(declare-fun INTERNAL_div_boogie (Int Int) Int)
(declare-fun INTERNAL_mod_boogie (Int Int) Int)
(declare-fun INTERNAL_lt_boogie (Int Int) Bool)
(declare-fun INTERNAL_le_boogie (Int Int) Bool)
(declare-fun INTERNAL_gt_boogie (Int Int) Bool)
(declare-fun INTERNAL_ge_boogie (Int Int) Bool)
(declare-fun null () T@U)
(declare-fun Tclass._System.array (T@U) T@U)
(declare-fun Tclass._System.array_0 (T@U) T@U)
(declare-fun dtype (T@U) T@U)
(declare-fun Tclass._System.___hFunc0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc0_0 (T@U) T@U)
(declare-fun HandleTypeType () T@T)
(declare-fun Apply0 (T@U T@U T@U) T@U)
(declare-fun Handle0 (T@U T@U T@U) T@U)
(declare-fun Requires0 (T@U T@U T@U) Bool)
(declare-fun Reads0 (T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hFunc1 (T@U T@U) T@U)
(declare-fun Tclass._System.___hFunc1_0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc1_1 (T@U) T@U)
(declare-fun MapType2Type (T@T T@T T@T) T@T)
(declare-fun MapType2TypeInv0 (T@T) T@T)
(declare-fun MapType2TypeInv1 (T@T) T@T)
(declare-fun MapType2TypeInv2 (T@T) T@T)
(declare-fun MapType2Select (T@U T@U T@U) T@U)
(declare-fun MapType2Store (T@U T@U T@U T@U) T@U)
(declare-fun Apply1 (T@U T@U T@U T@U T@U) T@U)
(declare-fun Handle1 (T@U T@U T@U) T@U)
(declare-fun Requires1 (T@U T@U T@U T@U T@U) Bool)
(declare-fun Reads1 (T@U T@U T@U T@U T@U) T@U)
(declare-fun Tclass._module.__default () T@U)
(declare-fun _module.__default.Factorial (T@U T@U Int) Int)
(declare-fun $IsHeapAnchor (T@U) Bool)
(declare-fun |_module.__default.Factorial#canCall| (T@U Int) Bool)
(declare-fun $ModuleContextHeight () Int)
(declare-fun $FunctionContextHeight () Int)
(declare-fun |_module.__default.Factorial#requires| (T@U T@U Int) Bool)
(declare-fun MapType3Type (T@T T@T) T@T)
(declare-fun MapType3TypeInv0 (T@T) T@T)
(declare-fun MapType3TypeInv1 (T@T) T@T)
(declare-fun MapType3Select (T@U T@U T@U) T@U)
(declare-fun MapType3Store (T@U T@U T@U T@U) T@U)
(declare-fun |lambda#0| (T@U T@U T@U) T@U)
(declare-fun |lambda#1| (T@U T@U T@U) T@U)
(declare-fun |lambda#2| (T@U T@U T@U) T@U)
(declare-fun |lambda#3| (T@U T@U T@U) T@U)
(declare-fun |lambda#4| (T@U T@U T@U T@U) T@U)
(declare-fun |lambda#5| (T@U T@U T@U T@U) T@U)
(declare-fun $LZ () T@U)
(declare-fun $Heap@@12 () T@U)
(declare-fun $_Frame@0 () T@U)
(declare-fun $_Frame@0@@0 () T@U)
(declare-fun %lbl%+13101 () Bool)
(declare-fun %lbl%@34767 () Bool)
(declare-fun |b$reqreads#0@1| () Bool)
(declare-fun %lbl%+13099 () Bool)
(declare-fun |n#0@@7| () Int)
(declare-fun %lbl%@34589 () Bool)
(declare-fun |##n#0@0| () Int)
(declare-fun |b$reqreads#0@0| () Bool)
(declare-fun %lbl%@34638 () Bool)
(declare-fun %lbl%@34651 () Bool)
(declare-fun %lbl%@34666 () Bool)
(declare-fun %lbl%+13097 () Bool)
(declare-fun %lbl%@34525 () Bool)
(declare-fun %lbl%+13095 () Bool)
(declare-fun %lbl%+13088 () Bool)
(declare-fun %lbl%+13084 () Bool)
(declare-fun %lbl%+34404 () Bool)
(assert (and (and (and (and (and (and (and (and (and (and (and (= (Ctor intType) 0) (= (Ctor realType) 1)) (= (Ctor boolType) 2)) (forall ((arg0 Int)) (! (= (U_2_int (int_2_U arg0)) arg0) :qid |typeInv:U_2_int| :pattern ((int_2_U arg0))))) (forall ((x T@U)) (! (=> (= (type x) intType) (= (int_2_U (U_2_int x)) x)) :qid |cast:U_2_int| :pattern ((U_2_int x))))) (forall ((arg0@@0 Int)) (! (= (type (int_2_U arg0@@0)) intType) :qid |funType:int_2_U| :pattern ((int_2_U arg0@@0))))) (forall ((arg0@@1 Real)) (! (= (U_2_real (real_2_U arg0@@1)) arg0@@1) :qid |typeInv:U_2_real| :pattern ((real_2_U arg0@@1))))) (forall ((x@@0 T@U)) (! (=> (= (type x@@0) realType) (= (real_2_U (U_2_real x@@0)) x@@0)) :qid |cast:U_2_real| :pattern ((U_2_real x@@0))))) (forall ((arg0@@2 Real)) (! (= (type (real_2_U arg0@@2)) realType) :qid |funType:real_2_U| :pattern ((real_2_U arg0@@2))))) (forall ((arg0@@3 Bool)) (! (= (U_2_bool (bool_2_U arg0@@3)) arg0@@3) :qid |typeInv:U_2_bool| :pattern ((bool_2_U arg0@@3))))) (forall ((x@@1 T@U)) (! (=> (= (type x@@1) boolType) (= (bool_2_U (U_2_bool x@@1)) x@@1)) :qid |cast:U_2_bool| :pattern ((U_2_bool x@@1))))) (forall ((arg0@@4 Bool)) (! (= (type (bool_2_U arg0@@4)) boolType) :qid |funType:bool_2_U| :pattern ((bool_2_U arg0@@4))))))
(assert (forall ((x@@2 T@U)) (! (UOrdering2 x@@2 x@@2) :qid |bg:subtype-refl| :no-pattern (U_2_int x@@2) :no-pattern (U_2_bool x@@2))))
(assert (forall ((x@@3 T@U) (y T@U) (z T@U)) (! (let ((alpha (type x@@3))) (=> (and (and (= (type y) alpha) (= (type z) alpha)) (and (UOrdering2 x@@3 y) (UOrdering2 y z))) (UOrdering2 x@@3 z))) :qid |bg:subtype-trans| :pattern ((UOrdering2 x@@3 y) (UOrdering2 y z)))))
(assert (forall ((x@@4 T@U) (y@@0 T@U)) (! (let ((alpha@@0 (type x@@4))) (=> (= (type y@@0) alpha@@0) (=> (and (UOrdering2 x@@4 y@@0) (UOrdering2 y@@0 x@@4)) (= x@@4 y@@0)))) :qid |bg:subtype-antisymm| :pattern ((UOrdering2 x@@4 y@@0) (UOrdering2 y@@0 x@@4)))))
(assert (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (= (Ctor TyType) 3) (= (type TBool) TyType)) (= (type TChar) TyType)) (= (type TInt) TyType)) (= (type TNat) TyType)) (= (type TReal) TyType)) (= (Ctor TyTagType) 4)) (= (type TagBool) TyTagType)) (= (type TagChar) TyTagType)) (= (type TagInt) TyTagType)) (= (type TagNat) TyTagType)) (= (type TagReal) TyTagType)) (= (type TagSet) TyTagType)) (= (type TagISet) TyTagType)) (= (type TagMultiSet) TyTagType)) (= (type TagSeq) TyTagType)) (= (type TagMap) TyTagType)) (= (type TagIMap) TyTagType)) (= (type TagClass) TyTagType)) (= (Ctor ClassNameType) 5)) (= (type NoTraitAtAll) ClassNameType)) (= (type class._System.int) ClassNameType)) (= (type class._System.bool) ClassNameType)) (= (type class._System.set) ClassNameType)) (= (type class._System.seq) ClassNameType)) (= (type class._System.multiset) ClassNameType)) (forall ((arg0@@5 T@T)) (! (= (Ctor (FieldType arg0@@5)) 6) :qid |ctor:FieldType|))) (forall ((arg0@@6 T@T)) (! (= (FieldTypeInv0 (FieldType arg0@@6)) arg0@@6) :qid |typeInv:FieldTypeInv0| :pattern ((FieldType arg0@@6))))) (= (type alloc) (FieldType boolType))) (= (type class._System.object) ClassNameType)) (= (type Tagclass._System.object) TyTagType)) (= (type class._System.array) ClassNameType)) (= (type Tagclass._System.array) TyTagType)) (= (type Tagclass._System.___hFunc0) TyTagType)) (= (type Tagclass._System.___hFunc1) TyTagType)) (= (type class._module.__default) ClassNameType)) (= (type Tagclass._module.__default) TyTagType)))
(assert (distinct TBool TChar TInt TNat TReal TagBool TagChar TagInt TagNat TagReal TagSet TagISet TagMultiSet TagSeq TagMap TagIMap TagClass NoTraitAtAll class._System.int class._System.bool class._System.set class._System.seq class._System.multiset alloc class._System.object Tagclass._System.object class._System.array Tagclass._System.array Tagclass._System.___hFunc0 Tagclass._System.___hFunc1 class._module.__default Tagclass._module.__default))
(assert $$Language$Dafny)
(assert (and (forall ((arg0@@7 T@U)) (! (= (type (TSet arg0@@7)) TyType) :qid |funType:TSet| :pattern ((TSet arg0@@7)))) (forall ((arg0@@8 T@U)) (! (= (type (Inv0_TSet arg0@@8)) TyType) :qid |funType:Inv0_TSet| :pattern ((Inv0_TSet arg0@@8))))))
(assert (forall ((t T@U)) (! (=> (= (type t) TyType) (= (Inv0_TSet (TSet t)) t)) :qid |DafnyPre.30:15| :skolemid |0| :pattern ((TSet t)))))
(assert (and (forall ((arg0@@9 T@U)) (! (= (type (TISet arg0@@9)) TyType) :qid |funType:TISet| :pattern ((TISet arg0@@9)))) (forall ((arg0@@10 T@U)) (! (= (type (Inv0_TISet arg0@@10)) TyType) :qid |funType:Inv0_TISet| :pattern ((Inv0_TISet arg0@@10))))))
(assert (forall ((t@@0 T@U)) (! (=> (= (type t@@0) TyType) (= (Inv0_TISet (TISet t@@0)) t@@0)) :qid |DafnyPre.32:15| :skolemid |1| :pattern ((TISet t@@0)))))
(assert (and (forall ((arg0@@11 T@U)) (! (= (type (TSeq arg0@@11)) TyType) :qid |funType:TSeq| :pattern ((TSeq arg0@@11)))) (forall ((arg0@@12 T@U)) (! (= (type (Inv0_TSeq arg0@@12)) TyType) :qid |funType:Inv0_TSeq| :pattern ((Inv0_TSeq arg0@@12))))))
(assert (forall ((t@@1 T@U)) (! (=> (= (type t@@1) TyType) (= (Inv0_TSeq (TSeq t@@1)) t@@1)) :qid |DafnyPre.34:15| :skolemid |2| :pattern ((TSeq t@@1)))))
(assert (and (forall ((arg0@@13 T@U)) (! (= (type (TMultiSet arg0@@13)) TyType) :qid |funType:TMultiSet| :pattern ((TMultiSet arg0@@13)))) (forall ((arg0@@14 T@U)) (! (= (type (Inv0_TMultiSet arg0@@14)) TyType) :qid |funType:Inv0_TMultiSet| :pattern ((Inv0_TMultiSet arg0@@14))))))
(assert (forall ((t@@2 T@U)) (! (=> (= (type t@@2) TyType) (= (Inv0_TMultiSet (TMultiSet t@@2)) t@@2)) :qid |DafnyPre.36:15| :skolemid |3| :pattern ((TMultiSet t@@2)))))
(assert (and (forall ((arg0@@15 T@U) (arg1 T@U)) (! (= (type (TMap arg0@@15 arg1)) TyType) :qid |funType:TMap| :pattern ((TMap arg0@@15 arg1)))) (forall ((arg0@@16 T@U)) (! (= (type (Inv0_TMap arg0@@16)) TyType) :qid |funType:Inv0_TMap| :pattern ((Inv0_TMap arg0@@16))))))
(assert (forall ((t@@3 T@U) (u T@U)) (! (=> (and (= (type t@@3) TyType) (= (type u) TyType)) (= (Inv0_TMap (TMap t@@3 u)) t@@3)) :qid |DafnyPre.39:15| :skolemid |4| :pattern ((TMap t@@3 u)))))
(assert (forall ((arg0@@17 T@U)) (! (= (type (Inv1_TMap arg0@@17)) TyType) :qid |funType:Inv1_TMap| :pattern ((Inv1_TMap arg0@@17)))))
(assert (forall ((t@@4 T@U) (u@@0 T@U)) (! (=> (and (= (type t@@4) TyType) (= (type u@@0) TyType)) (= (Inv1_TMap (TMap t@@4 u@@0)) u@@0)) :qid |DafnyPre.40:15| :skolemid |5| :pattern ((TMap t@@4 u@@0)))))
(assert (and (forall ((arg0@@18 T@U) (arg1@@0 T@U)) (! (= (type (TIMap arg0@@18 arg1@@0)) TyType) :qid |funType:TIMap| :pattern ((TIMap arg0@@18 arg1@@0)))) (forall ((arg0@@19 T@U)) (! (= (type (Inv0_TIMap arg0@@19)) TyType) :qid |funType:Inv0_TIMap| :pattern ((Inv0_TIMap arg0@@19))))))
(assert (forall ((t@@5 T@U) (u@@1 T@U)) (! (=> (and (= (type t@@5) TyType) (= (type u@@1) TyType)) (= (Inv0_TIMap (TIMap t@@5 u@@1)) t@@5)) :qid |DafnyPre.43:15| :skolemid |6| :pattern ((TIMap t@@5 u@@1)))))
(assert (forall ((arg0@@20 T@U)) (! (= (type (Inv1_TIMap arg0@@20)) TyType) :qid |funType:Inv1_TIMap| :pattern ((Inv1_TIMap arg0@@20)))))
(assert (forall ((t@@6 T@U) (u@@2 T@U)) (! (=> (and (= (type t@@6) TyType) (= (type u@@2) TyType)) (= (Inv1_TIMap (TIMap t@@6 u@@2)) u@@2)) :qid |DafnyPre.44:15| :skolemid |7| :pattern ((TIMap t@@6 u@@2)))))
(assert (forall ((arg0@@21 T@U)) (! (= (type (Tag arg0@@21)) TyTagType) :qid |funType:Tag| :pattern ((Tag arg0@@21)))))
(assert (= (Tag TBool) TagBool))
(assert (= (Tag TChar) TagChar))
(assert (= (Tag TInt) TagInt))
(assert (= (Tag TNat) TagNat))
(assert (= (Tag TReal) TagReal))
(assert (forall ((t@@7 T@U)) (! (=> (= (type t@@7) TyType) (= (Tag (TSet t@@7)) TagSet)) :qid |DafnyPre.70:15| :skolemid |8| :pattern ((TSet t@@7)))))
(assert (forall ((t@@8 T@U)) (! (=> (= (type t@@8) TyType) (= (Tag (TISet t@@8)) TagISet)) :qid |DafnyPre.71:15| :skolemid |9| :pattern ((TISet t@@8)))))
(assert (forall ((t@@9 T@U)) (! (=> (= (type t@@9) TyType) (= (Tag (TMultiSet t@@9)) TagMultiSet)) :qid |DafnyPre.72:15| :skolemid |10| :pattern ((TMultiSet t@@9)))))
(assert (forall ((t@@10 T@U)) (! (=> (= (type t@@10) TyType) (= (Tag (TSeq t@@10)) TagSeq)) :qid |DafnyPre.73:15| :skolemid |11| :pattern ((TSeq t@@10)))))
(assert (forall ((t@@11 T@U) (u@@3 T@U)) (! (=> (and (= (type t@@11) TyType) (= (type u@@3) TyType)) (= (Tag (TMap t@@11 u@@3)) TagMap)) :qid |DafnyPre.74:15| :skolemid |12| :pattern ((TMap t@@11 u@@3)))))
(assert (forall ((t@@12 T@U) (u@@4 T@U)) (! (=> (and (= (type t@@12) TyType) (= (type u@@4) TyType)) (= (Tag (TIMap t@@12 u@@4)) TagIMap)) :qid |DafnyPre.75:15| :skolemid |13| :pattern ((TIMap t@@12 u@@4)))))
(assert (forall ((x@@5 Int)) (! (= (LitInt x@@5) x@@5) :qid |DafnyPre.80:29| :skolemid |14| :pattern ((LitInt x@@5)))))
(assert (and (and (= (Ctor BoxType) 7) (forall ((arg0@@22 T@U)) (! (= (type ($Box arg0@@22)) BoxType) :qid |funType:$Box| :pattern (($Box arg0@@22))))) (forall ((arg0@@23 T@U)) (! (let ((T (type arg0@@23))) (= (type (Lit arg0@@23)) T)) :qid |funType:Lit| :pattern ((Lit arg0@@23))))))
(assert (forall ((x@@6 Int)) (! (= ($Box (int_2_U (LitInt x@@6))) (Lit ($Box (int_2_U x@@6)))) :qid |DafnyPre.81:15| :skolemid |15| :pattern (($Box (int_2_U (LitInt x@@6)))))))
(assert (forall ((x@@7 Real)) (! (= (LitReal x@@7) x@@7) :qid |DafnyPre.82:30| :skolemid |16| :pattern ((LitReal x@@7)))))
(assert (forall ((x@@8 Real)) (! (= ($Box (real_2_U (LitReal x@@8))) (Lit ($Box (real_2_U x@@8)))) :qid |DafnyPre.83:15| :skolemid |17| :pattern (($Box (real_2_U (LitReal x@@8)))))))
(assert (forall ((x@@9 T@U)) (! (= (Lit x@@9) x@@9) :qid |DafnyPre.84:29| :skolemid |18| :pattern ((Lit x@@9)))))
(assert (forall ((x@@10 T@U)) (! (= ($Box (Lit x@@10)) (Lit ($Box x@@10))) :qid |DafnyPre.85:18| :skolemid |19| :pattern (($Box (Lit x@@10))))))
(assert (and (= (Ctor charType) 8) (forall ((arg0@@24 Int)) (! (= (type (|char#FromInt| arg0@@24)) charType) :qid |funType:char#FromInt| :pattern ((|char#FromInt| arg0@@24))))))
(assert (forall ((ch T@U)) (! (=> (= (type ch) charType) (= (|char#FromInt| (|char#ToInt| ch)) ch)) :qid |DafnyPre.94:15| :skolemid |20| :pattern ((|char#ToInt| ch)))))
(assert (forall ((n Int)) (! (=> (and (<= 0 n) (< n 65536)) (= (|char#ToInt| (|char#FromInt| n)) n)) :qid |DafnyPre.97:15| :skolemid |21| :pattern ((|char#FromInt| n)))))
(assert (forall ((T@@0 T@T) (arg0@@25 T@U)) (! (= (type ($Unbox T@@0 arg0@@25)) T@@0) :qid |funType:$Unbox| :pattern (($Unbox T@@0 arg0@@25)))))
(assert (forall ((x@@11 T@U)) (! (let ((T@@1 (type x@@11))) (= ($Unbox T@@1 ($Box x@@11)) x@@11)) :qid |DafnyPre.125:18| :skolemid |22| :pattern (($Box x@@11)))))
(assert (forall ((bx T@U)) (! (=> (and (= (type bx) BoxType) ($IsBox bx TInt)) (and (= ($Box ($Unbox intType bx)) bx) ($Is ($Unbox intType bx) TInt))) :qid |DafnyPre.127:15| :skolemid |23| :pattern (($IsBox bx TInt)))))
(assert (forall ((bx@@0 T@U)) (! (=> (and (= (type bx@@0) BoxType) ($IsBox bx@@0 TNat)) (and (= ($Box ($Unbox intType bx@@0)) bx@@0) ($Is ($Unbox intType bx@@0) TNat))) :qid |DafnyPre.130:15| :skolemid |24| :pattern (($IsBox bx@@0 TNat)))))
(assert (forall ((bx@@1 T@U)) (! (=> (and (= (type bx@@1) BoxType) ($IsBox bx@@1 TReal)) (and (= ($Box ($Unbox realType bx@@1)) bx@@1) ($Is ($Unbox realType bx@@1) TReal))) :qid |DafnyPre.133:15| :skolemid |25| :pattern (($IsBox bx@@1 TReal)))))
(assert (forall ((bx@@2 T@U)) (! (=> (and (= (type bx@@2) BoxType) ($IsBox bx@@2 TBool)) (and (= ($Box ($Unbox boolType bx@@2)) bx@@2) ($Is ($Unbox boolType bx@@2) TBool))) :qid |DafnyPre.136:15| :skolemid |26| :pattern (($IsBox bx@@2 TBool)))))
(assert (forall ((bx@@3 T@U)) (! (=> (and (= (type bx@@3) BoxType) ($IsBox bx@@3 TChar)) (and (= ($Box ($Unbox charType bx@@3)) bx@@3) ($Is ($Unbox charType bx@@3) TChar))) :qid |DafnyPre.139:15| :skolemid |27| :pattern (($IsBox bx@@3 TChar)))))
(assert (and (and (and (and (and (and (forall ((arg0@@26 T@T) (arg1@@1 T@T)) (! (= (Ctor (MapType0Type arg0@@26 arg1@@1)) 9) :qid |ctor:MapType0Type|)) (forall ((arg0@@27 T@T) (arg1@@2 T@T)) (! (= (MapType0TypeInv0 (MapType0Type arg0@@27 arg1@@2)) arg0@@27) :qid |typeInv:MapType0TypeInv0| :pattern ((MapType0Type arg0@@27 arg1@@2))))) (forall ((arg0@@28 T@T) (arg1@@3 T@T)) (! (= (MapType0TypeInv1 (MapType0Type arg0@@28 arg1@@3)) arg1@@3) :qid |typeInv:MapType0TypeInv1| :pattern ((MapType0Type arg0@@28 arg1@@3))))) (forall ((arg0@@29 T@U) (arg1@@4 T@U)) (! (let ((aVar1 (MapType0TypeInv1 (type arg0@@29)))) (= (type (MapType0Select arg0@@29 arg1@@4)) aVar1)) :qid |funType:MapType0Select| :pattern ((MapType0Select arg0@@29 arg1@@4))))) (forall ((arg0@@30 T@U) (arg1@@5 T@U) (arg2 T@U)) (! (let ((aVar1@@0 (type arg2))) (let ((aVar0 (type arg1@@5))) (= (type (MapType0Store arg0@@30 arg1@@5 arg2)) (MapType0Type aVar0 aVar1@@0)))) :qid |funType:MapType0Store| :pattern ((MapType0Store arg0@@30 arg1@@5 arg2))))) (forall ((m T@U) (x0 T@U) (val T@U)) (! (let ((aVar1@@1 (MapType0TypeInv1 (type m)))) (=> (= (type val) aVar1@@1) (= (MapType0Select (MapType0Store m x0 val) x0) val))) :qid |mapAx0:MapType0Select| :weight 0))) (and (forall ((val@@0 T@U) (m@@0 T@U) (x0@@0 T@U) (y0 T@U)) (! (or (= x0@@0 y0) (= (MapType0Select (MapType0Store m@@0 x0@@0 val@@0) y0) (MapType0Select m@@0 y0))) :qid |mapAx1:MapType0Select:0| :weight 0)) (forall ((val@@1 T@U) (m@@1 T@U) (x0@@1 T@U) (y0@@0 T@U)) (! (or true (= (MapType0Select (MapType0Store m@@1 x0@@1 val@@1) y0@@0) (MapType0Select m@@1 y0@@0))) :qid |mapAx2:MapType0Select| :weight 0)))))
(assert (forall ((bx@@4 T@U) (t@@13 T@U)) (! (=> (and (and (= (type bx@@4) BoxType) (= (type t@@13) TyType)) ($IsBox bx@@4 (TSet t@@13))) (and (= ($Box ($Unbox (MapType0Type BoxType boolType) bx@@4)) bx@@4) ($Is ($Unbox (MapType0Type BoxType boolType) bx@@4) (TSet t@@13)))) :qid |DafnyPre.142:15| :skolemid |28| :pattern (($IsBox bx@@4 (TSet t@@13))))))
(assert (forall ((bx@@5 T@U) (t@@14 T@U)) (! (=> (and (and (= (type bx@@5) BoxType) (= (type t@@14) TyType)) ($IsBox bx@@5 (TISet t@@14))) (and (= ($Box ($Unbox (MapType0Type BoxType boolType) bx@@5)) bx@@5) ($Is ($Unbox (MapType0Type BoxType boolType) bx@@5) (TISet t@@14)))) :qid |DafnyPre.145:15| :skolemid |29| :pattern (($IsBox bx@@5 (TISet t@@14))))))
(assert (forall ((bx@@6 T@U) (t@@15 T@U)) (! (=> (and (and (= (type bx@@6) BoxType) (= (type t@@15) TyType)) ($IsBox bx@@6 (TMultiSet t@@15))) (and (= ($Box ($Unbox (MapType0Type BoxType intType) bx@@6)) bx@@6) ($Is ($Unbox (MapType0Type BoxType intType) bx@@6) (TMultiSet t@@15)))) :qid |DafnyPre.148:15| :skolemid |30| :pattern (($IsBox bx@@6 (TMultiSet t@@15))))))
(assert (and (forall ((arg0@@31 T@T)) (! (= (Ctor (SeqType arg0@@31)) 10) :qid |ctor:SeqType|)) (forall ((arg0@@32 T@T)) (! (= (SeqTypeInv0 (SeqType arg0@@32)) arg0@@32) :qid |typeInv:SeqTypeInv0| :pattern ((SeqType arg0@@32))))))
(assert (forall ((bx@@7 T@U) (t@@16 T@U)) (! (=> (and (and (= (type bx@@7) BoxType) (= (type t@@16) TyType)) ($IsBox bx@@7 (TSeq t@@16))) (and (= ($Box ($Unbox (SeqType BoxType) bx@@7)) bx@@7) ($Is ($Unbox (SeqType BoxType) bx@@7) (TSeq t@@16)))) :qid |DafnyPre.151:15| :skolemid |31| :pattern (($IsBox bx@@7 (TSeq t@@16))))))
(assert (and (and (forall ((arg0@@33 T@T) (arg1@@6 T@T)) (! (= (Ctor (MapType arg0@@33 arg1@@6)) 11) :qid |ctor:MapType|)) (forall ((arg0@@34 T@T) (arg1@@7 T@T)) (! (= (MapTypeInv0 (MapType arg0@@34 arg1@@7)) arg0@@34) :qid |typeInv:MapTypeInv0| :pattern ((MapType arg0@@34 arg1@@7))))) (forall ((arg0@@35 T@T) (arg1@@8 T@T)) (! (= (MapTypeInv1 (MapType arg0@@35 arg1@@8)) arg1@@8) :qid |typeInv:MapTypeInv1| :pattern ((MapType arg0@@35 arg1@@8))))))
(assert (forall ((bx@@8 T@U) (s T@U) (t@@17 T@U)) (! (=> (and (and (and (= (type bx@@8) BoxType) (= (type s) TyType)) (= (type t@@17) TyType)) ($IsBox bx@@8 (TMap s t@@17))) (and (= ($Box ($Unbox (MapType BoxType BoxType) bx@@8)) bx@@8) ($Is ($Unbox (MapType BoxType BoxType) bx@@8) (TMap s t@@17)))) :qid |DafnyPre.154:15| :skolemid |32| :pattern (($IsBox bx@@8 (TMap s t@@17))))))
(assert (and (and (forall ((arg0@@36 T@T) (arg1@@9 T@T)) (! (= (Ctor (IMapType arg0@@36 arg1@@9)) 12) :qid |ctor:IMapType|)) (forall ((arg0@@37 T@T) (arg1@@10 T@T)) (! (= (IMapTypeInv0 (IMapType arg0@@37 arg1@@10)) arg0@@37) :qid |typeInv:IMapTypeInv0| :pattern ((IMapType arg0@@37 arg1@@10))))) (forall ((arg0@@38 T@T) (arg1@@11 T@T)) (! (= (IMapTypeInv1 (IMapType arg0@@38 arg1@@11)) arg1@@11) :qid |typeInv:IMapTypeInv1| :pattern ((IMapType arg0@@38 arg1@@11))))))
(assert (forall ((bx@@9 T@U) (s@@0 T@U) (t@@18 T@U)) (! (=> (and (and (and (= (type bx@@9) BoxType) (= (type s@@0) TyType)) (= (type t@@18) TyType)) ($IsBox bx@@9 (TIMap s@@0 t@@18))) (and (= ($Box ($Unbox (IMapType BoxType BoxType) bx@@9)) bx@@9) ($Is ($Unbox (IMapType BoxType BoxType) bx@@9) (TIMap s@@0 t@@18)))) :qid |DafnyPre.157:15| :skolemid |33| :pattern (($IsBox bx@@9 (TIMap s@@0 t@@18))))))
(assert (forall ((v T@U) (t@@19 T@U)) (! (=> (= (type t@@19) TyType) (and (=> ($IsBox ($Box v) t@@19) ($Is v t@@19)) (=> ($Is v t@@19) ($IsBox ($Box v) t@@19)))) :qid |DafnyPre.161:18| :skolemid |34| :pattern (($IsBox ($Box v) t@@19)))))
(assert (and (and (and (and (and (and (forall ((arg0@@39 T@T)) (! (= (Ctor (MapType1Type arg0@@39)) 13) :qid |ctor:MapType1Type|)) (forall ((arg0@@40 T@T)) (! (= (MapType1TypeInv0 (MapType1Type arg0@@40)) arg0@@40) :qid |typeInv:MapType1TypeInv0| :pattern ((MapType1Type arg0@@40))))) (forall ((arg0@@41 T@U) (arg1@@12 T@U) (arg2@@0 T@U)) (! (let ((alpha@@1 (FieldTypeInv0 (type arg2@@0)))) (= (type (MapType1Select arg0@@41 arg1@@12 arg2@@0)) alpha@@1)) :qid |funType:MapType1Select| :pattern ((MapType1Select arg0@@41 arg1@@12 arg2@@0))))) (forall ((arg0@@42 T@U) (arg1@@13 T@U) (arg2@@1 T@U) (arg3 T@U)) (! (let ((aVar0@@0 (type arg1@@13))) (= (type (MapType1Store arg0@@42 arg1@@13 arg2@@1 arg3)) (MapType1Type aVar0@@0))) :qid |funType:MapType1Store| :pattern ((MapType1Store arg0@@42 arg1@@13 arg2@@1 arg3))))) (forall ((m@@2 T@U) (x0@@2 T@U) (x1 T@U) (val@@2 T@U)) (! (let ((alpha@@2 (FieldTypeInv0 (type x1)))) (=> (= (type val@@2) alpha@@2) (= (MapType1Select (MapType1Store m@@2 x0@@2 x1 val@@2) x0@@2 x1) val@@2))) :qid |mapAx0:MapType1Select| :weight 0))) (and (and (forall ((val@@3 T@U) (m@@3 T@U) (x0@@3 T@U) (x1@@0 T@U) (y0@@1 T@U) (y1 T@U)) (! (or (= x0@@3 y0@@1) (= (MapType1Select (MapType1Store m@@3 x0@@3 x1@@0 val@@3) y0@@1 y1) (MapType1Select m@@3 y0@@1 y1))) :qid |mapAx1:MapType1Select:0| :weight 0)) (forall ((val@@4 T@U) (m@@4 T@U) (x0@@4 T@U) (x1@@1 T@U) (y0@@2 T@U) (y1@@0 T@U)) (! (or (= x1@@1 y1@@0) (= (MapType1Select (MapType1Store m@@4 x0@@4 x1@@1 val@@4) y0@@2 y1@@0) (MapType1Select m@@4 y0@@2 y1@@0))) :qid |mapAx1:MapType1Select:1| :weight 0))) (forall ((val@@5 T@U) (m@@5 T@U) (x0@@5 T@U) (x1@@2 T@U) (y0@@3 T@U) (y1@@1 T@U)) (! (or true (= (MapType1Select (MapType1Store m@@5 x0@@5 x1@@2 val@@5) y0@@3 y1@@1) (MapType1Select m@@5 y0@@3 y1@@1))) :qid |mapAx2:MapType1Select| :weight 0)))) (= (Ctor refType) 14)))
(assert (forall ((v@@0 T@U) (t@@20 T@U) (h T@U)) (! (=> (and (= (type t@@20) TyType) (= (type h) (MapType1Type refType))) (and (=> ($IsAllocBox ($Box v@@0) t@@20 h) ($IsAlloc v@@0 t@@20 h)) (=> ($IsAlloc v@@0 t@@20 h) ($IsAllocBox ($Box v@@0) t@@20 h)))) :qid |DafnyPre.164:18| :skolemid |35| :pattern (($IsAllocBox ($Box v@@0) t@@20 h)))))
(assert (forall ((v@@1 T@U)) (! (=> (= (type v@@1) intType) ($Is v@@1 TInt)) :qid |DafnyPre.182:14| :skolemid |36| :pattern (($Is v@@1 TInt)))))
(assert (forall ((v@@2 T@U)) (! (=> (= (type v@@2) intType) (and (=> ($Is v@@2 TNat) (>= (U_2_int v@@2) 0)) (=> (>= (U_2_int v@@2) 0) ($Is v@@2 TNat)))) :qid |DafnyPre.183:14| :skolemid |37| :pattern (($Is v@@2 TNat)))))
(assert (forall ((v@@3 T@U)) (! (=> (= (type v@@3) realType) ($Is v@@3 TReal)) :qid |DafnyPre.184:14| :skolemid |38| :pattern (($Is v@@3 TReal)))))
(assert (forall ((v@@4 T@U)) (! (=> (= (type v@@4) boolType) ($Is v@@4 TBool)) :qid |DafnyPre.185:14| :skolemid |39| :pattern (($Is v@@4 TBool)))))
(assert (forall ((v@@5 T@U)) (! (=> (= (type v@@5) charType) ($Is v@@5 TChar)) :qid |DafnyPre.186:14| :skolemid |40| :pattern (($Is v@@5 TChar)))))
(assert (forall ((h@@0 T@U) (v@@6 T@U)) (! (=> (and (= (type h@@0) (MapType1Type refType)) (= (type v@@6) intType)) ($IsAlloc v@@6 TInt h@@0)) :qid |DafnyPre.188:14| :skolemid |41| :pattern (($IsAlloc v@@6 TInt h@@0)))))
(assert (forall ((h@@1 T@U) (v@@7 T@U)) (! (=> (and (= (type h@@1) (MapType1Type refType)) (= (type v@@7) intType)) ($IsAlloc v@@7 TNat h@@1)) :qid |DafnyPre.189:14| :skolemid |42| :pattern (($IsAlloc v@@7 TNat h@@1)))))
(assert (forall ((h@@2 T@U) (v@@8 T@U)) (! (=> (and (= (type h@@2) (MapType1Type refType)) (= (type v@@8) realType)) ($IsAlloc v@@8 TReal h@@2)) :qid |DafnyPre.190:14| :skolemid |43| :pattern (($IsAlloc v@@8 TReal h@@2)))))
(assert (forall ((h@@3 T@U) (v@@9 T@U)) (! (=> (and (= (type h@@3) (MapType1Type refType)) (= (type v@@9) boolType)) ($IsAlloc v@@9 TBool h@@3)) :qid |DafnyPre.191:14| :skolemid |44| :pattern (($IsAlloc v@@9 TBool h@@3)))))
(assert (forall ((h@@4 T@U) (v@@10 T@U)) (! (=> (and (= (type h@@4) (MapType1Type refType)) (= (type v@@10) charType)) ($IsAlloc v@@10 TChar h@@4)) :qid |DafnyPre.192:14| :skolemid |45| :pattern (($IsAlloc v@@10 TChar h@@4)))))
(assert (forall ((v@@11 T@U) (t0 T@U)) (! (=> (and (= (type v@@11) (MapType0Type BoxType boolType)) (= (type t0) TyType)) (and (=> ($Is v@@11 (TSet t0)) (forall ((bx@@10 T@U)) (! (=> (and (= (type bx@@10) BoxType) (U_2_bool (MapType0Select v@@11 bx@@10))) ($IsBox bx@@10 t0)) :qid |DafnyPre.196:11| :skolemid |46| :pattern ((MapType0Select v@@11 bx@@10))))) (=> (forall ((bx@@11 T@U)) (! (=> (and (= (type bx@@11) BoxType) (U_2_bool (MapType0Select v@@11 bx@@11))) ($IsBox bx@@11 t0)) :qid |DafnyPre.196:11| :skolemid |46| :pattern ((MapType0Select v@@11 bx@@11)))) ($Is v@@11 (TSet t0))))) :qid |DafnyPre.194:15| :skolemid |47| :pattern (($Is v@@11 (TSet t0))))))
(assert (forall ((v@@12 T@U) (t0@@0 T@U)) (! (=> (and (= (type v@@12) (MapType0Type BoxType boolType)) (= (type t0@@0) TyType)) (and (=> ($Is v@@12 (TISet t0@@0)) (forall ((bx@@12 T@U)) (! (=> (and (= (type bx@@12) BoxType) (U_2_bool (MapType0Select v@@12 bx@@12))) ($IsBox bx@@12 t0@@0)) :qid |DafnyPre.200:11| :skolemid |48| :pattern ((MapType0Select v@@12 bx@@12))))) (=> (forall ((bx@@13 T@U)) (! (=> (and (= (type bx@@13) BoxType) (U_2_bool (MapType0Select v@@12 bx@@13))) ($IsBox bx@@13 t0@@0)) :qid |DafnyPre.200:11| :skolemid |48| :pattern ((MapType0Select v@@12 bx@@13)))) ($Is v@@12 (TISet t0@@0))))) :qid |DafnyPre.198:15| :skolemid |49| :pattern (($Is v@@12 (TISet t0@@0))))))
(assert (forall ((v@@13 T@U) (t0@@1 T@U)) (! (=> (and (= (type v@@13) (MapType0Type BoxType intType)) (= (type t0@@1) TyType)) (and (=> ($Is v@@13 (TMultiSet t0@@1)) (forall ((bx@@14 T@U)) (! (=> (and (= (type bx@@14) BoxType) (< 0 (U_2_int (MapType0Select v@@13 bx@@14)))) ($IsBox bx@@14 t0@@1)) :qid |DafnyPre.204:11| :skolemid |50| :pattern ((MapType0Select v@@13 bx@@14))))) (=> (forall ((bx@@15 T@U)) (! (=> (and (= (type bx@@15) BoxType) (< 0 (U_2_int (MapType0Select v@@13 bx@@15)))) ($IsBox bx@@15 t0@@1)) :qid |DafnyPre.204:11| :skolemid |50| :pattern ((MapType0Select v@@13 bx@@15)))) ($Is v@@13 (TMultiSet t0@@1))))) :qid |DafnyPre.202:15| :skolemid |51| :pattern (($Is v@@13 (TMultiSet t0@@1))))))
(assert (forall ((v@@14 T@U) (t0@@2 T@U)) (! (=> (and (and (= (type v@@14) (MapType0Type BoxType intType)) (= (type t0@@2) TyType)) ($Is v@@14 (TMultiSet t0@@2))) ($IsGoodMultiSet v@@14)) :qid |DafnyPre.206:15| :skolemid |52| :pattern (($Is v@@14 (TMultiSet t0@@2))))))
(assert (forall ((arg0@@43 T@U) (arg1@@14 Int)) (! (let ((T@@2 (SeqTypeInv0 (type arg0@@43)))) (= (type (|Seq#Index| arg0@@43 arg1@@14)) T@@2)) :qid |funType:Seq#Index| :pattern ((|Seq#Index| arg0@@43 arg1@@14)))))
(assert (forall ((v@@15 T@U) (t0@@3 T@U)) (! (=> (and (= (type v@@15) (SeqType BoxType)) (= (type t0@@3) TyType)) (and (=> ($Is v@@15 (TSeq t0@@3)) (forall ((i Int)) (! (=> (and (<= 0 i) (< i (|Seq#Length| v@@15))) ($IsBox (|Seq#Index| v@@15 i) t0@@3)) :qid |DafnyPre.210:11| :skolemid |53| :pattern ((|Seq#Index| v@@15 i))))) (=> (forall ((i@@0 Int)) (! (=> (and (<= 0 i@@0) (< i@@0 (|Seq#Length| v@@15))) ($IsBox (|Seq#Index| v@@15 i@@0) t0@@3)) :qid |DafnyPre.210:11| :skolemid |53| :pattern ((|Seq#Index| v@@15 i@@0)))) ($Is v@@15 (TSeq t0@@3))))) :qid |DafnyPre.208:15| :skolemid |54| :pattern (($Is v@@15 (TSeq t0@@3))))))
(assert (forall ((v@@16 T@U) (t0@@4 T@U) (h@@5 T@U)) (! (=> (and (and (= (type v@@16) (MapType0Type BoxType boolType)) (= (type t0@@4) TyType)) (= (type h@@5) (MapType1Type refType))) (and (=> ($IsAlloc v@@16 (TSet t0@@4) h@@5) (forall ((bx@@16 T@U)) (! (=> (and (= (type bx@@16) BoxType) (U_2_bool (MapType0Select v@@16 bx@@16))) ($IsAllocBox bx@@16 t0@@4 h@@5)) :qid |DafnyPre.215:11| :skolemid |55| :pattern ((MapType0Select v@@16 bx@@16))))) (=> (forall ((bx@@17 T@U)) (! (=> (and (= (type bx@@17) BoxType) (U_2_bool (MapType0Select v@@16 bx@@17))) ($IsAllocBox bx@@17 t0@@4 h@@5)) :qid |DafnyPre.215:11| :skolemid |55| :pattern ((MapType0Select v@@16 bx@@17)))) ($IsAlloc v@@16 (TSet t0@@4) h@@5)))) :qid |DafnyPre.213:15| :skolemid |56| :pattern (($IsAlloc v@@16 (TSet t0@@4) h@@5)))))
(assert (forall ((v@@17 T@U) (t0@@5 T@U) (h@@6 T@U)) (! (=> (and (and (= (type v@@17) (MapType0Type BoxType boolType)) (= (type t0@@5) TyType)) (= (type h@@6) (MapType1Type refType))) (and (=> ($IsAlloc v@@17 (TISet t0@@5) h@@6) (forall ((bx@@18 T@U)) (! (=> (and (= (type bx@@18) BoxType) (U_2_bool (MapType0Select v@@17 bx@@18))) ($IsAllocBox bx@@18 t0@@5 h@@6)) :qid |DafnyPre.219:11| :skolemid |57| :pattern ((MapType0Select v@@17 bx@@18))))) (=> (forall ((bx@@19 T@U)) (! (=> (and (= (type bx@@19) BoxType) (U_2_bool (MapType0Select v@@17 bx@@19))) ($IsAllocBox bx@@19 t0@@5 h@@6)) :qid |DafnyPre.219:11| :skolemid |57| :pattern ((MapType0Select v@@17 bx@@19)))) ($IsAlloc v@@17 (TISet t0@@5) h@@6)))) :qid |DafnyPre.217:15| :skolemid |58| :pattern (($IsAlloc v@@17 (TISet t0@@5) h@@6)))))
(assert (forall ((v@@18 T@U) (t0@@6 T@U) (h@@7 T@U)) (! (=> (and (and (= (type v@@18) (MapType0Type BoxType intType)) (= (type t0@@6) TyType)) (= (type h@@7) (MapType1Type refType))) (and (=> ($IsAlloc v@@18 (TMultiSet t0@@6) h@@7) (forall ((bx@@20 T@U)) (! (=> (and (= (type bx@@20) BoxType) (< 0 (U_2_int (MapType0Select v@@18 bx@@20)))) ($IsAllocBox bx@@20 t0@@6 h@@7)) :qid |DafnyPre.223:11| :skolemid |59| :pattern ((MapType0Select v@@18 bx@@20))))) (=> (forall ((bx@@21 T@U)) (! (=> (and (= (type bx@@21) BoxType) (< 0 (U_2_int (MapType0Select v@@18 bx@@21)))) ($IsAllocBox bx@@21 t0@@6 h@@7)) :qid |DafnyPre.223:11| :skolemid |59| :pattern ((MapType0Select v@@18 bx@@21)))) ($IsAlloc v@@18 (TMultiSet t0@@6) h@@7)))) :qid |DafnyPre.221:15| :skolemid |60| :pattern (($IsAlloc v@@18 (TMultiSet t0@@6) h@@7)))))
(assert (forall ((v@@19 T@U) (t0@@7 T@U) (h@@8 T@U)) (! (=> (and (and (= (type v@@19) (SeqType BoxType)) (= (type t0@@7) TyType)) (= (type h@@8) (MapType1Type refType))) (and (=> ($IsAlloc v@@19 (TSeq t0@@7) h@@8) (forall ((i@@1 Int)) (! (=> (and (<= 0 i@@1) (< i@@1 (|Seq#Length| v@@19))) ($IsAllocBox (|Seq#Index| v@@19 i@@1) t0@@7 h@@8)) :qid |DafnyPre.227:11| :skolemid |61| :pattern ((|Seq#Index| v@@19 i@@1))))) (=> (forall ((i@@2 Int)) (! (=> (and (<= 0 i@@2) (< i@@2 (|Seq#Length| v@@19))) ($IsAllocBox (|Seq#Index| v@@19 i@@2) t0@@7 h@@8)) :qid |DafnyPre.227:11| :skolemid |61| :pattern ((|Seq#Index| v@@19 i@@2)))) ($IsAlloc v@@19 (TSeq t0@@7) h@@8)))) :qid |DafnyPre.225:15| :skolemid |62| :pattern (($IsAlloc v@@19 (TSeq t0@@7) h@@8)))))
(assert (and (forall ((arg0@@44 T@U)) (! (let ((V (MapTypeInv1 (type arg0@@44)))) (let ((U (MapTypeInv0 (type arg0@@44)))) (= (type (|Map#Elements| arg0@@44)) (MapType0Type U V)))) :qid |funType:Map#Elements| :pattern ((|Map#Elements| arg0@@44)))) (forall ((arg0@@45 T@U)) (! (let ((U@@0 (MapTypeInv0 (type arg0@@45)))) (= (type (|Map#Domain| arg0@@45)) (MapType0Type U@@0 boolType))) :qid |funType:Map#Domain| :pattern ((|Map#Domain| arg0@@45))))))
(assert (forall ((v@@20 T@U) (t0@@8 T@U) (t1 T@U)) (! (=> (and (and (= (type v@@20) (MapType BoxType BoxType)) (= (type t0@@8) TyType)) (= (type t1) TyType)) (and (=> ($Is v@@20 (TMap t0@@8 t1)) (forall ((bx@@22 T@U)) (! (=> (and (= (type bx@@22) BoxType) (U_2_bool (MapType0Select (|Map#Domain| v@@20) bx@@22))) (and ($IsBox (MapType0Select (|Map#Elements| v@@20) bx@@22) t1) ($IsBox bx@@22 t0@@8))) :qid |DafnyPre.234:19| :skolemid |63| :pattern ((MapType0Select (|Map#Elements| v@@20) bx@@22)) :pattern ((MapType0Select (|Map#Domain| v@@20) bx@@22))))) (=> (forall ((bx@@23 T@U)) (! (=> (and (= (type bx@@23) BoxType) (U_2_bool (MapType0Select (|Map#Domain| v@@20) bx@@23))) (and ($IsBox (MapType0Select (|Map#Elements| v@@20) bx@@23) t1) ($IsBox bx@@23 t0@@8))) :qid |DafnyPre.234:19| :skolemid |63| :pattern ((MapType0Select (|Map#Elements| v@@20) bx@@23)) :pattern ((MapType0Select (|Map#Domain| v@@20) bx@@23)))) ($Is v@@20 (TMap t0@@8 t1))))) :qid |DafnyPre.231:15| :skolemid |64| :pattern (($Is v@@20 (TMap t0@@8 t1))))))
(assert (forall ((v@@21 T@U) (t0@@9 T@U) (t1@@0 T@U) (h@@9 T@U)) (! (=> (and (and (and (= (type v@@21) (MapType BoxType BoxType)) (= (type t0@@9) TyType)) (= (type t1@@0) TyType)) (= (type h@@9) (MapType1Type refType))) (and (=> ($IsAlloc v@@21 (TMap t0@@9 t1@@0) h@@9) (forall ((bx@@24 T@U)) (! (=> (and (= (type bx@@24) BoxType) (U_2_bool (MapType0Select (|Map#Domain| v@@21) bx@@24))) (and ($IsAllocBox (MapType0Select (|Map#Elements| v@@21) bx@@24) t1@@0 h@@9) ($IsAllocBox bx@@24 t0@@9 h@@9))) :qid |DafnyPre.242:19| :skolemid |65| :pattern ((MapType0Select (|Map#Elements| v@@21) bx@@24)) :pattern ((MapType0Select (|Map#Domain| v@@21) bx@@24))))) (=> (forall ((bx@@25 T@U)) (! (=> (and (= (type bx@@25) BoxType) (U_2_bool (MapType0Select (|Map#Domain| v@@21) bx@@25))) (and ($IsAllocBox (MapType0Select (|Map#Elements| v@@21) bx@@25) t1@@0 h@@9) ($IsAllocBox bx@@25 t0@@9 h@@9))) :qid |DafnyPre.242:19| :skolemid |65| :pattern ((MapType0Select (|Map#Elements| v@@21) bx@@25)) :pattern ((MapType0Select (|Map#Domain| v@@21) bx@@25)))) ($IsAlloc v@@21 (TMap t0@@9 t1@@0) h@@9)))) :qid |DafnyPre.239:15| :skolemid |66| :pattern (($IsAlloc v@@21 (TMap t0@@9 t1@@0) h@@9)))))
(assert (and (forall ((arg0@@46 T@U)) (! (let ((V@@0 (IMapTypeInv1 (type arg0@@46)))) (let ((U@@1 (IMapTypeInv0 (type arg0@@46)))) (= (type (|IMap#Elements| arg0@@46)) (MapType0Type U@@1 V@@0)))) :qid |funType:IMap#Elements| :pattern ((|IMap#Elements| arg0@@46)))) (forall ((arg0@@47 T@U)) (! (let ((U@@2 (IMapTypeInv0 (type arg0@@47)))) (= (type (|IMap#Domain| arg0@@47)) (MapType0Type U@@2 boolType))) :qid |funType:IMap#Domain| :pattern ((|IMap#Domain| arg0@@47))))))
(assert (forall ((v@@22 T@U) (t0@@10 T@U) (t1@@1 T@U)) (! (=> (and (and (= (type v@@22) (IMapType BoxType BoxType)) (= (type t0@@10) TyType)) (= (type t1@@1) TyType)) (and (=> ($Is v@@22 (TIMap t0@@10 t1@@1)) (forall ((bx@@26 T@U)) (! (=> (and (= (type bx@@26) BoxType) (U_2_bool (MapType0Select (|IMap#Domain| v@@22) bx@@26))) (and ($IsBox (MapType0Select (|IMap#Elements| v@@22) bx@@26) t1@@1) ($IsBox bx@@26 t0@@10))) :qid |DafnyPre.251:19| :skolemid |67| :pattern ((MapType0Select (|IMap#Elements| v@@22) bx@@26)) :pattern ((MapType0Select (|IMap#Domain| v@@22) bx@@26))))) (=> (forall ((bx@@27 T@U)) (! (=> (and (= (type bx@@27) BoxType) (U_2_bool (MapType0Select (|IMap#Domain| v@@22) bx@@27))) (and ($IsBox (MapType0Select (|IMap#Elements| v@@22) bx@@27) t1@@1) ($IsBox bx@@27 t0@@10))) :qid |DafnyPre.251:19| :skolemid |67| :pattern ((MapType0Select (|IMap#Elements| v@@22) bx@@27)) :pattern ((MapType0Select (|IMap#Domain| v@@22) bx@@27)))) ($Is v@@22 (TIMap t0@@10 t1@@1))))) :qid |DafnyPre.248:15| :skolemid |68| :pattern (($Is v@@22 (TIMap t0@@10 t1@@1))))))
(assert (forall ((v@@23 T@U) (t0@@11 T@U) (t1@@2 T@U) (h@@10 T@U)) (! (=> (and (and (and (= (type v@@23) (IMapType BoxType BoxType)) (= (type t0@@11) TyType)) (= (type t1@@2) TyType)) (= (type h@@10) (MapType1Type refType))) (and (=> ($IsAlloc v@@23 (TIMap t0@@11 t1@@2) h@@10) (forall ((bx@@28 T@U)) (! (=> (and (= (type bx@@28) BoxType) (U_2_bool (MapType0Select (|IMap#Domain| v@@23) bx@@28))) (and ($IsAllocBox (MapType0Select (|IMap#Elements| v@@23) bx@@28) t1@@2 h@@10) ($IsAllocBox bx@@28 t0@@11 h@@10))) :qid |DafnyPre.259:19| :skolemid |69| :pattern ((MapType0Select (|IMap#Elements| v@@23) bx@@28)) :pattern ((MapType0Select (|IMap#Domain| v@@23) bx@@28))))) (=> (forall ((bx@@29 T@U)) (! (=> (and (= (type bx@@29) BoxType) (U_2_bool (MapType0Select (|IMap#Domain| v@@23) bx@@29))) (and ($IsAllocBox (MapType0Select (|IMap#Elements| v@@23) bx@@29) t1@@2 h@@10) ($IsAllocBox bx@@29 t0@@11 h@@10))) :qid |DafnyPre.259:19| :skolemid |69| :pattern ((MapType0Select (|IMap#Elements| v@@23) bx@@29)) :pattern ((MapType0Select (|IMap#Domain| v@@23) bx@@29)))) ($IsAlloc v@@23 (TIMap t0@@11 t1@@2) h@@10)))) :qid |DafnyPre.256:15| :skolemid |70| :pattern (($IsAlloc v@@23 (TIMap t0@@11 t1@@2) h@@10)))))
(assert (and (and (forall ((arg0@@48 T@U) (arg1@@15 T@U)) (! (= (type (TypeTuple arg0@@48 arg1@@15)) ClassNameType) :qid |funType:TypeTuple| :pattern ((TypeTuple arg0@@48 arg1@@15)))) (forall ((arg0@@49 T@U)) (! (= (type (TypeTupleCar arg0@@49)) ClassNameType) :qid |funType:TypeTupleCar| :pattern ((TypeTupleCar arg0@@49))))) (forall ((arg0@@50 T@U)) (! (= (type (TypeTupleCdr arg0@@50)) ClassNameType) :qid |funType:TypeTupleCdr| :pattern ((TypeTupleCdr arg0@@50))))))
(assert (forall ((a T@U) (b T@U)) (! (=> (and (= (type a) ClassNameType) (= (type b) ClassNameType)) (and (= (TypeTupleCar (TypeTuple a b)) a) (= (TypeTupleCdr (TypeTuple a b)) b))) :qid |DafnyPre.284:15| :skolemid |71| :pattern ((TypeTuple a b)))))
(assert (forall ((arg0@@51 T@U)) (! (= (type (SetRef_to_SetBox arg0@@51)) (MapType0Type BoxType boolType)) :qid |funType:SetRef_to_SetBox| :pattern ((SetRef_to_SetBox arg0@@51)))))
(assert (forall ((s@@1 T@U) (bx@@30 T@U)) (! (=> (and (= (type s@@1) (MapType0Type refType boolType)) (= (type bx@@30) BoxType)) (and (=> (U_2_bool (MapType0Select (SetRef_to_SetBox s@@1) bx@@30)) (U_2_bool (MapType0Select s@@1 ($Unbox refType bx@@30)))) (=> (U_2_bool (MapType0Select s@@1 ($Unbox refType bx@@30))) (U_2_bool (MapType0Select (SetRef_to_SetBox s@@1) bx@@30))))) :qid |DafnyPre.293:15| :skolemid |72| :pattern ((MapType0Select (SetRef_to_SetBox s@@1) bx@@30)))))
(assert (= (type Tclass._System.object) TyType))
(assert (forall ((s@@2 T@U)) (! (=> (= (type s@@2) (MapType0Type refType boolType)) ($Is (SetRef_to_SetBox s@@2) (TSet Tclass._System.object))) :qid |DafnyPre.295:15| :skolemid |73| :pattern ((SetRef_to_SetBox s@@2)))))
(assert (= (Ctor DatatypeTypeType) 15))
(assert (forall ((d T@U)) (! (=> (= (type d) DatatypeTypeType) (= (BoxRank ($Box d)) (DtRank d))) :qid |DafnyPre.310:15| :skolemid |74| :pattern ((BoxRank ($Box d))))))
(assert (and (= (Ctor LayerTypeType) 16) (forall ((arg0@@52 T@U) (arg1@@16 T@U)) (! (let ((A (MapType0TypeInv1 (type arg0@@52)))) (= (type (AtLayer arg0@@52 arg1@@16)) A)) :qid |funType:AtLayer| :pattern ((AtLayer arg0@@52 arg1@@16))))))
(assert (forall ((f T@U) (ly T@U)) (! (let ((A@@0 (MapType0TypeInv1 (type f)))) (=> (and (= (type f) (MapType0Type LayerTypeType A@@0)) (= (type ly) LayerTypeType)) (= (AtLayer f ly) (MapType0Select f ly)))) :qid |DafnyPre.329:18| :skolemid |75| :pattern ((AtLayer f ly)))))
(assert (forall ((arg0@@53 T@U)) (! (= (type ($LS arg0@@53)) LayerTypeType) :qid |funType:$LS| :pattern (($LS arg0@@53)))))
(assert (forall ((f@@0 T@U) (ly@@0 T@U)) (! (let ((A@@1 (MapType0TypeInv1 (type f@@0)))) (=> (and (= (type f@@0) (MapType0Type LayerTypeType A@@1)) (= (type ly@@0) LayerTypeType)) (= (AtLayer f@@0 ($LS ly@@0)) (AtLayer f@@0 ly@@0)))) :qid |DafnyPre.330:18| :skolemid |76| :pattern ((AtLayer f@@0 ($LS ly@@0))))))
(assert (forall ((arg0@@54 Int)) (! (= (type (IndexField arg0@@54)) (FieldType BoxType)) :qid |funType:IndexField| :pattern ((IndexField arg0@@54)))))
(assert (forall ((i@@3 Int)) (! (= (FDim (IndexField i@@3)) 1) :qid |DafnyPre.341:15| :skolemid |77| :pattern ((IndexField i@@3)))))
(assert (forall ((i@@4 Int)) (! (= (IndexField_Inverse (IndexField i@@4)) i@@4) :qid |DafnyPre.343:15| :skolemid |78| :pattern ((IndexField i@@4)))))
(assert (forall ((arg0@@55 T@U) (arg1@@17 Int)) (! (= (type (MultiIndexField arg0@@55 arg1@@17)) (FieldType BoxType)) :qid |funType:MultiIndexField| :pattern ((MultiIndexField arg0@@55 arg1@@17)))))
(assert (forall ((f@@1 T@U) (i@@5 Int)) (! (=> (= (type f@@1) (FieldType BoxType)) (= (FDim (MultiIndexField f@@1 i@@5)) (+ (FDim f@@1) 1))) :qid |DafnyPre.346:15| :skolemid |79| :pattern ((MultiIndexField f@@1 i@@5)))))
(assert (forall ((arg0@@56 T@U)) (! (let ((T@@3 (FieldTypeInv0 (type arg0@@56)))) (= (type (MultiIndexField_Inverse0 arg0@@56)) (FieldType T@@3))) :qid |funType:MultiIndexField_Inverse0| :pattern ((MultiIndexField_Inverse0 arg0@@56)))))
(assert (forall ((f@@2 T@U) (i@@6 Int)) (! (=> (= (type f@@2) (FieldType BoxType)) (and (= (MultiIndexField_Inverse0 (MultiIndexField f@@2 i@@6)) f@@2) (= (MultiIndexField_Inverse1 (MultiIndexField f@@2 i@@6)) i@@6))) :qid |DafnyPre.349:15| :skolemid |80| :pattern ((MultiIndexField f@@2 i@@6)))))
(assert (and (and (and (= (Ctor NameFamilyType) 17) (forall ((alpha@@3 T@T) (arg0@@57 T@U) (arg1@@18 T@U)) (! (= (type (FieldOfDecl alpha@@3 arg0@@57 arg1@@18)) (FieldType alpha@@3)) :qid |funType:FieldOfDecl| :pattern ((FieldOfDecl alpha@@3 arg0@@57 arg1@@18))))) (forall ((arg0@@58 T@U)) (! (= (type (DeclType arg0@@58)) ClassNameType) :qid |funType:DeclType| :pattern ((DeclType arg0@@58))))) (forall ((arg0@@59 T@U)) (! (= (type (DeclName arg0@@59)) NameFamilyType) :qid |funType:DeclName| :pattern ((DeclName arg0@@59))))))
(assert (forall ((cl T@U) (nm T@U) (T@@4 T@T)) (! (=> (and (= (type cl) ClassNameType) (= (type nm) NameFamilyType)) (and (= (DeclType (FieldOfDecl T@@4 cl nm)) cl) (= (DeclName (FieldOfDecl T@@4 cl nm)) nm))) :qid |DafnyPre.358:18| :skolemid |81| :pattern ((FieldOfDecl T@@4 cl nm)))))
(assert (forall ((h@@11 T@U) (k T@U) (v@@24 T@U) (t@@21 T@U)) (! (=> (and (and (and (and (= (type h@@11) (MapType1Type refType)) (= (type k) (MapType1Type refType))) (= (type t@@21) TyType)) ($HeapSucc h@@11 k)) ($IsAlloc v@@24 t@@21 h@@11)) ($IsAlloc v@@24 t@@21 k)) :qid |DafnyPre.371:17| :skolemid |82| :pattern (($HeapSucc h@@11 k) ($IsAlloc v@@24 t@@21 h@@11)))))
(assert (forall ((h@@12 T@U) (k@@0 T@U) (bx@@31 T@U) (t@@22 T@U)) (! (=> (and (and (and (and (and (= (type h@@12) (MapType1Type refType)) (= (type k@@0) (MapType1Type refType))) (= (type bx@@31) BoxType)) (= (type t@@22) TyType)) ($HeapSucc h@@12 k@@0)) ($IsAllocBox bx@@31 t@@22 h@@12)) ($IsAllocBox bx@@31 t@@22 k@@0)) :qid |DafnyPre.374:14| :skolemid |83| :pattern (($HeapSucc h@@12 k@@0) ($IsAllocBox bx@@31 t@@22 h@@12)))))
(assert (= (FDim alloc) 0))
(assert (not ($IsGhostField alloc)))
(assert (forall ((o T@U)) (! (=> (= (type o) refType) (<= 0 (_System.array.Length o))) :qid |DafnyPre.388:15| :skolemid |84| :no-pattern (type o) :no-pattern (U_2_int o) :no-pattern (U_2_bool o))))
(assert (forall ((x@@12 Real)) (! (= (q@Int x@@12) (to_int x@@12)) :qid |DafnyPre.394:14| :skolemid |85| :pattern ((q@Int x@@12)))))
(assert (forall ((x@@13 Int)) (! (= (q@Real x@@13) (to_real x@@13)) :qid |DafnyPre.395:15| :skolemid |86| :pattern ((q@Real x@@13)))))
(assert (forall ((i@@7 Int)) (! (= (q@Int (q@Real i@@7)) i@@7) :qid |DafnyPre.396:15| :skolemid |87| :pattern ((q@Int (q@Real i@@7))))))
(assert (forall ((h@@13 T@U) (r T@U) (f@@3 T@U) (x@@14 T@U)) (! (let ((alpha@@4 (type x@@14))) (=> (and (and (and (= (type h@@13) (MapType1Type refType)) (= (type r) refType)) (= (type f@@3) (FieldType alpha@@4))) ($IsGoodHeap (MapType1Store h@@13 r f@@3 x@@14))) ($HeapSucc h@@13 (MapType1Store h@@13 r f@@3 x@@14)))) :qid |DafnyPre.413:22| :skolemid |88| :pattern ((MapType1Store h@@13 r f@@3 x@@14)))))
(assert (forall ((a@@0 T@U) (b@@0 T@U) (c T@U)) (! (=> (and (and (and (= (type a@@0) (MapType1Type refType)) (= (type b@@0) (MapType1Type refType))) (= (type c) (MapType1Type refType))) (and ($HeapSucc a@@0 b@@0) ($HeapSucc b@@0 c))) ($HeapSucc a@@0 c)) :qid |DafnyPre.416:15| :skolemid |89| :pattern (($HeapSucc a@@0 b@@0) ($HeapSucc b@@0 c)))))
(assert (forall ((h@@14 T@U) (k@@1 T@U)) (! (=> (and (and (= (type h@@14) (MapType1Type refType)) (= (type k@@1) (MapType1Type refType))) ($HeapSucc h@@14 k@@1)) (forall ((o@@0 T@U)) (! (=> (and (= (type o@@0) refType) (U_2_bool (MapType1Select h@@14 o@@0 alloc))) (U_2_bool (MapType1Select k@@1 o@@0 alloc))) :qid |DafnyPre.419:30| :skolemid |90| :pattern ((MapType1Select k@@1 o@@0 alloc))))) :qid |DafnyPre.418:15| :skolemid |91| :pattern (($HeapSucc h@@14 k@@1)))))
(assert (forall ((h@@15 T@U) (k@@2 T@U)) (! (=> (and (and (= (type h@@15) (MapType1Type refType)) (= (type k@@2) (MapType1Type refType))) ($HeapSuccGhost h@@15 k@@2)) (and ($HeapSucc h@@15 k@@2) (forall ((o@@1 T@U) (f@@4 T@U)) (! (let ((alpha@@5 (FieldTypeInv0 (type f@@4)))) (=> (and (and (= (type o@@1) refType) (= (type f@@4) (FieldType alpha@@5))) (not ($IsGhostField f@@4))) (= (MapType1Select h@@15 o@@1 f@@4) (MapType1Select k@@2 o@@1 f@@4)))) :qid |DafnyPre.425:20| :skolemid |92| :pattern ((MapType1Select k@@2 o@@1 f@@4)))))) :qid |DafnyPre.422:15| :skolemid |93| :pattern (($HeapSuccGhost h@@15 k@@2)))))
(assert (forall ((s@@3 T@U)) (! (let ((T@@5 (MapType0TypeInv0 (type s@@3)))) (=> (= (type s@@3) (MapType0Type T@@5 boolType)) (<= 0 (|Set#Card| s@@3)))) :qid |DafnyPre.483:18| :skolemid |98| :pattern ((|Set#Card| s@@3)))))
(assert (forall ((T@@6 T@T)) (! (= (type (|Set#Empty| T@@6)) (MapType0Type T@@6 boolType)) :qid |funType:Set#Empty| :pattern ((|Set#Empty| T@@6)))))
(assert (forall ((o@@2 T@U)) (! (let ((T@@7 (type o@@2))) (not (U_2_bool (MapType0Select (|Set#Empty| T@@7) o@@2)))) :qid |DafnyPre.486:18| :skolemid |99| :pattern ((let ((T@@7 (type o@@2))) (MapType0Select (|Set#Empty| T@@7) o@@2))))))
(assert (forall ((s@@4 T@U)) (! (let ((T@@8 (MapType0TypeInv0 (type s@@4)))) (=> (= (type s@@4) (MapType0Type T@@8 boolType)) (and (and (=> (= (|Set#Card| s@@4) 0) (= s@@4 (|Set#Empty| T@@8))) (=> (= s@@4 (|Set#Empty| T@@8)) (= (|Set#Card| s@@4) 0))) (=> (not (= (|Set#Card| s@@4) 0)) (exists ((x@@15 T@U)) (! (and (= (type x@@15) T@@8) (U_2_bool (MapType0Select s@@4 x@@15))) :qid |DafnyPre.489:33| :skolemid |100| :no-pattern (type x@@15) :no-pattern (U_2_int x@@15) :no-pattern (U_2_bool x@@15))))))) :qid |DafnyPre.487:18| :skolemid |101| :pattern ((|Set#Card| s@@4)))))
(assert (forall ((arg0@@60 T@U)) (! (let ((T@@9 (type arg0@@60))) (= (type (|Set#Singleton| arg0@@60)) (MapType0Type T@@9 boolType))) :qid |funType:Set#Singleton| :pattern ((|Set#Singleton| arg0@@60)))))
(assert (forall ((r@@0 T@U)) (! (U_2_bool (MapType0Select (|Set#Singleton| r@@0) r@@0)) :qid |DafnyPre.495:18| :skolemid |102| :pattern ((|Set#Singleton| r@@0)))))
(assert (forall ((r@@1 T@U) (o@@3 T@U)) (! (let ((T@@10 (type r@@1))) (=> (= (type o@@3) T@@10) (and (=> (U_2_bool (MapType0Select (|Set#Singleton| r@@1) o@@3)) (= r@@1 o@@3)) (=> (= r@@1 o@@3) (U_2_bool (MapType0Select (|Set#Singleton| r@@1) o@@3)))))) :qid |DafnyPre.496:18| :skolemid |103| :pattern ((MapType0Select (|Set#Singleton| r@@1) o@@3)))))
(assert (forall ((r@@2 T@U)) (! (= (|Set#Card| (|Set#Singleton| r@@2)) 1) :qid |DafnyPre.497:18| :skolemid |104| :pattern ((|Set#Card| (|Set#Singleton| r@@2))))))
(assert (forall ((arg0@@61 T@U) (arg1@@19 T@U)) (! (let ((T@@11 (type arg1@@19))) (= (type (|Set#UnionOne| arg0@@61 arg1@@19)) (MapType0Type T@@11 boolType))) :qid |funType:Set#UnionOne| :pattern ((|Set#UnionOne| arg0@@61 arg1@@19)))))
(assert (forall ((a@@1 T@U) (x@@16 T@U) (o@@4 T@U)) (! (let ((T@@12 (type x@@16))) (=> (and (= (type a@@1) (MapType0Type T@@12 boolType)) (= (type o@@4) T@@12)) (and (=> (U_2_bool (MapType0Select (|Set#UnionOne| a@@1 x@@16) o@@4)) (or (= o@@4 x@@16) (U_2_bool (MapType0Select a@@1 o@@4)))) (=> (or (= o@@4 x@@16) (U_2_bool (MapType0Select a@@1 o@@4))) (U_2_bool (MapType0Select (|Set#UnionOne| a@@1 x@@16) o@@4)))))) :qid |DafnyPre.500:18| :skolemid |105| :pattern ((MapType0Select (|Set#UnionOne| a@@1 x@@16) o@@4)))))
(assert (forall ((a@@2 T@U) (x@@17 T@U)) (! (let ((T@@13 (type x@@17))) (=> (= (type a@@2) (MapType0Type T@@13 boolType)) (U_2_bool (MapType0Select (|Set#UnionOne| a@@2 x@@17) x@@17)))) :qid |DafnyPre.502:18| :skolemid |106| :pattern ((|Set#UnionOne| a@@2 x@@17)))))
(assert (forall ((a@@3 T@U) (x@@18 T@U) (y@@1 T@U)) (! (let ((T@@14 (type x@@18))) (=> (and (and (= (type a@@3) (MapType0Type T@@14 boolType)) (= (type y@@1) T@@14)) (U_2_bool (MapType0Select a@@3 y@@1))) (U_2_bool (MapType0Select (|Set#UnionOne| a@@3 x@@18) y@@1)))) :qid |DafnyPre.504:18| :skolemid |107| :pattern ((|Set#UnionOne| a@@3 x@@18) (MapType0Select a@@3 y@@1)))))
(assert (forall ((a@@4 T@U) (x@@19 T@U)) (! (let ((T@@15 (type x@@19))) (=> (and (= (type a@@4) (MapType0Type T@@15 boolType)) (U_2_bool (MapType0Select a@@4 x@@19))) (= (|Set#Card| (|Set#UnionOne| a@@4 x@@19)) (|Set#Card| a@@4)))) :qid |DafnyPre.506:18| :skolemid |108| :pattern ((|Set#Card| (|Set#UnionOne| a@@4 x@@19))))))
(assert (forall ((a@@5 T@U) (x@@20 T@U)) (! (let ((T@@16 (type x@@20))) (=> (and (= (type a@@5) (MapType0Type T@@16 boolType)) (not (U_2_bool (MapType0Select a@@5 x@@20)))) (= (|Set#Card| (|Set#UnionOne| a@@5 x@@20)) (+ (|Set#Card| a@@5) 1)))) :qid |DafnyPre.508:18| :skolemid |109| :pattern ((|Set#Card| (|Set#UnionOne| a@@5 x@@20))))))
(assert (forall ((arg0@@62 T@U) (arg1@@20 T@U)) (! (let ((T@@17 (MapType0TypeInv0 (type arg0@@62)))) (= (type (|Set#Union| arg0@@62 arg1@@20)) (MapType0Type T@@17 boolType))) :qid |funType:Set#Union| :pattern ((|Set#Union| arg0@@62 arg1@@20)))))
(assert (forall ((a@@6 T@U) (b@@1 T@U) (o@@5 T@U)) (! (let ((T@@18 (type o@@5))) (=> (and (= (type a@@6) (MapType0Type T@@18 boolType)) (= (type b@@1) (MapType0Type T@@18 boolType))) (and (=> (U_2_bool (MapType0Select (|Set#Union| a@@6 b@@1) o@@5)) (or (U_2_bool (MapType0Select a@@6 o@@5)) (U_2_bool (MapType0Select b@@1 o@@5)))) (=> (or (U_2_bool (MapType0Select a@@6 o@@5)) (U_2_bool (MapType0Select b@@1 o@@5))) (U_2_bool (MapType0Select (|Set#Union| a@@6 b@@1) o@@5)))))) :qid |DafnyPre.512:18| :skolemid |110| :pattern ((MapType0Select (|Set#Union| a@@6 b@@1) o@@5)))))
(assert (forall ((a@@7 T@U) (b@@2 T@U) (y@@2 T@U)) (! (let ((T@@19 (type y@@2))) (=> (and (and (= (type a@@7) (MapType0Type T@@19 boolType)) (= (type b@@2) (MapType0Type T@@19 boolType))) (U_2_bool (MapType0Select a@@7 y@@2))) (U_2_bool (MapType0Select (|Set#Union| a@@7 b@@2) y@@2)))) :qid |DafnyPre.514:18| :skolemid |111| :pattern ((|Set#Union| a@@7 b@@2) (MapType0Select a@@7 y@@2)))))
(assert (forall ((a@@8 T@U) (b@@3 T@U) (y@@3 T@U)) (! (let ((T@@20 (type y@@3))) (=> (and (and (= (type a@@8) (MapType0Type T@@20 boolType)) (= (type b@@3) (MapType0Type T@@20 boolType))) (U_2_bool (MapType0Select b@@3 y@@3))) (U_2_bool (MapType0Select (|Set#Union| a@@8 b@@3) y@@3)))) :qid |DafnyPre.516:18| :skolemid |112| :pattern ((|Set#Union| a@@8 b@@3) (MapType0Select b@@3 y@@3)))))
(assert (forall ((arg0@@63 T@U) (arg1@@21 T@U)) (! (let ((T@@21 (MapType0TypeInv0 (type arg0@@63)))) (= (type (|Set#Difference| arg0@@63 arg1@@21)) (MapType0Type T@@21 boolType))) :qid |funType:Set#Difference| :pattern ((|Set#Difference| arg0@@63 arg1@@21)))))
(assert (forall ((a@@9 T@U) (b@@4 T@U)) (! (let ((T@@22 (MapType0TypeInv0 (type a@@9)))) (=> (and (and (= (type a@@9) (MapType0Type T@@22 boolType)) (= (type b@@4) (MapType0Type T@@22 boolType))) (|Set#Disjoint| a@@9 b@@4)) (and (= (|Set#Difference| (|Set#Union| a@@9 b@@4) a@@9) b@@4) (= (|Set#Difference| (|Set#Union| a@@9 b@@4) b@@4) a@@9)))) :qid |DafnyPre.518:18| :skolemid |113| :pattern ((|Set#Union| a@@9 b@@4)))))
(assert (forall ((arg0@@64 T@U) (arg1@@22 T@U)) (! (let ((T@@23 (MapType0TypeInv0 (type arg0@@64)))) (= (type (|Set#Intersection| arg0@@64 arg1@@22)) (MapType0Type T@@23 boolType))) :qid |funType:Set#Intersection| :pattern ((|Set#Intersection| arg0@@64 arg1@@22)))))
(assert (forall ((a@@10 T@U) (b@@5 T@U) (o@@6 T@U)) (! (let ((T@@24 (type o@@6))) (=> (and (= (type a@@10) (MapType0Type T@@24 boolType)) (= (type b@@5) (MapType0Type T@@24 boolType))) (and (=> (U_2_bool (MapType0Select (|Set#Intersection| a@@10 b@@5) o@@6)) (and (U_2_bool (MapType0Select a@@10 o@@6)) (U_2_bool (MapType0Select b@@5 o@@6)))) (=> (and (U_2_bool (MapType0Select a@@10 o@@6)) (U_2_bool (MapType0Select b@@5 o@@6))) (U_2_bool (MapType0Select (|Set#Intersection| a@@10 b@@5) o@@6)))))) :qid |DafnyPre.528:18| :skolemid |114| :pattern ((MapType0Select (|Set#Intersection| a@@10 b@@5) o@@6)))))
(assert (forall ((a@@11 T@U) (b@@6 T@U)) (! (let ((T@@25 (MapType0TypeInv0 (type a@@11)))) (=> (and (= (type a@@11) (MapType0Type T@@25 boolType)) (= (type b@@6) (MapType0Type T@@25 boolType))) (= (|Set#Union| (|Set#Union| a@@11 b@@6) b@@6) (|Set#Union| a@@11 b@@6)))) :qid |DafnyPre.531:18| :skolemid |115| :pattern ((|Set#Union| (|Set#Union| a@@11 b@@6) b@@6)))))
(assert (forall ((a@@12 T@U) (b@@7 T@U)) (! (let ((T@@26 (MapType0TypeInv0 (type a@@12)))) (=> (and (= (type a@@12) (MapType0Type T@@26 boolType)) (= (type b@@7) (MapType0Type T@@26 boolType))) (= (|Set#Union| a@@12 (|Set#Union| a@@12 b@@7)) (|Set#Union| a@@12 b@@7)))) :qid |DafnyPre.533:18| :skolemid |116| :pattern ((|Set#Union| a@@12 (|Set#Union| a@@12 b@@7))))))
(assert (forall ((a@@13 T@U) (b@@8 T@U)) (! (let ((T@@27 (MapType0TypeInv0 (type a@@13)))) (=> (and (= (type a@@13) (MapType0Type T@@27 boolType)) (= (type b@@8) (MapType0Type T@@27 boolType))) (= (|Set#Intersection| (|Set#Intersection| a@@13 b@@8) b@@8) (|Set#Intersection| a@@13 b@@8)))) :qid |DafnyPre.535:18| :skolemid |117| :pattern ((|Set#Intersection| (|Set#Intersection| a@@13 b@@8) b@@8)))))
(assert (forall ((a@@14 T@U) (b@@9 T@U)) (! (let ((T@@28 (MapType0TypeInv0 (type a@@14)))) (=> (and (= (type a@@14) (MapType0Type T@@28 boolType)) (= (type b@@9) (MapType0Type T@@28 boolType))) (= (|Set#Intersection| a@@14 (|Set#Intersection| a@@14 b@@9)) (|Set#Intersection| a@@14 b@@9)))) :qid |DafnyPre.537:18| :skolemid |118| :pattern ((|Set#Intersection| a@@14 (|Set#Intersection| a@@14 b@@9))))))
(assert (forall ((a@@15 T@U) (b@@10 T@U)) (! (let ((T@@29 (MapType0TypeInv0 (type a@@15)))) (=> (and (= (type a@@15) (MapType0Type T@@29 boolType)) (= (type b@@10) (MapType0Type T@@29 boolType))) (= (+ (|Set#Card| (|Set#Union| a@@15 b@@10)) (|Set#Card| (|Set#Intersection| a@@15 b@@10))) (+ (|Set#Card| a@@15) (|Set#Card| b@@10))))) :qid |DafnyPre.539:18| :skolemid |119| :pattern ((|Set#Card| (|Set#Union| a@@15 b@@10))) :pattern ((|Set#Card| (|Set#Intersection| a@@15 b@@10))))))
(assert (forall ((a@@16 T@U) (b@@11 T@U) (o@@7 T@U)) (! (let ((T@@30 (type o@@7))) (=> (and (= (type a@@16) (MapType0Type T@@30 boolType)) (= (type b@@11) (MapType0Type T@@30 boolType))) (and (=> (U_2_bool (MapType0Select (|Set#Difference| a@@16 b@@11) o@@7)) (and (U_2_bool (MapType0Select a@@16 o@@7)) (not (U_2_bool (MapType0Select b@@11 o@@7))))) (=> (and (U_2_bool (MapType0Select a@@16 o@@7)) (not (U_2_bool (MapType0Select b@@11 o@@7)))) (U_2_bool (MapType0Select (|Set#Difference| a@@16 b@@11) o@@7)))))) :qid |DafnyPre.543:18| :skolemid |120| :pattern ((MapType0Select (|Set#Difference| a@@16 b@@11) o@@7)))))
(assert (forall ((a@@17 T@U) (b@@12 T@U) (y@@4 T@U)) (! (let ((T@@31 (type y@@4))) (=> (and (and (= (type a@@17) (MapType0Type T@@31 boolType)) (= (type b@@12) (MapType0Type T@@31 boolType))) (U_2_bool (MapType0Select b@@12 y@@4))) (not (U_2_bool (MapType0Select (|Set#Difference| a@@17 b@@12) y@@4))))) :qid |DafnyPre.545:18| :skolemid |121| :pattern ((|Set#Difference| a@@17 b@@12) (MapType0Select b@@12 y@@4)))))
(assert (forall ((a@@18 T@U) (b@@13 T@U)) (! (let ((T@@32 (MapType0TypeInv0 (type a@@18)))) (=> (and (= (type a@@18) (MapType0Type T@@32 boolType)) (= (type b@@13) (MapType0Type T@@32 boolType))) (and (= (+ (+ (|Set#Card| (|Set#Difference| a@@18 b@@13)) (|Set#Card| (|Set#Difference| b@@13 a@@18))) (|Set#Card| (|Set#Intersection| a@@18 b@@13))) (|Set#Card| (|Set#Union| a@@18 b@@13))) (= (|Set#Card| (|Set#Difference| a@@18 b@@13)) (- (|Set#Card| a@@18) (|Set#Card| (|Set#Intersection| a@@18 b@@13))))))) :qid |DafnyPre.547:18| :skolemid |122| :pattern ((|Set#Card| (|Set#Difference| a@@18 b@@13))))))
(assert (forall ((a@@19 T@U) (b@@14 T@U)) (! (let ((T@@33 (MapType0TypeInv0 (type a@@19)))) (=> (and (= (type a@@19) (MapType0Type T@@33 boolType)) (= (type b@@14) (MapType0Type T@@33 boolType))) (and (=> (|Set#Subset| a@@19 b@@14) (forall ((o@@8 T@U)) (! (=> (and (= (type o@@8) T@@33) (U_2_bool (MapType0Select a@@19 o@@8))) (U_2_bool (MapType0Select b@@14 o@@8))) :qid |DafnyPre.556:32| :skolemid |123| :pattern ((MapType0Select a@@19 o@@8)) :pattern ((MapType0Select b@@14 o@@8))))) (=> (forall ((o@@9 T@U)) (! (=> (and (= (type o@@9) T@@33) (U_2_bool (MapType0Select a@@19 o@@9))) (U_2_bool (MapType0Select b@@14 o@@9))) :qid |DafnyPre.556:32| :skolemid |123| :pattern ((MapType0Select a@@19 o@@9)) :pattern ((MapType0Select b@@14 o@@9)))) (|Set#Subset| a@@19 b@@14))))) :qid |DafnyPre.555:17| :skolemid |124| :pattern ((|Set#Subset| a@@19 b@@14)))))
(assert (forall ((a@@20 T@U) (b@@15 T@U)) (! (let ((T@@34 (MapType0TypeInv0 (type a@@20)))) (=> (and (= (type a@@20) (MapType0Type T@@34 boolType)) (= (type b@@15) (MapType0Type T@@34 boolType))) (and (=> (|Set#Equal| a@@20 b@@15) (forall ((o@@10 T@U)) (! (=> (= (type o@@10) T@@34) (and (=> (U_2_bool (MapType0Select a@@20 o@@10)) (U_2_bool (MapType0Select b@@15 o@@10))) (=> (U_2_bool (MapType0Select b@@15 o@@10)) (U_2_bool (MapType0Select a@@20 o@@10))))) :qid |DafnyPre.564:31| :skolemid |125| :pattern ((MapType0Select a@@20 o@@10)) :pattern ((MapType0Select b@@15 o@@10))))) (=> (forall ((o@@11 T@U)) (! (=> (= (type o@@11) T@@34) (and (=> (U_2_bool (MapType0Select a@@20 o@@11)) (U_2_bool (MapType0Select b@@15 o@@11))) (=> (U_2_bool (MapType0Select b@@15 o@@11)) (U_2_bool (MapType0Select a@@20 o@@11))))) :qid |DafnyPre.564:31| :skolemid |125| :pattern ((MapType0Select a@@20 o@@11)) :pattern ((MapType0Select b@@15 o@@11)))) (|Set#Equal| a@@20 b@@15))))) :qid |DafnyPre.563:17| :skolemid |126| :pattern ((|Set#Equal| a@@20 b@@15)))))
(assert (forall ((a@@21 T@U) (b@@16 T@U)) (! (let ((T@@35 (MapType0TypeInv0 (type a@@21)))) (=> (and (and (= (type a@@21) (MapType0Type T@@35 boolType)) (= (type b@@16) (MapType0Type T@@35 boolType))) (|Set#Equal| a@@21 b@@16)) (= a@@21 b@@16))) :qid |DafnyPre.565:17| :skolemid |127| :pattern ((|Set#Equal| a@@21 b@@16)))))
(assert (forall ((a@@22 T@U) (b@@17 T@U)) (! (let ((T@@36 (MapType0TypeInv0 (type a@@22)))) (=> (and (= (type a@@22) (MapType0Type T@@36 boolType)) (= (type b@@17) (MapType0Type T@@36 boolType))) (and (=> (|Set#Disjoint| a@@22 b@@17) (forall ((o@@12 T@U)) (! (=> (= (type o@@12) T@@36) (or (not (U_2_bool (MapType0Select a@@22 o@@12))) (not (U_2_bool (MapType0Select b@@17 o@@12))))) :qid |DafnyPre.570:34| :skolemid |128| :pattern ((MapType0Select a@@22 o@@12)) :pattern ((MapType0Select b@@17 o@@12))))) (=> (forall ((o@@13 T@U)) (! (=> (= (type o@@13) T@@36) (or (not (U_2_bool (MapType0Select a@@22 o@@13))) (not (U_2_bool (MapType0Select b@@17 o@@13))))) :qid |DafnyPre.570:34| :skolemid |128| :pattern ((MapType0Select a@@22 o@@13)) :pattern ((MapType0Select b@@17 o@@13)))) (|Set#Disjoint| a@@22 b@@17))))) :qid |DafnyPre.569:18| :skolemid |129| :pattern ((|Set#Disjoint| a@@22 b@@17)))))
(assert (forall ((T@@37 T@T)) (! (= (type (|ISet#Empty| T@@37)) (MapType0Type T@@37 boolType)) :qid |funType:ISet#Empty| :pattern ((|ISet#Empty| T@@37)))))
(assert (forall ((o@@14 T@U)) (! (let ((T@@38 (type o@@14))) (not (U_2_bool (MapType0Select (|ISet#Empty| T@@38) o@@14)))) :qid |DafnyPre.579:18| :skolemid |130| :pattern ((let ((T@@38 (type o@@14))) (MapType0Select (|ISet#Empty| T@@38) o@@14))))))
(assert (forall ((arg0@@65 T@U) (arg1@@23 T@U)) (! (let ((T@@39 (type arg1@@23))) (= (type (|ISet#UnionOne| arg0@@65 arg1@@23)) (MapType0Type T@@39 boolType))) :qid |funType:ISet#UnionOne| :pattern ((|ISet#UnionOne| arg0@@65 arg1@@23)))))
(assert (forall ((a@@23 T@U) (x@@21 T@U) (o@@15 T@U)) (! (let ((T@@40 (type x@@21))) (=> (and (= (type a@@23) (MapType0Type T@@40 boolType)) (= (type o@@15) T@@40)) (and (=> (U_2_bool (MapType0Select (|ISet#UnionOne| a@@23 x@@21) o@@15)) (or (= o@@15 x@@21) (U_2_bool (MapType0Select a@@23 o@@15)))) (=> (or (= o@@15 x@@21) (U_2_bool (MapType0Select a@@23 o@@15))) (U_2_bool (MapType0Select (|ISet#UnionOne| a@@23 x@@21) o@@15)))))) :qid |DafnyPre.586:18| :skolemid |131| :pattern ((MapType0Select (|ISet#UnionOne| a@@23 x@@21) o@@15)))))
(assert (forall ((a@@24 T@U) (x@@22 T@U)) (! (let ((T@@41 (type x@@22))) (=> (= (type a@@24) (MapType0Type T@@41 boolType)) (U_2_bool (MapType0Select (|ISet#UnionOne| a@@24 x@@22) x@@22)))) :qid |DafnyPre.588:18| :skolemid |132| :pattern ((|ISet#UnionOne| a@@24 x@@22)))))
(assert (forall ((a@@25 T@U) (x@@23 T@U) (y@@5 T@U)) (! (let ((T@@42 (type x@@23))) (=> (and (and (= (type a@@25) (MapType0Type T@@42 boolType)) (= (type y@@5) T@@42)) (U_2_bool (MapType0Select a@@25 y@@5))) (U_2_bool (MapType0Select (|ISet#UnionOne| a@@25 x@@23) y@@5)))) :qid |DafnyPre.590:18| :skolemid |133| :pattern ((|ISet#UnionOne| a@@25 x@@23) (MapType0Select a@@25 y@@5)))))
(assert (forall ((arg0@@66 T@U) (arg1@@24 T@U)) (! (let ((T@@43 (MapType0TypeInv0 (type arg0@@66)))) (= (type (|ISet#Union| arg0@@66 arg1@@24)) (MapType0Type T@@43 boolType))) :qid |funType:ISet#Union| :pattern ((|ISet#Union| arg0@@66 arg1@@24)))))
(assert (forall ((a@@26 T@U) (b@@18 T@U) (o@@16 T@U)) (! (let ((T@@44 (type o@@16))) (=> (and (= (type a@@26) (MapType0Type T@@44 boolType)) (= (type b@@18) (MapType0Type T@@44 boolType))) (and (=> (U_2_bool (MapType0Select (|ISet#Union| a@@26 b@@18) o@@16)) (or (U_2_bool (MapType0Select a@@26 o@@16)) (U_2_bool (MapType0Select b@@18 o@@16)))) (=> (or (U_2_bool (MapType0Select a@@26 o@@16)) (U_2_bool (MapType0Select b@@18 o@@16))) (U_2_bool (MapType0Select (|ISet#Union| a@@26 b@@18) o@@16)))))) :qid |DafnyPre.594:18| :skolemid |134| :pattern ((MapType0Select (|ISet#Union| a@@26 b@@18) o@@16)))))
(assert (forall ((a@@27 T@U) (b@@19 T@U) (y@@6 T@U)) (! (let ((T@@45 (type y@@6))) (=> (and (and (= (type a@@27) (MapType0Type T@@45 boolType)) (= (type b@@19) (MapType0Type T@@45 boolType))) (U_2_bool (MapType0Select a@@27 y@@6))) (U_2_bool (MapType0Select (|ISet#Union| a@@27 b@@19) y@@6)))) :qid |DafnyPre.596:18| :skolemid |135| :pattern ((|ISet#Union| a@@27 b@@19) (MapType0Select a@@27 y@@6)))))
(assert (forall ((a@@28 T@U) (b@@20 T@U) (y@@7 T@U)) (! (let ((T@@46 (type y@@7))) (=> (and (and (= (type a@@28) (MapType0Type T@@46 boolType)) (= (type b@@20) (MapType0Type T@@46 boolType))) (U_2_bool (MapType0Select b@@20 y@@7))) (U_2_bool (MapType0Select (|ISet#Union| a@@28 b@@20) y@@7)))) :qid |DafnyPre.598:18| :skolemid |136| :pattern ((|ISet#Union| a@@28 b@@20) (MapType0Select b@@20 y@@7)))))
(assert (forall ((arg0@@67 T@U) (arg1@@25 T@U)) (! (let ((T@@47 (MapType0TypeInv0 (type arg0@@67)))) (= (type (|ISet#Difference| arg0@@67 arg1@@25)) (MapType0Type T@@47 boolType))) :qid |funType:ISet#Difference| :pattern ((|ISet#Difference| arg0@@67 arg1@@25)))))
(assert (forall ((a@@29 T@U) (b@@21 T@U)) (! (let ((T@@48 (MapType0TypeInv0 (type a@@29)))) (=> (and (and (= (type a@@29) (MapType0Type T@@48 boolType)) (= (type b@@21) (MapType0Type T@@48 boolType))) (|ISet#Disjoint| a@@29 b@@21)) (and (= (|ISet#Difference| (|ISet#Union| a@@29 b@@21) a@@29) b@@21) (= (|ISet#Difference| (|ISet#Union| a@@29 b@@21) b@@21) a@@29)))) :qid |DafnyPre.600:18| :skolemid |137| :pattern ((|ISet#Union| a@@29 b@@21)))))
(assert (forall ((arg0@@68 T@U) (arg1@@26 T@U)) (! (let ((T@@49 (MapType0TypeInv0 (type arg0@@68)))) (= (type (|ISet#Intersection| arg0@@68 arg1@@26)) (MapType0Type T@@49 boolType))) :qid |funType:ISet#Intersection| :pattern ((|ISet#Intersection| arg0@@68 arg1@@26)))))
(assert (forall ((a@@30 T@U) (b@@22 T@U) (o@@17 T@U)) (! (let ((T@@50 (type o@@17))) (=> (and (= (type a@@30) (MapType0Type T@@50 boolType)) (= (type b@@22) (MapType0Type T@@50 boolType))) (and (=> (U_2_bool (MapType0Select (|ISet#Intersection| a@@30 b@@22) o@@17)) (and (U_2_bool (MapType0Select a@@30 o@@17)) (U_2_bool (MapType0Select b@@22 o@@17)))) (=> (and (U_2_bool (MapType0Select a@@30 o@@17)) (U_2_bool (MapType0Select b@@22 o@@17))) (U_2_bool (MapType0Select (|ISet#Intersection| a@@30 b@@22) o@@17)))))) :qid |DafnyPre.610:18| :skolemid |138| :pattern ((MapType0Select (|ISet#Intersection| a@@30 b@@22) o@@17)))))
(assert (forall ((a@@31 T@U) (b@@23 T@U)) (! (let ((T@@51 (MapType0TypeInv0 (type a@@31)))) (=> (and (= (type a@@31) (MapType0Type T@@51 boolType)) (= (type b@@23) (MapType0Type T@@51 boolType))) (= (|ISet#Union| (|ISet#Union| a@@31 b@@23) b@@23) (|ISet#Union| a@@31 b@@23)))) :qid |DafnyPre.613:18| :skolemid |139| :pattern ((|ISet#Union| (|ISet#Union| a@@31 b@@23) b@@23)))))
(assert (forall ((a@@32 T@U) (b@@24 T@U)) (! (let ((T@@52 (MapType0TypeInv0 (type a@@32)))) (=> (and (= (type a@@32) (MapType0Type T@@52 boolType)) (= (type b@@24) (MapType0Type T@@52 boolType))) (= (|ISet#Union| a@@32 (|ISet#Union| a@@32 b@@24)) (|ISet#Union| a@@32 b@@24)))) :qid |DafnyPre.615:18| :skolemid |140| :pattern ((|ISet#Union| a@@32 (|ISet#Union| a@@32 b@@24))))))
(assert (forall ((a@@33 T@U) (b@@25 T@U)) (! (let ((T@@53 (MapType0TypeInv0 (type a@@33)))) (=> (and (= (type a@@33) (MapType0Type T@@53 boolType)) (= (type b@@25) (MapType0Type T@@53 boolType))) (= (|ISet#Intersection| (|ISet#Intersection| a@@33 b@@25) b@@25) (|ISet#Intersection| a@@33 b@@25)))) :qid |DafnyPre.617:18| :skolemid |141| :pattern ((|ISet#Intersection| (|ISet#Intersection| a@@33 b@@25) b@@25)))))
(assert (forall ((a@@34 T@U) (b@@26 T@U)) (! (let ((T@@54 (MapType0TypeInv0 (type a@@34)))) (=> (and (= (type a@@34) (MapType0Type T@@54 boolType)) (= (type b@@26) (MapType0Type T@@54 boolType))) (= (|ISet#Intersection| a@@34 (|ISet#Intersection| a@@34 b@@26)) (|ISet#Intersection| a@@34 b@@26)))) :qid |DafnyPre.619:18| :skolemid |142| :pattern ((|ISet#Intersection| a@@34 (|ISet#Intersection| a@@34 b@@26))))))
(assert (forall ((a@@35 T@U) (b@@27 T@U) (o@@18 T@U)) (! (let ((T@@55 (type o@@18))) (=> (and (= (type a@@35) (MapType0Type T@@55 boolType)) (= (type b@@27) (MapType0Type T@@55 boolType))) (and (=> (U_2_bool (MapType0Select (|ISet#Difference| a@@35 b@@27) o@@18)) (and (U_2_bool (MapType0Select a@@35 o@@18)) (not (U_2_bool (MapType0Select b@@27 o@@18))))) (=> (and (U_2_bool (MapType0Select a@@35 o@@18)) (not (U_2_bool (MapType0Select b@@27 o@@18)))) (U_2_bool (MapType0Select (|ISet#Difference| a@@35 b@@27) o@@18)))))) :qid |DafnyPre.624:18| :skolemid |143| :pattern ((MapType0Select (|ISet#Difference| a@@35 b@@27) o@@18)))))
(assert (forall ((a@@36 T@U) (b@@28 T@U) (y@@8 T@U)) (! (let ((T@@56 (type y@@8))) (=> (and (and (= (type a@@36) (MapType0Type T@@56 boolType)) (= (type b@@28) (MapType0Type T@@56 boolType))) (U_2_bool (MapType0Select b@@28 y@@8))) (not (U_2_bool (MapType0Select (|ISet#Difference| a@@36 b@@28) y@@8))))) :qid |DafnyPre.626:18| :skolemid |144| :pattern ((|ISet#Difference| a@@36 b@@28) (MapType0Select b@@28 y@@8)))))
(assert (forall ((a@@37 T@U) (b@@29 T@U)) (! (let ((T@@57 (MapType0TypeInv0 (type a@@37)))) (=> (and (= (type a@@37) (MapType0Type T@@57 boolType)) (= (type b@@29) (MapType0Type T@@57 boolType))) (and (=> (|ISet#Subset| a@@37 b@@29) (forall ((o@@19 T@U)) (! (=> (and (= (type o@@19) T@@57) (U_2_bool (MapType0Select a@@37 o@@19))) (U_2_bool (MapType0Select b@@29 o@@19))) :qid |DafnyPre.631:33| :skolemid |145| :pattern ((MapType0Select a@@37 o@@19)) :pattern ((MapType0Select b@@29 o@@19))))) (=> (forall ((o@@20 T@U)) (! (=> (and (= (type o@@20) T@@57) (U_2_bool (MapType0Select a@@37 o@@20))) (U_2_bool (MapType0Select b@@29 o@@20))) :qid |DafnyPre.631:33| :skolemid |145| :pattern ((MapType0Select a@@37 o@@20)) :pattern ((MapType0Select b@@29 o@@20)))) (|ISet#Subset| a@@37 b@@29))))) :qid |DafnyPre.630:17| :skolemid |146| :pattern ((|ISet#Subset| a@@37 b@@29)))))
(assert (forall ((a@@38 T@U) (b@@30 T@U)) (! (let ((T@@58 (MapType0TypeInv0 (type a@@38)))) (=> (and (= (type a@@38) (MapType0Type T@@58 boolType)) (= (type b@@30) (MapType0Type T@@58 boolType))) (and (=> (|ISet#Equal| a@@38 b@@30) (forall ((o@@21 T@U)) (! (=> (= (type o@@21) T@@58) (and (=> (U_2_bool (MapType0Select a@@38 o@@21)) (U_2_bool (MapType0Select b@@30 o@@21))) (=> (U_2_bool (MapType0Select b@@30 o@@21)) (U_2_bool (MapType0Select a@@38 o@@21))))) :qid |DafnyPre.639:32| :skolemid |147| :pattern ((MapType0Select a@@38 o@@21)) :pattern ((MapType0Select b@@30 o@@21))))) (=> (forall ((o@@22 T@U)) (! (=> (= (type o@@22) T@@58) (and (=> (U_2_bool (MapType0Select a@@38 o@@22)) (U_2_bool (MapType0Select b@@30 o@@22))) (=> (U_2_bool (MapType0Select b@@30 o@@22)) (U_2_bool (MapType0Select a@@38 o@@22))))) :qid |DafnyPre.639:32| :skolemid |147| :pattern ((MapType0Select a@@38 o@@22)) :pattern ((MapType0Select b@@30 o@@22)))) (|ISet#Equal| a@@38 b@@30))))) :qid |DafnyPre.638:17| :skolemid |148| :pattern ((|ISet#Equal| a@@38 b@@30)))))
(assert (forall ((a@@39 T@U) (b@@31 T@U)) (! (let ((T@@59 (MapType0TypeInv0 (type a@@39)))) (=> (and (and (= (type a@@39) (MapType0Type T@@59 boolType)) (= (type b@@31) (MapType0Type T@@59 boolType))) (|ISet#Equal| a@@39 b@@31)) (= a@@39 b@@31))) :qid |DafnyPre.640:17| :skolemid |149| :pattern ((|ISet#Equal| a@@39 b@@31)))))
(assert (forall ((a@@40 T@U) (b@@32 T@U)) (! (let ((T@@60 (MapType0TypeInv0 (type a@@40)))) (=> (and (= (type a@@40) (MapType0Type T@@60 boolType)) (= (type b@@32) (MapType0Type T@@60 boolType))) (and (=> (|ISet#Disjoint| a@@40 b@@32) (forall ((o@@23 T@U)) (! (=> (= (type o@@23) T@@60) (or (not (U_2_bool (MapType0Select a@@40 o@@23))) (not (U_2_bool (MapType0Select b@@32 o@@23))))) :qid |DafnyPre.645:35| :skolemid |150| :pattern ((MapType0Select a@@40 o@@23)) :pattern ((MapType0Select b@@32 o@@23))))) (=> (forall ((o@@24 T@U)) (! (=> (= (type o@@24) T@@60) (or (not (U_2_bool (MapType0Select a@@40 o@@24))) (not (U_2_bool (MapType0Select b@@32 o@@24))))) :qid |DafnyPre.645:35| :skolemid |150| :pattern ((MapType0Select a@@40 o@@24)) :pattern ((MapType0Select b@@32 o@@24)))) (|ISet#Disjoint| a@@40 b@@32))))) :qid |DafnyPre.644:18| :skolemid |151| :pattern ((|ISet#Disjoint| a@@40 b@@32)))))
(assert (forall ((a@@41 Int) (b@@33 Int)) (! (and (=> (<= a@@41 b@@33) (= (|Math#min| a@@41 b@@33) a@@41)) (=> (= (|Math#min| a@@41 b@@33) a@@41) (<= a@@41 b@@33))) :qid |DafnyPre.652:15| :skolemid |152| :pattern ((|Math#min| a@@41 b@@33)))))
(assert (forall ((a@@42 Int) (b@@34 Int)) (! (and (=> (<= b@@34 a@@42) (= (|Math#min| a@@42 b@@34) b@@34)) (=> (= (|Math#min| a@@42 b@@34) b@@34) (<= b@@34 a@@42))) :qid |DafnyPre.653:15| :skolemid |153| :pattern ((|Math#min| a@@42 b@@34)))))
(assert (forall ((a@@43 Int) (b@@35 Int)) (! (or (= (|Math#min| a@@43 b@@35) a@@43) (= (|Math#min| a@@43 b@@35) b@@35)) :qid |DafnyPre.654:15| :skolemid |154| :pattern ((|Math#min| a@@43 b@@35)))))
(assert (forall ((a@@44 Int)) (! (=> (<= 0 a@@44) (= (|Math#clip| a@@44) a@@44)) :qid |DafnyPre.657:15| :skolemid |155| :pattern ((|Math#clip| a@@44)))))
(assert (forall ((a@@45 Int)) (! (=> (< a@@45 0) (= (|Math#clip| a@@45) 0)) :qid |DafnyPre.658:15| :skolemid |156| :pattern ((|Math#clip| a@@45)))))
(assert (forall ((ms T@U)) (! (let ((T@@61 (MapType0TypeInv0 (type ms)))) (=> (= (type ms) (MapType0Type T@@61 intType)) (and (=> ($IsGoodMultiSet ms) (forall ((bx@@32 T@U)) (! (=> (= (type bx@@32) T@@61) (and (<= 0 (U_2_int (MapType0Select ms bx@@32))) (<= (U_2_int (MapType0Select ms bx@@32)) (|MultiSet#Card| ms)))) :qid |DafnyPre.666:11| :skolemid |157| :pattern ((MapType0Select ms bx@@32))))) (=> (forall ((bx@@33 T@U)) (! (=> (= (type bx@@33) T@@61) (and (<= 0 (U_2_int (MapType0Select ms bx@@33))) (<= (U_2_int (MapType0Select ms bx@@33)) (|MultiSet#Card| ms)))) :qid |DafnyPre.666:11| :skolemid |157| :pattern ((MapType0Select ms bx@@33)))) ($IsGoodMultiSet ms))))) :qid |DafnyPre.664:18| :skolemid |158| :pattern (($IsGoodMultiSet ms)))))
(assert (forall ((s@@5 T@U)) (! (let ((T@@62 (MapType0TypeInv0 (type s@@5)))) (=> (= (type s@@5) (MapType0Type T@@62 intType)) (<= 0 (|MultiSet#Card| s@@5)))) :qid |DafnyPre.669:18| :skolemid |159| :pattern ((|MultiSet#Card| s@@5)))))
(assert (forall ((s@@6 T@U) (x@@24 T@U) (n@@0 T@U)) (! (let ((T@@63 (type x@@24))) (=> (and (and (= (type s@@6) (MapType0Type T@@63 intType)) (= (type n@@0) intType)) (<= 0 (U_2_int n@@0))) (= (|MultiSet#Card| (MapType0Store s@@6 x@@24 n@@0)) (+ (- (|MultiSet#Card| s@@6) (U_2_int (MapType0Select s@@6 x@@24))) (U_2_int n@@0))))) :qid |DafnyPre.670:18| :skolemid |160| :pattern ((|MultiSet#Card| (MapType0Store s@@6 x@@24 n@@0))))))
(assert (forall ((T@@64 T@T)) (! (= (type (|MultiSet#Empty| T@@64)) (MapType0Type T@@64 intType)) :qid |funType:MultiSet#Empty| :pattern ((|MultiSet#Empty| T@@64)))))
(assert (forall ((o@@25 T@U)) (! (let ((T@@65 (type o@@25))) (= (U_2_int (MapType0Select (|MultiSet#Empty| T@@65) o@@25)) 0)) :qid |DafnyPre.674:18| :skolemid |161| :pattern ((let ((T@@65 (type o@@25))) (MapType0Select (|MultiSet#Empty| T@@65) o@@25))))))
(assert (forall ((s@@7 T@U)) (! (let ((T@@66 (MapType0TypeInv0 (type s@@7)))) (=> (= (type s@@7) (MapType0Type T@@66 intType)) (and (and (=> (= (|MultiSet#Card| s@@7) 0) (= s@@7 (|MultiSet#Empty| T@@66))) (=> (= s@@7 (|MultiSet#Empty| T@@66)) (= (|MultiSet#Card| s@@7) 0))) (=> (not (= (|MultiSet#Card| s@@7) 0)) (exists ((x@@25 T@U)) (! (and (= (type x@@25) T@@66) (< 0 (U_2_int (MapType0Select s@@7 x@@25)))) :qid |DafnyPre.677:38| :skolemid |162| :no-pattern (type x@@25) :no-pattern (U_2_int x@@25) :no-pattern (U_2_bool x@@25))))))) :qid |DafnyPre.675:18| :skolemid |163| :pattern ((|MultiSet#Card| s@@7)))))
(assert (forall ((arg0@@69 T@U)) (! (let ((T@@67 (type arg0@@69))) (= (type (|MultiSet#Singleton| arg0@@69)) (MapType0Type T@@67 intType))) :qid |funType:MultiSet#Singleton| :pattern ((|MultiSet#Singleton| arg0@@69)))))
(assert (forall ((r@@3 T@U) (o@@26 T@U)) (! (let ((T@@68 (type r@@3))) (=> (= (type o@@26) T@@68) (and (and (=> (= (U_2_int (MapType0Select (|MultiSet#Singleton| r@@3) o@@26)) 1) (= r@@3 o@@26)) (=> (= r@@3 o@@26) (= (U_2_int (MapType0Select (|MultiSet#Singleton| r@@3) o@@26)) 1))) (and (=> (= (U_2_int (MapType0Select (|MultiSet#Singleton| r@@3) o@@26)) 0) (not (= r@@3 o@@26))) (=> (not (= r@@3 o@@26)) (= (U_2_int (MapType0Select (|MultiSet#Singleton| r@@3) o@@26)) 0)))))) :qid |DafnyPre.680:18| :skolemid |164| :pattern ((MapType0Select (|MultiSet#Singleton| r@@3) o@@26)))))
(assert (forall ((arg0@@70 T@U) (arg1@@27 T@U)) (! (let ((T@@69 (type arg1@@27))) (= (type (|MultiSet#UnionOne| arg0@@70 arg1@@27)) (MapType0Type T@@69 intType))) :qid |funType:MultiSet#UnionOne| :pattern ((|MultiSet#UnionOne| arg0@@70 arg1@@27)))))
(assert (forall ((r@@4 T@U)) (! (let ((T@@70 (type r@@4))) (= (|MultiSet#Singleton| r@@4) (|MultiSet#UnionOne| (|MultiSet#Empty| T@@70) r@@4))) :qid |DafnyPre.682:18| :skolemid |165| :pattern ((|MultiSet#Singleton| r@@4)))))
(assert (forall ((a@@46 T@U) (x@@26 T@U) (o@@27 T@U)) (! (let ((T@@71 (type x@@26))) (=> (and (= (type a@@46) (MapType0Type T@@71 intType)) (= (type o@@27) T@@71)) (and (=> (< 0 (U_2_int (MapType0Select (|MultiSet#UnionOne| a@@46 x@@26) o@@27))) (or (= o@@27 x@@26) (< 0 (U_2_int (MapType0Select a@@46 o@@27))))) (=> (or (= o@@27 x@@26) (< 0 (U_2_int (MapType0Select a@@46 o@@27)))) (< 0 (U_2_int (MapType0Select (|MultiSet#UnionOne| a@@46 x@@26) o@@27))))))) :qid |DafnyPre.686:18| :skolemid |166| :pattern ((MapType0Select (|MultiSet#UnionOne| a@@46 x@@26) o@@27)))))
(assert (forall ((a@@47 T@U) (x@@27 T@U)) (! (let ((T@@72 (type x@@27))) (=> (= (type a@@47) (MapType0Type T@@72 intType)) (= (U_2_int (MapType0Select (|MultiSet#UnionOne| a@@47 x@@27) x@@27)) (+ (U_2_int (MapType0Select a@@47 x@@27)) 1)))) :qid |DafnyPre.689:18| :skolemid |167| :pattern ((|MultiSet#UnionOne| a@@47 x@@27)))))
(assert (forall ((a@@48 T@U) (x@@28 T@U) (y@@9 T@U)) (! (let ((T@@73 (type x@@28))) (=> (and (and (= (type a@@48) (MapType0Type T@@73 intType)) (= (type y@@9) T@@73)) (< 0 (U_2_int (MapType0Select a@@48 y@@9)))) (< 0 (U_2_int (MapType0Select (|MultiSet#UnionOne| a@@48 x@@28) y@@9))))) :qid |DafnyPre.692:18| :skolemid |168| :pattern ((|MultiSet#UnionOne| a@@48 x@@28) (MapType0Select a@@48 y@@9)))))
(assert (forall ((a@@49 T@U) (x@@29 T@U) (y@@10 T@U)) (! (let ((T@@74 (type x@@29))) (=> (and (and (= (type a@@49) (MapType0Type T@@74 intType)) (= (type y@@10) T@@74)) (not (= x@@29 y@@10))) (= (U_2_int (MapType0Select a@@49 y@@10)) (U_2_int (MapType0Select (|MultiSet#UnionOne| a@@49 x@@29) y@@10))))) :qid |DafnyPre.695:18| :skolemid |169| :pattern ((|MultiSet#UnionOne| a@@49 x@@29) (MapType0Select a@@49 y@@10)))))
(assert (forall ((a@@50 T@U) (x@@30 T@U)) (! (let ((T@@75 (type x@@30))) (=> (= (type a@@50) (MapType0Type T@@75 intType)) (= (|MultiSet#Card| (|MultiSet#UnionOne| a@@50 x@@30)) (+ (|MultiSet#Card| a@@50) 1)))) :qid |DafnyPre.697:18| :skolemid |170| :pattern ((|MultiSet#Card| (|MultiSet#UnionOne| a@@50 x@@30))))))
(assert (forall ((arg0@@71 T@U) (arg1@@28 T@U)) (! (let ((T@@76 (MapType0TypeInv0 (type arg0@@71)))) (= (type (|MultiSet#Union| arg0@@71 arg1@@28)) (MapType0Type T@@76 intType))) :qid |funType:MultiSet#Union| :pattern ((|MultiSet#Union| arg0@@71 arg1@@28)))))
(assert (forall ((a@@51 T@U) (b@@36 T@U) (o@@28 T@U)) (! (let ((T@@77 (type o@@28))) (=> (and (= (type a@@51) (MapType0Type T@@77 intType)) (= (type b@@36) (MapType0Type T@@77 intType))) (= (U_2_int (MapType0Select (|MultiSet#Union| a@@51 b@@36) o@@28)) (+ (U_2_int (MapType0Select a@@51 o@@28)) (U_2_int (MapType0Select b@@36 o@@28)))))) :qid |DafnyPre.703:18| :skolemid |171| :pattern ((MapType0Select (|MultiSet#Union| a@@51 b@@36) o@@28)))))
(assert (forall ((a@@52 T@U) (b@@37 T@U)) (! (let ((T@@78 (MapType0TypeInv0 (type a@@52)))) (=> (and (= (type a@@52) (MapType0Type T@@78 intType)) (= (type b@@37) (MapType0Type T@@78 intType))) (= (|MultiSet#Card| (|MultiSet#Union| a@@52 b@@37)) (+ (|MultiSet#Card| a@@52) (|MultiSet#Card| b@@37))))) :qid |DafnyPre.705:18| :skolemid |172| :pattern ((|MultiSet#Card| (|MultiSet#Union| a@@52 b@@37))))))
(assert (forall ((arg0@@72 T@U) (arg1@@29 T@U)) (! (let ((T@@79 (MapType0TypeInv0 (type arg0@@72)))) (= (type (|MultiSet#Intersection| arg0@@72 arg1@@29)) (MapType0Type T@@79 intType))) :qid |funType:MultiSet#Intersection| :pattern ((|MultiSet#Intersection| arg0@@72 arg1@@29)))))
(assert (forall ((a@@53 T@U) (b@@38 T@U) (o@@29 T@U)) (! (let ((T@@80 (type o@@29))) (=> (and (= (type a@@53) (MapType0Type T@@80 intType)) (= (type b@@38) (MapType0Type T@@80 intType))) (= (U_2_int (MapType0Select (|MultiSet#Intersection| a@@53 b@@38) o@@29)) (|Math#min| (U_2_int (MapType0Select a@@53 o@@29)) (U_2_int (MapType0Select b@@38 o@@29)))))) :qid |DafnyPre.709:18| :skolemid |173| :pattern ((MapType0Select (|MultiSet#Intersection| a@@53 b@@38) o@@29)))))
(assert (forall ((a@@54 T@U) (b@@39 T@U)) (! (let ((T@@81 (MapType0TypeInv0 (type a@@54)))) (=> (and (= (type a@@54) (MapType0Type T@@81 intType)) (= (type b@@39) (MapType0Type T@@81 intType))) (= (|MultiSet#Intersection| (|MultiSet#Intersection| a@@54 b@@39) b@@39) (|MultiSet#Intersection| a@@54 b@@39)))) :qid |DafnyPre.713:18| :skolemid |174| :pattern ((|MultiSet#Intersection| (|MultiSet#Intersection| a@@54 b@@39) b@@39)))))
(assert (forall ((a@@55 T@U) (b@@40 T@U)) (! (let ((T@@82 (MapType0TypeInv0 (type a@@55)))) (=> (and (= (type a@@55) (MapType0Type T@@82 intType)) (= (type b@@40) (MapType0Type T@@82 intType))) (= (|MultiSet#Intersection| a@@55 (|MultiSet#Intersection| a@@55 b@@40)) (|MultiSet#Intersection| a@@55 b@@40)))) :qid |DafnyPre.715:18| :skolemid |175| :pattern ((|MultiSet#Intersection| a@@55 (|MultiSet#Intersection| a@@55 b@@40))))))
(assert (forall ((arg0@@73 T@U) (arg1@@30 T@U)) (! (let ((T@@83 (MapType0TypeInv0 (type arg0@@73)))) (= (type (|MultiSet#Difference| arg0@@73 arg1@@30)) (MapType0Type T@@83 intType))) :qid |funType:MultiSet#Difference| :pattern ((|MultiSet#Difference| arg0@@73 arg1@@30)))))
(assert (forall ((a@@56 T@U) (b@@41 T@U) (o@@30 T@U)) (! (let ((T@@84 (type o@@30))) (=> (and (= (type a@@56) (MapType0Type T@@84 intType)) (= (type b@@41) (MapType0Type T@@84 intType))) (= (U_2_int (MapType0Select (|MultiSet#Difference| a@@56 b@@41) o@@30)) (|Math#clip| (- (U_2_int (MapType0Select a@@56 o@@30)) (U_2_int (MapType0Select b@@41 o@@30))))))) :qid |DafnyPre.720:18| :skolemid |176| :pattern ((MapType0Select (|MultiSet#Difference| a@@56 b@@41) o@@30)))))
(assert (forall ((a@@57 T@U) (b@@42 T@U) (y@@11 T@U)) (! (let ((T@@85 (type y@@11))) (=> (and (and (= (type a@@57) (MapType0Type T@@85 intType)) (= (type b@@42) (MapType0Type T@@85 intType))) (<= (U_2_int (MapType0Select a@@57 y@@11)) (U_2_int (MapType0Select b@@42 y@@11)))) (= (U_2_int (MapType0Select (|MultiSet#Difference| a@@57 b@@42) y@@11)) 0))) :qid |DafnyPre.722:18| :skolemid |177| :pattern ((|MultiSet#Difference| a@@57 b@@42) (MapType0Select b@@42 y@@11) (MapType0Select a@@57 y@@11)))))
(assert (forall ((a@@58 T@U) (b@@43 T@U)) (! (let ((T@@86 (MapType0TypeInv0 (type a@@58)))) (=> (and (= (type a@@58) (MapType0Type T@@86 intType)) (= (type b@@43) (MapType0Type T@@86 intType))) (and (= (+ (+ (|MultiSet#Card| (|MultiSet#Difference| a@@58 b@@43)) (|MultiSet#Card| (|MultiSet#Difference| b@@43 a@@58))) (* 2 (|MultiSet#Card| (|MultiSet#Intersection| a@@58 b@@43)))) (|MultiSet#Card| (|MultiSet#Union| a@@58 b@@43))) (= (|MultiSet#Card| (|MultiSet#Difference| a@@58 b@@43)) (- (|MultiSet#Card| a@@58) (|MultiSet#Card| (|MultiSet#Intersection| a@@58 b@@43))))))) :qid |DafnyPre.724:18| :skolemid |178| :pattern ((|MultiSet#Card| (|MultiSet#Difference| a@@58 b@@43))))))
(assert (forall ((a@@59 T@U) (b@@44 T@U)) (! (let ((T@@87 (MapType0TypeInv0 (type a@@59)))) (=> (and (= (type a@@59) (MapType0Type T@@87 intType)) (= (type b@@44) (MapType0Type T@@87 intType))) (and (=> (|MultiSet#Subset| a@@59 b@@44) (forall ((o@@31 T@U)) (! (=> (= (type o@@31) T@@87) (<= (U_2_int (MapType0Select a@@59 o@@31)) (U_2_int (MapType0Select b@@44 o@@31)))) :qid |DafnyPre.734:37| :skolemid |179| :pattern ((MapType0Select a@@59 o@@31)) :pattern ((MapType0Select b@@44 o@@31))))) (=> (forall ((o@@32 T@U)) (! (=> (= (type o@@32) T@@87) (<= (U_2_int (MapType0Select a@@59 o@@32)) (U_2_int (MapType0Select b@@44 o@@32)))) :qid |DafnyPre.734:37| :skolemid |179| :pattern ((MapType0Select a@@59 o@@32)) :pattern ((MapType0Select b@@44 o@@32)))) (|MultiSet#Subset| a@@59 b@@44))))) :qid |DafnyPre.733:17| :skolemid |180| :pattern ((|MultiSet#Subset| a@@59 b@@44)))))
(assert (forall ((a@@60 T@U) (b@@45 T@U)) (! (let ((T@@88 (MapType0TypeInv0 (type a@@60)))) (=> (and (= (type a@@60) (MapType0Type T@@88 intType)) (= (type b@@45) (MapType0Type T@@88 intType))) (and (=> (|MultiSet#Equal| a@@60 b@@45) (forall ((o@@33 T@U)) (! (=> (= (type o@@33) T@@88) (= (U_2_int (MapType0Select a@@60 o@@33)) (U_2_int (MapType0Select b@@45 o@@33)))) :qid |DafnyPre.738:36| :skolemid |181| :pattern ((MapType0Select a@@60 o@@33)) :pattern ((MapType0Select b@@45 o@@33))))) (=> (forall ((o@@34 T@U)) (! (=> (= (type o@@34) T@@88) (= (U_2_int (MapType0Select a@@60 o@@34)) (U_2_int (MapType0Select b@@45 o@@34)))) :qid |DafnyPre.738:36| :skolemid |181| :pattern ((MapType0Select a@@60 o@@34)) :pattern ((MapType0Select b@@45 o@@34)))) (|MultiSet#Equal| a@@60 b@@45))))) :qid |DafnyPre.737:17| :skolemid |182| :pattern ((|MultiSet#Equal| a@@60 b@@45)))))
(assert (forall ((a@@61 T@U) (b@@46 T@U)) (! (let ((T@@89 (MapType0TypeInv0 (type a@@61)))) (=> (and (and (= (type a@@61) (MapType0Type T@@89 intType)) (= (type b@@46) (MapType0Type T@@89 intType))) (|MultiSet#Equal| a@@61 b@@46)) (= a@@61 b@@46))) :qid |DafnyPre.740:17| :skolemid |183| :pattern ((|MultiSet#Equal| a@@61 b@@46)))))
(assert (forall ((a@@62 T@U) (b@@47 T@U)) (! (let ((T@@90 (MapType0TypeInv0 (type a@@62)))) (=> (and (= (type a@@62) (MapType0Type T@@90 intType)) (= (type b@@47) (MapType0Type T@@90 intType))) (and (=> (|MultiSet#Disjoint| a@@62 b@@47) (forall ((o@@35 T@U)) (! (=> (= (type o@@35) T@@90) (or (= (U_2_int (MapType0Select a@@62 o@@35)) 0) (= (U_2_int (MapType0Select b@@47 o@@35)) 0))) :qid |DafnyPre.745:39| :skolemid |184| :pattern ((MapType0Select a@@62 o@@35)) :pattern ((MapType0Select b@@47 o@@35))))) (=> (forall ((o@@36 T@U)) (! (=> (= (type o@@36) T@@90) (or (= (U_2_int (MapType0Select a@@62 o@@36)) 0) (= (U_2_int (MapType0Select b@@47 o@@36)) 0))) :qid |DafnyPre.745:39| :skolemid |184| :pattern ((MapType0Select a@@62 o@@36)) :pattern ((MapType0Select b@@47 o@@36)))) (|MultiSet#Disjoint| a@@62 b@@47))))) :qid |DafnyPre.744:18| :skolemid |185| :pattern ((|MultiSet#Disjoint| a@@62 b@@47)))))
(assert (forall ((arg0@@74 T@U)) (! (let ((T@@91 (MapType0TypeInv0 (type arg0@@74)))) (= (type (|MultiSet#FromSet| arg0@@74)) (MapType0Type T@@91 intType))) :qid |funType:MultiSet#FromSet| :pattern ((|MultiSet#FromSet| arg0@@74)))))
(assert (forall ((s@@8 T@U) (a@@63 T@U)) (! (let ((T@@92 (type a@@63))) (=> (= (type s@@8) (MapType0Type T@@92 boolType)) (and (and (=> (= (U_2_int (MapType0Select (|MultiSet#FromSet| s@@8) a@@63)) 0) (not (U_2_bool (MapType0Select s@@8 a@@63)))) (=> (not (U_2_bool (MapType0Select s@@8 a@@63))) (= (U_2_int (MapType0Select (|MultiSet#FromSet| s@@8) a@@63)) 0))) (and (=> (= (U_2_int (MapType0Select (|MultiSet#FromSet| s@@8) a@@63)) 1) (U_2_bool (MapType0Select s@@8 a@@63))) (=> (U_2_bool (MapType0Select s@@8 a@@63)) (= (U_2_int (MapType0Select (|MultiSet#FromSet| s@@8) a@@63)) 1)))))) :qid |DafnyPre.749:18| :skolemid |186| :pattern ((MapType0Select (|MultiSet#FromSet| s@@8) a@@63)))))
(assert (forall ((s@@9 T@U)) (! (let ((T@@93 (MapType0TypeInv0 (type s@@9)))) (=> (= (type s@@9) (MapType0Type T@@93 boolType)) (= (|MultiSet#Card| (|MultiSet#FromSet| s@@9)) (|Set#Card| s@@9)))) :qid |DafnyPre.752:18| :skolemid |187| :pattern ((|MultiSet#Card| (|MultiSet#FromSet| s@@9))))))
(assert (forall ((arg0@@75 T@U)) (! (let ((T@@94 (SeqTypeInv0 (type arg0@@75)))) (= (type (|MultiSet#FromSeq| arg0@@75)) (MapType0Type T@@94 intType))) :qid |funType:MultiSet#FromSeq| :pattern ((|MultiSet#FromSeq| arg0@@75)))))
(assert (forall ((s@@10 T@U)) (! (let ((T@@95 (SeqTypeInv0 (type s@@10)))) (=> (= (type s@@10) (SeqType T@@95)) ($IsGoodMultiSet (|MultiSet#FromSeq| s@@10)))) :qid |DafnyPre.758:18| :skolemid |188| :pattern ((|MultiSet#FromSeq| s@@10)))))
(assert (forall ((s@@11 T@U)) (! (let ((T@@96 (SeqTypeInv0 (type s@@11)))) (=> (= (type s@@11) (SeqType T@@96)) (= (|MultiSet#Card| (|MultiSet#FromSeq| s@@11)) (|Seq#Length| s@@11)))) :qid |DafnyPre.760:18| :skolemid |189| :pattern ((|MultiSet#Card| (|MultiSet#FromSeq| s@@11))))))
(assert (forall ((arg0@@76 T@U) (arg1@@31 T@U)) (! (let ((T@@97 (type arg1@@31))) (= (type (|Seq#Build| arg0@@76 arg1@@31)) (SeqType T@@97))) :qid |funType:Seq#Build| :pattern ((|Seq#Build| arg0@@76 arg1@@31)))))
(assert (forall ((s@@12 T@U) (v@@25 T@U)) (! (let ((T@@98 (type v@@25))) (=> (= (type s@@12) (SeqType T@@98)) (= (|MultiSet#FromSeq| (|Seq#Build| s@@12 v@@25)) (|MultiSet#UnionOne| (|MultiSet#FromSeq| s@@12) v@@25)))) :qid |DafnyPre.764:18| :skolemid |190| :pattern ((|MultiSet#FromSeq| (|Seq#Build| s@@12 v@@25))))))
(assert (forall ((T@@99 T@T)) (! (= (type (|Seq#Empty| T@@99)) (SeqType T@@99)) :qid |funType:Seq#Empty| :pattern ((|Seq#Empty| T@@99)))))
(assert (forall ((T@@100 T@T)) (! (= (|MultiSet#FromSeq| (|Seq#Empty| T@@100)) (|MultiSet#Empty| T@@100)) :skolemid |191|)))
(assert (forall ((arg0@@77 T@U) (arg1@@32 T@U)) (! (let ((T@@101 (SeqTypeInv0 (type arg0@@77)))) (= (type (|Seq#Append| arg0@@77 arg1@@32)) (SeqType T@@101))) :qid |funType:Seq#Append| :pattern ((|Seq#Append| arg0@@77 arg1@@32)))))
(assert (forall ((a@@64 T@U) (b@@48 T@U)) (! (let ((T@@102 (SeqTypeInv0 (type a@@64)))) (=> (and (= (type a@@64) (SeqType T@@102)) (= (type b@@48) (SeqType T@@102))) (= (|MultiSet#FromSeq| (|Seq#Append| a@@64 b@@48)) (|MultiSet#Union| (|MultiSet#FromSeq| a@@64) (|MultiSet#FromSeq| b@@48))))) :qid |DafnyPre.771:18| :skolemid |192| :pattern ((|MultiSet#FromSeq| (|Seq#Append| a@@64 b@@48))))))
(assert (forall ((arg0@@78 T@U) (arg1@@33 Int) (arg2@@2 T@U)) (! (let ((T@@103 (type arg2@@2))) (= (type (|Seq#Update| arg0@@78 arg1@@33 arg2@@2)) (SeqType T@@103))) :qid |funType:Seq#Update| :pattern ((|Seq#Update| arg0@@78 arg1@@33 arg2@@2)))))
(assert (forall ((s@@13 T@U) (i@@8 Int) (v@@26 T@U) (x@@31 T@U)) (! (let ((T@@104 (type v@@26))) (=> (and (and (= (type s@@13) (SeqType T@@104)) (= (type x@@31) T@@104)) (and (<= 0 i@@8) (< i@@8 (|Seq#Length| s@@13)))) (= (U_2_int (MapType0Select (|MultiSet#FromSeq| (|Seq#Update| s@@13 i@@8 v@@26)) x@@31)) (U_2_int (MapType0Select (|MultiSet#Union| (|MultiSet#Difference| (|MultiSet#FromSeq| s@@13) (|MultiSet#Singleton| (|Seq#Index| s@@13 i@@8))) (|MultiSet#Singleton| v@@26)) x@@31))))) :qid |DafnyPre.776:18| :skolemid |193| :pattern ((MapType0Select (|MultiSet#FromSeq| (|Seq#Update| s@@13 i@@8 v@@26)) x@@31)))))
(assert (forall ((s@@14 T@U) (x@@32 T@U)) (! (let ((T@@105 (type x@@32))) (=> (= (type s@@14) (SeqType T@@105)) (and (=> (exists ((i@@9 Int)) (! (and (and (<= 0 i@@9) (< i@@9 (|Seq#Length| s@@14))) (= x@@32 (|Seq#Index| s@@14 i@@9))) :qid |DafnyPre.783:11| :skolemid |194| :pattern ((|Seq#Index| s@@14 i@@9)))) (< 0 (U_2_int (MapType0Select (|MultiSet#FromSeq| s@@14) x@@32)))) (=> (< 0 (U_2_int (MapType0Select (|MultiSet#FromSeq| s@@14) x@@32))) (exists ((i@@10 Int)) (! (and (and (<= 0 i@@10) (< i@@10 (|Seq#Length| s@@14))) (= x@@32 (|Seq#Index| s@@14 i@@10))) :qid |DafnyPre.783:11| :skolemid |194| :pattern ((|Seq#Index| s@@14 i@@10)))))))) :qid |DafnyPre.782:18| :skolemid |195| :pattern ((MapType0Select (|MultiSet#FromSeq| s@@14) x@@32)))))
(assert (forall ((s@@15 T@U)) (! (let ((T@@106 (SeqTypeInv0 (type s@@15)))) (=> (= (type s@@15) (SeqType T@@106)) (<= 0 (|Seq#Length| s@@15)))) :qid |DafnyPre.792:18| :skolemid |196| :pattern ((|Seq#Length| s@@15)))))
(assert (forall ((T@@107 T@T)) (! (= (|Seq#Length| (|Seq#Empty| T@@107)) 0) :skolemid |197|)))
(assert (forall ((s@@16 T@U)) (! (let ((T@@108 (SeqTypeInv0 (type s@@16)))) (=> (and (= (type s@@16) (SeqType T@@108)) (= (|Seq#Length| s@@16) 0)) (= s@@16 (|Seq#Empty| T@@108)))) :qid |DafnyPre.796:18| :skolemid |198| :pattern ((|Seq#Length| s@@16)))))
(assert (forall ((t@@23 T@U) (T@@109 T@T)) (! (=> (= (type t@@23) TyType) ($Is (|Seq#Empty| T@@109) t@@23)) :qid |DafnyPre.806:18| :skolemid |199| :pattern (($Is (|Seq#Empty| T@@109) t@@23)))))
(assert (forall ((arg0@@79 T@U)) (! (let ((T@@110 (type arg0@@79))) (= (type (|Seq#Singleton| arg0@@79)) (SeqType T@@110))) :qid |funType:Seq#Singleton| :pattern ((|Seq#Singleton| arg0@@79)))))
(assert (forall ((t@@24 T@U)) (! (= (|Seq#Length| (|Seq#Singleton| t@@24)) 1) :qid |DafnyPre.809:18| :skolemid |200| :pattern ((|Seq#Length| (|Seq#Singleton| t@@24))))))
(assert (forall ((s@@17 T@U) (v@@27 T@U)) (! (let ((T@@111 (type v@@27))) (=> (= (type s@@17) (SeqType T@@111)) (= (|Seq#Length| (|Seq#Build| s@@17 v@@27)) (+ 1 (|Seq#Length| s@@17))))) :qid |DafnyPre.812:18| :skolemid |201| :pattern ((|Seq#Length| (|Seq#Build| s@@17 v@@27))))))
(assert (forall ((s@@18 T@U) (i@@11 Int) (v@@28 T@U)) (! (let ((T@@112 (type v@@28))) (=> (= (type s@@18) (SeqType T@@112)) (and (=> (= i@@11 (|Seq#Length| s@@18)) (= (|Seq#Index| (|Seq#Build| s@@18 v@@28) i@@11) v@@28)) (=> (not (= i@@11 (|Seq#Length| s@@18))) (= (|Seq#Index| (|Seq#Build| s@@18 v@@28) i@@11) (|Seq#Index| s@@18 i@@11)))))) :qid |DafnyPre.814:18| :skolemid |202| :pattern ((|Seq#Index| (|Seq#Build| s@@18 v@@28) i@@11)))))
(assert (forall ((s@@19 T@U) (bx@@34 T@U) (t@@25 T@U)) (! (=> (and (and (and (= (type s@@19) (SeqType BoxType)) (= (type bx@@34) BoxType)) (= (type t@@25) TyType)) (and ($Is s@@19 (TSeq t@@25)) ($IsBox bx@@34 t@@25))) ($Is (|Seq#Build| s@@19 bx@@34) (TSeq t@@25))) :qid |DafnyPre.819:15| :skolemid |203| :pattern (($Is (|Seq#Build| s@@19 bx@@34) (TSeq t@@25))))))
(assert (forall ((s0 T@U) (s1 T@U)) (! (let ((T@@113 (SeqTypeInv0 (type s0)))) (=> (and (= (type s0) (SeqType T@@113)) (= (type s1) (SeqType T@@113))) (= (|Seq#Length| (|Seq#Append| s0 s1)) (+ (|Seq#Length| s0) (|Seq#Length| s1))))) :qid |DafnyPre.823:18| :skolemid |204| :pattern ((|Seq#Length| (|Seq#Append| s0 s1))))))
(assert (forall ((s0@@0 T@U) (s1@@0 T@U) (t@@26 T@U)) (! (=> (and (and (and (= (type s0@@0) (SeqType BoxType)) (= (type s1@@0) (SeqType BoxType))) (= (type t@@26) TyType)) (and ($Is s0@@0 t@@26) ($Is s1@@0 t@@26))) ($Is (|Seq#Append| s0@@0 s1@@0) t@@26)) :qid |DafnyPre.827:15| :skolemid |205| :pattern (($Is (|Seq#Append| s0@@0 s1@@0) t@@26)))))
(assert (forall ((t@@27 T@U)) (! (= (|Seq#Index| (|Seq#Singleton| t@@27) 0) t@@27) :qid |DafnyPre.831:18| :skolemid |206| :pattern ((|Seq#Index| (|Seq#Singleton| t@@27) 0)))))
(assert (forall ((s0@@1 T@U) (s1@@1 T@U) (n@@1 Int)) (! (let ((T@@114 (SeqTypeInv0 (type s0@@1)))) (=> (and (= (type s0@@1) (SeqType T@@114)) (= (type s1@@1) (SeqType T@@114))) (and (=> (< n@@1 (|Seq#Length| s0@@1)) (= (|Seq#Index| (|Seq#Append| s0@@1 s1@@1) n@@1) (|Seq#Index| s0@@1 n@@1))) (=> (<= (|Seq#Length| s0@@1) n@@1) (= (|Seq#Index| (|Seq#Append| s0@@1 s1@@1) n@@1) (|Seq#Index| s1@@1 (- n@@1 (|Seq#Length| s0@@1)))))))) :qid |DafnyPre.832:18| :skolemid |207| :pattern ((|Seq#Index| (|Seq#Append| s0@@1 s1@@1) n@@1)))))
(assert (forall ((s@@20 T@U) (i@@12 Int) (v@@29 T@U)) (! (let ((T@@115 (type v@@29))) (=> (= (type s@@20) (SeqType T@@115)) (=> (and (<= 0 i@@12) (< i@@12 (|Seq#Length| s@@20))) (= (|Seq#Length| (|Seq#Update| s@@20 i@@12 v@@29)) (|Seq#Length| s@@20))))) :qid |DafnyPre.837:18| :skolemid |208| :pattern ((|Seq#Length| (|Seq#Update| s@@20 i@@12 v@@29))))))
(assert (forall ((s@@21 T@U) (i@@13 Int) (v@@30 T@U) (n@@2 Int)) (! (let ((T@@116 (type v@@30))) (=> (= (type s@@21) (SeqType T@@116)) (=> (and (<= 0 n@@2) (< n@@2 (|Seq#Length| s@@21))) (and (=> (= i@@13 n@@2) (= (|Seq#Index| (|Seq#Update| s@@21 i@@13 v@@30) n@@2) v@@30)) (=> (not (= i@@13 n@@2)) (= (|Seq#Index| (|Seq#Update| s@@21 i@@13 v@@30) n@@2) (|Seq#Index| s@@21 n@@2))))))) :qid |DafnyPre.839:18| :skolemid |209| :pattern ((|Seq#Index| (|Seq#Update| s@@21 i@@13 v@@30) n@@2)))))
(assert (forall ((s@@22 T@U) (x@@33 T@U)) (! (let ((T@@117 (type x@@33))) (=> (= (type s@@22) (SeqType T@@117)) (and (=> (|Seq#Contains| s@@22 x@@33) (exists ((i@@14 Int)) (! (and (and (<= 0 i@@14) (< i@@14 (|Seq#Length| s@@22))) (= (|Seq#Index| s@@22 i@@14) x@@33)) :qid |DafnyPre.847:13| :skolemid |210| :pattern ((|Seq#Index| s@@22 i@@14))))) (=> (exists ((i@@15 Int)) (! (and (and (<= 0 i@@15) (< i@@15 (|Seq#Length| s@@22))) (= (|Seq#Index| s@@22 i@@15) x@@33)) :qid |DafnyPre.847:13| :skolemid |210| :pattern ((|Seq#Index| s@@22 i@@15)))) (|Seq#Contains| s@@22 x@@33))))) :qid |DafnyPre.845:18| :skolemid |211| :pattern ((|Seq#Contains| s@@22 x@@33)))))
(assert (forall ((x@@34 T@U)) (! (let ((T@@118 (type x@@34))) (not (|Seq#Contains| (|Seq#Empty| T@@118) x@@34))) :qid |DafnyPre.848:18| :skolemid |212| :pattern ((let ((T@@118 (type x@@34))) (|Seq#Contains| (|Seq#Empty| T@@118) x@@34))))))
(assert (forall ((s0@@2 T@U) (s1@@2 T@U) (x@@35 T@U)) (! (let ((T@@119 (type x@@35))) (=> (and (= (type s0@@2) (SeqType T@@119)) (= (type s1@@2) (SeqType T@@119))) (and (=> (|Seq#Contains| (|Seq#Append| s0@@2 s1@@2) x@@35) (or (|Seq#Contains| s0@@2 x@@35) (|Seq#Contains| s1@@2 x@@35))) (=> (or (|Seq#Contains| s0@@2 x@@35) (|Seq#Contains| s1@@2 x@@35)) (|Seq#Contains| (|Seq#Append| s0@@2 s1@@2) x@@35))))) :qid |DafnyPre.852:18| :skolemid |213| :pattern ((|Seq#Contains| (|Seq#Append| s0@@2 s1@@2) x@@35)))))
(assert (forall ((s@@23 T@U) (v@@31 T@U) (x@@36 T@U)) (! (let ((T@@120 (type v@@31))) (=> (and (= (type s@@23) (SeqType T@@120)) (= (type x@@36) T@@120)) (and (=> (|Seq#Contains| (|Seq#Build| s@@23 v@@31) x@@36) (or (= v@@31 x@@36) (|Seq#Contains| s@@23 x@@36))) (=> (or (= v@@31 x@@36) (|Seq#Contains| s@@23 x@@36)) (|Seq#Contains| (|Seq#Build| s@@23 v@@31) x@@36))))) :qid |DafnyPre.857:18| :skolemid |214| :pattern ((|Seq#Contains| (|Seq#Build| s@@23 v@@31) x@@36)))))
(assert (forall ((arg0@@80 T@U) (arg1@@34 Int)) (! (let ((T@@121 (SeqTypeInv0 (type arg0@@80)))) (= (type (|Seq#Take| arg0@@80 arg1@@34)) (SeqType T@@121))) :qid |funType:Seq#Take| :pattern ((|Seq#Take| arg0@@80 arg1@@34)))))
(assert (forall ((s@@24 T@U) (n@@3 Int) (x@@37 T@U)) (! (let ((T@@122 (type x@@37))) (=> (= (type s@@24) (SeqType T@@122)) (and (=> (|Seq#Contains| (|Seq#Take| s@@24 n@@3) x@@37) (exists ((i@@16 Int)) (! (and (and (and (<= 0 i@@16) (< i@@16 n@@3)) (< i@@16 (|Seq#Length| s@@24))) (= (|Seq#Index| s@@24 i@@16) x@@37)) :qid |DafnyPre.864:13| :skolemid |215| :pattern ((|Seq#Index| s@@24 i@@16))))) (=> (exists ((i@@17 Int)) (! (and (and (and (<= 0 i@@17) (< i@@17 n@@3)) (< i@@17 (|Seq#Length| s@@24))) (= (|Seq#Index| s@@24 i@@17) x@@37)) :qid |DafnyPre.864:13| :skolemid |215| :pattern ((|Seq#Index| s@@24 i@@17)))) (|Seq#Contains| (|Seq#Take| s@@24 n@@3) x@@37))))) :qid |DafnyPre.861:18| :skolemid |216| :pattern ((|Seq#Contains| (|Seq#Take| s@@24 n@@3) x@@37)))))
(assert (forall ((arg0@@81 T@U) (arg1@@35 Int)) (! (let ((T@@123 (SeqTypeInv0 (type arg0@@81)))) (= (type (|Seq#Drop| arg0@@81 arg1@@35)) (SeqType T@@123))) :qid |funType:Seq#Drop| :pattern ((|Seq#Drop| arg0@@81 arg1@@35)))))
(assert (forall ((s@@25 T@U) (n@@4 Int) (x@@38 T@U)) (! (let ((T@@124 (type x@@38))) (=> (= (type s@@25) (SeqType T@@124)) (and (=> (|Seq#Contains| (|Seq#Drop| s@@25 n@@4) x@@38) (exists ((i@@18 Int)) (! (and (and (and (<= 0 n@@4) (<= n@@4 i@@18)) (< i@@18 (|Seq#Length| s@@25))) (= (|Seq#Index| s@@25 i@@18) x@@38)) :qid |DafnyPre.869:13| :skolemid |217| :pattern ((|Seq#Index| s@@25 i@@18))))) (=> (exists ((i@@19 Int)) (! (and (and (and (<= 0 n@@4) (<= n@@4 i@@19)) (< i@@19 (|Seq#Length| s@@25))) (= (|Seq#Index| s@@25 i@@19) x@@38)) :qid |DafnyPre.869:13| :skolemid |217| :pattern ((|Seq#Index| s@@25 i@@19)))) (|Seq#Contains| (|Seq#Drop| s@@25 n@@4) x@@38))))) :qid |DafnyPre.866:18| :skolemid |218| :pattern ((|Seq#Contains| (|Seq#Drop| s@@25 n@@4) x@@38)))))
(assert (forall ((s0@@3 T@U) (s1@@3 T@U)) (! (let ((T@@125 (SeqTypeInv0 (type s0@@3)))) (=> (and (= (type s0@@3) (SeqType T@@125)) (= (type s1@@3) (SeqType T@@125))) (and (=> (|Seq#Equal| s0@@3 s1@@3) (and (= (|Seq#Length| s0@@3) (|Seq#Length| s1@@3)) (forall ((j Int)) (! (=> (and (<= 0 j) (< j (|Seq#Length| s0@@3))) (= (|Seq#Index| s0@@3 j) (|Seq#Index| s1@@3 j))) :qid |DafnyPre.876:13| :skolemid |219| :pattern ((|Seq#Index| s0@@3 j)) :pattern ((|Seq#Index| s1@@3 j)))))) (=> (and (= (|Seq#Length| s0@@3) (|Seq#Length| s1@@3)) (forall ((j@@0 Int)) (! (=> (and (<= 0 j@@0) (< j@@0 (|Seq#Length| s0@@3))) (= (|Seq#Index| s0@@3 j@@0) (|Seq#Index| s1@@3 j@@0))) :qid |DafnyPre.876:13| :skolemid |219| :pattern ((|Seq#Index| s0@@3 j@@0)) :pattern ((|Seq#Index| s1@@3 j@@0))))) (|Seq#Equal| s0@@3 s1@@3))))) :qid |DafnyPre.873:18| :skolemid |220| :pattern ((|Seq#Equal| s0@@3 s1@@3)))))
(assert (forall ((a@@65 T@U) (b@@49 T@U)) (! (let ((T@@126 (SeqTypeInv0 (type a@@65)))) (=> (and (and (= (type a@@65) (SeqType T@@126)) (= (type b@@49) (SeqType T@@126))) (|Seq#Equal| a@@65 b@@49)) (= a@@65 b@@49))) :qid |DafnyPre.878:18| :skolemid |221| :pattern ((|Seq#Equal| a@@65 b@@49)))))
(assert (forall ((s0@@4 T@U) (s1@@4 T@U) (n@@5 Int)) (! (let ((T@@127 (SeqTypeInv0 (type s0@@4)))) (=> (and (= (type s0@@4) (SeqType T@@127)) (= (type s1@@4) (SeqType T@@127))) (and (=> (|Seq#SameUntil| s0@@4 s1@@4 n@@5) (forall ((j@@1 Int)) (! (=> (and (<= 0 j@@1) (< j@@1 n@@5)) (= (|Seq#Index| s0@@4 j@@1) (|Seq#Index| s1@@4 j@@1))) :qid |DafnyPre.884:13| :skolemid |222| :pattern ((|Seq#Index| s0@@4 j@@1)) :pattern ((|Seq#Index| s1@@4 j@@1))))) (=> (forall ((j@@2 Int)) (! (=> (and (<= 0 j@@2) (< j@@2 n@@5)) (= (|Seq#Index| s0@@4 j@@2) (|Seq#Index| s1@@4 j@@2))) :qid |DafnyPre.884:13| :skolemid |222| :pattern ((|Seq#Index| s0@@4 j@@2)) :pattern ((|Seq#Index| s1@@4 j@@2)))) (|Seq#SameUntil| s0@@4 s1@@4 n@@5))))) :qid |DafnyPre.882:18| :skolemid |223| :pattern ((|Seq#SameUntil| s0@@4 s1@@4 n@@5)))))
(assert (forall ((s@@26 T@U) (n@@6 Int)) (! (let ((T@@128 (SeqTypeInv0 (type s@@26)))) (=> (= (type s@@26) (SeqType T@@128)) (=> (and (<= 0 n@@6) (<= n@@6 (|Seq#Length| s@@26))) (= (|Seq#Length| (|Seq#Take| s@@26 n@@6)) n@@6)))) :qid |DafnyPre.888:18| :skolemid |224| :pattern ((|Seq#Length| (|Seq#Take| s@@26 n@@6))))))
(assert (forall ((s@@27 T@U) (n@@7 Int) (j@@3 Int)) (! (let ((T@@129 (SeqTypeInv0 (type s@@27)))) (=> (= (type s@@27) (SeqType T@@129)) (=> (and (and (<= 0 j@@3) (< j@@3 n@@7)) (< j@@3 (|Seq#Length| s@@27))) (= (|Seq#Index| (|Seq#Take| s@@27 n@@7) j@@3) (|Seq#Index| s@@27 j@@3))))) :qid |DafnyPre.890:18| :weight 25 :skolemid |225| :pattern ((|Seq#Index| (|Seq#Take| s@@27 n@@7) j@@3)) :pattern ((|Seq#Index| s@@27 j@@3) (|Seq#Take| s@@27 n@@7)))))
(assert (forall ((s@@28 T@U) (n@@8 Int)) (! (let ((T@@130 (SeqTypeInv0 (type s@@28)))) (=> (= (type s@@28) (SeqType T@@130)) (=> (and (<= 0 n@@8) (<= n@@8 (|Seq#Length| s@@28))) (= (|Seq#Length| (|Seq#Drop| s@@28 n@@8)) (- (|Seq#Length| s@@28) n@@8))))) :qid |DafnyPre.898:18| :skolemid |226| :pattern ((|Seq#Length| (|Seq#Drop| s@@28 n@@8))))))
(assert (forall ((s@@29 T@U) (n@@9 Int) (j@@4 Int)) (! (let ((T@@131 (SeqTypeInv0 (type s@@29)))) (=> (= (type s@@29) (SeqType T@@131)) (=> (and (and (<= 0 n@@9) (<= 0 j@@4)) (< j@@4 (- (|Seq#Length| s@@29) n@@9))) (= (|Seq#Index| (|Seq#Drop| s@@29 n@@9) j@@4) (|Seq#Index| s@@29 (+ j@@4 n@@9)))))) :qid |DafnyPre.900:18| :weight 25 :skolemid |227| :pattern ((|Seq#Index| (|Seq#Drop| s@@29 n@@9) j@@4)))))
(assert (forall ((s@@30 T@U) (n@@10 Int) (k@@3 Int)) (! (let ((T@@132 (SeqTypeInv0 (type s@@30)))) (=> (= (type s@@30) (SeqType T@@132)) (=> (and (and (<= 0 n@@10) (<= n@@10 k@@3)) (< k@@3 (|Seq#Length| s@@30))) (= (|Seq#Index| (|Seq#Drop| s@@30 n@@10) (- k@@3 n@@10)) (|Seq#Index| s@@30 k@@3))))) :qid |DafnyPre.905:18| :weight 25 :skolemid |228| :pattern ((|Seq#Index| s@@30 k@@3) (|Seq#Drop| s@@30 n@@10)))))
(assert (forall ((s@@31 T@U) (t@@28 T@U)) (! (let ((T@@133 (SeqTypeInv0 (type s@@31)))) (=> (and (= (type s@@31) (SeqType T@@133)) (= (type t@@28) (SeqType T@@133))) (and (= (|Seq#Take| (|Seq#Append| s@@31 t@@28) (|Seq#Length| s@@31)) s@@31) (= (|Seq#Drop| (|Seq#Append| s@@31 t@@28) (|Seq#Length| s@@31)) t@@28)))) :qid |DafnyPre.911:18| :skolemid |229| :pattern ((|Seq#Append| s@@31 t@@28)))))
(assert (forall ((arg0@@82 T@U) (arg1@@36 T@U)) (! (= (type (|Seq#FromArray| arg0@@82 arg1@@36)) (SeqType BoxType)) :qid |funType:Seq#FromArray| :pattern ((|Seq#FromArray| arg0@@82 arg1@@36)))))
(assert (forall ((h@@16 T@U) (a@@66 T@U)) (! (=> (and (= (type h@@16) (MapType1Type refType)) (= (type a@@66) refType)) (= (|Seq#Length| (|Seq#FromArray| h@@16 a@@66)) (_System.array.Length a@@66))) :qid |DafnyPre.917:15| :skolemid |230| :pattern ((|Seq#Length| (|Seq#FromArray| h@@16 a@@66))))))
(assert (forall ((h@@17 T@U) (a@@67 T@U)) (! (=> (and (= (type h@@17) (MapType1Type refType)) (= (type a@@67) refType)) (forall ((i@@20 Int)) (! (=> (and (<= 0 i@@20) (< i@@20 (|Seq#Length| (|Seq#FromArray| h@@17 a@@67)))) (= (|Seq#Index| (|Seq#FromArray| h@@17 a@@67) i@@20) (MapType1Select h@@17 a@@67 (IndexField i@@20)))) :qid |DafnyPre.922:11| :skolemid |231| :pattern ((MapType1Select h@@17 a@@67 (IndexField i@@20))) :pattern ((|Seq#Index| (|Seq#FromArray| h@@17 a@@67) i@@20))))) :qid |DafnyPre.920:15| :skolemid |232| :pattern ((|Seq#FromArray| h@@17 a@@67)))))
(assert (forall ((h0 T@U) (h1 T@U) (a@@68 T@U)) (! (=> (and (and (= (type h0) (MapType1Type refType)) (= (type h1) (MapType1Type refType))) (= (type a@@68) refType)) (=> (and (and (and ($IsGoodHeap h0) ($IsGoodHeap h1)) ($HeapSucc h0 h1)) (forall ((i@@21 Int)) (! (=> (and (<= 0 i@@21) (< i@@21 (_System.array.Length a@@68))) (= (MapType1Select h0 a@@68 (IndexField i@@21)) (MapType1Select h1 a@@68 (IndexField i@@21)))) :qid |DafnyPre.935:11| :skolemid |233|))) (= (|Seq#FromArray| h0 a@@68) (|Seq#FromArray| h1 a@@68)))) :qid |DafnyPre.932:15| :skolemid |234| :pattern ((|Seq#FromArray| h1 a@@68) ($HeapSucc h0 h1)))))
(assert (forall ((h@@18 T@U) (i@@22 Int) (v@@32 T@U) (a@@69 T@U)) (! (=> (and (and (and (= (type h@@18) (MapType1Type refType)) (= (type v@@32) BoxType)) (= (type a@@69) refType)) (and (<= 0 i@@22) (< i@@22 (_System.array.Length a@@69)))) (= (|Seq#FromArray| (MapType1Store h@@18 a@@69 (IndexField i@@22) v@@32) a@@69) (|Seq#Update| (|Seq#FromArray| h@@18 a@@69) i@@22 v@@32))) :qid |DafnyPre.939:15| :skolemid |235| :pattern ((|Seq#FromArray| (MapType1Store h@@18 a@@69 (IndexField i@@22) v@@32) a@@69)))))
(assert (forall ((s@@32 T@U) (i@@23 Int) (v@@33 T@U) (n@@11 Int)) (! (let ((T@@134 (type v@@33))) (=> (= (type s@@32) (SeqType T@@134)) (=> (and (and (<= 0 i@@23) (< i@@23 n@@11)) (<= n@@11 (|Seq#Length| s@@32))) (= (|Seq#Take| (|Seq#Update| s@@32 i@@23 v@@33) n@@11) (|Seq#Update| (|Seq#Take| s@@32 n@@11) i@@23 v@@33))))) :qid |DafnyPre.944:18| :skolemid |236| :pattern ((|Seq#Take| (|Seq#Update| s@@32 i@@23 v@@33) n@@11)))))
(assert (forall ((s@@33 T@U) (i@@24 Int) (v@@34 T@U) (n@@12 Int)) (! (let ((T@@135 (type v@@34))) (=> (= (type s@@33) (SeqType T@@135)) (=> (and (<= n@@12 i@@24) (< i@@24 (|Seq#Length| s@@33))) (= (|Seq#Take| (|Seq#Update| s@@33 i@@24 v@@34) n@@12) (|Seq#Take| s@@33 n@@12))))) :qid |DafnyPre.947:18| :skolemid |237| :pattern ((|Seq#Take| (|Seq#Update| s@@33 i@@24 v@@34) n@@12)))))
(assert (forall ((s@@34 T@U) (i@@25 Int) (v@@35 T@U) (n@@13 Int)) (! (let ((T@@136 (type v@@35))) (=> (= (type s@@34) (SeqType T@@136)) (=> (and (and (<= 0 n@@13) (<= n@@13 i@@25)) (< i@@25 (|Seq#Length| s@@34))) (= (|Seq#Drop| (|Seq#Update| s@@34 i@@25 v@@35) n@@13) (|Seq#Update| (|Seq#Drop| s@@34 n@@13) (- i@@25 n@@13) v@@35))))) :qid |DafnyPre.950:18| :skolemid |238| :pattern ((|Seq#Drop| (|Seq#Update| s@@34 i@@25 v@@35) n@@13)))))
(assert (forall ((s@@35 T@U) (i@@26 Int) (v@@36 T@U) (n@@14 Int)) (! (let ((T@@137 (type v@@36))) (=> (= (type s@@35) (SeqType T@@137)) (=> (and (and (<= 0 i@@26) (< i@@26 n@@14)) (< n@@14 (|Seq#Length| s@@35))) (= (|Seq#Drop| (|Seq#Update| s@@35 i@@26 v@@36) n@@14) (|Seq#Drop| s@@35 n@@14))))) :qid |DafnyPre.953:18| :skolemid |239| :pattern ((|Seq#Drop| (|Seq#Update| s@@35 i@@26 v@@36) n@@14)))))
(assert (forall ((h@@19 T@U) (a@@70 T@U) (n0 Int) (n1 Int)) (! (=> (and (= (type h@@19) (MapType1Type refType)) (= (type a@@70) refType)) (=> (and (and (= (+ n0 1) n1) (<= 0 n0)) (<= n1 (_System.array.Length a@@70))) (= (|Seq#Take| (|Seq#FromArray| h@@19 a@@70) n1) (|Seq#Build| (|Seq#Take| (|Seq#FromArray| h@@19 a@@70) n0) (MapType1Select h@@19 a@@70 (IndexField n0)))))) :qid |DafnyPre.957:15| :skolemid |240| :pattern ((|Seq#Take| (|Seq#FromArray| h@@19 a@@70) n0) (|Seq#Take| (|Seq#FromArray| h@@19 a@@70) n1)))))
(assert (forall ((s@@36 T@U) (v@@37 T@U) (n@@15 Int)) (! (let ((T@@138 (type v@@37))) (=> (= (type s@@36) (SeqType T@@138)) (=> (and (<= 0 n@@15) (<= n@@15 (|Seq#Length| s@@36))) (= (|Seq#Drop| (|Seq#Build| s@@36 v@@37) n@@15) (|Seq#Build| (|Seq#Drop| s@@36 n@@15) v@@37))))) :qid |DafnyPre.961:18| :skolemid |241| :pattern ((|Seq#Drop| (|Seq#Build| s@@36 v@@37) n@@15)))))
(assert (forall ((s@@37 T@U) (i@@27 Int)) (! (=> (= (type s@@37) (SeqType BoxType)) (=> (and (<= 0 i@@27) (< i@@27 (|Seq#Length| s@@37))) (< (DtRank ($Unbox DatatypeTypeType (|Seq#Index| s@@37 i@@27))) (|Seq#Rank| s@@37)))) :qid |DafnyPre.966:15| :skolemid |242| :pattern ((DtRank ($Unbox DatatypeTypeType (|Seq#Index| s@@37 i@@27)))))))
(assert (forall ((s@@38 T@U) (i@@28 Int)) (! (let ((T@@139 (SeqTypeInv0 (type s@@38)))) (=> (= (type s@@38) (SeqType T@@139)) (=> (and (< 0 i@@28) (<= i@@28 (|Seq#Length| s@@38))) (< (|Seq#Rank| (|Seq#Drop| s@@38 i@@28)) (|Seq#Rank| s@@38))))) :qid |DafnyPre.969:18| :skolemid |243| :pattern ((|Seq#Rank| (|Seq#Drop| s@@38 i@@28))))))
(assert (forall ((s@@39 T@U) (i@@29 Int)) (! (let ((T@@140 (SeqTypeInv0 (type s@@39)))) (=> (= (type s@@39) (SeqType T@@140)) (=> (and (<= 0 i@@29) (< i@@29 (|Seq#Length| s@@39))) (< (|Seq#Rank| (|Seq#Take| s@@39 i@@29)) (|Seq#Rank| s@@39))))) :qid |DafnyPre.972:18| :skolemid |244| :pattern ((|Seq#Rank| (|Seq#Take| s@@39 i@@29))))))
(assert (forall ((s@@40 T@U) (i@@30 Int) (j@@5 Int)) (! (let ((T@@141 (SeqTypeInv0 (type s@@40)))) (=> (= (type s@@40) (SeqType T@@141)) (=> (and (and (<= 0 i@@30) (< i@@30 j@@5)) (<= j@@5 (|Seq#Length| s@@40))) (< (|Seq#Rank| (|Seq#Append| (|Seq#Take| s@@40 i@@30) (|Seq#Drop| s@@40 j@@5))) (|Seq#Rank| s@@40))))) :qid |DafnyPre.975:18| :skolemid |245| :pattern ((|Seq#Rank| (|Seq#Append| (|Seq#Take| s@@40 i@@30) (|Seq#Drop| s@@40 j@@5)))))))
(assert (forall ((s@@41 T@U) (n@@16 Int)) (! (let ((T@@142 (SeqTypeInv0 (type s@@41)))) (=> (and (= (type s@@41) (SeqType T@@142)) (= n@@16 0)) (= (|Seq#Drop| s@@41 n@@16) s@@41))) :qid |DafnyPre.980:18| :skolemid |246| :pattern ((|Seq#Drop| s@@41 n@@16)))))
(assert (forall ((s@@42 T@U) (n@@17 Int)) (! (let ((T@@143 (SeqTypeInv0 (type s@@42)))) (=> (and (= (type s@@42) (SeqType T@@143)) (= n@@17 0)) (= (|Seq#Take| s@@42 n@@17) (|Seq#Empty| T@@143)))) :qid |DafnyPre.982:18| :skolemid |247| :pattern ((|Seq#Take| s@@42 n@@17)))))
(assert (forall ((s@@43 T@U) (m@@6 Int) (n@@18 Int)) (! (let ((T@@144 (SeqTypeInv0 (type s@@43)))) (=> (= (type s@@43) (SeqType T@@144)) (=> (and (and (<= 0 m@@6) (<= 0 n@@18)) (<= (+ m@@6 n@@18) (|Seq#Length| s@@43))) (= (|Seq#Drop| (|Seq#Drop| s@@43 m@@6) n@@18) (|Seq#Drop| s@@43 (+ m@@6 n@@18)))))) :qid |DafnyPre.984:18| :skolemid |248| :pattern ((|Seq#Drop| (|Seq#Drop| s@@43 m@@6) n@@18)))))
(assert (forall ((m@@7 T@U)) (! (let ((V@@1 (MapTypeInv1 (type m@@7)))) (let ((U@@3 (MapTypeInv0 (type m@@7)))) (=> (= (type m@@7) (MapType U@@3 V@@1)) (<= 0 (|Map#Card| m@@7))))) :qid |DafnyPre.998:21| :skolemid |249| :pattern ((|Map#Card| m@@7)))))
(assert (forall ((U@@4 T@T) (V@@2 T@T)) (! (= (type (|Map#Empty| U@@4 V@@2)) (MapType U@@4 V@@2)) :qid |funType:Map#Empty| :pattern ((|Map#Empty| U@@4 V@@2)))))
(assert (forall ((u@@5 T@U) (V@@3 T@T)) (! (let ((U@@5 (type u@@5))) (not (U_2_bool (MapType0Select (|Map#Domain| (|Map#Empty| U@@5 V@@3)) u@@5)))) :qid |DafnyPre.1001:21| :skolemid |250| :pattern ((let ((U@@5 (type u@@5))) (MapType0Select (|Map#Domain| (|Map#Empty| U@@5 V@@3)) u@@5))))))
(assert (forall ((m@@8 T@U)) (! (let ((V@@4 (MapTypeInv1 (type m@@8)))) (let ((U@@6 (MapTypeInv0 (type m@@8)))) (=> (= (type m@@8) (MapType U@@6 V@@4)) (and (and (=> (= (|Map#Card| m@@8) 0) (= m@@8 (|Map#Empty| U@@6 V@@4))) (=> (= m@@8 (|Map#Empty| U@@6 V@@4)) (= (|Map#Card| m@@8) 0))) (=> (not (= (|Map#Card| m@@8) 0)) (exists ((x@@39 T@U)) (! (and (= (type x@@39) U@@6) (U_2_bool (MapType0Select (|Map#Domain| m@@8) x@@39))) :qid |DafnyPre.1006:32| :skolemid |251| :no-pattern (type x@@39) :no-pattern (U_2_int x@@39) :no-pattern (U_2_bool x@@39)))))))) :qid |DafnyPre.1004:21| :skolemid |252| :pattern ((|Map#Card| m@@8)))))
(assert (forall ((arg0@@83 T@U) (arg1@@37 T@U) (arg2@@3 T@U)) (! (let ((V@@5 (MapType0TypeInv1 (type arg1@@37)))) (let ((U@@7 (MapType0TypeInv0 (type arg0@@83)))) (= (type (|Map#Glue| arg0@@83 arg1@@37 arg2@@3)) (MapType U@@7 V@@5)))) :qid |funType:Map#Glue| :pattern ((|Map#Glue| arg0@@83 arg1@@37 arg2@@3)))))
(assert (forall ((a@@71 T@U) (b@@50 T@U) (t@@29 T@U)) (! (let ((V@@6 (MapType0TypeInv1 (type b@@50)))) (let ((U@@8 (MapType0TypeInv0 (type a@@71)))) (=> (and (and (= (type a@@71) (MapType0Type U@@8 boolType)) (= (type b@@50) (MapType0Type U@@8 V@@6))) (= (type t@@29) TyType)) (= (|Map#Domain| (|Map#Glue| a@@71 b@@50 t@@29)) a@@71)))) :qid |DafnyPre.1009:21| :skolemid |253| :pattern ((|Map#Domain| (|Map#Glue| a@@71 b@@50 t@@29))))))
(assert (forall ((a@@72 T@U) (b@@51 T@U) (t@@30 T@U)) (! (let ((V@@7 (MapType0TypeInv1 (type b@@51)))) (let ((U@@9 (MapType0TypeInv0 (type a@@72)))) (=> (and (and (= (type a@@72) (MapType0Type U@@9 boolType)) (= (type b@@51) (MapType0Type U@@9 V@@7))) (= (type t@@30) TyType)) (= (|Map#Elements| (|Map#Glue| a@@72 b@@51 t@@30)) b@@51)))) :qid |DafnyPre.1012:21| :skolemid |254| :pattern ((|Map#Elements| (|Map#Glue| a@@72 b@@51 t@@30))))))
(assert (forall ((a@@73 T@U) (b@@52 T@U) (t@@31 T@U)) (! (let ((V@@8 (MapType0TypeInv1 (type b@@52)))) (let ((U@@10 (MapType0TypeInv0 (type a@@73)))) (=> (and (and (= (type a@@73) (MapType0Type U@@10 boolType)) (= (type b@@52) (MapType0Type U@@10 V@@8))) (= (type t@@31) TyType)) ($Is (|Map#Glue| a@@73 b@@52 t@@31) t@@31)))) :qid |DafnyPre.1015:21| :skolemid |255| :pattern (($Is (|Map#Glue| a@@73 b@@52 t@@31) t@@31)))))
(assert (forall ((arg0@@84 T@U) (arg1@@38 T@U) (arg2@@4 T@U)) (! (let ((V@@9 (type arg2@@4))) (let ((U@@11 (type arg1@@38))) (= (type (|Map#Build| arg0@@84 arg1@@38 arg2@@4)) (MapType U@@11 V@@9)))) :qid |funType:Map#Build| :pattern ((|Map#Build| arg0@@84 arg1@@38 arg2@@4)))))
(assert (forall ((m@@9 T@U) (u@@6 T@U) (|u'| T@U) (v@@38 T@U)) (! (let ((V@@10 (type v@@38))) (let ((U@@12 (type u@@6))) (=> (and (= (type m@@9) (MapType U@@12 V@@10)) (= (type |u'|) U@@12)) (and (=> (= |u'| u@@6) (and (U_2_bool (MapType0Select (|Map#Domain| (|Map#Build| m@@9 u@@6 v@@38)) |u'|)) (= (MapType0Select (|Map#Elements| (|Map#Build| m@@9 u@@6 v@@38)) |u'|) v@@38))) (=> (not (= |u'| u@@6)) (and (and (=> (U_2_bool (MapType0Select (|Map#Domain| (|Map#Build| m@@9 u@@6 v@@38)) |u'|)) (U_2_bool (MapType0Select (|Map#Domain| m@@9) |u'|))) (=> (U_2_bool (MapType0Select (|Map#Domain| m@@9) |u'|)) (U_2_bool (MapType0Select (|Map#Domain| (|Map#Build| m@@9 u@@6 v@@38)) |u'|)))) (= (MapType0Select (|Map#Elements| (|Map#Build| m@@9 u@@6 v@@38)) |u'|) (MapType0Select (|Map#Elements| m@@9) |u'|)))))))) :qid |DafnyPre.1026:21| :skolemid |256| :pattern ((MapType0Select (|Map#Domain| (|Map#Build| m@@9 u@@6 v@@38)) |u'|)) :pattern ((MapType0Select (|Map#Elements| (|Map#Build| m@@9 u@@6 v@@38)) |u'|)))))
(assert (forall ((m@@10 T@U) (u@@7 T@U) (v@@39 T@U)) (! (let ((V@@11 (type v@@39))) (let ((U@@13 (type u@@7))) (=> (and (= (type m@@10) (MapType U@@13 V@@11)) (U_2_bool (MapType0Select (|Map#Domain| m@@10) u@@7))) (= (|Map#Card| (|Map#Build| m@@10 u@@7 v@@39)) (|Map#Card| m@@10))))) :qid |DafnyPre.1032:21| :skolemid |257| :pattern ((|Map#Card| (|Map#Build| m@@10 u@@7 v@@39))))))
(assert (forall ((m@@11 T@U) (u@@8 T@U) (v@@40 T@U)) (! (let ((V@@12 (type v@@40))) (let ((U@@14 (type u@@8))) (=> (and (= (type m@@11) (MapType U@@14 V@@12)) (not (U_2_bool (MapType0Select (|Map#Domain| m@@11) u@@8)))) (= (|Map#Card| (|Map#Build| m@@11 u@@8 v@@40)) (+ (|Map#Card| m@@11) 1))))) :qid |DafnyPre.1034:21| :skolemid |258| :pattern ((|Map#Card| (|Map#Build| m@@11 u@@8 v@@40))))))
(assert (forall ((m@@12 T@U) (|m'| T@U)) (! (let ((V@@13 (MapTypeInv1 (type m@@12)))) (let ((U@@15 (MapTypeInv0 (type m@@12)))) (=> (and (= (type m@@12) (MapType U@@15 V@@13)) (= (type |m'|) (MapType U@@15 V@@13))) (and (=> (|Map#Equal| m@@12 |m'|) (and (forall ((u@@9 T@U)) (! (=> (= (type u@@9) U@@15) (and (=> (U_2_bool (MapType0Select (|Map#Domain| m@@12) u@@9)) (U_2_bool (MapType0Select (|Map#Domain| |m'|) u@@9))) (=> (U_2_bool (MapType0Select (|Map#Domain| |m'|) u@@9)) (U_2_bool (MapType0Select (|Map#Domain| m@@12) u@@9))))) :qid |DafnyPre.1042:35| :skolemid |259| :no-pattern (type u@@9) :no-pattern (U_2_int u@@9) :no-pattern (U_2_bool u@@9))) (forall ((u@@10 T@U)) (! (=> (and (= (type u@@10) U@@15) (U_2_bool (MapType0Select (|Map#Domain| m@@12) u@@10))) (= (MapType0Select (|Map#Elements| m@@12) u@@10) (MapType0Select (|Map#Elements| |m'|) u@@10))) :qid |DafnyPre.1043:35| :skolemid |260| :no-pattern (type u@@10) :no-pattern (U_2_int u@@10) :no-pattern (U_2_bool u@@10))))) (=> (and (forall ((u@@11 T@U)) (! (=> (= (type u@@11) U@@15) (and (=> (U_2_bool (MapType0Select (|Map#Domain| m@@12) u@@11)) (U_2_bool (MapType0Select (|Map#Domain| |m'|) u@@11))) (=> (U_2_bool (MapType0Select (|Map#Domain| |m'|) u@@11)) (U_2_bool (MapType0Select (|Map#Domain| m@@12) u@@11))))) :qid |DafnyPre.1042:35| :skolemid |259| :no-pattern (type u@@11) :no-pattern (U_2_int u@@11) :no-pattern (U_2_bool u@@11))) (forall ((u@@12 T@U)) (! (=> (and (= (type u@@12) U@@15) (U_2_bool (MapType0Select (|Map#Domain| m@@12) u@@12))) (= (MapType0Select (|Map#Elements| m@@12) u@@12) (MapType0Select (|Map#Elements| |m'|) u@@12))) :qid |DafnyPre.1043:35| :skolemid |260| :no-pattern (type u@@12) :no-pattern (U_2_int u@@12) :no-pattern (U_2_bool u@@12)))) (|Map#Equal| m@@12 |m'|)))))) :qid |DafnyPre.1040:21| :skolemid |261| :pattern ((|Map#Equal| m@@12 |m'|)))))
(assert (forall ((m@@13 T@U) (|m'@@0| T@U)) (! (let ((V@@14 (MapTypeInv1 (type m@@13)))) (let ((U@@16 (MapTypeInv0 (type m@@13)))) (=> (and (and (= (type m@@13) (MapType U@@16 V@@14)) (= (type |m'@@0|) (MapType U@@16 V@@14))) (|Map#Equal| m@@13 |m'@@0|)) (= m@@13 |m'@@0|)))) :qid |DafnyPre.1045:21| :skolemid |262| :pattern ((|Map#Equal| m@@13 |m'@@0|)))))
(assert (forall ((m@@14 T@U) (|m'@@1| T@U)) (! (let ((V@@15 (MapTypeInv1 (type m@@14)))) (let ((U@@17 (MapTypeInv0 (type m@@14)))) (=> (and (= (type m@@14) (MapType U@@17 V@@15)) (= (type |m'@@1|) (MapType U@@17 V@@15))) (and (=> (|Map#Disjoint| m@@14 |m'@@1|) (forall ((o@@37 T@U)) (! (=> (= (type o@@37) U@@17) (or (not (U_2_bool (MapType0Select (|Map#Domain| m@@14) o@@37))) (not (U_2_bool (MapType0Select (|Map#Domain| |m'@@1|) o@@37))))) :qid |DafnyPre.1052:38| :skolemid |263| :pattern ((MapType0Select (|Map#Domain| m@@14) o@@37)) :pattern ((MapType0Select (|Map#Domain| |m'@@1|) o@@37))))) (=> (forall ((o@@38 T@U)) (! (=> (= (type o@@38) U@@17) (or (not (U_2_bool (MapType0Select (|Map#Domain| m@@14) o@@38))) (not (U_2_bool (MapType0Select (|Map#Domain| |m'@@1|) o@@38))))) :qid |DafnyPre.1052:38| :skolemid |263| :pattern ((MapType0Select (|Map#Domain| m@@14) o@@38)) :pattern ((MapType0Select (|Map#Domain| |m'@@1|) o@@38)))) (|Map#Disjoint| m@@14 |m'@@1|)))))) :qid |DafnyPre.1050:21| :skolemid |264| :pattern ((|Map#Disjoint| m@@14 |m'@@1|)))))
(assert (forall ((U@@18 T@T) (V@@16 T@T)) (! (= (type (|IMap#Empty| U@@18 V@@16)) (IMapType U@@18 V@@16)) :qid |funType:IMap#Empty| :pattern ((|IMap#Empty| U@@18 V@@16)))))
(assert (forall ((u@@13 T@U) (V@@17 T@T)) (! (let ((U@@19 (type u@@13))) (not (U_2_bool (MapType0Select (|IMap#Domain| (|IMap#Empty| U@@19 V@@17)) u@@13)))) :qid |DafnyPre.1064:21| :skolemid |265| :pattern ((let ((U@@19 (type u@@13))) (MapType0Select (|IMap#Domain| (|IMap#Empty| U@@19 V@@17)) u@@13))))))
(assert (forall ((arg0@@85 T@U) (arg1@@39 T@U) (arg2@@5 T@U)) (! (let ((V@@18 (MapType0TypeInv1 (type arg1@@39)))) (let ((U@@20 (MapType0TypeInv0 (type arg0@@85)))) (= (type (|IMap#Glue| arg0@@85 arg1@@39 arg2@@5)) (IMapType U@@20 V@@18)))) :qid |funType:IMap#Glue| :pattern ((|IMap#Glue| arg0@@85 arg1@@39 arg2@@5)))))
(assert (forall ((a@@74 T@U) (b@@53 T@U) (t@@32 T@U)) (! (let ((V@@19 (MapType0TypeInv1 (type b@@53)))) (let ((U@@21 (MapType0TypeInv0 (type a@@74)))) (=> (and (and (= (type a@@74) (MapType0Type U@@21 boolType)) (= (type b@@53) (MapType0Type U@@21 V@@19))) (= (type t@@32) TyType)) (= (|IMap#Domain| (|IMap#Glue| a@@74 b@@53 t@@32)) a@@74)))) :qid |DafnyPre.1069:21| :skolemid |266| :pattern ((|IMap#Domain| (|IMap#Glue| a@@74 b@@53 t@@32))))))
(assert (forall ((a@@75 T@U) (b@@54 T@U) (t@@33 T@U)) (! (let ((V@@20 (MapType0TypeInv1 (type b@@54)))) (let ((U@@22 (MapType0TypeInv0 (type a@@75)))) (=> (and (and (= (type a@@75) (MapType0Type U@@22 boolType)) (= (type b@@54) (MapType0Type U@@22 V@@20))) (= (type t@@33) TyType)) (= (|IMap#Elements| (|IMap#Glue| a@@75 b@@54 t@@33)) b@@54)))) :qid |DafnyPre.1072:21| :skolemid |267| :pattern ((|IMap#Elements| (|IMap#Glue| a@@75 b@@54 t@@33))))))
(assert (forall ((a@@76 T@U) (b@@55 T@U) (t@@34 T@U)) (! (let ((V@@21 (MapType0TypeInv1 (type b@@55)))) (let ((U@@23 (MapType0TypeInv0 (type a@@76)))) (=> (and (and (= (type a@@76) (MapType0Type U@@23 boolType)) (= (type b@@55) (MapType0Type U@@23 V@@21))) (= (type t@@34) TyType)) ($Is (|IMap#Glue| a@@76 b@@55 t@@34) t@@34)))) :qid |DafnyPre.1075:21| :skolemid |268| :pattern (($Is (|IMap#Glue| a@@76 b@@55 t@@34) t@@34)))))
(assert (forall ((arg0@@86 T@U) (arg1@@40 T@U) (arg2@@6 T@U)) (! (let ((V@@22 (type arg2@@6))) (let ((U@@24 (type arg1@@40))) (= (type (|IMap#Build| arg0@@86 arg1@@40 arg2@@6)) (IMapType U@@24 V@@22)))) :qid |funType:IMap#Build| :pattern ((|IMap#Build| arg0@@86 arg1@@40 arg2@@6)))))
(assert (forall ((m@@15 T@U) (u@@14 T@U) (|u'@@0| T@U) (v@@41 T@U)) (! (let ((V@@23 (type v@@41))) (let ((U@@25 (type u@@14))) (=> (and (= (type m@@15) (IMapType U@@25 V@@23)) (= (type |u'@@0|) U@@25)) (and (=> (= |u'@@0| u@@14) (and (U_2_bool (MapType0Select (|IMap#Domain| (|IMap#Build| m@@15 u@@14 v@@41)) |u'@@0|)) (= (MapType0Select (|IMap#Elements| (|IMap#Build| m@@15 u@@14 v@@41)) |u'@@0|) v@@41))) (=> (not (= |u'@@0| u@@14)) (and (and (=> (U_2_bool (MapType0Select (|IMap#Domain| (|IMap#Build| m@@15 u@@14 v@@41)) |u'@@0|)) (U_2_bool (MapType0Select (|IMap#Domain| m@@15) |u'@@0|))) (=> (U_2_bool (MapType0Select (|IMap#Domain| m@@15) |u'@@0|)) (U_2_bool (MapType0Select (|IMap#Domain| (|IMap#Build| m@@15 u@@14 v@@41)) |u'@@0|)))) (= (MapType0Select (|IMap#Elements| (|IMap#Build| m@@15 u@@14 v@@41)) |u'@@0|) (MapType0Select (|IMap#Elements| m@@15) |u'@@0|)))))))) :qid |DafnyPre.1085:21| :skolemid |269| :pattern ((MapType0Select (|IMap#Domain| (|IMap#Build| m@@15 u@@14 v@@41)) |u'@@0|)) :pattern ((MapType0Select (|IMap#Elements| (|IMap#Build| m@@15 u@@14 v@@41)) |u'@@0|)))))
(assert (forall ((m@@16 T@U) (|m'@@2| T@U)) (! (let ((V@@24 (IMapTypeInv1 (type m@@16)))) (let ((U@@26 (IMapTypeInv0 (type m@@16)))) (=> (and (= (type m@@16) (IMapType U@@26 V@@24)) (= (type |m'@@2|) (IMapType U@@26 V@@24))) (and (=> (|IMap#Equal| m@@16 |m'@@2|) (and (forall ((u@@15 T@U)) (! (=> (= (type u@@15) U@@26) (and (=> (U_2_bool (MapType0Select (|IMap#Domain| m@@16) u@@15)) (U_2_bool (MapType0Select (|IMap#Domain| |m'@@2|) u@@15))) (=> (U_2_bool (MapType0Select (|IMap#Domain| |m'@@2|) u@@15)) (U_2_bool (MapType0Select (|IMap#Domain| m@@16) u@@15))))) :qid |DafnyPre.1096:36| :skolemid |270| :no-pattern (type u@@15) :no-pattern (U_2_int u@@15) :no-pattern (U_2_bool u@@15))) (forall ((u@@16 T@U)) (! (=> (and (= (type u@@16) U@@26) (U_2_bool (MapType0Select (|IMap#Domain| m@@16) u@@16))) (= (MapType0Select (|IMap#Elements| m@@16) u@@16) (MapType0Select (|IMap#Elements| |m'@@2|) u@@16))) :qid |DafnyPre.1097:35| :skolemid |271| :no-pattern (type u@@16) :no-pattern (U_2_int u@@16) :no-pattern (U_2_bool u@@16))))) (=> (and (forall ((u@@17 T@U)) (! (=> (= (type u@@17) U@@26) (and (=> (U_2_bool (MapType0Select (|IMap#Domain| m@@16) u@@17)) (U_2_bool (MapType0Select (|IMap#Domain| |m'@@2|) u@@17))) (=> (U_2_bool (MapType0Select (|IMap#Domain| |m'@@2|) u@@17)) (U_2_bool (MapType0Select (|IMap#Domain| m@@16) u@@17))))) :qid |DafnyPre.1096:36| :skolemid |270| :no-pattern (type u@@17) :no-pattern (U_2_int u@@17) :no-pattern (U_2_bool u@@17))) (forall ((u@@18 T@U)) (! (=> (and (= (type u@@18) U@@26) (U_2_bool (MapType0Select (|IMap#Domain| m@@16) u@@18))) (= (MapType0Select (|IMap#Elements| m@@16) u@@18) (MapType0Select (|IMap#Elements| |m'@@2|) u@@18))) :qid |DafnyPre.1097:35| :skolemid |271| :no-pattern (type u@@18) :no-pattern (U_2_int u@@18) :no-pattern (U_2_bool u@@18)))) (|IMap#Equal| m@@16 |m'@@2|)))))) :qid |DafnyPre.1094:21| :skolemid |272| :pattern ((|IMap#Equal| m@@16 |m'@@2|)))))
(assert (forall ((m@@17 T@U) (|m'@@3| T@U)) (! (let ((V@@25 (IMapTypeInv1 (type m@@17)))) (let ((U@@27 (IMapTypeInv0 (type m@@17)))) (=> (and (and (= (type m@@17) (IMapType U@@27 V@@25)) (= (type |m'@@3|) (IMapType U@@27 V@@25))) (|IMap#Equal| m@@17 |m'@@3|)) (= m@@17 |m'@@3|)))) :qid |DafnyPre.1099:21| :skolemid |273| :pattern ((|IMap#Equal| m@@17 |m'@@3|)))))
(assert (forall ((x@@40 Int) (y@@12 Int)) (! (= (INTERNAL_add_boogie x@@40 y@@12) (+ x@@40 y@@12)) :qid |DafnyPre.1107:30| :skolemid |274| :pattern ((INTERNAL_add_boogie x@@40 y@@12)))))
(assert (forall ((x@@41 Int) (y@@13 Int)) (! (= (INTERNAL_sub_boogie x@@41 y@@13) (- x@@41 y@@13)) :qid |DafnyPre.1108:30| :skolemid |275| :pattern ((INTERNAL_sub_boogie x@@41 y@@13)))))
(assert (forall ((x@@42 Int) (y@@14 Int)) (! (= (INTERNAL_mul_boogie x@@42 y@@14) (* x@@42 y@@14)) :qid |DafnyPre.1109:30| :skolemid |276| :pattern ((INTERNAL_mul_boogie x@@42 y@@14)))))
(assert (forall ((x@@43 Int) (y@@15 Int)) (! (= (INTERNAL_div_boogie x@@43 y@@15) (div x@@43 y@@15)) :qid |DafnyPre.1110:30| :skolemid |277| :pattern ((INTERNAL_div_boogie x@@43 y@@15)))))
(assert (forall ((x@@44 Int) (y@@16 Int)) (! (= (INTERNAL_mod_boogie x@@44 y@@16) (mod x@@44 y@@16)) :qid |DafnyPre.1111:30| :skolemid |278| :pattern ((INTERNAL_mod_boogie x@@44 y@@16)))))
(assert (forall ((x@@45 Int) (y@@17 Int)) (! (and (=> (INTERNAL_lt_boogie x@@45 y@@17) (< x@@45 y@@17)) (=> (< x@@45 y@@17) (INTERNAL_lt_boogie x@@45 y@@17))) :qid |DafnyPre.1112:51| :skolemid |279| :pattern ((INTERNAL_lt_boogie x@@45 y@@17)))))
(assert (forall ((x@@46 Int) (y@@18 Int)) (! (and (=> (INTERNAL_le_boogie x@@46 y@@18) (<= x@@46 y@@18)) (=> (<= x@@46 y@@18) (INTERNAL_le_boogie x@@46 y@@18))) :qid |DafnyPre.1113:51| :skolemid |280| :pattern ((INTERNAL_le_boogie x@@46 y@@18)))))
(assert (forall ((x@@47 Int) (y@@19 Int)) (! (and (=> (INTERNAL_gt_boogie x@@47 y@@19) (> x@@47 y@@19)) (=> (> x@@47 y@@19) (INTERNAL_gt_boogie x@@47 y@@19))) :qid |DafnyPre.1114:51| :skolemid |281| :pattern ((INTERNAL_gt_boogie x@@47 y@@19)))))
(assert (forall ((x@@48 Int) (y@@20 Int)) (! (and (=> (INTERNAL_ge_boogie x@@48 y@@20) (>= x@@48 y@@20)) (=> (>= x@@48 y@@20) (INTERNAL_ge_boogie x@@48 y@@20))) :qid |DafnyPre.1115:51| :skolemid |282| :pattern ((INTERNAL_ge_boogie x@@48 y@@20)))))
(assert (= (Tag Tclass._System.object) Tagclass._System.object))
(assert (forall ((bx@@35 T@U)) (! (=> (and (= (type bx@@35) BoxType) ($IsBox bx@@35 Tclass._System.object)) (and (= ($Box ($Unbox refType bx@@35)) bx@@35) ($Is ($Unbox refType bx@@35) Tclass._System.object))) :qid |unknown.0:0| :skolemid |283| :pattern (($IsBox bx@@35 Tclass._System.object)))))
(assert (forall (($o T@U)) (! (=> (= (type $o) refType) ($Is $o Tclass._System.object)) :qid |unknown.0:0| :skolemid |284| :pattern (($Is $o Tclass._System.object)))))
(assert (= (type null) refType))
(assert (forall (($o@@0 T@U) ($h T@U)) (! (=> (and (= (type $o@@0) refType) (= (type $h) (MapType1Type refType))) (and (=> ($IsAlloc $o@@0 Tclass._System.object $h) (or (= $o@@0 null) (U_2_bool (MapType1Select $h $o@@0 alloc)))) (=> (or (= $o@@0 null) (U_2_bool (MapType1Select $h $o@@0 alloc))) ($IsAlloc $o@@0 Tclass._System.object $h)))) :qid |unknown.0:0| :skolemid |285| :pattern (($IsAlloc $o@@0 Tclass._System.object $h)))))
(assert (forall ((arg0@@87 T@U)) (! (= (type (Tclass._System.array arg0@@87)) TyType) :qid |funType:Tclass._System.array| :pattern ((Tclass._System.array arg0@@87)))))
(assert (forall ((|#$arg| T@U)) (! (=> (= (type |#$arg|) TyType) (= (Tag (Tclass._System.array |#$arg|)) Tagclass._System.array)) :qid |unknown.0:0| :skolemid |286| :pattern ((Tclass._System.array |#$arg|)))))
(assert (forall ((arg0@@88 T@U)) (! (= (type (Tclass._System.array_0 arg0@@88)) TyType) :qid |funType:Tclass._System.array_0| :pattern ((Tclass._System.array_0 arg0@@88)))))
(assert (forall ((|#$arg@@0| T@U)) (! (=> (= (type |#$arg@@0|) TyType) (= (Tclass._System.array_0 (Tclass._System.array |#$arg@@0|)) |#$arg@@0|)) :qid |unknown.0:0| :skolemid |287| :pattern ((Tclass._System.array |#$arg@@0|)))))
(assert (forall ((|#$arg@@1| T@U) (bx@@36 T@U)) (! (=> (and (and (= (type |#$arg@@1|) TyType) (= (type bx@@36) BoxType)) ($IsBox bx@@36 (Tclass._System.array |#$arg@@1|))) (and (= ($Box ($Unbox refType bx@@36)) bx@@36) ($Is ($Unbox refType bx@@36) (Tclass._System.array |#$arg@@1|)))) :qid |unknown.0:0| :skolemid |288| :pattern (($IsBox bx@@36 (Tclass._System.array |#$arg@@1|))))))
(assert (forall ((arg0@@89 T@U)) (! (= (type (dtype arg0@@89)) TyType) :qid |funType:dtype| :pattern ((dtype arg0@@89)))))
(assert (forall ((|#$arg@@2| T@U) ($i0 Int) ($h@@0 T@U) ($o@@1 T@U)) (! (=> (and (and (= (type |#$arg@@2|) TyType) (= (type $h@@0) (MapType1Type refType))) (= (type $o@@1) refType)) (=> (and (and (and ($IsGoodHeap $h@@0) (not (= $o@@1 null))) (= (dtype $o@@1) (Tclass._System.array |#$arg@@2|))) (and (<= 0 $i0) (< $i0 (_System.array.Length $o@@1)))) (and ($IsBox (MapType1Select $h@@0 $o@@1 (IndexField $i0)) |#$arg@@2|) (=> (U_2_bool (MapType1Select $h@@0 $o@@1 alloc)) ($IsAllocBox (MapType1Select $h@@0 $o@@1 (IndexField $i0)) |#$arg@@2| $h@@0))))) :qid |unknown.0:0| :skolemid |289| :pattern ((MapType1Select $h@@0 $o@@1 (IndexField $i0)) (Tclass._System.array |#$arg@@2|)))))
(assert (forall ((|#$arg@@3| T@U) ($o@@2 T@U)) (! (=> (and (= (type |#$arg@@3|) TyType) (= (type $o@@2) refType)) (and (=> ($Is $o@@2 (Tclass._System.array |#$arg@@3|)) (or (= $o@@2 null) (= (dtype $o@@2) (Tclass._System.array |#$arg@@3|)))) (=> (or (= $o@@2 null) (= (dtype $o@@2) (Tclass._System.array |#$arg@@3|))) ($Is $o@@2 (Tclass._System.array |#$arg@@3|))))) :qid |unknown.0:0| :skolemid |290| :pattern (($Is $o@@2 (Tclass._System.array |#$arg@@3|))))))
(assert (forall ((|#$arg@@4| T@U) ($o@@3 T@U) ($h@@1 T@U)) (! (=> (and (and (= (type |#$arg@@4|) TyType) (= (type $o@@3) refType)) (= (type $h@@1) (MapType1Type refType))) (and (=> ($IsAlloc $o@@3 (Tclass._System.array |#$arg@@4|) $h@@1) (or (= $o@@3 null) (U_2_bool (MapType1Select $h@@1 $o@@3 alloc)))) (=> (or (= $o@@3 null) (U_2_bool (MapType1Select $h@@1 $o@@3 alloc))) ($IsAlloc $o@@3 (Tclass._System.array |#$arg@@4|) $h@@1)))) :qid |unknown.0:0| :skolemid |291| :pattern (($IsAlloc $o@@3 (Tclass._System.array |#$arg@@4|) $h@@1)))))
(assert (forall ((|#$arg@@5| T@U) ($h@@2 T@U) ($o@@4 T@U)) (! (=> (and (and (and (= (type |#$arg@@5|) TyType) (= (type $h@@2) (MapType1Type refType))) (= (type $o@@4) refType)) (and (and ($IsGoodHeap $h@@2) (not (= $o@@4 null))) (= (dtype $o@@4) (Tclass._System.array |#$arg@@5|)))) (and ($Is (int_2_U (_System.array.Length $o@@4)) TInt) (=> (U_2_bool (MapType1Select $h@@2 $o@@4 alloc)) ($IsAlloc (int_2_U (_System.array.Length $o@@4)) TInt $h@@2)))) :qid |unknown.0:0| :skolemid |292| :no-pattern (type |#$arg@@5|) :no-pattern (type $h@@2) :no-pattern (type $o@@4) :no-pattern (U_2_int |#$arg@@5|) :no-pattern (U_2_bool |#$arg@@5|) :no-pattern (U_2_int $h@@2) :no-pattern (U_2_bool $h@@2) :no-pattern (U_2_int $o@@4) :no-pattern (U_2_bool $o@@4))))
(assert (forall ((arg0@@90 T@U)) (! (= (type (Tclass._System.___hFunc0 arg0@@90)) TyType) :qid |funType:Tclass._System.___hFunc0| :pattern ((Tclass._System.___hFunc0 arg0@@90)))))
(assert (forall ((|#$T0| T@U)) (! (=> (= (type |#$T0|) TyType) (= (Tag (Tclass._System.___hFunc0 |#$T0|)) Tagclass._System.___hFunc0)) :qid |unknown.0:0| :skolemid |293| :pattern ((Tclass._System.___hFunc0 |#$T0|)))))
(assert (forall ((arg0@@91 T@U)) (! (= (type (Tclass._System.___hFunc0_0 arg0@@91)) TyType) :qid |funType:Tclass._System.___hFunc0_0| :pattern ((Tclass._System.___hFunc0_0 arg0@@91)))))
(assert (forall ((|#$T0@@0| T@U)) (! (=> (= (type |#$T0@@0|) TyType) (= (Tclass._System.___hFunc0_0 (Tclass._System.___hFunc0 |#$T0@@0|)) |#$T0@@0|)) :qid |unknown.0:0| :skolemid |294| :pattern ((Tclass._System.___hFunc0 |#$T0@@0|)))))
(assert (= (Ctor HandleTypeType) 18))
(assert (forall ((|#$T0@@1| T@U) (bx@@37 T@U)) (! (=> (and (and (= (type |#$T0@@1|) TyType) (= (type bx@@37) BoxType)) ($IsBox bx@@37 (Tclass._System.___hFunc0 |#$T0@@1|))) (and (= ($Box ($Unbox HandleTypeType bx@@37)) bx@@37) ($Is ($Unbox HandleTypeType bx@@37) (Tclass._System.___hFunc0 |#$T0@@1|)))) :qid |unknown.0:0| :skolemid |295| :pattern (($IsBox bx@@37 (Tclass._System.___hFunc0 |#$T0@@1|))))))
(assert (and (forall ((arg0@@92 T@U) (arg1@@41 T@U) (arg2@@7 T@U)) (! (= (type (Apply0 arg0@@92 arg1@@41 arg2@@7)) BoxType) :qid |funType:Apply0| :pattern ((Apply0 arg0@@92 arg1@@41 arg2@@7)))) (forall ((arg0@@93 T@U) (arg1@@42 T@U) (arg2@@8 T@U)) (! (= (type (Handle0 arg0@@93 arg1@@42 arg2@@8)) HandleTypeType) :qid |funType:Handle0| :pattern ((Handle0 arg0@@93 arg1@@42 arg2@@8))))))
(assert (forall ((t0@@12 T@U) (heap T@U) (h@@20 T@U) (r@@5 T@U) (rd T@U)) (! (=> (and (and (and (and (= (type t0@@12) TyType) (= (type heap) (MapType1Type refType))) (= (type h@@20) (MapType0Type (MapType1Type refType) BoxType))) (= (type r@@5) (MapType0Type (MapType1Type refType) boolType))) (= (type rd) (MapType0Type (MapType1Type refType) (MapType0Type BoxType boolType)))) (= (Apply0 t0@@12 (Handle0 h@@20 r@@5 rd) heap) (MapType0Select h@@20 heap))) :qid |unknown.0:0| :skolemid |296| :pattern ((Apply0 t0@@12 (Handle0 h@@20 r@@5 rd) heap)))))
(assert (forall ((t0@@13 T@U) (heap@@0 T@U) (h@@21 T@U) (r@@6 T@U) (rd@@0 T@U)) (! (=> (and (and (and (and (and (= (type t0@@13) TyType) (= (type heap@@0) (MapType1Type refType))) (= (type h@@21) (MapType0Type (MapType1Type refType) BoxType))) (= (type r@@6) (MapType0Type (MapType1Type refType) boolType))) (= (type rd@@0) (MapType0Type (MapType1Type refType) (MapType0Type BoxType boolType)))) (U_2_bool (MapType0Select r@@6 heap@@0))) (Requires0 t0@@13 (Handle0 h@@21 r@@6 rd@@0) heap@@0)) :qid |unknown.0:0| :skolemid |297| :pattern ((Requires0 t0@@13 (Handle0 h@@21 r@@6 rd@@0) heap@@0)))))
(assert (forall ((arg0@@94 T@U) (arg1@@43 T@U) (arg2@@9 T@U)) (! (= (type (Reads0 arg0@@94 arg1@@43 arg2@@9)) (MapType0Type BoxType boolType)) :qid |funType:Reads0| :pattern ((Reads0 arg0@@94 arg1@@43 arg2@@9)))))
(assert (forall ((t0@@14 T@U) (heap@@1 T@U) (h@@22 T@U) (r@@7 T@U) (rd@@1 T@U) (bx@@38 T@U)) (! (=> (and (and (and (and (and (= (type t0@@14) TyType) (= (type heap@@1) (MapType1Type refType))) (= (type h@@22) (MapType0Type (MapType1Type refType) BoxType))) (= (type r@@7) (MapType0Type (MapType1Type refType) boolType))) (= (type rd@@1) (MapType0Type (MapType1Type refType) (MapType0Type BoxType boolType)))) (= (type bx@@38) BoxType)) (and (=> (U_2_bool (MapType0Select (Reads0 t0@@14 (Handle0 h@@22 r@@7 rd@@1) heap@@1) bx@@38)) (U_2_bool (MapType0Select (MapType0Select rd@@1 heap@@1) bx@@38))) (=> (U_2_bool (MapType0Select (MapType0Select rd@@1 heap@@1) bx@@38)) (U_2_bool (MapType0Select (Reads0 t0@@14 (Handle0 h@@22 r@@7 rd@@1) heap@@1) bx@@38))))) :qid |unknown.0:0| :skolemid |298| :pattern ((MapType0Select (Reads0 t0@@14 (Handle0 h@@22 r@@7 rd@@1) heap@@1) bx@@38)))))
(assert (forall ((t0@@15 T@U) (h0@@0 T@U) (h1@@0 T@U) (f@@5 T@U)) (! (=> (and (and (and (and (= (type t0@@15) TyType) (= (type h0@@0) (MapType1Type refType))) (= (type h1@@0) (MapType1Type refType))) (= (type f@@5) HandleTypeType)) (and (and (and ($HeapSucc h0@@0 h1@@0) (and ($IsGoodHeap h0@@0) ($IsGoodHeap h1@@0))) (and ($Is f@@5 (Tclass._System.___hFunc0 t0@@15)) ($IsAlloc f@@5 (Tclass._System.___hFunc0 t0@@15) h0@@0))) (forall ((o@@39 T@U) (fld T@U)) (! (let ((a@@77 (FieldTypeInv0 (type fld)))) (=> (and (= (type o@@39) refType) (= (type fld) (FieldType a@@77))) (=> (and (and (and (not (= o@@39 null)) (U_2_bool (MapType1Select h0@@0 o@@39 alloc))) (U_2_bool (MapType1Select h1@@0 o@@39 alloc))) (U_2_bool (MapType0Select (Reads0 t0@@15 f@@5 h0@@0) ($Box o@@39)))) (= (MapType1Select h0@@0 o@@39 fld) (MapType1Select h1@@0 o@@39 fld))))) :qid |unknown.0:0| :skolemid |299| :no-pattern (type o@@39) :no-pattern (type fld) :no-pattern (U_2_int o@@39) :no-pattern (U_2_bool o@@39) :no-pattern (U_2_int fld) :no-pattern (U_2_bool fld))))) (= (Reads0 t0@@15 f@@5 h0@@0) (Reads0 t0@@15 f@@5 h1@@0))) :qid |unknown.0:0| :skolemid |300| :pattern (($HeapSucc h0@@0 h1@@0) (Reads0 t0@@15 f@@5 h1@@0)))))
(assert (forall ((t0@@16 T@U) (h0@@1 T@U) (h1@@1 T@U) (f@@6 T@U)) (! (=> (and (and (and (and (= (type t0@@16) TyType) (= (type h0@@1) (MapType1Type refType))) (= (type h1@@1) (MapType1Type refType))) (= (type f@@6) HandleTypeType)) (and (and (and ($HeapSucc h0@@1 h1@@1) (and ($IsGoodHeap h0@@1) ($IsGoodHeap h1@@1))) (and ($Is f@@6 (Tclass._System.___hFunc0 t0@@16)) ($IsAlloc f@@6 (Tclass._System.___hFunc0 t0@@16) h0@@1))) (forall ((o@@40 T@U) (fld@@0 T@U)) (! (let ((a@@78 (FieldTypeInv0 (type fld@@0)))) (=> (and (= (type o@@40) refType) (= (type fld@@0) (FieldType a@@78))) (=> (and (and (and (not (= o@@40 null)) (U_2_bool (MapType1Select h0@@1 o@@40 alloc))) (U_2_bool (MapType1Select h1@@1 o@@40 alloc))) (U_2_bool (MapType0Select (Reads0 t0@@16 f@@6 h1@@1) ($Box o@@40)))) (= (MapType1Select h0@@1 o@@40 fld@@0) (MapType1Select h1@@1 o@@40 fld@@0))))) :qid |unknown.0:0| :skolemid |301| :no-pattern (type o@@40) :no-pattern (type fld@@0) :no-pattern (U_2_int o@@40) :no-pattern (U_2_bool o@@40) :no-pattern (U_2_int fld@@0) :no-pattern (U_2_bool fld@@0))))) (= (Reads0 t0@@16 f@@6 h0@@1) (Reads0 t0@@16 f@@6 h1@@1))) :qid |unknown.0:0| :skolemid |302| :pattern (($HeapSucc h0@@1 h1@@1) (Reads0 t0@@16 f@@6 h1@@1)))))
(assert (forall ((t0@@17 T@U) (h0@@2 T@U) (h1@@2 T@U) (f@@7 T@U)) (! (=> (and (and (and (and (= (type t0@@17) TyType) (= (type h0@@2) (MapType1Type refType))) (= (type h1@@2) (MapType1Type refType))) (= (type f@@7) HandleTypeType)) (and (and (and ($HeapSucc h0@@2 h1@@2) (and ($IsGoodHeap h0@@2) ($IsGoodHeap h1@@2))) (and ($Is f@@7 (Tclass._System.___hFunc0 t0@@17)) ($IsAlloc f@@7 (Tclass._System.___hFunc0 t0@@17) h0@@2))) (forall ((o@@41 T@U) (fld@@1 T@U)) (! (let ((a@@79 (FieldTypeInv0 (type fld@@1)))) (=> (and (= (type o@@41) refType) (= (type fld@@1) (FieldType a@@79))) (=> (and (and (and (not (= o@@41 null)) (U_2_bool (MapType1Select h0@@2 o@@41 alloc))) (U_2_bool (MapType1Select h1@@2 o@@41 alloc))) (U_2_bool (MapType0Select (Reads0 t0@@17 f@@7 h0@@2) ($Box o@@41)))) (= (MapType1Select h0@@2 o@@41 fld@@1) (MapType1Select h1@@2 o@@41 fld@@1))))) :qid |unknown.0:0| :skolemid |303| :no-pattern (type o@@41) :no-pattern (type fld@@1) :no-pattern (U_2_int o@@41) :no-pattern (U_2_bool o@@41) :no-pattern (U_2_int fld@@1) :no-pattern (U_2_bool fld@@1))))) (and (=> (Requires0 t0@@17 f@@7 h0@@2) (Requires0 t0@@17 f@@7 h1@@2)) (=> (Requires0 t0@@17 f@@7 h1@@2) (Requires0 t0@@17 f@@7 h0@@2)))) :qid |unknown.0:0| :skolemid |304| :pattern (($HeapSucc h0@@2 h1@@2) (Requires0 t0@@17 f@@7 h1@@2)))))
(assert (forall ((t0@@18 T@U) (h0@@3 T@U) (h1@@3 T@U) (f@@8 T@U)) (! (=> (and (and (and (and (= (type t0@@18) TyType) (= (type h0@@3) (MapType1Type refType))) (= (type h1@@3) (MapType1Type refType))) (= (type f@@8) HandleTypeType)) (and (and (and ($HeapSucc h0@@3 h1@@3) (and ($IsGoodHeap h0@@3) ($IsGoodHeap h1@@3))) (and ($Is f@@8 (Tclass._System.___hFunc0 t0@@18)) ($IsAlloc f@@8 (Tclass._System.___hFunc0 t0@@18) h0@@3))) (forall ((o@@42 T@U) (fld@@2 T@U)) (! (let ((a@@80 (FieldTypeInv0 (type fld@@2)))) (=> (and (= (type o@@42) refType) (= (type fld@@2) (FieldType a@@80))) (=> (and (and (and (not (= o@@42 null)) (U_2_bool (MapType1Select h0@@3 o@@42 alloc))) (U_2_bool (MapType1Select h1@@3 o@@42 alloc))) (U_2_bool (MapType0Select (Reads0 t0@@18 f@@8 h1@@3) ($Box o@@42)))) (= (MapType1Select h0@@3 o@@42 fld@@2) (MapType1Select h1@@3 o@@42 fld@@2))))) :qid |unknown.0:0| :skolemid |305| :no-pattern (type o@@42) :no-pattern (type fld@@2) :no-pattern (U_2_int o@@42) :no-pattern (U_2_bool o@@42) :no-pattern (U_2_int fld@@2) :no-pattern (U_2_bool fld@@2))))) (and (=> (Requires0 t0@@18 f@@8 h0@@3) (Requires0 t0@@18 f@@8 h1@@3)) (=> (Requires0 t0@@18 f@@8 h1@@3) (Requires0 t0@@18 f@@8 h0@@3)))) :qid |unknown.0:0| :skolemid |306| :pattern (($HeapSucc h0@@3 h1@@3) (Requires0 t0@@18 f@@8 h1@@3)))))
(assert (forall ((t0@@19 T@U) (h0@@4 T@U) (h1@@4 T@U) (f@@9 T@U)) (! (=> (and (and (and (and (= (type t0@@19) TyType) (= (type h0@@4) (MapType1Type refType))) (= (type h1@@4) (MapType1Type refType))) (= (type f@@9) HandleTypeType)) (and (and (and ($HeapSucc h0@@4 h1@@4) (and ($IsGoodHeap h0@@4) ($IsGoodHeap h1@@4))) (and ($Is f@@9 (Tclass._System.___hFunc0 t0@@19)) ($IsAlloc f@@9 (Tclass._System.___hFunc0 t0@@19) h0@@4))) (forall ((o@@43 T@U) (fld@@3 T@U)) (! (let ((a@@81 (FieldTypeInv0 (type fld@@3)))) (=> (and (= (type o@@43) refType) (= (type fld@@3) (FieldType a@@81))) (=> (and (and (and (not (= o@@43 null)) (U_2_bool (MapType1Select h0@@4 o@@43 alloc))) (U_2_bool (MapType1Select h1@@4 o@@43 alloc))) (U_2_bool (MapType0Select (Reads0 t0@@19 f@@9 h0@@4) ($Box o@@43)))) (= (MapType1Select h0@@4 o@@43 fld@@3) (MapType1Select h1@@4 o@@43 fld@@3))))) :qid |unknown.0:0| :skolemid |307| :no-pattern (type o@@43) :no-pattern (type fld@@3) :no-pattern (U_2_int o@@43) :no-pattern (U_2_bool o@@43) :no-pattern (U_2_int fld@@3) :no-pattern (U_2_bool fld@@3))))) (= (Apply0 t0@@19 f@@9 h0@@4) (Apply0 t0@@19 f@@9 h1@@4))) :qid |unknown.0:0| :skolemid |308| :pattern (($HeapSucc h0@@4 h1@@4) (Apply0 t0@@19 f@@9 h1@@4)))))
(assert (forall ((t0@@20 T@U) (h0@@5 T@U) (h1@@5 T@U) (f@@10 T@U)) (! (=> (and (and (and (and (= (type t0@@20) TyType) (= (type h0@@5) (MapType1Type refType))) (= (type h1@@5) (MapType1Type refType))) (= (type f@@10) HandleTypeType)) (and (and (and ($HeapSucc h0@@5 h1@@5) (and ($IsGoodHeap h0@@5) ($IsGoodHeap h1@@5))) (and ($Is f@@10 (Tclass._System.___hFunc0 t0@@20)) ($IsAlloc f@@10 (Tclass._System.___hFunc0 t0@@20) h0@@5))) (forall ((o@@44 T@U) (fld@@4 T@U)) (! (let ((a@@82 (FieldTypeInv0 (type fld@@4)))) (=> (and (= (type o@@44) refType) (= (type fld@@4) (FieldType a@@82))) (=> (and (and (and (not (= o@@44 null)) (U_2_bool (MapType1Select h0@@5 o@@44 alloc))) (U_2_bool (MapType1Select h1@@5 o@@44 alloc))) (U_2_bool (MapType0Select (Reads0 t0@@20 f@@10 h1@@5) ($Box o@@44)))) (= (MapType1Select h0@@5 o@@44 fld@@4) (MapType1Select h1@@5 o@@44 fld@@4))))) :qid |unknown.0:0| :skolemid |309| :no-pattern (type o@@44) :no-pattern (type fld@@4) :no-pattern (U_2_int o@@44) :no-pattern (U_2_bool o@@44) :no-pattern (U_2_int fld@@4) :no-pattern (U_2_bool fld@@4))))) (= (Apply0 t0@@20 f@@10 h0@@5) (Apply0 t0@@20 f@@10 h1@@5))) :qid |unknown.0:0| :skolemid |310| :pattern (($HeapSucc h0@@5 h1@@5) (Apply0 t0@@20 f@@10 h1@@5)))))
(assert (forall ((t0@@21 T@U) (h@@23 T@U) (f@@11 T@U)) (! (=> (and (and (and (= (type t0@@21) TyType) (= (type h@@23) (MapType1Type refType))) (= (type f@@11) HandleTypeType)) (and ($IsGoodHeap h@@23) (and ($Is f@@11 (Tclass._System.___hFunc0 t0@@21)) ($IsAlloc f@@11 (Tclass._System.___hFunc0 t0@@21) h@@23)))) (and ($IsBox (Apply0 t0@@21 f@@11 h@@23) t0@@21) ($IsAllocBox (Apply0 t0@@21 f@@11 h@@23) t0@@21 h@@23))) :qid |unknown.0:0| :skolemid |311| :pattern ((Apply0 t0@@21 f@@11 h@@23)))))
(assert (forall ((arg0@@95 T@U) (arg1@@44 T@U)) (! (= (type (Tclass._System.___hFunc1 arg0@@95 arg1@@44)) TyType) :qid |funType:Tclass._System.___hFunc1| :pattern ((Tclass._System.___hFunc1 arg0@@95 arg1@@44)))))
(assert (forall ((|#$T0@@2| T@U) (|#$T1| T@U)) (! (=> (and (= (type |#$T0@@2|) TyType) (= (type |#$T1|) TyType)) (= (Tag (Tclass._System.___hFunc1 |#$T0@@2| |#$T1|)) Tagclass._System.___hFunc1)) :qid |unknown.0:0| :skolemid |312| :pattern ((Tclass._System.___hFunc1 |#$T0@@2| |#$T1|)))))
(assert (forall ((arg0@@96 T@U)) (! (= (type (Tclass._System.___hFunc1_0 arg0@@96)) TyType) :qid |funType:Tclass._System.___hFunc1_0| :pattern ((Tclass._System.___hFunc1_0 arg0@@96)))))
(assert (forall ((|#$T0@@3| T@U) (|#$T1@@0| T@U)) (! (=> (and (= (type |#$T0@@3|) TyType) (= (type |#$T1@@0|) TyType)) (= (Tclass._System.___hFunc1_0 (Tclass._System.___hFunc1 |#$T0@@3| |#$T1@@0|)) |#$T0@@3|)) :qid |unknown.0:0| :skolemid |313| :pattern ((Tclass._System.___hFunc1 |#$T0@@3| |#$T1@@0|)))))
(assert (forall ((arg0@@97 T@U)) (! (= (type (Tclass._System.___hFunc1_1 arg0@@97)) TyType) :qid |funType:Tclass._System.___hFunc1_1| :pattern ((Tclass._System.___hFunc1_1 arg0@@97)))))
(assert (forall ((|#$T0@@4| T@U) (|#$T1@@1| T@U)) (! (=> (and (= (type |#$T0@@4|) TyType) (= (type |#$T1@@1|) TyType)) (= (Tclass._System.___hFunc1_1 (Tclass._System.___hFunc1 |#$T0@@4| |#$T1@@1|)) |#$T1@@1|)) :qid |unknown.0:0| :skolemid |314| :pattern ((Tclass._System.___hFunc1 |#$T0@@4| |#$T1@@1|)))))
(assert (forall ((|#$T0@@5| T@U) (|#$T1@@2| T@U) (bx@@39 T@U)) (! (=> (and (and (and (= (type |#$T0@@5|) TyType) (= (type |#$T1@@2|) TyType)) (= (type bx@@39) BoxType)) ($IsBox bx@@39 (Tclass._System.___hFunc1 |#$T0@@5| |#$T1@@2|))) (and (= ($Box ($Unbox HandleTypeType bx@@39)) bx@@39) ($Is ($Unbox HandleTypeType bx@@39) (Tclass._System.___hFunc1 |#$T0@@5| |#$T1@@2|)))) :qid |unknown.0:0| :skolemid |315| :pattern (($IsBox bx@@39 (Tclass._System.___hFunc1 |#$T0@@5| |#$T1@@2|))))))
(assert (and (and (and (and (and (and (and (and (and (forall ((arg0@@98 T@T) (arg1@@45 T@T) (arg2@@10 T@T)) (! (= (Ctor (MapType2Type arg0@@98 arg1@@45 arg2@@10)) 19) :qid |ctor:MapType2Type|)) (forall ((arg0@@99 T@T) (arg1@@46 T@T) (arg2@@11 T@T)) (! (= (MapType2TypeInv0 (MapType2Type arg0@@99 arg1@@46 arg2@@11)) arg0@@99) :qid |typeInv:MapType2TypeInv0| :pattern ((MapType2Type arg0@@99 arg1@@46 arg2@@11))))) (forall ((arg0@@100 T@T) (arg1@@47 T@T) (arg2@@12 T@T)) (! (= (MapType2TypeInv1 (MapType2Type arg0@@100 arg1@@47 arg2@@12)) arg1@@47) :qid |typeInv:MapType2TypeInv1| :pattern ((MapType2Type arg0@@100 arg1@@47 arg2@@12))))) (forall ((arg0@@101 T@T) (arg1@@48 T@T) (arg2@@13 T@T)) (! (= (MapType2TypeInv2 (MapType2Type arg0@@101 arg1@@48 arg2@@13)) arg2@@13) :qid |typeInv:MapType2TypeInv2| :pattern ((MapType2Type arg0@@101 arg1@@48 arg2@@13))))) (forall ((arg0@@102 T@U) (arg1@@49 T@U) (arg2@@14 T@U)) (! (let ((aVar2 (MapType2TypeInv2 (type arg0@@102)))) (= (type (MapType2Select arg0@@102 arg1@@49 arg2@@14)) aVar2)) :qid |funType:MapType2Select| :pattern ((MapType2Select arg0@@102 arg1@@49 arg2@@14))))) (forall ((arg0@@103 T@U) (arg1@@50 T@U) (arg2@@15 T@U) (arg3@@0 T@U)) (! (let ((aVar2@@0 (type arg3@@0))) (let ((aVar1@@2 (type arg2@@15))) (let ((aVar0@@1 (type arg1@@50))) (= (type (MapType2Store arg0@@103 arg1@@50 arg2@@15 arg3@@0)) (MapType2Type aVar0@@1 aVar1@@2 aVar2@@0))))) :qid |funType:MapType2Store| :pattern ((MapType2Store arg0@@103 arg1@@50 arg2@@15 arg3@@0))))) (forall ((m@@18 T@U) (x0@@6 T@U) (x1@@3 T@U) (val@@6 T@U)) (! (let ((aVar2@@1 (MapType2TypeInv2 (type m@@18)))) (=> (= (type val@@6) aVar2@@1) (= (MapType2Select (MapType2Store m@@18 x0@@6 x1@@3 val@@6) x0@@6 x1@@3) val@@6))) :qid |mapAx0:MapType2Select| :weight 0))) (and (and (forall ((val@@7 T@U) (m@@19 T@U) (x0@@7 T@U) (x1@@4 T@U) (y0@@4 T@U) (y1@@2 T@U)) (! (or (= x0@@7 y0@@4) (= (MapType2Select (MapType2Store m@@19 x0@@7 x1@@4 val@@7) y0@@4 y1@@2) (MapType2Select m@@19 y0@@4 y1@@2))) :qid |mapAx1:MapType2Select:0| :weight 0)) (forall ((val@@8 T@U) (m@@20 T@U) (x0@@8 T@U) (x1@@5 T@U) (y0@@5 T@U) (y1@@3 T@U)) (! (or (= x1@@5 y1@@3) (= (MapType2Select (MapType2Store m@@20 x0@@8 x1@@5 val@@8) y0@@5 y1@@3) (MapType2Select m@@20 y0@@5 y1@@3))) :qid |mapAx1:MapType2Select:1| :weight 0))) (forall ((val@@9 T@U) (m@@21 T@U) (x0@@9 T@U) (x1@@6 T@U) (y0@@6 T@U) (y1@@4 T@U)) (! (or true (= (MapType2Select (MapType2Store m@@21 x0@@9 x1@@6 val@@9) y0@@6 y1@@4) (MapType2Select m@@21 y0@@6 y1@@4))) :qid |mapAx2:MapType2Select| :weight 0)))) (forall ((arg0@@104 T@U) (arg1@@51 T@U) (arg2@@16 T@U) (arg3@@1 T@U) (arg4 T@U)) (! (= (type (Apply1 arg0@@104 arg1@@51 arg2@@16 arg3@@1 arg4)) BoxType) :qid |funType:Apply1| :pattern ((Apply1 arg0@@104 arg1@@51 arg2@@16 arg3@@1 arg4))))) (forall ((arg0@@105 T@U) (arg1@@52 T@U) (arg2@@17 T@U)) (! (= (type (Handle1 arg0@@105 arg1@@52 arg2@@17)) HandleTypeType) :qid |funType:Handle1| :pattern ((Handle1 arg0@@105 arg1@@52 arg2@@17))))))
(assert (forall ((t0@@22 T@U) (t1@@3 T@U) (heap@@2 T@U) (h@@24 T@U) (r@@8 T@U) (rd@@2 T@U) (bx0 T@U)) (! (=> (and (and (and (and (and (and (= (type t0@@22) TyType) (= (type t1@@3) TyType)) (= (type heap@@2) (MapType1Type refType))) (= (type h@@24) (MapType2Type (MapType1Type refType) BoxType BoxType))) (= (type r@@8) (MapType2Type (MapType1Type refType) BoxType boolType))) (= (type rd@@2) (MapType2Type (MapType1Type refType) BoxType (MapType0Type BoxType boolType)))) (= (type bx0) BoxType)) (= (Apply1 t0@@22 t1@@3 (Handle1 h@@24 r@@8 rd@@2) heap@@2 bx0) (MapType2Select h@@24 heap@@2 bx0))) :qid |unknown.0:0| :skolemid |316| :pattern ((Apply1 t0@@22 t1@@3 (Handle1 h@@24 r@@8 rd@@2) heap@@2 bx0)))))
(assert (forall ((t0@@23 T@U) (t1@@4 T@U) (heap@@3 T@U) (h@@25 T@U) (r@@9 T@U) (rd@@3 T@U) (bx0@@0 T@U)) (! (=> (and (and (and (and (and (and (and (= (type t0@@23) TyType) (= (type t1@@4) TyType)) (= (type heap@@3) (MapType1Type refType))) (= (type h@@25) (MapType2Type (MapType1Type refType) BoxType BoxType))) (= (type r@@9) (MapType2Type (MapType1Type refType) BoxType boolType))) (= (type rd@@3) (MapType2Type (MapType1Type refType) BoxType (MapType0Type BoxType boolType)))) (= (type bx0@@0) BoxType)) (U_2_bool (MapType2Select r@@9 heap@@3 bx0@@0))) (Requires1 t0@@23 t1@@4 (Handle1 h@@25 r@@9 rd@@3) heap@@3 bx0@@0)) :qid |unknown.0:0| :skolemid |317| :pattern ((Requires1 t0@@23 t1@@4 (Handle1 h@@25 r@@9 rd@@3) heap@@3 bx0@@0)))))
(assert (forall ((arg0@@106 T@U) (arg1@@53 T@U) (arg2@@18 T@U) (arg3@@2 T@U) (arg4@@0 T@U)) (! (= (type (Reads1 arg0@@106 arg1@@53 arg2@@18 arg3@@2 arg4@@0)) (MapType0Type BoxType boolType)) :qid |funType:Reads1| :pattern ((Reads1 arg0@@106 arg1@@53 arg2@@18 arg3@@2 arg4@@0)))))
(assert (forall ((t0@@24 T@U) (t1@@5 T@U) (heap@@4 T@U) (h@@26 T@U) (r@@10 T@U) (rd@@4 T@U) (bx0@@1 T@U) (bx@@40 T@U)) (! (=> (and (and (and (and (and (and (and (= (type t0@@24) TyType) (= (type t1@@5) TyType)) (= (type heap@@4) (MapType1Type refType))) (= (type h@@26) (MapType2Type (MapType1Type refType) BoxType BoxType))) (= (type r@@10) (MapType2Type (MapType1Type refType) BoxType boolType))) (= (type rd@@4) (MapType2Type (MapType1Type refType) BoxType (MapType0Type BoxType boolType)))) (= (type bx0@@1) BoxType)) (= (type bx@@40) BoxType)) (and (=> (U_2_bool (MapType0Select (Reads1 t0@@24 t1@@5 (Handle1 h@@26 r@@10 rd@@4) heap@@4 bx0@@1) bx@@40)) (U_2_bool (MapType0Select (MapType2Select rd@@4 heap@@4 bx0@@1) bx@@40))) (=> (U_2_bool (MapType0Select (MapType2Select rd@@4 heap@@4 bx0@@1) bx@@40)) (U_2_bool (MapType0Select (Reads1 t0@@24 t1@@5 (Handle1 h@@26 r@@10 rd@@4) heap@@4 bx0@@1) bx@@40))))) :qid |unknown.0:0| :skolemid |318| :pattern ((MapType0Select (Reads1 t0@@24 t1@@5 (Handle1 h@@26 r@@10 rd@@4) heap@@4 bx0@@1) bx@@40)))))
(assert (forall ((t0@@25 T@U) (t1@@6 T@U) (h0@@6 T@U) (h1@@6 T@U) (f@@12 T@U) (bx0@@2 T@U)) (! (=> (and (and (and (and (and (and (= (type t0@@25) TyType) (= (type t1@@6) TyType)) (= (type h0@@6) (MapType1Type refType))) (= (type h1@@6) (MapType1Type refType))) (= (type f@@12) HandleTypeType)) (= (type bx0@@2) BoxType)) (and (and (and ($HeapSucc h0@@6 h1@@6) (and ($IsGoodHeap h0@@6) ($IsGoodHeap h1@@6))) (and (and ($IsBox bx0@@2 t0@@25) ($IsAllocBox bx0@@2 t0@@25 h0@@6)) (and ($Is f@@12 (Tclass._System.___hFunc1 t0@@25 t1@@6)) ($IsAlloc f@@12 (Tclass._System.___hFunc1 t0@@25 t1@@6) h0@@6)))) (forall ((o@@45 T@U) (fld@@5 T@U)) (! (let ((a@@83 (FieldTypeInv0 (type fld@@5)))) (=> (and (= (type o@@45) refType) (= (type fld@@5) (FieldType a@@83))) (=> (and (and (and (not (= o@@45 null)) (U_2_bool (MapType1Select h0@@6 o@@45 alloc))) (U_2_bool (MapType1Select h1@@6 o@@45 alloc))) (U_2_bool (MapType0Select (Reads1 t0@@25 t1@@6 f@@12 h0@@6 bx0@@2) ($Box o@@45)))) (= (MapType1Select h0@@6 o@@45 fld@@5) (MapType1Select h1@@6 o@@45 fld@@5))))) :qid |unknown.0:0| :skolemid |319| :no-pattern (type o@@45) :no-pattern (type fld@@5) :no-pattern (U_2_int o@@45) :no-pattern (U_2_bool o@@45) :no-pattern (U_2_int fld@@5) :no-pattern (U_2_bool fld@@5))))) (= (Reads1 t0@@25 t1@@6 f@@12 h0@@6 bx0@@2) (Reads1 t0@@25 t1@@6 f@@12 h1@@6 bx0@@2))) :qid |unknown.0:0| :skolemid |320| :pattern (($HeapSucc h0@@6 h1@@6) (Reads1 t0@@25 t1@@6 f@@12 h1@@6 bx0@@2)))))
(assert (forall ((t0@@26 T@U) (t1@@7 T@U) (h0@@7 T@U) (h1@@7 T@U) (f@@13 T@U) (bx0@@3 T@U)) (! (=> (and (and (and (and (and (and (= (type t0@@26) TyType) (= (type t1@@7) TyType)) (= (type h0@@7) (MapType1Type refType))) (= (type h1@@7) (MapType1Type refType))) (= (type f@@13) HandleTypeType)) (= (type bx0@@3) BoxType)) (and (and (and ($HeapSucc h0@@7 h1@@7) (and ($IsGoodHeap h0@@7) ($IsGoodHeap h1@@7))) (and (and ($IsBox bx0@@3 t0@@26) ($IsAllocBox bx0@@3 t0@@26 h0@@7)) (and ($Is f@@13 (Tclass._System.___hFunc1 t0@@26 t1@@7)) ($IsAlloc f@@13 (Tclass._System.___hFunc1 t0@@26 t1@@7) h0@@7)))) (forall ((o@@46 T@U) (fld@@6 T@U)) (! (let ((a@@84 (FieldTypeInv0 (type fld@@6)))) (=> (and (= (type o@@46) refType) (= (type fld@@6) (FieldType a@@84))) (=> (and (and (and (not (= o@@46 null)) (U_2_bool (MapType1Select h0@@7 o@@46 alloc))) (U_2_bool (MapType1Select h1@@7 o@@46 alloc))) (U_2_bool (MapType0Select (Reads1 t0@@26 t1@@7 f@@13 h1@@7 bx0@@3) ($Box o@@46)))) (= (MapType1Select h0@@7 o@@46 fld@@6) (MapType1Select h1@@7 o@@46 fld@@6))))) :qid |unknown.0:0| :skolemid |321| :no-pattern (type o@@46) :no-pattern (type fld@@6) :no-pattern (U_2_int o@@46) :no-pattern (U_2_bool o@@46) :no-pattern (U_2_int fld@@6) :no-pattern (U_2_bool fld@@6))))) (= (Reads1 t0@@26 t1@@7 f@@13 h0@@7 bx0@@3) (Reads1 t0@@26 t1@@7 f@@13 h1@@7 bx0@@3))) :qid |unknown.0:0| :skolemid |322| :pattern (($HeapSucc h0@@7 h1@@7) (Reads1 t0@@26 t1@@7 f@@13 h1@@7 bx0@@3)))))
(assert (forall ((t0@@27 T@U) (t1@@8 T@U) (h0@@8 T@U) (h1@@8 T@U) (f@@14 T@U) (bx0@@4 T@U)) (! (=> (and (and (and (and (and (and (= (type t0@@27) TyType) (= (type t1@@8) TyType)) (= (type h0@@8) (MapType1Type refType))) (= (type h1@@8) (MapType1Type refType))) (= (type f@@14) HandleTypeType)) (= (type bx0@@4) BoxType)) (and (and (and ($HeapSucc h0@@8 h1@@8) (and ($IsGoodHeap h0@@8) ($IsGoodHeap h1@@8))) (and (and ($IsBox bx0@@4 t0@@27) ($IsAllocBox bx0@@4 t0@@27 h0@@8)) (and ($Is f@@14 (Tclass._System.___hFunc1 t0@@27 t1@@8)) ($IsAlloc f@@14 (Tclass._System.___hFunc1 t0@@27 t1@@8) h0@@8)))) (forall ((o@@47 T@U) (fld@@7 T@U)) (! (let ((a@@85 (FieldTypeInv0 (type fld@@7)))) (=> (and (= (type o@@47) refType) (= (type fld@@7) (FieldType a@@85))) (=> (and (and (and (not (= o@@47 null)) (U_2_bool (MapType1Select h0@@8 o@@47 alloc))) (U_2_bool (MapType1Select h1@@8 o@@47 alloc))) (U_2_bool (MapType0Select (Reads1 t0@@27 t1@@8 f@@14 h0@@8 bx0@@4) ($Box o@@47)))) (= (MapType1Select h0@@8 o@@47 fld@@7) (MapType1Select h1@@8 o@@47 fld@@7))))) :qid |unknown.0:0| :skolemid |323| :no-pattern (type o@@47) :no-pattern (type fld@@7) :no-pattern (U_2_int o@@47) :no-pattern (U_2_bool o@@47) :no-pattern (U_2_int fld@@7) :no-pattern (U_2_bool fld@@7))))) (and (=> (Requires1 t0@@27 t1@@8 f@@14 h0@@8 bx0@@4) (Requires1 t0@@27 t1@@8 f@@14 h1@@8 bx0@@4)) (=> (Requires1 t0@@27 t1@@8 f@@14 h1@@8 bx0@@4) (Requires1 t0@@27 t1@@8 f@@14 h0@@8 bx0@@4)))) :qid |unknown.0:0| :skolemid |324| :pattern (($HeapSucc h0@@8 h1@@8) (Requires1 t0@@27 t1@@8 f@@14 h1@@8 bx0@@4)))))
(assert (forall ((t0@@28 T@U) (t1@@9 T@U) (h0@@9 T@U) (h1@@9 T@U) (f@@15 T@U) (bx0@@5 T@U)) (! (=> (and (and (and (and (and (and (= (type t0@@28) TyType) (= (type t1@@9) TyType)) (= (type h0@@9) (MapType1Type refType))) (= (type h1@@9) (MapType1Type refType))) (= (type f@@15) HandleTypeType)) (= (type bx0@@5) BoxType)) (and (and (and ($HeapSucc h0@@9 h1@@9) (and ($IsGoodHeap h0@@9) ($IsGoodHeap h1@@9))) (and (and ($IsBox bx0@@5 t0@@28) ($IsAllocBox bx0@@5 t0@@28 h0@@9)) (and ($Is f@@15 (Tclass._System.___hFunc1 t0@@28 t1@@9)) ($IsAlloc f@@15 (Tclass._System.___hFunc1 t0@@28 t1@@9) h0@@9)))) (forall ((o@@48 T@U) (fld@@8 T@U)) (! (let ((a@@86 (FieldTypeInv0 (type fld@@8)))) (=> (and (= (type o@@48) refType) (= (type fld@@8) (FieldType a@@86))) (=> (and (and (and (not (= o@@48 null)) (U_2_bool (MapType1Select h0@@9 o@@48 alloc))) (U_2_bool (MapType1Select h1@@9 o@@48 alloc))) (U_2_bool (MapType0Select (Reads1 t0@@28 t1@@9 f@@15 h1@@9 bx0@@5) ($Box o@@48)))) (= (MapType1Select h0@@9 o@@48 fld@@8) (MapType1Select h1@@9 o@@48 fld@@8))))) :qid |unknown.0:0| :skolemid |325| :no-pattern (type o@@48) :no-pattern (type fld@@8) :no-pattern (U_2_int o@@48) :no-pattern (U_2_bool o@@48) :no-pattern (U_2_int fld@@8) :no-pattern (U_2_bool fld@@8))))) (and (=> (Requires1 t0@@28 t1@@9 f@@15 h0@@9 bx0@@5) (Requires1 t0@@28 t1@@9 f@@15 h1@@9 bx0@@5)) (=> (Requires1 t0@@28 t1@@9 f@@15 h1@@9 bx0@@5) (Requires1 t0@@28 t1@@9 f@@15 h0@@9 bx0@@5)))) :qid |unknown.0:0| :skolemid |326| :pattern (($HeapSucc h0@@9 h1@@9) (Requires1 t0@@28 t1@@9 f@@15 h1@@9 bx0@@5)))))
(assert (forall ((t0@@29 T@U) (t1@@10 T@U) (h0@@10 T@U) (h1@@10 T@U) (f@@16 T@U) (bx0@@6 T@U)) (! (=> (and (and (and (and (and (and (= (type t0@@29) TyType) (= (type t1@@10) TyType)) (= (type h0@@10) (MapType1Type refType))) (= (type h1@@10) (MapType1Type refType))) (= (type f@@16) HandleTypeType)) (= (type bx0@@6) BoxType)) (and (and (and ($HeapSucc h0@@10 h1@@10) (and ($IsGoodHeap h0@@10) ($IsGoodHeap h1@@10))) (and (and ($IsBox bx0@@6 t0@@29) ($IsAllocBox bx0@@6 t0@@29 h0@@10)) (and ($Is f@@16 (Tclass._System.___hFunc1 t0@@29 t1@@10)) ($IsAlloc f@@16 (Tclass._System.___hFunc1 t0@@29 t1@@10) h0@@10)))) (forall ((o@@49 T@U) (fld@@9 T@U)) (! (let ((a@@87 (FieldTypeInv0 (type fld@@9)))) (=> (and (= (type o@@49) refType) (= (type fld@@9) (FieldType a@@87))) (=> (and (and (and (not (= o@@49 null)) (U_2_bool (MapType1Select h0@@10 o@@49 alloc))) (U_2_bool (MapType1Select h1@@10 o@@49 alloc))) (U_2_bool (MapType0Select (Reads1 t0@@29 t1@@10 f@@16 h0@@10 bx0@@6) ($Box o@@49)))) (= (MapType1Select h0@@10 o@@49 fld@@9) (MapType1Select h1@@10 o@@49 fld@@9))))) :qid |unknown.0:0| :skolemid |327| :no-pattern (type o@@49) :no-pattern (type fld@@9) :no-pattern (U_2_int o@@49) :no-pattern (U_2_bool o@@49) :no-pattern (U_2_int fld@@9) :no-pattern (U_2_bool fld@@9))))) (= (Apply1 t0@@29 t1@@10 f@@16 h0@@10 bx0@@6) (Apply1 t0@@29 t1@@10 f@@16 h1@@10 bx0@@6))) :qid |unknown.0:0| :skolemid |328| :pattern (($HeapSucc h0@@10 h1@@10) (Apply1 t0@@29 t1@@10 f@@16 h1@@10 bx0@@6)))))
(assert (forall ((t0@@30 T@U) (t1@@11 T@U) (h0@@11 T@U) (h1@@11 T@U) (f@@17 T@U) (bx0@@7 T@U)) (! (=> (and (and (and (and (and (and (= (type t0@@30) TyType) (= (type t1@@11) TyType)) (= (type h0@@11) (MapType1Type refType))) (= (type h1@@11) (MapType1Type refType))) (= (type f@@17) HandleTypeType)) (= (type bx0@@7) BoxType)) (and (and (and ($HeapSucc h0@@11 h1@@11) (and ($IsGoodHeap h0@@11) ($IsGoodHeap h1@@11))) (and (and ($IsBox bx0@@7 t0@@30) ($IsAllocBox bx0@@7 t0@@30 h0@@11)) (and ($Is f@@17 (Tclass._System.___hFunc1 t0@@30 t1@@11)) ($IsAlloc f@@17 (Tclass._System.___hFunc1 t0@@30 t1@@11) h0@@11)))) (forall ((o@@50 T@U) (fld@@10 T@U)) (! (let ((a@@88 (FieldTypeInv0 (type fld@@10)))) (=> (and (= (type o@@50) refType) (= (type fld@@10) (FieldType a@@88))) (=> (and (and (and (not (= o@@50 null)) (U_2_bool (MapType1Select h0@@11 o@@50 alloc))) (U_2_bool (MapType1Select h1@@11 o@@50 alloc))) (U_2_bool (MapType0Select (Reads1 t0@@30 t1@@11 f@@17 h1@@11 bx0@@7) ($Box o@@50)))) (= (MapType1Select h0@@11 o@@50 fld@@10) (MapType1Select h1@@11 o@@50 fld@@10))))) :qid |unknown.0:0| :skolemid |329| :no-pattern (type o@@50) :no-pattern (type fld@@10) :no-pattern (U_2_int o@@50) :no-pattern (U_2_bool o@@50) :no-pattern (U_2_int fld@@10) :no-pattern (U_2_bool fld@@10))))) (= (Apply1 t0@@30 t1@@11 f@@17 h0@@11 bx0@@7) (Apply1 t0@@30 t1@@11 f@@17 h1@@11 bx0@@7))) :qid |unknown.0:0| :skolemid |330| :pattern (($HeapSucc h0@@11 h1@@11) (Apply1 t0@@30 t1@@11 f@@17 h1@@11 bx0@@7)))))
(assert (forall ((t0@@31 T@U) (t1@@12 T@U) (h@@27 T@U) (f@@18 T@U) (bx0@@8 T@U)) (! (=> (and (and (and (and (and (= (type t0@@31) TyType) (= (type t1@@12) TyType)) (= (type h@@27) (MapType1Type refType))) (= (type f@@18) HandleTypeType)) (= (type bx0@@8) BoxType)) (and ($IsGoodHeap h@@27) (and (and ($IsBox bx0@@8 t0@@31) ($IsAllocBox bx0@@8 t0@@31 h@@27)) (and ($Is f@@18 (Tclass._System.___hFunc1 t0@@31 t1@@12)) ($IsAlloc f@@18 (Tclass._System.___hFunc1 t0@@31 t1@@12) h@@27))))) (and ($IsBox (Apply1 t0@@31 t1@@12 f@@18 h@@27 bx0@@8) t1@@12) ($IsAllocBox (Apply1 t0@@31 t1@@12 f@@18 h@@27 bx0@@8) t1@@12 h@@27))) :qid |unknown.0:0| :skolemid |331| :pattern ((Apply1 t0@@31 t1@@12 f@@18 h@@27 bx0@@8)))))
(assert (= (type Tclass._module.__default) TyType))
(assert (= (Tag Tclass._module.__default) Tagclass._module.__default))
(assert (forall ((bx@@41 T@U)) (! (=> (and (= (type bx@@41) BoxType) ($IsBox bx@@41 Tclass._module.__default)) (and (= ($Box ($Unbox refType bx@@41)) bx@@41) ($Is ($Unbox refType bx@@41) Tclass._module.__default))) :qid |unknown.0:0| :skolemid |332| :pattern (($IsBox bx@@41 Tclass._module.__default)))))
(assert (forall (($o@@5 T@U)) (! (=> (= (type $o@@5) refType) (and (=> ($Is $o@@5 Tclass._module.__default) (or (= $o@@5 null) (= (dtype $o@@5) Tclass._module.__default))) (=> (or (= $o@@5 null) (= (dtype $o@@5) Tclass._module.__default)) ($Is $o@@5 Tclass._module.__default)))) :qid |unknown.0:0| :skolemid |333| :pattern (($Is $o@@5 Tclass._module.__default)))))
(assert (forall (($o@@6 T@U) ($h@@3 T@U)) (! (=> (and (= (type $o@@6) refType) (= (type $h@@3) (MapType1Type refType))) (and (=> ($IsAlloc $o@@6 Tclass._module.__default $h@@3) (or (= $o@@6 null) (U_2_bool (MapType1Select $h@@3 $o@@6 alloc)))) (=> (or (= $o@@6 null) (U_2_bool (MapType1Select $h@@3 $o@@6 alloc))) ($IsAlloc $o@@6 Tclass._module.__default $h@@3)))) :qid |unknown.0:0| :skolemid |334| :pattern (($IsAlloc $o@@6 Tclass._module.__default $h@@3)))))
(assert (forall (($ly T@U) ($Heap T@U) (|n#0| Int)) (! (=> (and (= (type $ly) LayerTypeType) (= (type $Heap) (MapType1Type refType))) (= (_module.__default.Factorial ($LS $ly) $Heap |n#0|) (_module.__default.Factorial $ly $Heap |n#0|))) :qid |Classics.7:10| :skolemid |335| :pattern ((_module.__default.Factorial ($LS $ly) $Heap |n#0|)))))
(assert (forall (($ly@@0 T@U) ($h0 T@U) ($h1 T@U) (|n#0@@0| Int)) (! (=> (and (and (= (type $ly@@0) LayerTypeType) (= (type $h0) (MapType1Type refType))) (= (type $h1) (MapType1Type refType))) (=> (and (and (and ($IsGoodHeap $h0) ($IsGoodHeap $h1)) (and (or (|_module.__default.Factorial#canCall| $h0 |n#0@@0|) (<= 0 |n#0@@0|)) (or (|_module.__default.Factorial#canCall| $h1 |n#0@@0|) (<= 0 |n#0@@0|)))) (and ($IsHeapAnchor $h0) ($HeapSucc $h0 $h1))) (=> (forall (($o@@7 T@U) ($f T@U)) (! (let ((alpha@@6 (FieldTypeInv0 (type $f)))) (=> (and (and (= (type $o@@7) refType) (= (type $f) (FieldType alpha@@6))) false) (= (MapType1Select $h0 $o@@7 $f) (MapType1Select $h1 $o@@7 $f)))) :qid |unknown.0:0| :skolemid |336| :no-pattern (type $o@@7) :no-pattern (type $f) :no-pattern (U_2_int $o@@7) :no-pattern (U_2_bool $o@@7) :no-pattern (U_2_int $f) :no-pattern (U_2_bool $f))) (= (_module.__default.Factorial $ly@@0 $h0 |n#0@@0|) (_module.__default.Factorial $ly@@0 $h1 |n#0@@0|))))) :qid |unknown.0:0| :skolemid |337| :pattern (($IsHeapAnchor $h0) ($HeapSucc $h0 $h1) (_module.__default.Factorial $ly@@0 $h1 |n#0@@0|)))))
(assert (=> (or (< 0 $ModuleContextHeight) (and (= 0 $ModuleContextHeight) (<= 0 $FunctionContextHeight))) (forall (($ly@@1 T@U) ($Heap@@0 T@U) (|n#0@@1| Int)) (! (=> (and (and (= (type $ly@@1) LayerTypeType) (= (type $Heap@@0) (MapType1Type refType))) (or (|_module.__default.Factorial#canCall| $Heap@@0 |n#0@@1|) (and (or (not (= 0 $ModuleContextHeight)) (not (= 0 $FunctionContextHeight))) (and ($IsGoodHeap $Heap@@0) (<= 0 |n#0@@1|))))) (<= 0 (_module.__default.Factorial ($LS $ly@@1) $Heap@@0 |n#0@@1|))) :qid |Classics.7:10| :skolemid |338| :pattern ((_module.__default.Factorial ($LS $ly@@1) $Heap@@0 |n#0@@1|))))))
(assert (forall (($ly@@2 T@U) ($Heap@@1 T@U) (|n#0@@2| Int)) (! (=> (and (and (= (type $ly@@2) LayerTypeType) (= (type $Heap@@1) (MapType1Type refType))) (and ($IsGoodHeap $Heap@@1) (<= 0 |n#0@@2|))) (and (=> (|_module.__default.Factorial#requires| $ly@@2 $Heap@@1 |n#0@@2|) true) (=> true (|_module.__default.Factorial#requires| $ly@@2 $Heap@@1 |n#0@@2|)))) :qid |Classics.7:10| :skolemid |339| :pattern ((|_module.__default.Factorial#requires| $ly@@2 $Heap@@1 |n#0@@2|)))))
(assert (=> (and (= 0 $ModuleContextHeight) (<= 0 $FunctionContextHeight)) (forall (($ly@@3 T@U) ($Heap@@2 T@U) (|n#0@@3| Int)) (! (=> (and (and (= (type $ly@@3) LayerTypeType) (= (type $Heap@@2) (MapType1Type refType))) (or (|_module.__default.Factorial#canCall| $Heap@@2 |n#0@@3|) (and (not (= 0 $FunctionContextHeight)) (and ($IsGoodHeap $Heap@@2) (<= 0 |n#0@@3|))))) (and (and (=> (= |n#0@@3| (LitInt 0)) true) (=> (not (= |n#0@@3| (LitInt 0))) (|_module.__default.Factorial#canCall| $Heap@@2 (- |n#0@@3| 1)))) (= (_module.__default.Factorial ($LS $ly@@3) $Heap@@2 |n#0@@3|) (ite (= |n#0@@3| (LitInt 0)) 1 (* |n#0@@3| (_module.__default.Factorial $ly@@3 $Heap@@2 (- |n#0@@3| 1))))))) :qid |Classics.7:10| :skolemid |340| :pattern ((_module.__default.Factorial ($LS $ly@@3) $Heap@@2 |n#0@@3|))))))
(assert (=> (and (= 0 $ModuleContextHeight) (<= 0 $FunctionContextHeight)) (forall (($ly@@4 T@U) ($Heap@@3 T@U) (|n#0@@4| Int)) (! (=> (and (and (= (type $ly@@4) LayerTypeType) (= (type $Heap@@3) (MapType1Type refType))) (or (|_module.__default.Factorial#canCall| $Heap@@3 (LitInt |n#0@@4|)) (and (not (= 0 $FunctionContextHeight)) (and ($IsGoodHeap $Heap@@3) (<= 0 |n#0@@4|))))) (and (and (=> (= (LitInt |n#0@@4|) (LitInt 0)) true) (=> (not (= (LitInt |n#0@@4|) (LitInt 0))) (|_module.__default.Factorial#canCall| $Heap@@3 (LitInt (- |n#0@@4| 1))))) (= (_module.__default.Factorial $ly@@4 $Heap@@3 (LitInt |n#0@@4|)) (ite (= (LitInt |n#0@@4|) (LitInt 0)) 1 (* |n#0@@4| (_module.__default.Factorial $ly@@4 $Heap@@3 (LitInt (- |n#0@@4| 1)))))))) :qid |Classics.7:10| :weight 3 :skolemid |341| :pattern ((_module.__default.Factorial $ly@@4 $Heap@@3 (LitInt |n#0@@4|)))))))
(assert (=> (< 0 $ModuleContextHeight) (forall (($ly@@5 T@U) ($Heap@@4 T@U) (|n#0@@5| Int)) (! (=> (and (and (= (type $ly@@5) LayerTypeType) (= (type $Heap@@4) (MapType1Type refType))) (or (|_module.__default.Factorial#canCall| $Heap@@4 |n#0@@5|) (and ($IsGoodHeap $Heap@@4) (<= 0 |n#0@@5|)))) (and (and (=> (= |n#0@@5| (LitInt 0)) true) (=> (not (= |n#0@@5| (LitInt 0))) (|_module.__default.Factorial#canCall| $Heap@@4 (- |n#0@@5| 1)))) (= (_module.__default.Factorial ($LS $ly@@5) $Heap@@4 |n#0@@5|) (ite (= |n#0@@5| (LitInt 0)) 1 (* |n#0@@5| (_module.__default.Factorial $ly@@5 $Heap@@4 (- |n#0@@5| 1))))))) :qid |Classics.7:10| :skolemid |342| :pattern ((_module.__default.Factorial ($LS $ly@@5) $Heap@@4 |n#0@@5|))))))
(assert (=> (< 0 $ModuleContextHeight) (forall (($ly@@6 T@U) ($Heap@@5 T@U) (|n#0@@6| Int)) (! (=> (and (and (= (type $ly@@6) LayerTypeType) (= (type $Heap@@5) (MapType1Type refType))) (or (|_module.__default.Factorial#canCall| $Heap@@5 (LitInt |n#0@@6|)) (and ($IsGoodHeap $Heap@@5) (<= 0 |n#0@@6|)))) (and (and (=> (= (LitInt |n#0@@6|) (LitInt 0)) true) (=> (not (= (LitInt |n#0@@6|) (LitInt 0))) (|_module.__default.Factorial#canCall| $Heap@@5 (LitInt (- |n#0@@6| 1))))) (= (_module.__default.Factorial $ly@@6 $Heap@@5 (LitInt |n#0@@6|)) (ite (= (LitInt |n#0@@6|) (LitInt 0)) 1 (* |n#0@@6| (_module.__default.Factorial $ly@@6 $Heap@@5 (LitInt (- |n#0@@6| 1)))))))) :qid |Classics.7:10| :weight 3 :skolemid |343| :pattern ((_module.__default.Factorial $ly@@6 $Heap@@5 (LitInt |n#0@@6|)))))))
(assert (and (and (and (and (and (and (and (forall ((arg0@@107 T@T) (arg1@@54 T@T)) (! (= (Ctor (MapType3Type arg0@@107 arg1@@54)) 20) :qid |ctor:MapType3Type|)) (forall ((arg0@@108 T@T) (arg1@@55 T@T)) (! (= (MapType3TypeInv0 (MapType3Type arg0@@108 arg1@@55)) arg0@@108) :qid |typeInv:MapType3TypeInv0| :pattern ((MapType3Type arg0@@108 arg1@@55))))) (forall ((arg0@@109 T@T) (arg1@@56 T@T)) (! (= (MapType3TypeInv1 (MapType3Type arg0@@109 arg1@@56)) arg1@@56) :qid |typeInv:MapType3TypeInv1| :pattern ((MapType3Type arg0@@109 arg1@@56))))) (forall ((arg0@@110 T@U) (arg1@@57 T@U) (arg2@@19 T@U)) (! (let ((aVar1@@3 (MapType3TypeInv1 (type arg0@@110)))) (= (type (MapType3Select arg0@@110 arg1@@57 arg2@@19)) aVar1@@3)) :qid |funType:MapType3Select| :pattern ((MapType3Select arg0@@110 arg1@@57 arg2@@19))))) (forall ((arg0@@111 T@U) (arg1@@58 T@U) (arg2@@20 T@U) (arg3@@3 T@U)) (! (let ((aVar1@@4 (type arg3@@3))) (let ((aVar0@@2 (type arg1@@58))) (= (type (MapType3Store arg0@@111 arg1@@58 arg2@@20 arg3@@3)) (MapType3Type aVar0@@2 aVar1@@4)))) :qid |funType:MapType3Store| :pattern ((MapType3Store arg0@@111 arg1@@58 arg2@@20 arg3@@3))))) (forall ((m@@22 T@U) (x0@@10 T@U) (x1@@7 T@U) (val@@10 T@U)) (! (let ((aVar1@@5 (MapType3TypeInv1 (type m@@22)))) (=> (= (type val@@10) aVar1@@5) (= (MapType3Select (MapType3Store m@@22 x0@@10 x1@@7 val@@10) x0@@10 x1@@7) val@@10))) :qid |mapAx0:MapType3Select| :weight 0))) (and (and (forall ((val@@11 T@U) (m@@23 T@U) (x0@@11 T@U) (x1@@8 T@U) (y0@@7 T@U) (y1@@5 T@U)) (! (or (= x0@@11 y0@@7) (= (MapType3Select (MapType3Store m@@23 x0@@11 x1@@8 val@@11) y0@@7 y1@@5) (MapType3Select m@@23 y0@@7 y1@@5))) :qid |mapAx1:MapType3Select:0| :weight 0)) (forall ((val@@12 T@U) (m@@24 T@U) (x0@@12 T@U) (x1@@9 T@U) (y0@@8 T@U) (y1@@6 T@U)) (! (or (= x1@@9 y1@@6) (= (MapType3Select (MapType3Store m@@24 x0@@12 x1@@9 val@@12) y0@@8 y1@@6) (MapType3Select m@@24 y0@@8 y1@@6))) :qid |mapAx1:MapType3Select:1| :weight 0))) (forall ((val@@13 T@U) (m@@25 T@U) (x0@@13 T@U) (x1@@10 T@U) (y0@@9 T@U) (y1@@7 T@U)) (! (or true (= (MapType3Select (MapType3Store m@@25 x0@@13 x1@@10 val@@13) y0@@9 y1@@7) (MapType3Select m@@25 y0@@9 y1@@7))) :qid |mapAx2:MapType3Select| :weight 0)))) (forall ((arg0@@112 T@U) (arg1@@59 T@U) (arg2@@21 T@U)) (! (= (type (|lambda#0| arg0@@112 arg1@@59 arg2@@21)) (MapType3Type refType boolType)) :qid |funType:lambda#0| :pattern ((|lambda#0| arg0@@112 arg1@@59 arg2@@21))))))
(assert (forall (($o@@8 T@U) ($f@@0 T@U) (alloc@@0 T@U) (null@@0 T@U) ($Heap@@6 T@U)) (! (let ((alpha@@7 (FieldTypeInv0 (type $f@@0)))) (=> (and (and (and (and (= (type $o@@8) refType) (= (type $f@@0) (FieldType alpha@@7))) (= (type alloc@@0) (FieldType boolType))) (= (type null@@0) refType)) (= (type $Heap@@6) (MapType1Type refType))) (= (U_2_bool (MapType3Select (|lambda#0| alloc@@0 null@@0 $Heap@@6) $o@@8 $f@@0)) (=> (and (not (= $o@@8 null@@0)) (U_2_bool (MapType1Select $Heap@@6 $o@@8 alloc@@0))) false)))) :qid |Classics.7:10| :skolemid |454| :pattern ((MapType3Select (|lambda#0| alloc@@0 null@@0 $Heap@@6) $o@@8 $f@@0)))))
(assert (forall ((arg0@@113 T@U) (arg1@@60 T@U) (arg2@@22 T@U)) (! (= (type (|lambda#1| arg0@@113 arg1@@60 arg2@@22)) (MapType3Type refType boolType)) :qid |funType:lambda#1| :pattern ((|lambda#1| arg0@@113 arg1@@60 arg2@@22)))))
(assert (forall (($o@@9 T@U) ($f@@1 T@U) (alloc@@1 T@U) (null@@1 T@U) ($Heap@@7 T@U)) (! (let ((alpha@@8 (FieldTypeInv0 (type $f@@1)))) (=> (and (and (and (and (= (type $o@@9) refType) (= (type $f@@1) (FieldType alpha@@8))) (= (type alloc@@1) (FieldType boolType))) (= (type null@@1) refType)) (= (type $Heap@@7) (MapType1Type refType))) (= (U_2_bool (MapType3Select (|lambda#1| alloc@@1 null@@1 $Heap@@7) $o@@9 $f@@1)) (=> (and (not (= $o@@9 null@@1)) (U_2_bool (MapType1Select $Heap@@7 $o@@9 alloc@@1))) false)))) :qid |Classics.7:10| :skolemid |455| :pattern ((MapType3Select (|lambda#1| alloc@@1 null@@1 $Heap@@7) $o@@9 $f@@1)))))
(assert (forall ((arg0@@114 T@U) (arg1@@61 T@U) (arg2@@23 T@U)) (! (= (type (|lambda#2| arg0@@114 arg1@@61 arg2@@23)) (MapType3Type refType boolType)) :qid |funType:lambda#2| :pattern ((|lambda#2| arg0@@114 arg1@@61 arg2@@23)))))
(assert (forall (($o@@10 T@U) ($f@@2 T@U) (alloc@@2 T@U) (null@@2 T@U) ($Heap@@8 T@U)) (! (let ((alpha@@9 (FieldTypeInv0 (type $f@@2)))) (=> (and (and (and (and (= (type $o@@10) refType) (= (type $f@@2) (FieldType alpha@@9))) (= (type alloc@@2) (FieldType boolType))) (= (type null@@2) refType)) (= (type $Heap@@8) (MapType1Type refType))) (= (U_2_bool (MapType3Select (|lambda#2| alloc@@2 null@@2 $Heap@@8) $o@@10 $f@@2)) (=> (and (not (= $o@@10 null@@2)) (U_2_bool (MapType1Select $Heap@@8 $o@@10 alloc@@2))) false)))) :qid |Classics.12:8| :skolemid |456| :pattern ((MapType3Select (|lambda#2| alloc@@2 null@@2 $Heap@@8) $o@@10 $f@@2)))))
(assert (forall ((arg0@@115 T@U) (arg1@@62 T@U) (arg2@@24 T@U)) (! (= (type (|lambda#3| arg0@@115 arg1@@62 arg2@@24)) (MapType3Type refType boolType)) :qid |funType:lambda#3| :pattern ((|lambda#3| arg0@@115 arg1@@62 arg2@@24)))))
(assert (forall (($o@@11 T@U) ($f@@3 T@U) (alloc@@3 T@U) (null@@3 T@U) ($Heap@@9 T@U)) (! (let ((alpha@@10 (FieldTypeInv0 (type $f@@3)))) (=> (and (and (and (and (= (type $o@@11) refType) (= (type $f@@3) (FieldType alpha@@10))) (= (type alloc@@3) (FieldType boolType))) (= (type null@@3) refType)) (= (type $Heap@@9) (MapType1Type refType))) (= (U_2_bool (MapType3Select (|lambda#3| alloc@@3 null@@3 $Heap@@9) $o@@11 $f@@3)) (=> (and (not (= $o@@11 null@@3)) (U_2_bool (MapType1Select $Heap@@9 $o@@11 alloc@@3))) false)))) :qid |Classics.12:8| :skolemid |457| :pattern ((MapType3Select (|lambda#3| alloc@@3 null@@3 $Heap@@9) $o@@11 $f@@3)))))
(assert (forall ((arg0@@116 T@U) (arg1@@63 T@U) (arg2@@25 T@U) (arg3@@4 T@U)) (! (= (type (|lambda#4| arg0@@116 arg1@@63 arg2@@25 arg3@@4)) (MapType3Type refType boolType)) :qid |funType:lambda#4| :pattern ((|lambda#4| arg0@@116 arg1@@63 arg2@@25 arg3@@4)))))
(assert (forall (($o@@12 T@U) ($f@@4 T@U) (|A#0| T@U) (null@@4 T@U) ($Heap@@10 T@U) (alloc@@4 T@U)) (! (let ((alpha@@11 (FieldTypeInv0 (type $f@@4)))) (=> (and (and (and (and (and (= (type $o@@12) refType) (= (type $f@@4) (FieldType alpha@@11))) (= (type |A#0|) refType)) (= (type null@@4) refType)) (= (type $Heap@@10) (MapType1Type refType))) (= (type alloc@@4) (FieldType boolType))) (= (U_2_bool (MapType3Select (|lambda#4| |A#0| null@@4 $Heap@@10 alloc@@4) $o@@12 $f@@4)) (=> (and (not (= $o@@12 null@@4)) (U_2_bool (MapType1Select $Heap@@10 $o@@12 alloc@@4))) (= $o@@12 |A#0|))))) :qid |Classics.47:8| :skolemid |458| :pattern ((MapType3Select (|lambda#4| |A#0| null@@4 $Heap@@10 alloc@@4) $o@@12 $f@@4)))))
(assert (forall ((arg0@@117 T@U) (arg1@@64 T@U) (arg2@@26 T@U) (arg3@@5 T@U)) (! (= (type (|lambda#5| arg0@@117 arg1@@64 arg2@@26 arg3@@5)) (MapType3Type refType boolType)) :qid |funType:lambda#5| :pattern ((|lambda#5| arg0@@117 arg1@@64 arg2@@26 arg3@@5)))))
(assert (forall (($o@@13 T@U) ($f@@5 T@U) (|A#0@@0| T@U) (null@@5 T@U) ($Heap@@11 T@U) (alloc@@5 T@U)) (! (let ((alpha@@12 (FieldTypeInv0 (type $f@@5)))) (=> (and (and (and (and (and (= (type $o@@13) refType) (= (type $f@@5) (FieldType alpha@@12))) (= (type |A#0@@0|) refType)) (= (type null@@5) refType)) (= (type $Heap@@11) (MapType1Type refType))) (= (type alloc@@5) (FieldType boolType))) (= (U_2_bool (MapType3Select (|lambda#5| |A#0@@0| null@@5 $Heap@@11 alloc@@5) $o@@13 $f@@5)) (=> (and (not (= $o@@13 null@@5)) (U_2_bool (MapType1Select $Heap@@11 $o@@13 alloc@@5))) (= $o@@13 |A#0@@0|))))) :qid |Classics.47:8| :skolemid |459| :pattern ((MapType3Select (|lambda#5| |A#0@@0| null@@5 $Heap@@11 alloc@@5) $o@@13 $f@@5)))))
(assert (and (and (and (= (type $LZ) LayerTypeType) (= (type $Heap@@12) (MapType1Type refType))) (= (type $_Frame@0) (MapType3Type refType boolType))) (= (type $_Frame@0@@0) (MapType3Type refType boolType))))
(declare-fun $_Frame@0@@1 () T@U)
(declare-fun $Heap@0 () T@U)
(declare-fun %lbl%+13222 () Bool)
(declare-fun |u#0@0| () Int)
(declare-fun %lbl%@38757 () Bool)
(declare-fun |n#0@@8| () Int)
(declare-fun %lbl%+38617 () Bool)
(declare-fun |u#0| () Int)
(assert (and (= (type $_Frame@0@@1) (MapType3Type refType boolType)) (= (type $Heap@0) (MapType1Type refType))))
(declare-fun $_Frame@0@@2 () T@U)
(declare-fun %lbl%+14020 () Bool)
(declare-fun |r#0@1| () Int)
(declare-fun |n#0@@9| () Int)
(declare-fun %lbl%@40047 () Bool)
(declare-fun %lbl%+14018 () Bool)
(declare-fun %lbl%+14016 () Bool)
(declare-fun %lbl%+14014 () Bool)
(declare-fun |$w$loop#0@0| () Bool)
(declare-fun %lbl%+38846 () Bool)
(declare-fun %lbl%@40111 () Bool)
(declare-fun |u#0@4| () Int)
(declare-fun %lbl%+14031 () Bool)
(declare-fun |u#0@1| () Int)
(declare-fun %lbl%+14060 () Bool)
(declare-fun |s#0_0@2| () Int)
(declare-fun %lbl%@39965 () Bool)
(declare-fun %lbl%+14058 () Bool)
(declare-fun %lbl%+14056 () Bool)
(declare-fun %lbl%+14054 () Bool)
(declare-fun |$w$loop#0_0@1| () Bool)
(declare-fun %lbl%+14073 () Bool)
(declare-fun |$decr$loop#0_00@2| () Int)
(declare-fun %lbl%@39804 () Bool)
(declare-fun |u#0@2| () Int)
(declare-fun |u#0@3| () Int)
(declare-fun |s#0_0@3| () Int)
(declare-fun %lbl%@39843 () Bool)
(declare-fun %lbl%@39857 () Bool)
(declare-fun %lbl%@39880 () Bool)
(declare-fun %lbl%@39890 () Bool)
(declare-fun %lbl%@39901 () Bool)
(declare-fun %lbl%+14071 () Bool)
(declare-fun |r#0@2| () Int)
(declare-fun %lbl%@39710 () Bool)
(declare-fun |$decr$loop#00@1| () Int)
(declare-fun %lbl%@39725 () Bool)
(declare-fun %lbl%@39749 () Bool)
(declare-fun %lbl%@39759 () Bool)
(declare-fun %lbl%@39767 () Bool)
(declare-fun %lbl%+14062 () Bool)
(declare-fun %lbl%+14047 () Bool)
(declare-fun %lbl%+14077 () Bool)
(declare-fun %lbl%+14041 () Bool)
(declare-fun |$decr_init$loop#0_00@1| () Int)
(declare-fun %lbl%+14033 () Bool)
(declare-fun |s#0_0@1| () Int)
(declare-fun %lbl%@39390 () Bool)
(declare-fun %lbl%@39400 () Bool)
(declare-fun %lbl%@39411 () Bool)
(declare-fun %lbl%+14022 () Bool)
(declare-fun %lbl%+14007 () Bool)
(declare-fun %lbl%+14081 () Bool)
(declare-fun %lbl%+14001 () Bool)
(declare-fun |$decr_init$loop#00@0| () Int)
(declare-fun %lbl%+13999 () Bool)
(declare-fun %lbl%@38989 () Bool)
(declare-fun |u#0@0@@0| () Int)
(declare-fun |r#0@0| () Int)
(declare-fun %lbl%@39044 () Bool)
(declare-fun %lbl%@39054 () Bool)
(declare-fun %lbl%@39062 () Bool)
(declare-fun %lbl%+38866 () Bool)
(declare-fun |u#0@@0| () Int)
(assert (= (type $_Frame@0@@2) (MapType3Type refType boolType)))
(declare-fun |A#0@@1| () T@U)
(declare-fun $Heap@0@@0 () T@U)
(declare-fun $_Frame@0@@3 () T@U)
(declare-fun %lbl%+14397 () Bool)
(declare-fun %lbl%+14395 () Bool)
(declare-fun |p#0@0| () Int)
(declare-fun |f#0| () Int)
(declare-fun |q#0@0| () Int)
(declare-fun |N#0| () Int)
(declare-fun %lbl%+14393 () Bool)
(declare-fun %lbl%@40421 () Bool)
(declare-fun %lbl%@40427 () Bool)
(declare-fun %lbl%@40441 () Bool)
(declare-fun %lbl%@40447 () Bool)
(declare-fun %lbl%+14391 () Bool)
(declare-fun %lbl%+14389 () Bool)
(declare-fun %lbl%+14387 () Bool)
(declare-fun %lbl%+14385 () Bool)
(declare-fun %lbl%@40278 () Bool)
(declare-fun %lbl%+40193 () Bool)
(assert (and (and (= (type |A#0@@1|) refType) (= (type $Heap@0@@0) (MapType1Type refType))) (= (type $_Frame@0@@3) (MapType3Type refType boolType))))
(set-option :TIMEOUT 0)
(declare-fun $Heap@1 () T@U)
(declare-fun |A#0@@2| () T@U)
(declare-fun $Heap@4 () T@U)
(declare-fun $Heap@3 () T@U)
(declare-fun $_Frame@0@@4 () T@U)
(declare-fun $Heap@2 () T@U)
(declare-fun $Heap@6 () T@U)
(declare-fun $Heap@5 () T@U)
(declare-fun $Heap@0@@1 () T@U)
(declare-fun %lbl%+20562 () Bool)
(declare-fun %lbl%+20560 () Bool)
(declare-fun |p#4@0| () Int)
(declare-fun |n#0@0| () Int)
(declare-fun |q#4@0| () Int)
(declare-fun |N#0@@0| () Int)
(declare-fun %lbl%+20558 () Bool)
(declare-fun %lbl%@51117 () Bool)
(declare-fun %lbl%@51123 () Bool)
(declare-fun %lbl%@51137 () Bool)
(declare-fun %lbl%@51143 () Bool)
(declare-fun %lbl%+20549 () Bool)
(declare-fun %lbl%+20547 () Bool)
(declare-fun %lbl%+20538 () Bool)
(declare-fun %lbl%+20536 () Bool)
(declare-fun %lbl%+20527 () Bool)
(declare-fun %lbl%+20525 () Bool)
(declare-fun %lbl%+20523 () Bool)
(declare-fun |m#0@0| () Int)
(declare-fun %lbl%+20516 () Bool)
(declare-fun |p#2@0| () Int)
(declare-fun |q#2@0| () Int)
(declare-fun %lbl%+20514 () Bool)
(declare-fun %lbl%@50764 () Bool)
(declare-fun %lbl%@50770 () Bool)
(declare-fun %lbl%@50784 () Bool)
(declare-fun %lbl%@50790 () Bool)
(declare-fun %lbl%+20505 () Bool)
(declare-fun %lbl%+20503 () Bool)
(declare-fun %lbl%+20494 () Bool)
(declare-fun %lbl%+20492 () Bool)
(declare-fun %lbl%+20483 () Bool)
(declare-fun %lbl%+20481 () Bool)
(declare-fun %lbl%+20479 () Bool)
(declare-fun |f#0@@0| () Int)
(declare-fun %lbl%+20472 () Bool)
(declare-fun %lbl%+20470 () Bool)
(declare-fun %lbl%+20461 () Bool)
(declare-fun %lbl%+20459 () Bool)
(declare-fun %lbl%+20450 () Bool)
(declare-fun %lbl%+20448 () Bool)
(declare-fun %lbl%+20446 () Bool)
(declare-fun |$w$loop#0@0@@0| () Bool)
(declare-fun %lbl%+20852 () Bool)
(declare-fun %lbl%+20848 () Bool)
(declare-fun |i#0_0@1| () Int)
(declare-fun %lbl%+20846 () Bool)
(declare-fun %lbl%+20844 () Bool)
(declare-fun |j#0_0@1| () Int)
(declare-fun |$rhs#0_0@1| () Int)
(declare-fun %lbl%+20850 () Bool)
(declare-fun %lbl%+20831 () Bool)
(declare-fun %lbl%+20829 () Bool)
(declare-fun %lbl%@50266 () Bool)
(declare-fun %lbl%@50272 () Bool)
(declare-fun %lbl%+20820 () Bool)
(declare-fun %lbl%+20818 () Bool)
(declare-fun %lbl%+20816 () Bool)
(declare-fun %lbl%+20809 () Bool)
(declare-fun |p#0_4@0| () Int)
(declare-fun |q#0_4@0| () Int)
(declare-fun %lbl%+20807 () Bool)
(declare-fun %lbl%@50009 () Bool)
(declare-fun %lbl%@50015 () Bool)
(declare-fun %lbl%@50029 () Bool)
(declare-fun %lbl%@50035 () Bool)
(declare-fun %lbl%+20798 () Bool)
(declare-fun %lbl%+20796 () Bool)
(declare-fun %lbl%+20787 () Bool)
(declare-fun %lbl%+20785 () Bool)
(declare-fun %lbl%+20776 () Bool)
(declare-fun %lbl%+20774 () Bool)
(declare-fun %lbl%+20772 () Bool)
(declare-fun %lbl%+20765 () Bool)
(declare-fun |p#0_2@0| () Int)
(declare-fun |q#0_2@0| () Int)
(declare-fun %lbl%+20763 () Bool)
(declare-fun %lbl%@49656 () Bool)
(declare-fun %lbl%@49662 () Bool)
(declare-fun %lbl%@49676 () Bool)
(declare-fun %lbl%@49682 () Bool)
(declare-fun %lbl%+20754 () Bool)
(declare-fun %lbl%+20752 () Bool)
(declare-fun %lbl%+20743 () Bool)
(declare-fun %lbl%+20741 () Bool)
(declare-fun %lbl%+20732 () Bool)
(declare-fun %lbl%+20730 () Bool)
(declare-fun %lbl%+20728 () Bool)
(declare-fun %lbl%+20721 () Bool)
(declare-fun |q#0_0@0| () Int)
(declare-fun %lbl%+20719 () Bool)
(declare-fun %lbl%@49436 () Bool)
(declare-fun %lbl%@49442 () Bool)
(declare-fun %lbl%+20710 () Bool)
(declare-fun %lbl%+20708 () Bool)
(declare-fun %lbl%+20706 () Bool)
(declare-fun %lbl%+20699 () Bool)
(declare-fun |p#0_0@0| () Int)
(declare-fun %lbl%+20697 () Bool)
(declare-fun %lbl%@49299 () Bool)
(declare-fun %lbl%@49305 () Bool)
(declare-fun %lbl%+20688 () Bool)
(declare-fun %lbl%+20686 () Bool)
(declare-fun %lbl%+20684 () Bool)
(declare-fun %lbl%+20673 () Bool)
(declare-fun |g#0_2@0| () Int)
(declare-fun %lbl%+20671 () Bool)
(declare-fun %lbl%@49146 () Bool)
(declare-fun %lbl%@49152 () Bool)
(declare-fun %lbl%+20662 () Bool)
(declare-fun %lbl%+20660 () Bool)
(declare-fun %lbl%+20658 () Bool)
(declare-fun %lbl%+20677 () Bool)
(declare-fun %lbl%+20651 () Bool)
(declare-fun %lbl%+20640 () Bool)
(declare-fun |g#0_0@0| () Int)
(declare-fun %lbl%+20638 () Bool)
(declare-fun %lbl%@48994 () Bool)
(declare-fun %lbl%@49000 () Bool)
(declare-fun %lbl%+20629 () Bool)
(declare-fun %lbl%+20627 () Bool)
(declare-fun %lbl%+20625 () Bool)
(declare-fun %lbl%+20644 () Bool)
(declare-fun %lbl%+20618 () Bool)
(declare-fun %lbl%+20611 () Bool)
(declare-fun %lbl%+20609 () Bool)
(declare-fun %lbl%+20607 () Bool)
(declare-fun %lbl%+20600 () Bool)
(declare-fun %lbl%+20598 () Bool)
(declare-fun %lbl%+20596 () Bool)
(declare-fun |$w$loop#0_0@1@@0| () Bool)
(declare-fun %lbl%+21194 () Bool)
(declare-fun %lbl%@48420 () Bool)
(declare-fun |$decr$loop#00@1@@0| () Int)
(declare-fun |n#0@1| () Int)
(declare-fun |m#0@1| () Int)
(declare-fun %lbl%@48434 () Bool)
(declare-fun %lbl%@48707 () Bool)
(declare-fun %lbl%@48717 () Bool)
(declare-fun %lbl%@48725 () Bool)
(declare-fun %lbl%@48733 () Bool)
(declare-fun %lbl%@48741 () Bool)
(declare-fun %lbl%@48811 () Bool)
(declare-fun %lbl%+21191 () Bool)
(declare-fun %lbl%+21182 () Bool)
(declare-fun %lbl%+40820 () Bool)
(declare-fun %lbl%@51402 () Bool)
(declare-fun %lbl%+21198 () Bool)
(declare-fun %lbl%+21192 () Bool)
(declare-fun %lbl%+21189 () Bool)
(declare-fun %lbl%+20863 () Bool)
(declare-fun %lbl%+20573 () Bool)
(declare-fun %lbl%+20989 () Bool)
(declare-fun %lbl%+20987 () Bool)
(declare-fun |p#0_0_0@0| () Int)
(declare-fun |i#0_0@2| () Int)
(declare-fun %lbl%+20985 () Bool)
(declare-fun %lbl%@48232 () Bool)
(declare-fun %lbl%@48238 () Bool)
(declare-fun %lbl%+20976 () Bool)
(declare-fun %lbl%+20974 () Bool)
(declare-fun %lbl%+20972 () Bool)
(declare-fun %lbl%+20965 () Bool)
(declare-fun |g#0_0_2@0| () Int)
(declare-fun %lbl%+20963 () Bool)
(declare-fun %lbl%@48091 () Bool)
(declare-fun %lbl%@48097 () Bool)
(declare-fun %lbl%+20954 () Bool)
(declare-fun %lbl%+20952 () Bool)
(declare-fun %lbl%+20950 () Bool)
(declare-fun %lbl%+20943 () Bool)
(declare-fun |g#0_0_0@0| () Int)
(declare-fun %lbl%+20941 () Bool)
(declare-fun %lbl%@47959 () Bool)
(declare-fun %lbl%@47965 () Bool)
(declare-fun %lbl%+20932 () Bool)
(declare-fun %lbl%+20930 () Bool)
(declare-fun %lbl%+20928 () Bool)
(declare-fun |firstIteration#0_0_0@2| () Bool)
(declare-fun %lbl%+20919 () Bool)
(declare-fun %lbl%+20917 () Bool)
(declare-fun %lbl%+20915 () Bool)
(declare-fun %lbl%+20921 () Bool)
(declare-fun %lbl%+20901 () Bool)
(declare-fun %lbl%+20899 () Bool)
(declare-fun %lbl%+20897 () Bool)
(declare-fun |$w$loop#0_0_0@2| () Bool)
(declare-fun %lbl%+21119 () Bool)
(declare-fun %lbl%+21117 () Bool)
(declare-fun |j#0_0@2| () Int)
(declare-fun |q#0_0_0@0| () Int)
(declare-fun %lbl%+21115 () Bool)
(declare-fun %lbl%@47742 () Bool)
(declare-fun %lbl%@47748 () Bool)
(declare-fun %lbl%+21106 () Bool)
(declare-fun %lbl%+21104 () Bool)
(declare-fun %lbl%+21102 () Bool)
(declare-fun %lbl%+21095 () Bool)
(declare-fun |g#0_0_6@0| () Int)
(declare-fun %lbl%+21093 () Bool)
(declare-fun %lbl%@47609 () Bool)
(declare-fun %lbl%@47615 () Bool)
(declare-fun %lbl%+21084 () Bool)
(declare-fun %lbl%+21082 () Bool)
(declare-fun %lbl%+21080 () Bool)
(declare-fun %lbl%+21073 () Bool)
(declare-fun |g#0_0_4@0| () Int)
(declare-fun %lbl%+21071 () Bool)
(declare-fun %lbl%@47477 () Bool)
(declare-fun %lbl%@47483 () Bool)
(declare-fun %lbl%+21062 () Bool)
(declare-fun %lbl%+21060 () Bool)
(declare-fun %lbl%+21058 () Bool)
(declare-fun %lbl%+21049 () Bool)
(declare-fun %lbl%+21047 () Bool)
(declare-fun %lbl%+21045 () Bool)
(declare-fun %lbl%+21051 () Bool)
(declare-fun %lbl%+21031 () Bool)
(declare-fun %lbl%+21029 () Bool)
(declare-fun %lbl%+21027 () Bool)
(declare-fun |$w$loop#0_0_1@2| () Bool)
(declare-fun %lbl%+21171 () Bool)
(declare-fun %lbl%@46480 () Bool)
(declare-fun |$decr$loop#0_00@2@@0| () Int)
(declare-fun |j#0_0@4| () Int)
(declare-fun |i#0_0@4| () Int)
(declare-fun %lbl%@46494 () Bool)
(declare-fun %lbl%@46960 () Bool)
(declare-fun %lbl%@46967 () Bool)
(declare-fun %lbl%@46974 () Bool)
(declare-fun %lbl%@46988 () Bool)
(declare-fun %lbl%@46996 () Bool)
(declare-fun %lbl%@47039 () Bool)
(declare-fun %lbl%@47084 () Bool)
(declare-fun %lbl%@47127 () Bool)
(declare-fun %lbl%@47168 () Bool)
(declare-fun %lbl%@47238 () Bool)
(declare-fun %lbl%@47308 () Bool)
(declare-fun %lbl%+21167 () Bool)
(declare-fun %lbl%@46351 () Bool)
(declare-fun %lbl%@46366 () Bool)
(declare-fun |$rhs#0_0_2_2@2| () Int)
(declare-fun |$rhs#0_0_2_3@2| () Int)
(declare-fun %lbl%+21165 () Bool)
(declare-fun %lbl%+21163 () Bool)
(declare-fun %lbl%@46297 () Bool)
(declare-fun %lbl%@46303 () Bool)
(declare-fun %lbl%+21161 () Bool)
(declare-fun %lbl%@46062 () Bool)
(declare-fun %lbl%@46068 () Bool)
(declare-fun |w#0_0_2_0@2| () Int)
(declare-fun %lbl%@46106 () Bool)
(declare-fun %lbl%@46112 () Bool)
(declare-fun %lbl%@46128 () Bool)
(declare-fun %lbl%@46136 () Bool)
(declare-fun %lbl%@46142 () Bool)
(declare-fun |$rhs#0_0_2_0@2| () Int)
(declare-fun %lbl%@46200 () Bool)
(declare-fun %lbl%@46206 () Bool)
(declare-fun %lbl%@46222 () Bool)
(declare-fun %lbl%@46258 () Bool)
(declare-fun %lbl%@46264 () Bool)
(declare-fun %lbl%+21169 () Bool)
(declare-fun %lbl%+21154 () Bool)
(declare-fun %lbl%@45992 () Bool)
(declare-fun %lbl%@46007 () Bool)
(declare-fun %lbl%+21147 () Bool)
(declare-fun %lbl%+21145 () Bool)
(declare-fun %lbl%@45938 () Bool)
(declare-fun %lbl%@45944 () Bool)
(declare-fun %lbl%+21130 () Bool)
(declare-fun %lbl%@45562 () Bool)
(declare-fun %lbl%@45568 () Bool)
(declare-fun %lbl%+21132 () Bool)
(declare-fun |j#0_0@3| () Int)
(declare-fun %lbl%@45618 () Bool)
(declare-fun %lbl%@45629 () Bool)
(declare-fun %lbl%@45776 () Bool)
(declare-fun %lbl%@45786 () Bool)
(declare-fun %lbl%@45793 () Bool)
(declare-fun %lbl%@45804 () Bool)
(declare-fun %lbl%@45841 () Bool)
(declare-fun %lbl%@45880 () Bool)
(declare-fun %lbl%+21121 () Bool)
(declare-fun %lbl%@45525 () Bool)
(declare-fun %lbl%@45531 () Bool)
(declare-fun %lbl%+21020 () Bool)
(declare-fun %lbl%+21136 () Bool)
(declare-fun %lbl%+21014 () Bool)
(declare-fun |$rhs#0@0| () Int)
(declare-fun |$rhs#1@0| () Int)
(declare-fun |$decr_init$loop#00@0@@0| () Int)
(declare-fun %lbl%+21000 () Bool)
(declare-fun %lbl%@44504 () Bool)
(declare-fun %lbl%@44514 () Bool)
(declare-fun %lbl%@44521 () Bool)
(declare-fun %lbl%@44532 () Bool)
(declare-fun %lbl%@44569 () Bool)
(declare-fun %lbl%@44608 () Bool)
(declare-fun %lbl%+21002 () Bool)
(declare-fun |$decr$loop#0_0_00@3| () Int)
(declare-fun |i#0_0@3| () Int)
(declare-fun %lbl%@44693 () Bool)
(declare-fun %lbl%@44707 () Bool)
(declare-fun %lbl%@44857 () Bool)
(declare-fun %lbl%@44864 () Bool)
(declare-fun %lbl%@44872 () Bool)
(declare-fun %lbl%@44883 () Bool)
(declare-fun %lbl%@44920 () Bool)
(declare-fun %lbl%@44959 () Bool)
(declare-fun %lbl%+20991 () Bool)
(declare-fun %lbl%@44460 () Bool)
(declare-fun %lbl%@44466 () Bool)
(declare-fun %lbl%+20890 () Bool)
(declare-fun %lbl%+21006 () Bool)
(declare-fun %lbl%+20884 () Bool)
(declare-fun |$decr_init$loop#0_0_00@2| () Int)
(declare-fun %lbl%+20882 () Bool)
(declare-fun %lbl%@43798 () Bool)
(declare-fun %lbl%@43805 () Bool)
(declare-fun %lbl%@43813 () Bool)
(declare-fun %lbl%@43824 () Bool)
(declare-fun %lbl%@43861 () Bool)
(declare-fun %lbl%@43900 () Bool)
(declare-fun %lbl%+20876 () Bool)
(declare-fun %lbl%+20874 () Bool)
(declare-fun %lbl%+20865 () Bool)
(declare-fun %lbl%+20854 () Bool)
(declare-fun %lbl%+20589 () Bool)
(declare-fun %lbl%+21173 () Bool)
(declare-fun %lbl%+20583 () Bool)
(declare-fun |$decr_init$loop#0_00@1@@0| () Int)
(declare-fun %lbl%+20575 () Bool)
(declare-fun %lbl%@42105 () Bool)
(declare-fun %lbl%@42111 () Bool)
(declare-fun %lbl%@42185 () Bool)
(declare-fun %lbl%@42192 () Bool)
(declare-fun %lbl%@42199 () Bool)
(declare-fun %lbl%@42213 () Bool)
(declare-fun %lbl%@42221 () Bool)
(declare-fun %lbl%@42264 () Bool)
(declare-fun %lbl%@42309 () Bool)
(declare-fun %lbl%@42352 () Bool)
(declare-fun %lbl%@42393 () Bool)
(declare-fun %lbl%@42463 () Bool)
(declare-fun %lbl%@42533 () Bool)
(declare-fun %lbl%+20564 () Bool)
(declare-fun %lbl%+20439 () Bool)
(declare-fun %lbl%+21196 () Bool)
(declare-fun %lbl%+20433 () Bool)
(declare-fun %lbl%+20431 () Bool)
(declare-fun %lbl%@41183 () Bool)
(declare-fun %lbl%@41193 () Bool)
(declare-fun %lbl%@41201 () Bool)
(declare-fun %lbl%@41209 () Bool)
(declare-fun %lbl%@41217 () Bool)
(declare-fun %lbl%@41289 () Bool)
(declare-fun %lbl%+40854 () Bool)
(assert (and (and (and (and (and (and (and (and (= (type $Heap@1) (MapType1Type refType)) (= (type |A#0@@2|) refType)) (= (type $Heap@4) (MapType1Type refType))) (= (type $Heap@3) (MapType1Type refType))) (= (type $_Frame@0@@4) (MapType3Type refType boolType))) (= (type $Heap@2) (MapType1Type refType))) (= (type $Heap@6) (MapType1Type refType))) (= (type $Heap@5) (MapType1Type refType))) (= (type $Heap@0@@1) (MapType1Type refType))))
(push 1)
(set-info :boogie-vc-id Impl$$_module.__default.FIND)
(assert (not (let ((anon24_correct (=> (! (and %lbl%+20562 true) :lblpos +20562) true))) (let ((anon153_Else_correct (=> (! (and %lbl%+20560 true) :lblpos +20560) (=> (not (and (and (and (<= (LitInt 0) |p#4@0|) (<= |p#4@0| |n#0@0|)) (< |n#0@0| |q#4@0|)) (< |q#4@0| |N#0@@0|))) anon24_correct)))) (let ((anon153_Then_correct (=> (! (and %lbl%+20558 true) :lblpos +20558) (=> (and (and (and (<= (LitInt 0) |p#4@0|) (<= |p#4@0| |n#0@0|)) (< |n#0@0| |q#4@0|)) (< |q#4@0| |N#0@@0|)) (and (! (or %lbl%@51117 (not (= |A#0@@2| null))) :lblneg @51117) (=> (not (= |A#0@@2| null)) (and (! (or %lbl%@51123 (and (<= 0 |p#4@0|) (< |p#4@0| (_System.array.Length |A#0@@2|)))) :lblneg @51123) (and (! (or %lbl%@51137 (not (= |A#0@@2| null))) :lblneg @51137) (=> (not (= |A#0@@2| null)) (and (! (or %lbl%@51143 (and (<= 0 |q#4@0|) (< |q#4@0| (_System.array.Length |A#0@@2|)))) :lblneg @51143) anon24_correct)))))))))) (let ((anon152_Else_correct (=> (! (and %lbl%+20549 true) :lblpos +20549) (=> (not (and (and (<= (LitInt 0) |p#4@0|) (<= |p#4@0| |n#0@0|)) (< |n#0@0| |q#4@0|))) (and anon153_Then_correct anon153_Else_correct))))) (let ((anon152_Then_correct (=> (! (and %lbl%+20547 true) :lblpos +20547) (=> (and (and (<= (LitInt 0) |p#4@0|) (<= |p#4@0| |n#0@0|)) (< |n#0@0| |q#4@0|)) (and anon153_Then_correct anon153_Else_correct))))) (let ((anon151_Else_correct (=> (! (and %lbl%+20538 true) :lblpos +20538) (=> (not (and (<= (LitInt 0) |p#4@0|) (<= |p#4@0| |n#0@0|))) (and anon152_Then_correct anon152_Else_correct))))) (let ((anon151_Then_correct (=> (! (and %lbl%+20536 true) :lblpos +20536) (=> (and (<= (LitInt 0) |p#4@0|) (<= |p#4@0| |n#0@0|)) (and anon152_Then_correct anon152_Else_correct))))) (let ((anon150_Else_correct (=> (! (and %lbl%+20527 true) :lblpos +20527) (=> (< |p#4@0| (LitInt 0)) (and anon151_Then_correct anon151_Else_correct))))) (let ((anon150_Then_correct (=> (! (and %lbl%+20525 true) :lblpos +20525) (=> (<= (LitInt 0) |p#4@0|) (and anon151_Then_correct anon151_Else_correct))))) (let ((anon16_correct (=> (! (and %lbl%+20523 true) :lblpos +20523) (=> (and (forall ((|p#3| Int) (|q#3| Int)) (! (=> true (and (and (and (=> (<= (LitInt 0) |p#3|) true) (=> (and (<= (LitInt 0) |p#3|) (< |p#3| |m#0@0|)) true)) (=> (and (and (<= (LitInt 0) |p#3|) (< |p#3| |m#0@0|)) (<= |m#0@0| |q#3|)) true)) (=> (and (and (and (<= (LitInt 0) |p#3|) (< |p#3| |m#0@0|)) (<= |m#0@0| |q#3|)) (< |q#3| |N#0@@0|)) true))) :qid |Classics.56:22| :skolemid |364|)) (forall ((|p#3@@0| Int) (|q#3@@0| Int)) (! (=> true (=> (and (and (and (<= (LitInt 0) |p#3@@0|) (< |p#3@@0| |m#0@0|)) (<= |m#0@0| |q#3@@0|)) (< |q#3@@0| |N#0@@0|)) (<= (U_2_int ($Unbox intType (MapType1Select $Heap@0@@1 |A#0@@2| (IndexField |p#3@@0|)))) (U_2_int ($Unbox intType (MapType1Select $Heap@0@@1 |A#0@@2| (IndexField |q#3@@0|))))))) :qid |Classics.56:22| :skolemid |365|))) (and anon150_Then_correct anon150_Else_correct))))) (let ((anon149_Else_correct (=> (! (and %lbl%+20516 true) :lblpos +20516) (=> (not (and (and (and (<= (LitInt 0) |p#2@0|) (< |p#2@0| |m#0@0|)) (<= |m#0@0| |q#2@0|)) (< |q#2@0| |N#0@@0|))) anon16_correct)))) (let ((anon149_Then_correct (=> (! (and %lbl%+20514 true) :lblpos +20514) (=> (and (and (and (<= (LitInt 0) |p#2@0|) (< |p#2@0| |m#0@0|)) (<= |m#0@0| |q#2@0|)) (< |q#2@0| |N#0@@0|)) (and (! (or %lbl%@50764 (not (= |A#0@@2| null))) :lblneg @50764) (=> (not (= |A#0@@2| null)) (and (! (or %lbl%@50770 (and (<= 0 |p#2@0|) (< |p#2@0| (_System.array.Length |A#0@@2|)))) :lblneg @50770) (and (! (or %lbl%@50784 (not (= |A#0@@2| null))) :lblneg @50784) (=> (not (= |A#0@@2| null)) (and (! (or %lbl%@50790 (and (<= 0 |q#2@0|) (< |q#2@0| (_System.array.Length |A#0@@2|)))) :lblneg @50790) anon16_correct)))))))))) (let ((anon148_Else_correct (=> (! (and %lbl%+20505 true) :lblpos +20505) (=> (not (and (and (<= (LitInt 0) |p#2@0|) (< |p#2@0| |m#0@0|)) (<= |m#0@0| |q#2@0|))) (and anon149_Then_correct anon149_Else_correct))))) (let ((anon148_Then_correct (=> (! (and %lbl%+20503 true) :lblpos +20503) (=> (and (and (<= (LitInt 0) |p#2@0|) (< |p#2@0| |m#0@0|)) (<= |m#0@0| |q#2@0|)) (and anon149_Then_correct anon149_Else_correct))))) (let ((anon147_Else_correct (=> (! (and %lbl%+20494 true) :lblpos +20494) (=> (not (and (<= (LitInt 0) |p#2@0|) (< |p#2@0| |m#0@0|))) (and anon148_Then_correct anon148_Else_correct))))) (let ((anon147_Then_correct (=> (! (and %lbl%+20492 true) :lblpos +20492) (=> (and (<= (LitInt 0) |p#2@0|) (< |p#2@0| |m#0@0|)) (and anon148_Then_correct anon148_Else_correct))))) (let ((anon146_Else_correct (=> (! (and %lbl%+20483 true) :lblpos +20483) (=> (< |p#2@0| (LitInt 0)) (and anon147_Then_correct anon147_Else_correct))))) (let ((anon146_Then_correct (=> (! (and %lbl%+20481 true) :lblpos +20481) (=> (<= (LitInt 0) |p#2@0|) (and anon147_Then_correct anon147_Else_correct))))) (let ((anon8_correct (=> (! (and %lbl%+20479 true) :lblpos +20479) (=> (and (and (=> (<= (LitInt 0) |m#0@0|) true) (=> (and (<= (LitInt 0) |m#0@0|) (<= |m#0@0| |f#0@@0|)) true)) (=> (and (and (<= (LitInt 0) |m#0@0|) (<= |m#0@0| |f#0@@0|)) (<= |f#0@@0| |n#0@0|)) true)) (=> (and (and (and (<= (LitInt 0) |m#0@0|) (<= |m#0@0| |f#0@@0|)) (<= |f#0@@0| |n#0@0|)) (< |n#0@0| |N#0@@0|)) (and anon146_Then_correct anon146_Else_correct)))))) (let ((anon145_Else_correct (=> (! (and %lbl%+20472 true) :lblpos +20472) (=> (not (and (and (<= (LitInt 0) |m#0@0|) (<= |m#0@0| |f#0@@0|)) (<= |f#0@@0| |n#0@0|))) anon8_correct)))) (let ((anon145_Then_correct (=> (! (and %lbl%+20470 true) :lblpos +20470) (=> (and (and (<= (LitInt 0) |m#0@0|) (<= |m#0@0| |f#0@@0|)) (<= |f#0@@0| |n#0@0|)) anon8_correct)))) (let ((anon144_Else_correct (=> (! (and %lbl%+20461 true) :lblpos +20461) (=> (not (and (<= (LitInt 0) |m#0@0|) (<= |m#0@0| |f#0@@0|))) (and anon145_Then_correct anon145_Else_correct))))) (let ((anon144_Then_correct (=> (! (and %lbl%+20459 true) :lblpos +20459) (=> (and (<= (LitInt 0) |m#0@0|) (<= |m#0@0| |f#0@@0|)) (and anon145_Then_correct anon145_Else_correct))))) (let ((anon143_Else_correct (=> (! (and %lbl%+20450 true) :lblpos +20450) (=> (< |m#0@0| (LitInt 0)) (and anon144_Then_correct anon144_Else_correct))))) (let ((anon143_Then_correct (=> (! (and %lbl%+20448 true) :lblpos +20448) (=> (<= (LitInt 0) |m#0@0|) (and anon144_Then_correct anon144_Else_correct))))) (let ((anon142_Then_correct (=> (! (and %lbl%+20446 true) :lblpos +20446) (=> (not |$w$loop#0@0@@0|) (and anon143_Then_correct anon143_Else_correct))))) (let ((anon76_correct (=> (! (and %lbl%+20852 true) :lblpos +20852) true))) (let ((anon180_Else_correct (=> (! (and %lbl%+20848 true) :lblpos +20848) (=> (<= |i#0_0@1| |m#0@0|) anon76_correct)))) (let ((anon180_Then_correct (=> (! (and %lbl%+20846 true) :lblpos +20846) (=> (< |m#0@0| |i#0_0@1|) anon76_correct)))) (let ((anon179_Then_correct (=> (! (and %lbl%+20844 true) :lblpos +20844) (=> (not (and (and (= |i#0_0@1| |m#0@0|) (= |j#0_0@1| |n#0@0|)) (= |$rhs#0_0@1| (U_2_int ($Unbox intType (MapType1Select $Heap@1 |A#0@@2| (IndexField |f#0@@0|))))))) (and anon180_Then_correct anon180_Else_correct))))) (let ((anon179_Else_correct (=> (! (and %lbl%+20850 true) :lblpos +20850) (=> (and (and (= |i#0_0@1| |m#0@0|) (= |j#0_0@1| |n#0@0|)) (= |$rhs#0_0@1| (U_2_int ($Unbox intType (MapType1Select $Heap@1 |A#0@@2| (IndexField |f#0@@0|)))))) anon76_correct)))) (let ((anon178_Else_correct (=> (! (and %lbl%+20831 true) :lblpos +20831) (=> (not (and (= |i#0_0@1| |m#0@0|) (= |j#0_0@1| |n#0@0|))) (and anon179_Then_correct anon179_Else_correct))))) (let ((anon178_Then_correct (=> (! (and %lbl%+20829 true) :lblpos +20829) (=> (and (= |i#0_0@1| |m#0@0|) (= |j#0_0@1| |n#0@0|)) (and (! (or %lbl%@50266 (not (= |A#0@@2| null))) :lblneg @50266) (=> (not (= |A#0@@2| null)) (and (! (or %lbl%@50272 (and (<= 0 |f#0@@0|) (< |f#0@@0| (_System.array.Length |A#0@@2|)))) :lblneg @50272) (and anon179_Then_correct anon179_Else_correct)))))))) (let ((anon177_Else_correct (=> (! (and %lbl%+20820 true) :lblpos +20820) (=> (not (= |i#0_0@1| |m#0@0|)) (and anon178_Then_correct anon178_Else_correct))))) (let ((anon177_Then_correct (=> (! (and %lbl%+20818 true) :lblpos +20818) (=> (= |i#0_0@1| |m#0@0|) (and anon178_Then_correct anon178_Else_correct))))) (let ((anon69_correct (=> (! (and %lbl%+20816 true) :lblpos +20816) (=> (and (forall ((|p#0_5| Int) (|q#0_5| Int)) (! (=> true (and (and (and (=> (<= (LitInt 0) |p#0_5|) true) (=> (and (<= (LitInt 0) |p#0_5|) (<= |p#0_5| |n#0@0|)) true)) (=> (and (and (<= (LitInt 0) |p#0_5|) (<= |p#0_5| |n#0@0|)) (< |n#0@0| |q#0_5|)) true)) (=> (and (and (and (<= (LitInt 0) |p#0_5|) (<= |p#0_5| |n#0@0|)) (< |n#0@0| |q#0_5|)) (< |q#0_5| |N#0@@0|)) true))) :qid |Classics.69:24| :skolemid |399|)) (forall ((|p#0_5@@0| Int) (|q#0_5@@0| Int)) (! (=> true (=> (and (and (and (<= (LitInt 0) |p#0_5@@0|) (<= |p#0_5@@0| |n#0@0|)) (< |n#0@0| |q#0_5@@0|)) (< |q#0_5@@0| |N#0@@0|)) (<= (U_2_int ($Unbox intType (MapType1Select $Heap@1 |A#0@@2| (IndexField |p#0_5@@0|)))) (U_2_int ($Unbox intType (MapType1Select $Heap@1 |A#0@@2| (IndexField |q#0_5@@0|))))))) :qid |Classics.69:24| :skolemid |400|))) (and anon177_Then_correct anon177_Else_correct))))) (let ((anon176_Else_correct (=> (! (and %lbl%+20809 true) :lblpos +20809) (=> (not (and (and (and (<= (LitInt 0) |p#0_4@0|) (<= |p#0_4@0| |n#0@0|)) (< |n#0@0| |q#0_4@0|)) (< |q#0_4@0| |N#0@@0|))) anon69_correct)))) (let ((anon176_Then_correct (=> (! (and %lbl%+20807 true) :lblpos +20807) (=> (and (and (and (<= (LitInt 0) |p#0_4@0|) (<= |p#0_4@0| |n#0@0|)) (< |n#0@0| |q#0_4@0|)) (< |q#0_4@0| |N#0@@0|)) (and (! (or %lbl%@50009 (not (= |A#0@@2| null))) :lblneg @50009) (=> (not (= |A#0@@2| null)) (and (! (or %lbl%@50015 (and (<= 0 |p#0_4@0|) (< |p#0_4@0| (_System.array.Length |A#0@@2|)))) :lblneg @50015) (and (! (or %lbl%@50029 (not (= |A#0@@2| null))) :lblneg @50029) (=> (not (= |A#0@@2| null)) (and (! (or %lbl%@50035 (and (<= 0 |q#0_4@0|) (< |q#0_4@0| (_System.array.Length |A#0@@2|)))) :lblneg @50035) anon69_correct)))))))))) (let ((anon175_Else_correct (=> (! (and %lbl%+20798 true) :lblpos +20798) (=> (not (and (and (<= (LitInt 0) |p#0_4@0|) (<= |p#0_4@0| |n#0@0|)) (< |n#0@0| |q#0_4@0|))) (and anon176_Then_correct anon176_Else_correct))))) (let ((anon175_Then_correct (=> (! (and %lbl%+20796 true) :lblpos +20796) (=> (and (and (<= (LitInt 0) |p#0_4@0|) (<= |p#0_4@0| |n#0@0|)) (< |n#0@0| |q#0_4@0|)) (and anon176_Then_correct anon176_Else_correct))))) (let ((anon174_Else_correct (=> (! (and %lbl%+20787 true) :lblpos +20787) (=> (not (and (<= (LitInt 0) |p#0_4@0|) (<= |p#0_4@0| |n#0@0|))) (and anon175_Then_correct anon175_Else_correct))))) (let ((anon174_Then_correct (=> (! (and %lbl%+20785 true) :lblpos +20785) (=> (and (<= (LitInt 0) |p#0_4@0|) (<= |p#0_4@0| |n#0@0|)) (and anon175_Then_correct anon175_Else_correct))))) (let ((anon173_Else_correct (=> (! (and %lbl%+20776 true) :lblpos +20776) (=> (< |p#0_4@0| (LitInt 0)) (and anon174_Then_correct anon174_Else_correct))))) (let ((anon173_Then_correct (=> (! (and %lbl%+20774 true) :lblpos +20774) (=> (<= (LitInt 0) |p#0_4@0|) (and anon174_Then_correct anon174_Else_correct))))) (let ((anon61_correct (=> (! (and %lbl%+20772 true) :lblpos +20772) (=> (and (forall ((|p#0_3| Int) (|q#0_3| Int)) (! (=> true (and (and (and (=> (<= (LitInt 0) |p#0_3|) true) (=> (and (<= (LitInt 0) |p#0_3|) (< |p#0_3| |m#0@0|)) true)) (=> (and (and (<= (LitInt 0) |p#0_3|) (< |p#0_3| |m#0@0|)) (<= |m#0@0| |q#0_3|)) true)) (=> (and (and (and (<= (LitInt 0) |p#0_3|) (< |p#0_3| |m#0@0|)) (<= |m#0@0| |q#0_3|)) (< |q#0_3| |N#0@@0|)) true))) :qid |Classics.68:24| :skolemid |394|)) (forall ((|p#0_3@@0| Int) (|q#0_3@@0| Int)) (! (=> true (=> (and (and (and (<= (LitInt 0) |p#0_3@@0|) (< |p#0_3@@0| |m#0@0|)) (<= |m#0@0| |q#0_3@@0|)) (< |q#0_3@@0| |N#0@@0|)) (<= (U_2_int ($Unbox intType (MapType1Select $Heap@1 |A#0@@2| (IndexField |p#0_3@@0|)))) (U_2_int ($Unbox intType (MapType1Select $Heap@1 |A#0@@2| (IndexField |q#0_3@@0|))))))) :qid |Classics.68:24| :skolemid |395|))) (and anon173_Then_correct anon173_Else_correct))))) (let ((anon172_Else_correct (=> (! (and %lbl%+20765 true) :lblpos +20765) (=> (not (and (and (and (<= (LitInt 0) |p#0_2@0|) (< |p#0_2@0| |m#0@0|)) (<= |m#0@0| |q#0_2@0|)) (< |q#0_2@0| |N#0@@0|))) anon61_correct)))) (let ((anon172_Then_correct (=> (! (and %lbl%+20763 true) :lblpos +20763) (=> (and (and (and (<= (LitInt 0) |p#0_2@0|) (< |p#0_2@0| |m#0@0|)) (<= |m#0@0| |q#0_2@0|)) (< |q#0_2@0| |N#0@@0|)) (and (! (or %lbl%@49656 (not (= |A#0@@2| null))) :lblneg @49656) (=> (not (= |A#0@@2| null)) (and (! (or %lbl%@49662 (and (<= 0 |p#0_2@0|) (< |p#0_2@0| (_System.array.Length |A#0@@2|)))) :lblneg @49662) (and (! (or %lbl%@49676 (not (= |A#0@@2| null))) :lblneg @49676) (=> (not (= |A#0@@2| null)) (and (! (or %lbl%@49682 (and (<= 0 |q#0_2@0|) (< |q#0_2@0| (_System.array.Length |A#0@@2|)))) :lblneg @49682) anon61_correct)))))))))) (let ((anon171_Else_correct (=> (! (and %lbl%+20754 true) :lblpos +20754) (=> (not (and (and (<= (LitInt 0) |p#0_2@0|) (< |p#0_2@0| |m#0@0|)) (<= |m#0@0| |q#0_2@0|))) (and anon172_Then_correct anon172_Else_correct))))) (let ((anon171_Then_correct (=> (! (and %lbl%+20752 true) :lblpos +20752) (=> (and (and (<= (LitInt 0) |p#0_2@0|) (< |p#0_2@0| |m#0@0|)) (<= |m#0@0| |q#0_2@0|)) (and anon172_Then_correct anon172_Else_correct))))) (let ((anon170_Else_correct (=> (! (and %lbl%+20743 true) :lblpos +20743) (=> (not (and (<= (LitInt 0) |p#0_2@0|) (< |p#0_2@0| |m#0@0|))) (and anon171_Then_correct anon171_Else_correct))))) (let ((anon170_Then_correct (=> (! (and %lbl%+20741 true) :lblpos +20741) (=> (and (<= (LitInt 0) |p#0_2@0|) (< |p#0_2@0| |m#0@0|)) (and anon171_Then_correct anon171_Else_correct))))) (let ((anon169_Else_correct (=> (! (and %lbl%+20732 true) :lblpos +20732) (=> (< |p#0_2@0| (LitInt 0)) (and anon170_Then_correct anon170_Else_correct))))) (let ((anon169_Then_correct (=> (! (and %lbl%+20730 true) :lblpos +20730) (=> (<= (LitInt 0) |p#0_2@0|) (and anon170_Then_correct anon170_Else_correct))))) (let ((anon53_correct (=> (! (and %lbl%+20728 true) :lblpos +20728) (=> (and (forall ((|q#0_1| Int)) (! (=> true (and (=> (< |j#0_0@1| |q#0_1|) true) (=> (and (< |j#0_0@1| |q#0_1|) (< |q#0_1| |N#0@@0|)) true))) :qid |Classics.66:24| :skolemid |389|)) (forall ((|q#0_1@@0| Int)) (! (=> true (=> (and (< |j#0_0@1| |q#0_1@@0|) (< |q#0_1@@0| |N#0@@0|)) (<= |$rhs#0_0@1| (U_2_int ($Unbox intType (MapType1Select $Heap@1 |A#0@@2| (IndexField |q#0_1@@0|))))))) :qid |Classics.66:24| :skolemid |390|))) (and anon169_Then_correct anon169_Else_correct))))) (let ((anon168_Else_correct (=> (! (and %lbl%+20721 true) :lblpos +20721) (=> (not (and (< |j#0_0@1| |q#0_0@0|) (< |q#0_0@0| |N#0@@0|))) anon53_correct)))) (let ((anon168_Then_correct (=> (! (and %lbl%+20719 true) :lblpos +20719) (=> (and (< |j#0_0@1| |q#0_0@0|) (< |q#0_0@0| |N#0@@0|)) (and (! (or %lbl%@49436 (not (= |A#0@@2| null))) :lblneg @49436) (=> (not (= |A#0@@2| null)) (and (! (or %lbl%@49442 (and (<= 0 |q#0_0@0|) (< |q#0_0@0| (_System.array.Length |A#0@@2|)))) :lblneg @49442) anon53_correct))))))) (let ((anon167_Else_correct (=> (! (and %lbl%+20710 true) :lblpos +20710) (=> (<= |q#0_0@0| |j#0_0@1|) (and anon168_Then_correct anon168_Else_correct))))) (let ((anon167_Then_correct (=> (! (and %lbl%+20708 true) :lblpos +20708) (=> (< |j#0_0@1| |q#0_0@0|) (and anon168_Then_correct anon168_Else_correct))))) (let ((anon49_correct (=> (! (and %lbl%+20706 true) :lblpos +20706) (=> (and (forall ((|p#0_1| Int)) (! (=> true (and (=> (<= (LitInt 0) |p#0_1|) true) (=> (and (<= (LitInt 0) |p#0_1|) (< |p#0_1| |i#0_0@1|)) true))) :qid |Classics.65:24| :skolemid |384|)) (forall ((|p#0_1@@0| Int)) (! (=> true (=> (and (<= (LitInt 0) |p#0_1@@0|) (< |p#0_1@@0| |i#0_0@1|)) (<= (U_2_int ($Unbox intType (MapType1Select $Heap@1 |A#0@@2| (IndexField |p#0_1@@0|)))) |$rhs#0_0@1|))) :qid |Classics.65:24| :skolemid |385|))) (and anon167_Then_correct anon167_Else_correct))))) (let ((anon166_Else_correct (=> (! (and %lbl%+20699 true) :lblpos +20699) (=> (not (and (<= (LitInt 0) |p#0_0@0|) (< |p#0_0@0| |i#0_0@1|))) anon49_correct)))) (let ((anon166_Then_correct (=> (! (and %lbl%+20697 true) :lblpos +20697) (=> (and (<= (LitInt 0) |p#0_0@0|) (< |p#0_0@0| |i#0_0@1|)) (and (! (or %lbl%@49299 (not (= |A#0@@2| null))) :lblneg @49299) (=> (not (= |A#0@@2| null)) (and (! (or %lbl%@49305 (and (<= 0 |p#0_0@0|) (< |p#0_0@0| (_System.array.Length |A#0@@2|)))) :lblneg @49305) anon49_correct))))))) (let ((anon165_Else_correct (=> (! (and %lbl%+20688 true) :lblpos +20688) (=> (< |p#0_0@0| (LitInt 0)) (and anon166_Then_correct anon166_Else_correct))))) (let ((anon165_Then_correct (=> (! (and %lbl%+20686 true) :lblpos +20686) (=> (<= (LitInt 0) |p#0_0@0|) (and anon166_Then_correct anon166_Else_correct))))) (let ((anon45_correct (=> (! (and %lbl%+20684 true) :lblpos +20684) (=> (and (=> (<= |i#0_0@1| |j#0_0@1|) (forall ((|g#0_3| Int)) (! (=> true (and (=> (<= (LitInt 0) |g#0_3|) true) (=> (and (<= (LitInt 0) |g#0_3|) (<= |g#0_3| |j#0_0@1|)) true))) :qid |Classics.64:35| :skolemid |380|))) (=> (<= |i#0_0@1| |j#0_0@1|) (exists ((|g#0_3@@0| Int)) (! (and (and (<= (LitInt 0) |g#0_3@@0|) (<= |g#0_3@@0| |j#0_0@1|)) (<= (U_2_int ($Unbox intType (MapType1Select $Heap@1 |A#0@@2| (IndexField |g#0_3@@0|)))) |$rhs#0_0@1|)) :qid |Classics.64:35| :skolemid |381|)))) (and anon165_Then_correct anon165_Else_correct))))) (let ((anon164_Else_correct (=> (! (and %lbl%+20673 true) :lblpos +20673) (=> (not (and (<= (LitInt 0) |g#0_2@0|) (<= |g#0_2@0| |j#0_0@1|))) anon45_correct)))) (let ((anon164_Then_correct (=> (! (and %lbl%+20671 true) :lblpos +20671) (=> (and (<= (LitInt 0) |g#0_2@0|) (<= |g#0_2@0| |j#0_0@1|)) (and (! (or %lbl%@49146 (not (= |A#0@@2| null))) :lblneg @49146) (=> (not (= |A#0@@2| null)) (and (! (or %lbl%@49152 (and (<= 0 |g#0_2@0|) (< |g#0_2@0| (_System.array.Length |A#0@@2|)))) :lblneg @49152) anon45_correct))))))) (let ((anon163_Else_correct (=> (! (and %lbl%+20662 true) :lblpos +20662) (=> (< |g#0_2@0| (LitInt 0)) (and anon164_Then_correct anon164_Else_correct))))) (let ((anon163_Then_correct (=> (! (and %lbl%+20660 true) :lblpos +20660) (=> (<= (LitInt 0) |g#0_2@0|) (and anon164_Then_correct anon164_Else_correct))))) (let ((anon162_Then_correct (=> (! (and %lbl%+20658 true) :lblpos +20658) (=> (<= |i#0_0@1| |j#0_0@1|) (and anon163_Then_correct anon163_Else_correct))))) (let ((anon162_Else_correct (=> (! (and %lbl%+20677 true) :lblpos +20677) (=> (< |j#0_0@1| |i#0_0@1|) anon45_correct)))) (let ((anon39_correct (=> (! (and %lbl%+20651 true) :lblpos +20651) (=> (and (=> (<= |i#0_0@1| |j#0_0@1|) (forall ((|g#0_1| Int)) (! (=> true (and (=> (<= |i#0_0@1| |g#0_1|) true) (=> (and (<= |i#0_0@1| |g#0_1|) (< |g#0_1| |N#0@@0|)) true))) :qid |Classics.63:35| :skolemid |376|))) (=> (<= |i#0_0@1| |j#0_0@1|) (exists ((|g#0_1@@0| Int)) (! (and (and (<= |i#0_0@1| |g#0_1@@0|) (< |g#0_1@@0| |N#0@@0|)) (<= |$rhs#0_0@1| (U_2_int ($Unbox intType (MapType1Select $Heap@1 |A#0@@2| (IndexField |g#0_1@@0|)))))) :qid |Classics.63:35| :skolemid |377|)))) (and anon162_Then_correct anon162_Else_correct))))) (let ((anon161_Else_correct (=> (! (and %lbl%+20640 true) :lblpos +20640) (=> (not (and (<= |i#0_0@1| |g#0_0@0|) (< |g#0_0@0| |N#0@@0|))) anon39_correct)))) (let ((anon161_Then_correct (=> (! (and %lbl%+20638 true) :lblpos +20638) (=> (and (<= |i#0_0@1| |g#0_0@0|) (< |g#0_0@0| |N#0@@0|)) (and (! (or %lbl%@48994 (not (= |A#0@@2| null))) :lblneg @48994) (=> (not (= |A#0@@2| null)) (and (! (or %lbl%@49000 (and (<= 0 |g#0_0@0|) (< |g#0_0@0| (_System.array.Length |A#0@@2|)))) :lblneg @49000) anon39_correct))))))) (let ((anon160_Else_correct (=> (! (and %lbl%+20629 true) :lblpos +20629) (=> (< |g#0_0@0| |i#0_0@1|) (and anon161_Then_correct anon161_Else_correct))))) (let ((anon160_Then_correct (=> (! (and %lbl%+20627 true) :lblpos +20627) (=> (<= |i#0_0@1| |g#0_0@0|) (and anon161_Then_correct anon161_Else_correct))))) (let ((anon159_Then_correct (=> (! (and %lbl%+20625 true) :lblpos +20625) (=> (<= |i#0_0@1| |j#0_0@1|) (and anon160_Then_correct anon160_Else_correct))))) (let ((anon159_Else_correct (=> (! (and %lbl%+20644 true) :lblpos +20644) (=> (< |j#0_0@1| |i#0_0@1|) anon39_correct)))) (let ((anon33_correct (=> (! (and %lbl%+20618 true) :lblpos +20618) (=> (=> (<= (LitInt (- 0 1)) |j#0_0@1|) true) (=> (and (<= (LitInt (- 0 1)) |j#0_0@1|) (<= |i#0_0@1| |N#0@@0|)) (and anon159_Then_correct anon159_Else_correct)))))) (let ((anon158_Else_correct (=> (! (and %lbl%+20611 true) :lblpos +20611) (=> (< |j#0_0@1| (LitInt (- 0 1))) anon33_correct)))) (let ((anon158_Then_correct (=> (! (and %lbl%+20609 true) :lblpos +20609) (=> (<= (LitInt (- 0 1)) |j#0_0@1|) anon33_correct)))) (let ((anon31_correct (=> (! (and %lbl%+20607 true) :lblpos +20607) (=> (=> (<= |m#0@0| |i#0_0@1|) true) (=> (and (<= |m#0@0| |i#0_0@1|) (<= |j#0_0@1| |n#0@0|)) (and anon158_Then_correct anon158_Else_correct)))))) (let ((anon157_Else_correct (=> (! (and %lbl%+20600 true) :lblpos +20600) (=> (< |i#0_0@1| |m#0@0|) anon31_correct)))) (let ((anon157_Then_correct (=> (! (and %lbl%+20598 true) :lblpos +20598) (=> (<= |m#0@0| |i#0_0@1|) anon31_correct)))) (let ((anon156_Then_correct (=> (! (and %lbl%+20596 true) :lblpos +20596) (=> (not |$w$loop#0_0@1@@0|) (and anon157_Then_correct anon157_Else_correct))))) (let ((anon140_correct (=> (! (and %lbl%+21194 true) :lblpos +21194) (and (! (or %lbl%@48420 (or (<= 0 |$decr$loop#00@1@@0|) (= (- |n#0@1| |m#0@1|) |$decr$loop#00@1@@0|))) :lblneg @48420) (=> (or (<= 0 |$decr$loop#00@1@@0|) (= (- |n#0@1| |m#0@1|) |$decr$loop#00@1@@0|)) (and (! (or %lbl%@48434 (< (- |n#0@1| |m#0@1|) |$decr$loop#00@1@@0|)) :lblneg @48434) (=> (< (- |n#0@1| |m#0@1|) |$decr$loop#00@1@@0|) (=> (and (and (and (=> (<= (LitInt 0) |m#0@1|) true) (=> (and (<= (LitInt 0) |m#0@1|) (<= |m#0@1| |f#0@@0|)) true)) (=> (and (and (<= (LitInt 0) |m#0@1|) (<= |m#0@1| |f#0@@0|)) (<= |f#0@@0| |n#0@1|)) true)) (and (forall ((|p#3@@1| Int) (|q#3@@1| Int)) (! (=> true (and (and (and (=> (<= (LitInt 0) |p#3@@1|) true) (=> (and (<= (LitInt 0) |p#3@@1|) (< |p#3@@1| |m#0@1|)) true)) (=> (and (and (<= (LitInt 0) |p#3@@1|) (< |p#3@@1| |m#0@1|)) (<= |m#0@1| |q#3@@1|)) true)) (=> (and (and (and (<= (LitInt 0) |p#3@@1|) (< |p#3@@1| |m#0@1|)) (<= |m#0@1| |q#3@@1|)) (< |q#3@@1| |N#0@@0|)) true))) :qid |Classics.56:22| :skolemid |452|)) (forall ((|p#5| Int) (|q#5| Int)) (! (=> true (and (and (and (=> (<= (LitInt 0) |p#5|) true) (=> (and (<= (LitInt 0) |p#5|) (<= |p#5| |n#0@1|)) true)) (=> (and (and (<= (LitInt 0) |p#5|) (<= |p#5| |n#0@1|)) (< |n#0@1| |q#5|)) true)) (=> (and (and (and (<= (LitInt 0) |p#5|) (<= |p#5| |n#0@1|)) (< |n#0@1| |q#5|)) (< |q#5| |N#0@@0|)) true))) :qid |Classics.57:22| :skolemid |453|)))) (and (! (or %lbl%@48707 (=> |$w$loop#0@0@@0| (<= (LitInt 0) |m#0@1|))) :lblneg @48707) (=> (=> |$w$loop#0@0@@0| (<= (LitInt 0) |m#0@1|)) (and (! (or %lbl%@48717 (=> |$w$loop#0@0@@0| (<= |m#0@1| |f#0@@0|))) :lblneg @48717) (=> (=> |$w$loop#0@0@@0| (<= |m#0@1| |f#0@@0|)) (and (! (or %lbl%@48725 (=> |$w$loop#0@0@@0| (<= |f#0@@0| |n#0@1|))) :lblneg @48725) (=> (=> |$w$loop#0@0@@0| (<= |f#0@@0| |n#0@1|)) (and (! (or %lbl%@48733 (=> |$w$loop#0@0@@0| (< |n#0@1| |N#0@@0|))) :lblneg @48733) (=> (=> |$w$loop#0@0@@0| (< |n#0@1| |N#0@@0|)) (and (! (or %lbl%@48741 (=> |$w$loop#0@0@@0| (forall ((|p#3@@2| Int) (|q#3@@2| Int)) (! (=> true (=> (and (and (and (<= (LitInt 0) |p#3@@2|) (< |p#3@@2| |m#0@1|)) (<= |m#0@1| |q#3@@2|)) (< |q#3@@2| |N#0@@0|)) (<= (U_2_int ($Unbox intType (MapType1Select $Heap@1 |A#0@@2| (IndexField |p#3@@2|)))) (U_2_int ($Unbox intType (MapType1Select $Heap@1 |A#0@@2| (IndexField |q#3@@2|))))))) :qid |Classics.56:22| :skolemid |368|)))) :lblneg @48741) (=> (=> |$w$loop#0@0@@0| (forall ((|p#3@@3| Int) (|q#3@@3| Int)) (! (=> true (=> (and (and (and (<= (LitInt 0) |p#3@@3|) (< |p#3@@3| |m#0@1|)) (<= |m#0@1| |q#3@@3|)) (< |q#3@@3| |N#0@@0|)) (<= (U_2_int ($Unbox intType (MapType1Select $Heap@1 |A#0@@2| (IndexField |p#3@@3|)))) (U_2_int ($Unbox intType (MapType1Select $Heap@1 |A#0@@2| (IndexField |q#3@@3|))))))) :qid |Classics.56:22| :skolemid |368|))) (! (or %lbl%@48811 (=> |$w$loop#0@0@@0| (forall ((|p#5@@0| Int) (|q#5@@0| Int)) (! (=> true (=> (and (and (and (<= (LitInt 0) |p#5@@0|) (<= |p#5@@0| |n#0@1|)) (< |n#0@1| |q#5@@0|)) (< |q#5@@0| |N#0@@0|)) (<= (U_2_int ($Unbox intType (MapType1Select $Heap@1 |A#0@@2| (IndexField |p#5@@0|)))) (U_2_int ($Unbox intType (MapType1Select $Heap@1 |A#0@@2| (IndexField |q#5@@0|))))))) :qid |Classics.57:22| :skolemid |373|)))) :lblneg @48811))))))))))))))))))) (let ((anon211_Then_correct (=> (! (and %lbl%+21191 true) :lblpos +21191) (=> (<= |i#0_0@1| |f#0@@0|) (=> (and (= |m#0@1| |i#0_0@1|) (= |n#0@1| |n#0@0|)) anon140_correct))))) (let ((anon210_Then_correct (=> (! (and %lbl%+21182 true) :lblpos +21182) (=> (<= |f#0@@0| |j#0_0@1|) (=> (and (= |m#0@1| |m#0@0|) (= |n#0@1| |j#0_0@1|)) anon140_correct))))) (let ((GeneratedUnifiedExit_correct@@0 (=> (! (and %lbl%+40820 true) :lblpos +40820) (! (or %lbl%@51402 (forall ((|p#1| Int) (|q#1| Int)) (! (=> true (=> (and (and (and (<= (LitInt 0) |p#1|) (<= |p#1| |f#0@@0|)) (<= |f#0@@0| |q#1|)) (< |q#1| |N#0@@0|)) (<= (U_2_int ($Unbox intType (MapType1Select $Heap@6 |A#0@@2| (IndexField |p#1|)))) (U_2_int ($Unbox intType (MapType1Select $Heap@6 |A#0@@2| (IndexField |q#1|))))))) :qid |Classics.51:18| :skolemid |362|))) :lblneg @51402)))) (let ((after_0_0_correct (=> (! (and %lbl%+21198 true) :lblpos +21198) (=> (= $Heap@6 $Heap@5) GeneratedUnifiedExit_correct@@0)))) (let ((anon211_Else_correct (=> (! (and %lbl%+21192 true) :lblpos +21192) (=> (and (< |f#0@@0| |i#0_0@1|) (= $Heap@5 $Heap@1)) after_0_0_correct)))) (let ((anon210_Else_correct (=> (! (and %lbl%+21189 true) :lblpos +21189) (=> (< |j#0_0@1| |f#0@@0|) (and anon211_Then_correct anon211_Else_correct))))) (let ((anon181_Then_correct (=> (! (and %lbl%+20863 true) :lblpos +20863) (=> (< |j#0_0@1| |i#0_0@1|) (and anon210_Then_correct anon210_Else_correct))))) (let ((anon154_Then_correct (=> (! (and %lbl%+20573 true) :lblpos +20573) (=> (and (<= |n#0@0| |m#0@0|) (= $Heap@5 $Heap@0@@1)) after_0_0_correct)))) (let ((anon100_correct (=> (! (and %lbl%+20989 true) :lblpos +20989) true))) (let ((anon193_Else_correct (=> (! (and %lbl%+20987 true) :lblpos +20987) (=> (not (and (<= (LitInt 0) |p#0_0_0@0|) (< |p#0_0_0@0| |i#0_0@2|))) anon100_correct)))) (let ((anon193_Then_correct (=> (! (and %lbl%+20985 true) :lblpos +20985) (=> (and (<= (LitInt 0) |p#0_0_0@0|) (< |p#0_0_0@0| |i#0_0@2|)) (and (! (or %lbl%@48232 (not (= |A#0@@2| null))) :lblneg @48232) (=> (not (= |A#0@@2| null)) (and (! (or %lbl%@48238 (and (<= 0 |p#0_0_0@0|) (< |p#0_0_0@0| (_System.array.Length |A#0@@2|)))) :lblneg @48238) anon100_correct))))))) (let ((anon192_Else_correct (=> (! (and %lbl%+20976 true) :lblpos +20976) (=> (< |p#0_0_0@0| (LitInt 0)) (and anon193_Then_correct anon193_Else_correct))))) (let ((anon192_Then_correct (=> (! (and %lbl%+20974 true) :lblpos +20974) (=> (<= (LitInt 0) |p#0_0_0@0|) (and anon193_Then_correct anon193_Else_correct))))) (let ((anon96_correct (=> (! (and %lbl%+20972 true) :lblpos +20972) (=> (and (forall ((|g#0_0_3| Int)) (! (=> true (and (=> (<= (LitInt 0) |g#0_0_3|) true) (=> (and (<= (LitInt 0) |g#0_0_3|) (<= |g#0_0_3| |j#0_0@1|)) true))) :qid |Classics.77:26| :skolemid |411|)) (exists ((|g#0_0_3@@0| Int)) (! (and (and (<= (LitInt 0) |g#0_0_3@@0|) (<= |g#0_0_3@@0| |j#0_0@1|)) (<= (U_2_int ($Unbox intType (MapType1Select $Heap@1 |A#0@@2| (IndexField |g#0_0_3@@0|)))) |$rhs#0_0@1|)) :qid |Classics.77:26| :skolemid |412|))) (and anon192_Then_correct anon192_Else_correct))))) (let ((anon191_Else_correct (=> (! (and %lbl%+20965 true) :lblpos +20965) (=> (not (and (<= (LitInt 0) |g#0_0_2@0|) (<= |g#0_0_2@0| |j#0_0@1|))) anon96_correct)))) (let ((anon191_Then_correct (=> (! (and %lbl%+20963 true) :lblpos +20963) (=> (and (<= (LitInt 0) |g#0_0_2@0|) (<= |g#0_0_2@0| |j#0_0@1|)) (and (! (or %lbl%@48091 (not (= |A#0@@2| null))) :lblneg @48091) (=> (not (= |A#0@@2| null)) (and (! (or %lbl%@48097 (and (<= 0 |g#0_0_2@0|) (< |g#0_0_2@0| (_System.array.Length |A#0@@2|)))) :lblneg @48097) anon96_correct))))))) (let ((anon190_Else_correct (=> (! (and %lbl%+20954 true) :lblpos +20954) (=> (< |g#0_0_2@0| (LitInt 0)) (and anon191_Then_correct anon191_Else_correct))))) (let ((anon190_Then_correct (=> (! (and %lbl%+20952 true) :lblpos +20952) (=> (<= (LitInt 0) |g#0_0_2@0|) (and anon191_Then_correct anon191_Else_correct))))) (let ((anon92_correct (=> (! (and %lbl%+20950 true) :lblpos +20950) (=> (and (forall ((|g#0_0_1| Int)) (! (=> true (and (=> (<= |i#0_0@2| |g#0_0_1|) true) (=> (and (<= |i#0_0@2| |g#0_0_1|) (< |g#0_0_1| |N#0@@0|)) true))) :qid |Classics.76:26| :skolemid |406|)) (exists ((|g#0_0_1@@0| Int)) (! (and (and (<= |i#0_0@2| |g#0_0_1@@0|) (< |g#0_0_1@@0| |N#0@@0|)) (<= |$rhs#0_0@1| (U_2_int ($Unbox intType (MapType1Select $Heap@1 |A#0@@2| (IndexField |g#0_0_1@@0|)))))) :qid |Classics.76:26| :skolemid |407|))) (and anon190_Then_correct anon190_Else_correct))))) (let ((anon189_Else_correct (=> (! (and %lbl%+20943 true) :lblpos +20943) (=> (not (and (<= |i#0_0@2| |g#0_0_0@0|) (< |g#0_0_0@0| |N#0@@0|))) anon92_correct)))) (let ((anon189_Then_correct (=> (! (and %lbl%+20941 true) :lblpos +20941) (=> (and (<= |i#0_0@2| |g#0_0_0@0|) (< |g#0_0_0@0| |N#0@@0|)) (and (! (or %lbl%@47959 (not (= |A#0@@2| null))) :lblneg @47959) (=> (not (= |A#0@@2| null)) (and (! (or %lbl%@47965 (and (<= 0 |g#0_0_0@0|) (< |g#0_0_0@0| (_System.array.Length |A#0@@2|)))) :lblneg @47965) anon92_correct))))))) (let ((anon188_Else_correct (=> (! (and %lbl%+20932 true) :lblpos +20932) (=> (< |g#0_0_0@0| |i#0_0@2|) (and anon189_Then_correct anon189_Else_correct))))) (let ((anon188_Then_correct (=> (! (and %lbl%+20930 true) :lblpos +20930) (=> (<= |i#0_0@2| |g#0_0_0@0|) (and anon189_Then_correct anon189_Else_correct))))) (let ((anon88_correct (=> (! (and %lbl%+20928 true) :lblpos +20928) (=> (and (=> (<= |m#0@0| |i#0_0@2|) true) (=> (and (<= |m#0@0| |i#0_0@2|) (<= |i#0_0@2| |N#0@@0|)) (=> |firstIteration#0_0_0@2| true))) (=> (and (and (<= |m#0@0| |i#0_0@2|) (<= |i#0_0@2| |N#0@@0|)) (=> |firstIteration#0_0_0@2| (<= |i#0_0@2| |f#0@@0|))) (and anon188_Then_correct anon188_Else_correct)))))) (let ((anon187_Else_correct (=> (! (and %lbl%+20919 true) :lblpos +20919) (=> (not |firstIteration#0_0_0@2|) anon88_correct)))) (let ((anon187_Then_correct (=> (! (and %lbl%+20917 true) :lblpos +20917) (=> |firstIteration#0_0_0@2| anon88_correct)))) (let ((anon186_Then_correct (=> (! (and %lbl%+20915 true) :lblpos +20915) (=> (and (<= |m#0@0| |i#0_0@2|) (<= |i#0_0@2| |N#0@@0|)) (and anon187_Then_correct anon187_Else_correct))))) (let ((anon186_Else_correct (=> (! (and %lbl%+20921 true) :lblpos +20921) (=> (not (and (<= |m#0@0| |i#0_0@2|) (<= |i#0_0@2| |N#0@@0|))) anon88_correct)))) (let ((anon185_Else_correct (=> (! (and %lbl%+20901 true) :lblpos +20901) (=> (< |i#0_0@2| |m#0@0|) (and anon186_Then_correct anon186_Else_correct))))) (let ((anon185_Then_correct (=> (! (and %lbl%+20899 true) :lblpos +20899) (=> (<= |m#0@0| |i#0_0@2|) (and anon186_Then_correct anon186_Else_correct))))) (let ((anon184_Then_correct (=> (! (and %lbl%+20897 true) :lblpos +20897) (=> (not |$w$loop#0_0_0@2|) (and anon185_Then_correct anon185_Else_correct))))) (let ((anon123_correct (=> (! (and %lbl%+21119 true) :lblpos +21119) true))) (let ((anon205_Else_correct (=> (! (and %lbl%+21117 true) :lblpos +21117) (=> (not (and (< |j#0_0@2| |q#0_0_0@0|) (< |q#0_0_0@0| |N#0@@0|))) anon123_correct)))) (let ((anon205_Then_correct (=> (! (and %lbl%+21115 true) :lblpos +21115) (=> (and (< |j#0_0@2| |q#0_0_0@0|) (< |q#0_0_0@0| |N#0@@0|)) (and (! (or %lbl%@47742 (not (= |A#0@@2| null))) :lblneg @47742) (=> (not (= |A#0@@2| null)) (and (! (or %lbl%@47748 (and (<= 0 |q#0_0_0@0|) (< |q#0_0_0@0| (_System.array.Length |A#0@@2|)))) :lblneg @47748) anon123_correct))))))) (let ((anon204_Else_correct (=> (! (and %lbl%+21106 true) :lblpos +21106) (=> (<= |q#0_0_0@0| |j#0_0@2|) (and anon205_Then_correct anon205_Else_correct))))) (let ((anon204_Then_correct (=> (! (and %lbl%+21104 true) :lblpos +21104) (=> (< |j#0_0@2| |q#0_0_0@0|) (and anon205_Then_correct anon205_Else_correct))))) (let ((anon119_correct (=> (! (and %lbl%+21102 true) :lblpos +21102) (=> (and (forall ((|g#0_0_7| Int)) (! (=> true (and (=> (<= (LitInt 0) |g#0_0_7|) true) (=> (and (<= (LitInt 0) |g#0_0_7|) (<= |g#0_0_7| |j#0_0@2|)) true))) :qid |Classics.85:26| :skolemid |431|)) (exists ((|g#0_0_7@@0| Int)) (! (and (and (<= (LitInt 0) |g#0_0_7@@0|) (<= |g#0_0_7@@0| |j#0_0@2|)) (<= (U_2_int ($Unbox intType (MapType1Select $Heap@1 |A#0@@2| (IndexField |g#0_0_7@@0|)))) |$rhs#0_0@1|)) :qid |Classics.85:26| :skolemid |432|))) (and anon204_Then_correct anon204_Else_correct))))) (let ((anon203_Else_correct (=> (! (and %lbl%+21095 true) :lblpos +21095) (=> (not (and (<= (LitInt 0) |g#0_0_6@0|) (<= |g#0_0_6@0| |j#0_0@2|))) anon119_correct)))) (let ((anon203_Then_correct (=> (! (and %lbl%+21093 true) :lblpos +21093) (=> (and (<= (LitInt 0) |g#0_0_6@0|) (<= |g#0_0_6@0| |j#0_0@2|)) (and (! (or %lbl%@47609 (not (= |A#0@@2| null))) :lblneg @47609) (=> (not (= |A#0@@2| null)) (and (! (or %lbl%@47615 (and (<= 0 |g#0_0_6@0|) (< |g#0_0_6@0| (_System.array.Length |A#0@@2|)))) :lblneg @47615) anon119_correct))))))) (let ((anon202_Else_correct (=> (! (and %lbl%+21084 true) :lblpos +21084) (=> (< |g#0_0_6@0| (LitInt 0)) (and anon203_Then_correct anon203_Else_correct))))) (let ((anon202_Then_correct (=> (! (and %lbl%+21082 true) :lblpos +21082) (=> (<= (LitInt 0) |g#0_0_6@0|) (and anon203_Then_correct anon203_Else_correct))))) (let ((anon115_correct (=> (! (and %lbl%+21080 true) :lblpos +21080) (=> (and (forall ((|g#0_0_5| Int)) (! (=> true (and (=> (<= |i#0_0@2| |g#0_0_5|) true) (=> (and (<= |i#0_0@2| |g#0_0_5|) (< |g#0_0_5| |N#0@@0|)) true))) :qid |Classics.84:26| :skolemid |426|)) (exists ((|g#0_0_5@@0| Int)) (! (and (and (<= |i#0_0@2| |g#0_0_5@@0|) (< |g#0_0_5@@0| |N#0@@0|)) (<= |$rhs#0_0@1| (U_2_int ($Unbox intType (MapType1Select $Heap@1 |A#0@@2| (IndexField |g#0_0_5@@0|)))))) :qid |Classics.84:26| :skolemid |427|))) (and anon202_Then_correct anon202_Else_correct))))) (let ((anon201_Else_correct (=> (! (and %lbl%+21073 true) :lblpos +21073) (=> (not (and (<= |i#0_0@2| |g#0_0_4@0|) (< |g#0_0_4@0| |N#0@@0|))) anon115_correct)))) (let ((anon201_Then_correct (=> (! (and %lbl%+21071 true) :lblpos +21071) (=> (and (<= |i#0_0@2| |g#0_0_4@0|) (< |g#0_0_4@0| |N#0@@0|)) (and (! (or %lbl%@47477 (not (= |A#0@@2| null))) :lblneg @47477) (=> (not (= |A#0@@2| null)) (and (! (or %lbl%@47483 (and (<= 0 |g#0_0_4@0|) (< |g#0_0_4@0| (_System.array.Length |A#0@@2|)))) :lblneg @47483) anon115_correct))))))) (let ((anon200_Else_correct (=> (! (and %lbl%+21062 true) :lblpos +21062) (=> (< |g#0_0_4@0| |i#0_0@2|) (and anon201_Then_correct anon201_Else_correct))))) (let ((anon200_Then_correct (=> (! (and %lbl%+21060 true) :lblpos +21060) (=> (<= |i#0_0@2| |g#0_0_4@0|) (and anon201_Then_correct anon201_Else_correct))))) (let ((anon111_correct (=> (! (and %lbl%+21058 true) :lblpos +21058) (=> (and (=> (<= (LitInt 0) |j#0_0@2|) true) (=> (and (<= (LitInt 0) |j#0_0@2|) (<= |j#0_0@2| |n#0@0|)) (=> |firstIteration#0_0_0@2| true))) (=> (and (and (<= (LitInt 0) |j#0_0@2|) (<= |j#0_0@2| |n#0@0|)) (=> |firstIteration#0_0_0@2| (<= |f#0@@0| |j#0_0@2|))) (and anon200_Then_correct anon200_Else_correct)))))) (let ((anon199_Else_correct (=> (! (and %lbl%+21049 true) :lblpos +21049) (=> (not |firstIteration#0_0_0@2|) anon111_correct)))) (let ((anon199_Then_correct (=> (! (and %lbl%+21047 true) :lblpos +21047) (=> |firstIteration#0_0_0@2| anon111_correct)))) (let ((anon198_Then_correct (=> (! (and %lbl%+21045 true) :lblpos +21045) (=> (and (<= (LitInt 0) |j#0_0@2|) (<= |j#0_0@2| |n#0@0|)) (and anon199_Then_correct anon199_Else_correct))))) (let ((anon198_Else_correct (=> (! (and %lbl%+21051 true) :lblpos +21051) (=> (not (and (<= (LitInt 0) |j#0_0@2|) (<= |j#0_0@2| |n#0@0|))) anon111_correct)))) (let ((anon197_Else_correct (=> (! (and %lbl%+21031 true) :lblpos +21031) (=> (< |j#0_0@2| (LitInt 0)) (and anon198_Then_correct anon198_Else_correct))))) (let ((anon197_Then_correct (=> (! (and %lbl%+21029 true) :lblpos +21029) (=> (<= (LitInt 0) |j#0_0@2|) (and anon198_Then_correct anon198_Else_correct))))) (let ((anon196_Then_correct (=> (! (and %lbl%+21027 true) :lblpos +21027) (=> (not |$w$loop#0_0_1@2|) (and anon197_Then_correct anon197_Else_correct))))) (let ((anon134_correct (=> (! (and %lbl%+21171 true) :lblpos +21171) (and (! (or %lbl%@46480 (or (<= 0 |$decr$loop#0_00@2@@0|) (= (- |j#0_0@4| |i#0_0@4|) |$decr$loop#0_00@2@@0|))) :lblneg @46480) (=> (or (<= 0 |$decr$loop#0_00@2@@0|) (= (- |j#0_0@4| |i#0_0@4|) |$decr$loop#0_00@2@@0|)) (and (! (or %lbl%@46494 (< (- |j#0_0@4| |i#0_0@4|) |$decr$loop#0_00@2@@0|)) :lblneg @46494) (=> (< (- |j#0_0@4| |i#0_0@4|) |$decr$loop#0_00@2@@0|) (=> (and (and (=> (<= |m#0@0| |i#0_0@4|) true) (=> (<= (LitInt (- 0 1)) |j#0_0@4|) true)) (and (=> (<= |i#0_0@4| |j#0_0@4|) (forall ((|g#0_1@@1| Int)) (! (=> true (and (=> (<= |i#0_0@4| |g#0_1@@1|) true) (=> (and (<= |i#0_0@4| |g#0_1@@1|) (< |g#0_1@@1| |N#0@@0|)) true))) :qid |Classics.63:35| :skolemid |446|))) (=> (<= |i#0_0@4| |j#0_0@4|) (forall ((|g#0_3@@1| Int)) (! (=> true (and (=> (<= (LitInt 0) |g#0_3@@1|) true) (=> (and (<= (LitInt 0) |g#0_3@@1|) (<= |g#0_3@@1| |j#0_0@4|)) true))) :qid |Classics.64:35| :skolemid |447|))))) (=> (and (and (and (forall ((|p#0_1@@1| Int)) (! (=> true (and (=> (<= (LitInt 0) |p#0_1@@1|) true) (=> (and (<= (LitInt 0) |p#0_1@@1|) (< |p#0_1@@1| |i#0_0@4|)) true))) :qid |Classics.65:24| :skolemid |448|)) (forall ((|q#0_1@@1| Int)) (! (=> true (and (=> (< |j#0_0@4| |q#0_1@@1|) true) (=> (and (< |j#0_0@4| |q#0_1@@1|) (< |q#0_1@@1| |N#0@@0|)) true))) :qid |Classics.66:24| :skolemid |449|))) (and (forall ((|p#0_3@@1| Int) (|q#0_3@@1| Int)) (! (=> true (and (and (and (=> (<= (LitInt 0) |p#0_3@@1|) true) (=> (and (<= (LitInt 0) |p#0_3@@1|) (< |p#0_3@@1| |m#0@0|)) true)) (=> (and (and (<= (LitInt 0) |p#0_3@@1|) (< |p#0_3@@1| |m#0@0|)) (<= |m#0@0| |q#0_3@@1|)) true)) (=> (and (and (and (<= (LitInt 0) |p#0_3@@1|) (< |p#0_3@@1| |m#0@0|)) (<= |m#0@0| |q#0_3@@1|)) (< |q#0_3@@1| |N#0@@0|)) true))) :qid |Classics.68:24| :skolemid |450|)) (forall ((|p#0_5@@1| Int) (|q#0_5@@1| Int)) (! (=> true (and (and (and (=> (<= (LitInt 0) |p#0_5@@1|) true) (=> (and (<= (LitInt 0) |p#0_5@@1|) (<= |p#0_5@@1| |n#0@0|)) true)) (=> (and (and (<= (LitInt 0) |p#0_5@@1|) (<= |p#0_5@@1| |n#0@0|)) (< |n#0@0| |q#0_5@@1|)) true)) (=> (and (and (and (<= (LitInt 0) |p#0_5@@1|) (<= |p#0_5@@1| |n#0@0|)) (< |n#0@0| |q#0_5@@1|)) (< |q#0_5@@1| |N#0@@0|)) true))) :qid |Classics.69:24| :skolemid |451|)))) (and (and (=> (= |i#0_0@4| |m#0@0|) true) (=> (and (= |i#0_0@4| |m#0@0|) (= |j#0_0@4| |n#0@0|)) true)) (=> (not (and (and (= |i#0_0@4| |m#0@0|) (= |j#0_0@4| |n#0@0|)) (= |$rhs#0_0@1| (U_2_int ($Unbox intType (MapType1Select $Heap@4 |A#0@@2| (IndexField |f#0@@0|))))))) (=> (< |m#0@0| |i#0_0@4|) true)))) (and (! (or %lbl%@46960 (=> |$w$loop#0_0@1@@0| (<= |m#0@0| |i#0_0@4|))) :lblneg @46960) (=> (=> |$w$loop#0_0@1@@0| (<= |m#0@0| |i#0_0@4|)) (and (! (or %lbl%@46967 (=> |$w$loop#0_0@1@@0| (<= |j#0_0@4| |n#0@0|))) :lblneg @46967) (=> (=> |$w$loop#0_0@1@@0| (<= |j#0_0@4| |n#0@0|)) (and (! (or %lbl%@46974 (=> |$w$loop#0_0@1@@0| (<= (LitInt (- 0 1)) |j#0_0@4|))) :lblneg @46974) (=> (=> |$w$loop#0_0@1@@0| (<= (LitInt (- 0 1)) |j#0_0@4|)) (and (! (or %lbl%@46988 (=> |$w$loop#0_0@1@@0| (<= |i#0_0@4| |N#0@@0|))) :lblneg @46988) (=> (=> |$w$loop#0_0@1@@0| (<= |i#0_0@4| |N#0@@0|)) (and (! (or %lbl%@46996 (=> |$w$loop#0_0@1@@0| (=> (<= |i#0_0@4| |j#0_0@4|) (exists ((|g#0_1@@2| Int)) (! (and (and (<= |i#0_0@4| |g#0_1@@2|) (< |g#0_1@@2| |N#0@@0|)) (<= |$rhs#0_0@1| (U_2_int ($Unbox intType (MapType1Select $Heap@4 |A#0@@2| (IndexField |g#0_1@@2|)))))) :qid |Classics.63:35| :skolemid |379|))))) :lblneg @46996) (=> (=> |$w$loop#0_0@1@@0| (=> (<= |i#0_0@4| |j#0_0@4|) (exists ((|g#0_1@@3| Int)) (! (and (and (<= |i#0_0@4| |g#0_1@@3|) (< |g#0_1@@3| |N#0@@0|)) (<= |$rhs#0_0@1| (U_2_int ($Unbox intType (MapType1Select $Heap@4 |A#0@@2| (IndexField |g#0_1@@3|)))))) :qid |Classics.63:35| :skolemid |379|)))) (and (! (or %lbl%@47039 (=> |$w$loop#0_0@1@@0| (=> (<= |i#0_0@4| |j#0_0@4|) (exists ((|g#0_3@@2| Int)) (! (and (and (<= (LitInt 0) |g#0_3@@2|) (<= |g#0_3@@2| |j#0_0@4|)) (<= (U_2_int ($Unbox intType (MapType1Select $Heap@4 |A#0@@2| (IndexField |g#0_3@@2|)))) |$rhs#0_0@1|)) :qid |Classics.64:35| :skolemid |383|))))) :lblneg @47039) (=> (=> |$w$loop#0_0@1@@0| (=> (<= |i#0_0@4| |j#0_0@4|) (exists ((|g#0_3@@3| Int)) (! (and (and (<= (LitInt 0) |g#0_3@@3|) (<= |g#0_3@@3| |j#0_0@4|)) (<= (U_2_int ($Unbox intType (MapType1Select $Heap@4 |A#0@@2| (IndexField |g#0_3@@3|)))) |$rhs#0_0@1|)) :qid |Classics.64:35| :skolemid |383|)))) (and (! (or %lbl%@47084 (=> |$w$loop#0_0@1@@0| (forall ((|p#0_1@@2| Int)) (! (=> true (=> (and (<= (LitInt 0) |p#0_1@@2|) (< |p#0_1@@2| |i#0_0@4|)) (<= (U_2_int ($Unbox intType (MapType1Select $Heap@4 |A#0@@2| (IndexField |p#0_1@@2|)))) |$rhs#0_0@1|))) :qid |Classics.65:24| :skolemid |388|)))) :lblneg @47084) (=> (=> |$w$loop#0_0@1@@0| (forall ((|p#0_1@@3| Int)) (! (=> true (=> (and (<= (LitInt 0) |p#0_1@@3|) (< |p#0_1@@3| |i#0_0@4|)) (<= (U_2_int ($Unbox intType (MapType1Select $Heap@4 |A#0@@2| (IndexField |p#0_1@@3|)))) |$rhs#0_0@1|))) :qid |Classics.65:24| :skolemid |388|))) (and (! (or %lbl%@47127 (=> |$w$loop#0_0@1@@0| (forall ((|q#0_1@@2| Int)) (! (=> true (=> (and (< |j#0_0@4| |q#0_1@@2|) (< |q#0_1@@2| |N#0@@0|)) (<= |$rhs#0_0@1| (U_2_int ($Unbox intType (MapType1Select $Heap@4 |A#0@@2| (IndexField |q#0_1@@2|))))))) :qid |Classics.66:24| :skolemid |393|)))) :lblneg @47127) (=> (=> |$w$loop#0_0@1@@0| (forall ((|q#0_1@@3| Int)) (! (=> true (=> (and (< |j#0_0@4| |q#0_1@@3|) (< |q#0_1@@3| |N#0@@0|)) (<= |$rhs#0_0@1| (U_2_int ($Unbox intType (MapType1Select $Heap@4 |A#0@@2| (IndexField |q#0_1@@3|))))))) :qid |Classics.66:24| :skolemid |393|))) (and (! (or %lbl%@47168 (=> |$w$loop#0_0@1@@0| (forall ((|p#0_3@@2| Int) (|q#0_3@@2| Int)) (! (=> true (=> (and (and (and (<= (LitInt 0) |p#0_3@@2|) (< |p#0_3@@2| |m#0@0|)) (<= |m#0@0| |q#0_3@@2|)) (< |q#0_3@@2| |N#0@@0|)) (<= (U_2_int ($Unbox intType (MapType1Select $Heap@4 |A#0@@2| (IndexField |p#0_3@@2|)))) (U_2_int ($Unbox intType (MapType1Select $Heap@4 |A#0@@2| (IndexField |q#0_3@@2|))))))) :qid |Classics.68:24| :skolemid |398|)))) :lblneg @47168) (=> (=> |$w$loop#0_0@1@@0| (forall ((|p#0_3@@3| Int) (|q#0_3@@3| Int)) (! (=> true (=> (and (and (and (<= (LitInt 0) |p#0_3@@3|) (< |p#0_3@@3| |m#0@0|)) (<= |m#0@0| |q#0_3@@3|)) (< |q#0_3@@3| |N#0@@0|)) (<= (U_2_int ($Unbox intType (MapType1Select $Heap@4 |A#0@@2| (IndexField |p#0_3@@3|)))) (U_2_int ($Unbox intType (MapType1Select $Heap@4 |A#0@@2| (IndexField |q#0_3@@3|))))))) :qid |Classics.68:24| :skolemid |398|))) (and (! (or %lbl%@47238 (=> |$w$loop#0_0@1@@0| (forall ((|p#0_5@@2| Int) (|q#0_5@@2| Int)) (! (=> true (=> (and (and (and (<= (LitInt 0) |p#0_5@@2|) (<= |p#0_5@@2| |n#0@0|)) (< |n#0@0| |q#0_5@@2|)) (< |q#0_5@@2| |N#0@@0|)) (<= (U_2_int ($Unbox intType (MapType1Select $Heap@4 |A#0@@2| (IndexField |p#0_5@@2|)))) (U_2_int ($Unbox intType (MapType1Select $Heap@4 |A#0@@2| (IndexField |q#0_5@@2|))))))) :qid |Classics.69:24| :skolemid |403|)))) :lblneg @47238) (=> (=> |$w$loop#0_0@1@@0| (forall ((|p#0_5@@3| Int) (|q#0_5@@3| Int)) (! (=> true (=> (and (and (and (<= (LitInt 0) |p#0_5@@3|) (<= |p#0_5@@3| |n#0@0|)) (< |n#0@0| |q#0_5@@3|)) (< |q#0_5@@3| |N#0@@0|)) (<= (U_2_int ($Unbox intType (MapType1Select $Heap@4 |A#0@@2| (IndexField |p#0_5@@3|)))) (U_2_int ($Unbox intType (MapType1Select $Heap@4 |A#0@@2| (IndexField |q#0_5@@3|))))))) :qid |Classics.69:24| :skolemid |403|))) (! (or %lbl%@47308 (=> |$w$loop#0_0@1@@0| (or (and (and (= |i#0_0@4| |m#0@0|) (= |j#0_0@4| |n#0@0|)) (= |$rhs#0_0@1| (U_2_int ($Unbox intType (MapType1Select $Heap@4 |A#0@@2| (IndexField |f#0@@0|)))))) (and (< |m#0@0| |i#0_0@4|) (< |j#0_0@4| |n#0@0|))))) :lblneg @47308)))))))))))))))))))))))))))))) (let ((anon132_correct (=> (! (and %lbl%+21167 true) :lblpos +21167) (=> (=> (<= (U_2_int ($Unbox intType (MapType1Select $Heap@3 |A#0@@2| (IndexField |i#0_0@2|)))) |$rhs#0_0@1|) true) (and (! (or %lbl%@46351 (<= (U_2_int ($Unbox intType (MapType1Select $Heap@3 |A#0@@2| (IndexField |i#0_0@2|)))) |$rhs#0_0@1|)) :lblneg @46351) (and (! (or %lbl%@46366 (<= |$rhs#0_0@1| (U_2_int ($Unbox intType (MapType1Select $Heap@3 |A#0@@2| (IndexField |j#0_0@2|)))))) :lblneg @46366) (=> (and (and (and (<= (U_2_int ($Unbox intType (MapType1Select $Heap@3 |A#0@@2| (IndexField |i#0_0@2|)))) |$rhs#0_0@1|) (<= |$rhs#0_0@1| (U_2_int ($Unbox intType (MapType1Select $Heap@3 |A#0@@2| (IndexField |j#0_0@2|)))))) (= |$rhs#0_0_2_2@2| (+ |i#0_0@2| 1))) (and (and (= |$rhs#0_0_2_3@2| (- |j#0_0@2| 1)) (= |i#0_0@4| |$rhs#0_0_2_2@2|)) (and (= |j#0_0@4| |$rhs#0_0_2_3@2|) (= $Heap@4 $Heap@3)))) anon134_correct))))))) (let ((anon209_Else_correct (=> (! (and %lbl%+21165 true) :lblpos +21165) (=> (< |$rhs#0_0@1| (U_2_int ($Unbox intType (MapType1Select $Heap@3 |A#0@@2| (IndexField |i#0_0@2|))))) anon132_correct)))) (let ((anon209_Then_correct (=> (! (and %lbl%+21163 true) :lblpos +21163) (=> (<= (U_2_int ($Unbox intType (MapType1Select $Heap@3 |A#0@@2| (IndexField |i#0_0@2|)))) |$rhs#0_0@1|) (and (! (or %lbl%@46297 (not (= |A#0@@2| null))) :lblneg @46297) (=> (not (= |A#0@@2| null)) (and (! (or %lbl%@46303 (and (<= 0 |j#0_0@2|) (< |j#0_0@2| (_System.array.Length |A#0@@2|)))) :lblneg @46303) anon132_correct))))))) (let ((anon208_Then_correct (=> (! (and %lbl%+21161 true) :lblpos +21161) (=> (<= |i#0_0@2| |j#0_0@2|) (and (! (or %lbl%@46062 (not (= |A#0@@2| null))) :lblneg @46062) (=> (not (= |A#0@@2| null)) (and (! (or %lbl%@46068 (and (<= 0 |i#0_0@2|) (< |i#0_0@2| (_System.array.Length |A#0@@2|)))) :lblneg @46068) (=> (and (<= 0 |i#0_0@2|) (< |i#0_0@2| (_System.array.Length |A#0@@2|))) (=> (= |w#0_0_2_0@2| (U_2_int ($Unbox intType (MapType1Select $Heap@1 |A#0@@2| (IndexField |i#0_0@2|))))) (and (! (or %lbl%@46106 (not (= |A#0@@2| null))) :lblneg @46106) (=> (not (= |A#0@@2| null)) (and (! (or %lbl%@46112 (and (<= 0 |i#0_0@2|) (< |i#0_0@2| (_System.array.Length |A#0@@2|)))) :lblneg @46112) (=> (and (<= 0 |i#0_0@2|) (< |i#0_0@2| (_System.array.Length |A#0@@2|))) (and (! (or %lbl%@46128 (U_2_bool (MapType3Select $_Frame@0@@4 |A#0@@2| (IndexField |i#0_0@2|)))) :lblneg @46128) (=> (U_2_bool (MapType3Select $_Frame@0@@4 |A#0@@2| (IndexField |i#0_0@2|))) (and (! (or %lbl%@46136 (not (= |A#0@@2| null))) :lblneg @46136) (=> (not (= |A#0@@2| null)) (and (! (or %lbl%@46142 (and (<= 0 |j#0_0@2|) (< |j#0_0@2| (_System.array.Length |A#0@@2|)))) :lblneg @46142) (=> (and (<= 0 |j#0_0@2|) (< |j#0_0@2| (_System.array.Length |A#0@@2|))) (=> (= |$rhs#0_0_2_0@2| (U_2_int ($Unbox intType (MapType1Select $Heap@1 |A#0@@2| (IndexField |j#0_0@2|))))) (=> (and (= $Heap@2 (MapType1Store $Heap@1 |A#0@@2| (IndexField |i#0_0@2|) ($Box (int_2_U |$rhs#0_0_2_0@2|)))) ($IsGoodHeap $Heap@2)) (and (! (or %lbl%@46200 (not (= |A#0@@2| null))) :lblneg @46200) (=> (not (= |A#0@@2| null)) (and (! (or %lbl%@46206 (and (<= 0 |j#0_0@2|) (< |j#0_0@2| (_System.array.Length |A#0@@2|)))) :lblneg @46206) (=> (and (<= 0 |j#0_0@2|) (< |j#0_0@2| (_System.array.Length |A#0@@2|))) (and (! (or %lbl%@46222 (U_2_bool (MapType3Select $_Frame@0@@4 |A#0@@2| (IndexField |j#0_0@2|)))) :lblneg @46222) (=> (U_2_bool (MapType3Select $_Frame@0@@4 |A#0@@2| (IndexField |j#0_0@2|))) (=> (and (= $Heap@3 (MapType1Store $Heap@2 |A#0@@2| (IndexField |j#0_0@2|) ($Box (int_2_U |w#0_0_2_0@2|)))) ($IsGoodHeap $Heap@3)) (and (! (or %lbl%@46258 (not (= |A#0@@2| null))) :lblneg @46258) (=> (not (= |A#0@@2| null)) (and (! (or %lbl%@46264 (and (<= 0 |i#0_0@2|) (< |i#0_0@2| (_System.array.Length |A#0@@2|)))) :lblneg @46264) (and anon209_Then_correct anon209_Else_correct)))))))))))))))))))))))))))))))) (let ((anon208_Else_correct (=> (! (and %lbl%+21169 true) :lblpos +21169) (=> (and (and (< |j#0_0@2| |i#0_0@2|) (= |i#0_0@4| |i#0_0@2|)) (and (= |j#0_0@4| |j#0_0@2|) (= $Heap@4 $Heap@1))) anon134_correct)))) (let ((anon129_correct (=> (! (and %lbl%+21154 true) :lblpos +21154) (=> (=> (<= (U_2_int ($Unbox intType (MapType1Select $Heap@1 |A#0@@2| (IndexField |j#0_0@2|)))) |$rhs#0_0@1|) true) (and (! (or %lbl%@45992 (<= (U_2_int ($Unbox intType (MapType1Select $Heap@1 |A#0@@2| (IndexField |j#0_0@2|)))) |$rhs#0_0@1|)) :lblneg @45992) (and (! (or %lbl%@46007 (<= |$rhs#0_0@1| (U_2_int ($Unbox intType (MapType1Select $Heap@1 |A#0@@2| (IndexField |i#0_0@2|)))))) :lblneg @46007) (=> (and (<= (U_2_int ($Unbox intType (MapType1Select $Heap@1 |A#0@@2| (IndexField |j#0_0@2|)))) |$rhs#0_0@1|) (<= |$rhs#0_0@1| (U_2_int ($Unbox intType (MapType1Select $Heap@1 |A#0@@2| (IndexField |i#0_0@2|)))))) (and anon208_Then_correct anon208_Else_correct)))))))) (let ((anon207_Else_correct (=> (! (and %lbl%+21147 true) :lblpos +21147) (=> (< |$rhs#0_0@1| (U_2_int ($Unbox intType (MapType1Select $Heap@1 |A#0@@2| (IndexField |j#0_0@2|))))) anon129_correct)))) (let ((anon207_Then_correct (=> (! (and %lbl%+21145 true) :lblpos +21145) (=> (<= (U_2_int ($Unbox intType (MapType1Select $Heap@1 |A#0@@2| (IndexField |j#0_0@2|)))) |$rhs#0_0@1|) (and (! (or %lbl%@45938 (not (= |A#0@@2| null))) :lblneg @45938) (=> (not (= |A#0@@2| null)) (and (! (or %lbl%@45944 (and (<= 0 |i#0_0@2|) (< |i#0_0@2| (_System.array.Length |A#0@@2|)))) :lblneg @45944) anon129_correct))))))) (let ((anon206_Then_correct (=> (! (and %lbl%+21130 true) :lblpos +21130) (=> (<= (U_2_int ($Unbox intType (MapType1Select $Heap@1 |A#0@@2| (IndexField |j#0_0@2|)))) |$rhs#0_0@1|) (and (! (or %lbl%@45562 (not (= |A#0@@2| null))) :lblneg @45562) (=> (not (= |A#0@@2| null)) (and (! (or %lbl%@45568 (and (<= 0 |j#0_0@2|) (< |j#0_0@2| (_System.array.Length |A#0@@2|)))) :lblneg @45568) (and anon207_Then_correct anon207_Else_correct)))))))) (let ((anon206_Else_correct (=> (! (and %lbl%+21132 true) :lblpos +21132) (=> (and (< |$rhs#0_0@1| (U_2_int ($Unbox intType (MapType1Select $Heap@1 |A#0@@2| (IndexField |j#0_0@2|))))) (= |j#0_0@3| (- |j#0_0@2| 1))) (and (! (or %lbl%@45618 (or (<= 0 |j#0_0@2|) (= |j#0_0@3| |j#0_0@2|))) :lblneg @45618) (=> (or (<= 0 |j#0_0@2|) (= |j#0_0@3| |j#0_0@2|)) (and (! (or %lbl%@45629 (< |j#0_0@3| |j#0_0@2|)) :lblneg @45629) (=> (< |j#0_0@3| |j#0_0@2|) (=> (and (and (and (=> (<= (LitInt 0) |j#0_0@3|) true) (=> (and (<= (LitInt 0) |j#0_0@3|) (<= |j#0_0@3| |n#0@0|)) (=> |firstIteration#0_0_0@2| true))) (forall ((|g#0_0_5@@1| Int)) (! (=> true (and (=> (<= |i#0_0@2| |g#0_0_5@@1|) true) (=> (and (<= |i#0_0@2| |g#0_0_5@@1|) (< |g#0_0_5@@1| |N#0@@0|)) true))) :qid |Classics.84:26| :skolemid |443|))) (and (forall ((|g#0_0_7@@1| Int)) (! (=> true (and (=> (<= (LitInt 0) |g#0_0_7@@1|) true) (=> (and (<= (LitInt 0) |g#0_0_7@@1|) (<= |g#0_0_7@@1| |j#0_0@3|)) true))) :qid |Classics.85:26| :skolemid |444|)) (forall ((|q#0_0_1| Int)) (! (=> true (and (=> (< |j#0_0@3| |q#0_0_1|) true) (=> (and (< |j#0_0@3| |q#0_0_1|) (< |q#0_0_1| |N#0@@0|)) true))) :qid |Classics.86:26| :skolemid |445|)))) (and (! (or %lbl%@45776 (=> |$w$loop#0_0_1@2| (<= (LitInt 0) |j#0_0@3|))) :lblneg @45776) (=> (=> |$w$loop#0_0_1@2| (<= (LitInt 0) |j#0_0@3|)) (and (! (or %lbl%@45786 (=> |$w$loop#0_0_1@2| (<= |j#0_0@3| |n#0@0|))) :lblneg @45786) (=> (=> |$w$loop#0_0_1@2| (<= |j#0_0@3| |n#0@0|)) (and (! (or %lbl%@45793 (=> |$w$loop#0_0_1@2| (=> |firstIteration#0_0_0@2| (<= |f#0@@0| |j#0_0@3|)))) :lblneg @45793) (=> (=> |$w$loop#0_0_1@2| (=> |firstIteration#0_0_0@2| (<= |f#0@@0| |j#0_0@3|))) (and (! (or %lbl%@45804 (=> |$w$loop#0_0_1@2| (exists ((|g#0_0_5@@2| Int)) (! (and (and (<= |i#0_0@2| |g#0_0_5@@2|) (< |g#0_0_5@@2| |N#0@@0|)) (<= |$rhs#0_0@1| (U_2_int ($Unbox intType (MapType1Select $Heap@1 |A#0@@2| (IndexField |g#0_0_5@@2|)))))) :qid |Classics.84:26| :skolemid |430|)))) :lblneg @45804) (=> (=> |$w$loop#0_0_1@2| (exists ((|g#0_0_5@@3| Int)) (! (and (and (<= |i#0_0@2| |g#0_0_5@@3|) (< |g#0_0_5@@3| |N#0@@0|)) (<= |$rhs#0_0@1| (U_2_int ($Unbox intType (MapType1Select $Heap@1 |A#0@@2| (IndexField |g#0_0_5@@3|)))))) :qid |Classics.84:26| :skolemid |430|))) (and (! (or %lbl%@45841 (=> |$w$loop#0_0_1@2| (exists ((|g#0_0_7@@2| Int)) (! (and (and (<= (LitInt 0) |g#0_0_7@@2|) (<= |g#0_0_7@@2| |j#0_0@3|)) (<= (U_2_int ($Unbox intType (MapType1Select $Heap@1 |A#0@@2| (IndexField |g#0_0_7@@2|)))) |$rhs#0_0@1|)) :qid |Classics.85:26| :skolemid |435|)))) :lblneg @45841) (=> (=> |$w$loop#0_0_1@2| (exists ((|g#0_0_7@@3| Int)) (! (and (and (<= (LitInt 0) |g#0_0_7@@3|) (<= |g#0_0_7@@3| |j#0_0@3|)) (<= (U_2_int ($Unbox intType (MapType1Select $Heap@1 |A#0@@2| (IndexField |g#0_0_7@@3|)))) |$rhs#0_0@1|)) :qid |Classics.85:26| :skolemid |435|))) (! (or %lbl%@45880 (=> |$w$loop#0_0_1@2| (forall ((|q#0_0_1@@0| Int)) (! (=> true (=> (and (< |j#0_0@3| |q#0_0_1@@0|) (< |q#0_0_1@@0| |N#0@@0|)) (<= |$rhs#0_0@1| (U_2_int ($Unbox intType (MapType1Select $Heap@1 |A#0@@2| (IndexField |q#0_0_1@@0|))))))) :qid |Classics.86:26| :skolemid |440|)))) :lblneg @45880)))))))))))))))))))) (let ((anon196_Else_correct (=> (! (and %lbl%+21121 true) :lblpos +21121) (=> |$w$loop#0_0_1@2| (and (! (or %lbl%@45525 (not (= |A#0@@2| null))) :lblneg @45525) (=> (not (= |A#0@@2| null)) (and (! (or %lbl%@45531 (and (<= 0 |j#0_0@2|) (< |j#0_0@2| (_System.array.Length |A#0@@2|)))) :lblneg @45531) (=> (and (<= 0 |j#0_0@2|) (< |j#0_0@2| (_System.array.Length |A#0@@2|))) (and anon206_Then_correct anon206_Else_correct))))))))) (let ((anon195_LoopBody_correct (=> (! (and %lbl%+21020 true) :lblpos +21020) (and anon196_Then_correct anon196_Else_correct)))) (let ((anon195_LoopDone_correct (=> (! (and %lbl%+21136 true) :lblpos +21136) true))) (let ((anon195_LoopHead_correct (=> (! (and %lbl%+21014 true) :lblpos +21014) (=> (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (not false) (<= 0 |m#0@0|)) (<= 1 |n#0@0|)) (= |$rhs#0@0| 0)) (<= 0 |$rhs#1@0|)) (<= 0 |$decr_init$loop#00@0@@0|)) |$w$loop#0@0@@0|) (<= 0 |i#0_0@2|)) (<= (- 0 1) |j#0_0@2|)) (<= 0 |m#0@0|)) (<= 1 |n#0@0|)) |$w$loop#0_0@1@@0|) |$w$loop#0_0_0@2|) (<= 0 |j#0_0@1|)) (=> |$w$loop#0_0_1@2| (and (=> (<= (LitInt 0) |j#0_0@2|) true) (=> (and (<= (LitInt 0) |j#0_0@2|) (<= |j#0_0@2| |n#0@0|)) (=> |firstIteration#0_0_0@2| true))))) (and (=> |$w$loop#0_0_1@2| (<= (LitInt 0) |j#0_0@2|)) (=> |$w$loop#0_0_1@2| (<= |j#0_0@2| |n#0@0|)))) (and (and (=> |$w$loop#0_0_1@2| (=> |firstIteration#0_0_0@2| (<= |f#0@@0| |j#0_0@2|))) (=> |$w$loop#0_0_1@2| (forall ((|g#0_0_5@@4| Int)) (! (=> true (and (=> (<= |i#0_0@2| |g#0_0_5@@4|) true) (=> (and (<= |i#0_0@2| |g#0_0_5@@4|) (< |g#0_0_5@@4| |N#0@@0|)) true))) :qid |Classics.84:26| :skolemid |428|)))) (and (=> |$w$loop#0_0_1@2| (exists ((|g#0_0_5@@5| Int)) (! (and (and (<= |i#0_0@2| |g#0_0_5@@5|) (< |g#0_0_5@@5| |N#0@@0|)) (<= |$rhs#0_0@1| (U_2_int ($Unbox intType (MapType1Select $Heap@1 |A#0@@2| (IndexField |g#0_0_5@@5|)))))) :qid |Classics.84:26| :skolemid |430|))) (=> |$w$loop#0_0_1@2| (forall ((|g#0_0_7@@4| Int)) (! (=> true (and (=> (<= (LitInt 0) |g#0_0_7@@4|) true) (=> (and (<= (LitInt 0) |g#0_0_7@@4|) (<= |g#0_0_7@@4| |j#0_0@2|)) true))) :qid |Classics.85:26| :skolemid |433|)))))) (and (and (and (=> |$w$loop#0_0_1@2| (exists ((|g#0_0_7@@5| Int)) (! (and (and (<= (LitInt 0) |g#0_0_7@@5|) (<= |g#0_0_7@@5| |j#0_0@2|)) (<= (U_2_int ($Unbox intType (MapType1Select $Heap@1 |A#0@@2| (IndexField |g#0_0_7@@5|)))) |$rhs#0_0@1|)) :qid |Classics.85:26| :skolemid |435|))) (=> |$w$loop#0_0_1@2| (forall ((|q#0_0_1@@1| Int)) (! (=> true (and (=> (< |j#0_0@2| |q#0_0_1@@1|) true) (=> (and (< |j#0_0@2| |q#0_0_1@@1|) (< |q#0_0_1@@1| |N#0@@0|)) true))) :qid |Classics.86:26| :skolemid |438|)))) (and (=> |$w$loop#0_0_1@2| (forall ((|q#0_0_1@@2| Int)) (! (=> true (=> (and (< |j#0_0@2| |q#0_0_1@@2|) (< |q#0_0_1@@2| |N#0@@0|)) (<= |$rhs#0_0@1| (U_2_int ($Unbox intType (MapType1Select $Heap@1 |A#0@@2| (IndexField |q#0_0_1@@2|))))))) :qid |Classics.86:26| :skolemid |440|))) (forall (($o@@22 T@U) ($f@@14 T@U)) (! (let ((alpha@@21 (FieldTypeInv0 (type $f@@14)))) (=> (and (and (= (type $o@@22) refType) (= (type $f@@14) (FieldType alpha@@21))) (and (not (= $o@@22 null)) (U_2_bool (MapType1Select $Heap@@12 $o@@22 alloc)))) (or (= (MapType1Select $Heap@1 $o@@22 $f@@14) (MapType1Select $Heap@1 $o@@22 $f@@14)) (= $o@@22 |A#0@@2|)))) :qid |Classics.82:7| :skolemid |441| :pattern ((MapType1Select $Heap@1 $o@@22 $f@@14)))))) (and (and ($HeapSucc $Heap@1 $Heap@1) (forall (($o@@23 T@U) ($f@@15 T@U)) (! (let ((alpha@@22 (FieldTypeInv0 (type $f@@15)))) (=> (and (and (= (type $o@@23) refType) (= (type $f@@15) (FieldType alpha@@22))) (and (not (= $o@@23 null)) (U_2_bool (MapType1Select $Heap@1 $o@@23 alloc)))) (or (= (MapType1Select $Heap@1 $o@@23 $f@@15) (MapType1Select $Heap@1 $o@@23 $f@@15)) (U_2_bool (MapType3Select $_Frame@0@@4 $o@@23 $f@@15))))) :qid |Classics.82:7| :skolemid |442| :pattern ((MapType1Select $Heap@1 $o@@23 $f@@15))))) (and (<= |j#0_0@2| |j#0_0@1|) (=> (= |j#0_0@2| |j#0_0@1|) true))))) (and anon195_LoopDone_correct anon195_LoopBody_correct))))) (let ((anon194_Then_correct (=> (! (and %lbl%+21000 true) :lblpos +21000) (=> (<= |$rhs#0_0@1| (U_2_int ($Unbox intType (MapType1Select $Heap@1 |A#0@@2| (IndexField |i#0_0@2|))))) (and (! (or %lbl%@44504 (=> |$w$loop#0_0_1@2| (<= (LitInt 0) |j#0_0@1|))) :lblneg @44504) (=> (=> |$w$loop#0_0_1@2| (<= (LitInt 0) |j#0_0@1|)) (and (! (or %lbl%@44514 (=> |$w$loop#0_0_1@2| (<= |j#0_0@1| |n#0@0|))) :lblneg @44514) (=> (=> |$w$loop#0_0_1@2| (<= |j#0_0@1| |n#0@0|)) (and (! (or %lbl%@44521 (=> |$w$loop#0_0_1@2| (=> |firstIteration#0_0_0@2| (<= |f#0@@0| |j#0_0@1|)))) :lblneg @44521) (=> (=> |$w$loop#0_0_1@2| (=> |firstIteration#0_0_0@2| (<= |f#0@@0| |j#0_0@1|))) (and (! (or %lbl%@44532 (=> |$w$loop#0_0_1@2| (exists ((|g#0_0_5@@6| Int)) (! (and (and (<= |i#0_0@2| |g#0_0_5@@6|) (< |g#0_0_5@@6| |N#0@@0|)) (<= |$rhs#0_0@1| (U_2_int ($Unbox intType (MapType1Select $Heap@1 |A#0@@2| (IndexField |g#0_0_5@@6|)))))) :qid |Classics.84:26| :skolemid |430|)))) :lblneg @44532) (=> (=> |$w$loop#0_0_1@2| (exists ((|g#0_0_5@@7| Int)) (! (and (and (<= |i#0_0@2| |g#0_0_5@@7|) (< |g#0_0_5@@7| |N#0@@0|)) (<= |$rhs#0_0@1| (U_2_int ($Unbox intType (MapType1Select $Heap@1 |A#0@@2| (IndexField |g#0_0_5@@7|)))))) :qid |Classics.84:26| :skolemid |430|))) (and (! (or %lbl%@44569 (=> |$w$loop#0_0_1@2| (exists ((|g#0_0_7@@6| Int)) (! (and (and (<= (LitInt 0) |g#0_0_7@@6|) (<= |g#0_0_7@@6| |j#0_0@1|)) (<= (U_2_int ($Unbox intType (MapType1Select $Heap@1 |A#0@@2| (IndexField |g#0_0_7@@6|)))) |$rhs#0_0@1|)) :qid |Classics.85:26| :skolemid |435|)))) :lblneg @44569) (=> (=> |$w$loop#0_0_1@2| (exists ((|g#0_0_7@@7| Int)) (! (and (and (<= (LitInt 0) |g#0_0_7@@7|) (<= |g#0_0_7@@7| |j#0_0@1|)) (<= (U_2_int ($Unbox intType (MapType1Select $Heap@1 |A#0@@2| (IndexField |g#0_0_7@@7|)))) |$rhs#0_0@1|)) :qid |Classics.85:26| :skolemid |435|))) (and (! (or %lbl%@44608 (=> |$w$loop#0_0_1@2| (forall ((|q#0_0_1@@3| Int)) (! (=> true (=> (and (< |j#0_0@1| |q#0_0_1@@3|) (< |q#0_0_1@@3| |N#0@@0|)) (<= |$rhs#0_0@1| (U_2_int ($Unbox intType (MapType1Select $Heap@1 |A#0@@2| (IndexField |q#0_0_1@@3|))))))) :qid |Classics.86:26| :skolemid |440|)))) :lblneg @44608) (=> (=> |$w$loop#0_0_1@2| (forall ((|q#0_0_1@@4| Int)) (! (=> true (=> (and (< |j#0_0@1| |q#0_0_1@@4|) (< |q#0_0_1@@4| |N#0@@0|)) (<= |$rhs#0_0@1| (U_2_int ($Unbox intType (MapType1Select $Heap@1 |A#0@@2| (IndexField |q#0_0_1@@4|))))))) :qid |Classics.86:26| :skolemid |440|))) anon195_LoopHead_correct)))))))))))))))) (let ((anon194_Else_correct (=> (! (and %lbl%+21002 true) :lblpos +21002) (=> (< (U_2_int ($Unbox intType (MapType1Select $Heap@1 |A#0@@2| (IndexField |i#0_0@2|)))) |$rhs#0_0@1|) (=> (and (= |$decr$loop#0_0_00@3| (- |j#0_0@1| |i#0_0@2|)) (= |i#0_0@3| (+ |i#0_0@2| 1))) (and (! (or %lbl%@44693 (or (<= 0 |$decr$loop#0_0_00@3|) (= (- |j#0_0@1| |i#0_0@3|) |$decr$loop#0_0_00@3|))) :lblneg @44693) (=> (or (<= 0 |$decr$loop#0_0_00@3|) (= (- |j#0_0@1| |i#0_0@3|) |$decr$loop#0_0_00@3|)) (and (! (or %lbl%@44707 (< (- |j#0_0@1| |i#0_0@3|) |$decr$loop#0_0_00@3|)) :lblneg @44707) (=> (< (- |j#0_0@1| |i#0_0@3|) |$decr$loop#0_0_00@3|) (=> (and (and (and (=> (<= |m#0@0| |i#0_0@3|) true) (=> (and (<= |m#0@0| |i#0_0@3|) (<= |i#0_0@3| |N#0@@0|)) (=> |firstIteration#0_0_0@2| true))) (forall ((|g#0_0_1@@1| Int)) (! (=> true (and (=> (<= |i#0_0@3| |g#0_0_1@@1|) true) (=> (and (<= |i#0_0@3| |g#0_0_1@@1|) (< |g#0_0_1@@1| |N#0@@0|)) true))) :qid |Classics.76:26| :skolemid |423|))) (and (forall ((|g#0_0_3@@1| Int)) (! (=> true (and (=> (<= (LitInt 0) |g#0_0_3@@1|) true) (=> (and (<= (LitInt 0) |g#0_0_3@@1|) (<= |g#0_0_3@@1| |j#0_0@1|)) true))) :qid |Classics.77:26| :skolemid |424|)) (forall ((|p#0_0_1| Int)) (! (=> true (and (=> (<= (LitInt 0) |p#0_0_1|) true) (=> (and (<= (LitInt 0) |p#0_0_1|) (< |p#0_0_1| |i#0_0@3|)) true))) :qid |Classics.78:26| :skolemid |425|)))) (and (! (or %lbl%@44857 (=> |$w$loop#0_0_0@2| (<= |m#0@0| |i#0_0@3|))) :lblneg @44857) (=> (=> |$w$loop#0_0_0@2| (<= |m#0@0| |i#0_0@3|)) (and (! (or %lbl%@44864 (=> |$w$loop#0_0_0@2| (<= |i#0_0@3| |N#0@@0|))) :lblneg @44864) (=> (=> |$w$loop#0_0_0@2| (<= |i#0_0@3| |N#0@@0|)) (and (! (or %lbl%@44872 (=> |$w$loop#0_0_0@2| (=> |firstIteration#0_0_0@2| (<= |i#0_0@3| |f#0@@0|)))) :lblneg @44872) (=> (=> |$w$loop#0_0_0@2| (=> |firstIteration#0_0_0@2| (<= |i#0_0@3| |f#0@@0|))) (and (! (or %lbl%@44883 (=> |$w$loop#0_0_0@2| (exists ((|g#0_0_1@@2| Int)) (! (and (and (<= |i#0_0@3| |g#0_0_1@@2|) (< |g#0_0_1@@2| |N#0@@0|)) (<= |$rhs#0_0@1| (U_2_int ($Unbox intType (MapType1Select $Heap@1 |A#0@@2| (IndexField |g#0_0_1@@2|)))))) :qid |Classics.76:26| :skolemid |410|)))) :lblneg @44883) (=> (=> |$w$loop#0_0_0@2| (exists ((|g#0_0_1@@3| Int)) (! (and (and (<= |i#0_0@3| |g#0_0_1@@3|) (< |g#0_0_1@@3| |N#0@@0|)) (<= |$rhs#0_0@1| (U_2_int ($Unbox intType (MapType1Select $Heap@1 |A#0@@2| (IndexField |g#0_0_1@@3|)))))) :qid |Classics.76:26| :skolemid |410|))) (and (! (or %lbl%@44920 (=> |$w$loop#0_0_0@2| (exists ((|g#0_0_3@@2| Int)) (! (and (and (<= (LitInt 0) |g#0_0_3@@2|) (<= |g#0_0_3@@2| |j#0_0@1|)) (<= (U_2_int ($Unbox intType (MapType1Select $Heap@1 |A#0@@2| (IndexField |g#0_0_3@@2|)))) |$rhs#0_0@1|)) :qid |Classics.77:26| :skolemid |415|)))) :lblneg @44920) (=> (=> |$w$loop#0_0_0@2| (exists ((|g#0_0_3@@3| Int)) (! (and (and (<= (LitInt 0) |g#0_0_3@@3|) (<= |g#0_0_3@@3| |j#0_0@1|)) (<= (U_2_int ($Unbox intType (MapType1Select $Heap@1 |A#0@@2| (IndexField |g#0_0_3@@3|)))) |$rhs#0_0@1|)) :qid |Classics.77:26| :skolemid |415|))) (! (or %lbl%@44959 (=> |$w$loop#0_0_0@2| (forall ((|p#0_0_1@@0| Int)) (! (=> true (=> (and (<= (LitInt 0) |p#0_0_1@@0|) (< |p#0_0_1@@0| |i#0_0@3|)) (<= (U_2_int ($Unbox intType (MapType1Select $Heap@1 |A#0@@2| (IndexField |p#0_0_1@@0|)))) |$rhs#0_0@1|))) :qid |Classics.78:26| :skolemid |420|)))) :lblneg @44959))))))))))))))))))))) (let ((anon184_Else_correct (=> (! (and %lbl%+20991 true) :lblpos +20991) (=> |$w$loop#0_0_0@2| (and (! (or %lbl%@44460 (not (= |A#0@@2| null))) :lblneg @44460) (=> (not (= |A#0@@2| null)) (and (! (or %lbl%@44466 (and (<= 0 |i#0_0@2|) (< |i#0_0@2| (_System.array.Length |A#0@@2|)))) :lblneg @44466) (=> (and (<= 0 |i#0_0@2|) (< |i#0_0@2| (_System.array.Length |A#0@@2|))) (and anon194_Then_correct anon194_Else_correct))))))))) (let ((anon183_LoopBody_correct (=> (! (and %lbl%+20890 true) :lblpos +20890) (and anon184_Then_correct anon184_Else_correct)))) (let ((anon183_LoopDone_correct (=> (! (and %lbl%+21006 true) :lblpos +21006) true))) (let ((anon183_LoopHead_correct (=> (! (and %lbl%+20884 true) :lblpos +20884) (=> (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (not false) (<= 0 |m#0@0|)) (<= 1 |n#0@0|)) (= |$rhs#0@0| 0)) (<= 0 |$rhs#1@0|)) (<= 0 |$decr_init$loop#00@0@@0|)) |$w$loop#0@0@@0|) (<= 0 |i#0_0@2|)) (<= 0 |j#0_0@1|)) (<= 0 |m#0@0|)) (<= 1 |n#0@0|)) |$w$loop#0_0@1@@0|) (=> |$w$loop#0_0_0@2| (and (=> (<= |m#0@0| |i#0_0@2|) true) (=> (and (<= |m#0@0| |i#0_0@2|) (<= |i#0_0@2| |N#0@@0|)) (=> |firstIteration#0_0_0@2| true))))) (and (=> |$w$loop#0_0_0@2| (<= |m#0@0| |i#0_0@2|)) (=> |$w$loop#0_0_0@2| (<= |i#0_0@2| |N#0@@0|)))) (and (and (=> |$w$loop#0_0_0@2| (=> |firstIteration#0_0_0@2| (<= |i#0_0@2| |f#0@@0|))) (=> |$w$loop#0_0_0@2| (forall ((|g#0_0_1@@4| Int)) (! (=> true (and (=> (<= |i#0_0@2| |g#0_0_1@@4|) true) (=> (and (<= |i#0_0@2| |g#0_0_1@@4|) (< |g#0_0_1@@4| |N#0@@0|)) true))) :qid |Classics.76:26| :skolemid |408|)))) (and (=> |$w$loop#0_0_0@2| (exists ((|g#0_0_1@@5| Int)) (! (and (and (<= |i#0_0@2| |g#0_0_1@@5|) (< |g#0_0_1@@5| |N#0@@0|)) (<= |$rhs#0_0@1| (U_2_int ($Unbox intType (MapType1Select $Heap@1 |A#0@@2| (IndexField |g#0_0_1@@5|)))))) :qid |Classics.76:26| :skolemid |410|))) (=> |$w$loop#0_0_0@2| (forall ((|g#0_0_3@@4| Int)) (! (=> true (and (=> (<= (LitInt 0) |g#0_0_3@@4|) true) (=> (and (<= (LitInt 0) |g#0_0_3@@4|) (<= |g#0_0_3@@4| |j#0_0@1|)) true))) :qid |Classics.77:26| :skolemid |413|)))))) (and (and (and (=> |$w$loop#0_0_0@2| (exists ((|g#0_0_3@@5| Int)) (! (and (and (<= (LitInt 0) |g#0_0_3@@5|) (<= |g#0_0_3@@5| |j#0_0@1|)) (<= (U_2_int ($Unbox intType (MapType1Select $Heap@1 |A#0@@2| (IndexField |g#0_0_3@@5|)))) |$rhs#0_0@1|)) :qid |Classics.77:26| :skolemid |415|))) (=> |$w$loop#0_0_0@2| (forall ((|p#0_0_1@@1| Int)) (! (=> true (and (=> (<= (LitInt 0) |p#0_0_1@@1|) true) (=> (and (<= (LitInt 0) |p#0_0_1@@1|) (< |p#0_0_1@@1| |i#0_0@2|)) true))) :qid |Classics.78:26| :skolemid |418|)))) (and (=> |$w$loop#0_0_0@2| (forall ((|p#0_0_1@@2| Int)) (! (=> true (=> (and (<= (LitInt 0) |p#0_0_1@@2|) (< |p#0_0_1@@2| |i#0_0@2|)) (<= (U_2_int ($Unbox intType (MapType1Select $Heap@1 |A#0@@2| (IndexField |p#0_0_1@@2|)))) |$rhs#0_0@1|))) :qid |Classics.78:26| :skolemid |420|))) (forall (($o@@24 T@U) ($f@@16 T@U)) (! (let ((alpha@@23 (FieldTypeInv0 (type $f@@16)))) (=> (and (and (= (type $o@@24) refType) (= (type $f@@16) (FieldType alpha@@23))) (and (not (= $o@@24 null)) (U_2_bool (MapType1Select $Heap@@12 $o@@24 alloc)))) (or (= (MapType1Select $Heap@1 $o@@24 $f@@16) (MapType1Select $Heap@1 $o@@24 $f@@16)) (= $o@@24 |A#0@@2|)))) :qid |Classics.74:7| :skolemid |421| :pattern ((MapType1Select $Heap@1 $o@@24 $f@@16)))))) (and (and ($HeapSucc $Heap@1 $Heap@1) (forall (($o@@25 T@U) ($f@@17 T@U)) (! (let ((alpha@@24 (FieldTypeInv0 (type $f@@17)))) (=> (and (and (= (type $o@@25) refType) (= (type $f@@17) (FieldType alpha@@24))) (and (not (= $o@@25 null)) (U_2_bool (MapType1Select $Heap@1 $o@@25 alloc)))) (or (= (MapType1Select $Heap@1 $o@@25 $f@@17) (MapType1Select $Heap@1 $o@@25 $f@@17)) (U_2_bool (MapType3Select $_Frame@0@@4 $o@@25 $f@@17))))) :qid |Classics.74:7| :skolemid |422| :pattern ((MapType1Select $Heap@1 $o@@25 $f@@17))))) (and (<= (- |j#0_0@1| |i#0_0@2|) |$decr_init$loop#0_0_00@2|) (=> (= (- |j#0_0@1| |i#0_0@2|) |$decr_init$loop#0_0_00@2|) true))))) (and anon183_LoopDone_correct anon183_LoopBody_correct))))) (let ((anon81_correct (=> (! (and %lbl%+20882 true) :lblpos +20882) (=> (=> (= |i#0_0@1| |m#0@0|) true) (=> (and (and (=> |firstIteration#0_0_0@2| (and (= |i#0_0@1| |m#0@0|) (= |j#0_0@1| |n#0@0|))) (=> (and (= |i#0_0@1| |m#0@0|) (= |j#0_0@1| |n#0@0|)) |firstIteration#0_0_0@2|)) (= |$decr_init$loop#0_0_00@2| (- |j#0_0@1| |i#0_0@1|))) (and (! (or %lbl%@43798 (=> |$w$loop#0_0_0@2| (<= |m#0@0| |i#0_0@1|))) :lblneg @43798) (=> (=> |$w$loop#0_0_0@2| (<= |m#0@0| |i#0_0@1|)) (and (! (or %lbl%@43805 (=> |$w$loop#0_0_0@2| (<= |i#0_0@1| |N#0@@0|))) :lblneg @43805) (=> (=> |$w$loop#0_0_0@2| (<= |i#0_0@1| |N#0@@0|)) (and (! (or %lbl%@43813 (=> |$w$loop#0_0_0@2| (=> |firstIteration#0_0_0@2| (<= |i#0_0@1| |f#0@@0|)))) :lblneg @43813) (=> (=> |$w$loop#0_0_0@2| (=> |firstIteration#0_0_0@2| (<= |i#0_0@1| |f#0@@0|))) (and (! (or %lbl%@43824 (=> |$w$loop#0_0_0@2| (exists ((|g#0_0_1@@6| Int)) (! (and (and (<= |i#0_0@1| |g#0_0_1@@6|) (< |g#0_0_1@@6| |N#0@@0|)) (<= |$rhs#0_0@1| (U_2_int ($Unbox intType (MapType1Select $Heap@1 |A#0@@2| (IndexField |g#0_0_1@@6|)))))) :qid |Classics.76:26| :skolemid |410|)))) :lblneg @43824) (=> (=> |$w$loop#0_0_0@2| (exists ((|g#0_0_1@@7| Int)) (! (and (and (<= |i#0_0@1| |g#0_0_1@@7|) (< |g#0_0_1@@7| |N#0@@0|)) (<= |$rhs#0_0@1| (U_2_int ($Unbox intType (MapType1Select $Heap@1 |A#0@@2| (IndexField |g#0_0_1@@7|)))))) :qid |Classics.76:26| :skolemid |410|))) (and (! (or %lbl%@43861 (=> |$w$loop#0_0_0@2| (exists ((|g#0_0_3@@6| Int)) (! (and (and (<= (LitInt 0) |g#0_0_3@@6|) (<= |g#0_0_3@@6| |j#0_0@1|)) (<= (U_2_int ($Unbox intType (MapType1Select $Heap@1 |A#0@@2| (IndexField |g#0_0_3@@6|)))) |$rhs#0_0@1|)) :qid |Classics.77:26| :skolemid |415|)))) :lblneg @43861) (=> (=> |$w$loop#0_0_0@2| (exists ((|g#0_0_3@@7| Int)) (! (and (and (<= (LitInt 0) |g#0_0_3@@7|) (<= |g#0_0_3@@7| |j#0_0@1|)) (<= (U_2_int ($Unbox intType (MapType1Select $Heap@1 |A#0@@2| (IndexField |g#0_0_3@@7|)))) |$rhs#0_0@1|)) :qid |Classics.77:26| :skolemid |415|))) (and (! (or %lbl%@43900 (=> |$w$loop#0_0_0@2| (forall ((|p#0_0_1@@3| Int)) (! (=> true (=> (and (<= (LitInt 0) |p#0_0_1@@3|) (< |p#0_0_1@@3| |i#0_0@1|)) (<= (U_2_int ($Unbox intType (MapType1Select $Heap@1 |A#0@@2| (IndexField |p#0_0_1@@3|)))) |$rhs#0_0@1|))) :qid |Classics.78:26| :skolemid |420|)))) :lblneg @43900) (=> (=> |$w$loop#0_0_0@2| (forall ((|p#0_0_1@@4| Int)) (! (=> true (=> (and (<= (LitInt 0) |p#0_0_1@@4|) (< |p#0_0_1@@4| |i#0_0@1|)) (<= (U_2_int ($Unbox intType (MapType1Select $Heap@1 |A#0@@2| (IndexField |p#0_0_1@@4|)))) |$rhs#0_0@1|))) :qid |Classics.78:26| :skolemid |420|))) anon183_LoopHead_correct))))))))))))))))) (let ((anon182_Else_correct (=> (! (and %lbl%+20876 true) :lblpos +20876) (=> (not (= |i#0_0@1| |m#0@0|)) anon81_correct)))) (let ((anon182_Then_correct (=> (! (and %lbl%+20874 true) :lblpos +20874) (=> (= |i#0_0@1| |m#0@0|) anon81_correct)))) (let ((anon181_Else_correct (=> (! (and %lbl%+20865 true) :lblpos +20865) (=> (and (<= |i#0_0@1| |j#0_0@1|) (= |$decr$loop#0_00@2@@0| (- |j#0_0@1| |i#0_0@1|))) (and anon182_Then_correct anon182_Else_correct))))) (let ((anon156_Else_correct (=> (! (and %lbl%+20854 true) :lblpos +20854) (=> |$w$loop#0_0@1@@0| (and anon181_Then_correct anon181_Else_correct))))) (let ((anon155_LoopBody_correct (=> (! (and %lbl%+20589 true) :lblpos +20589) (and anon156_Then_correct anon156_Else_correct)))) (let ((anon155_LoopDone_correct (=> (! (and %lbl%+21173 true) :lblpos +21173) true))) (let ((anon155_LoopHead_correct (=> (! (and %lbl%+20583 true) :lblpos +20583) (=> (and ($IsGoodHeap $Heap@1) ($IsHeapAnchor $Heap@1)) (=> (and (and (and (and (and (and (and (and (and (and (and (and (and (not false) (<= 0 |m#0@0|)) (<= 1 |n#0@0|)) (= |$rhs#0@0| 0)) (<= 0 |$rhs#1@0|)) (<= 0 |$decr_init$loop#00@0@@0|)) |$w$loop#0@0@@0|) (<= 0 |i#0_0@1|)) (<= (- 0 1) |j#0_0@1|)) (<= 0 |m#0@0|)) (<= 1 |n#0@0|)) (=> |$w$loop#0_0@1@@0| (=> (<= |m#0@0| |i#0_0@1|) true))) (and (and (and (=> |$w$loop#0_0@1@@0| (<= |m#0@0| |i#0_0@1|)) (=> |$w$loop#0_0@1@@0| (<= |j#0_0@1| |n#0@0|))) (and (=> |$w$loop#0_0@1@@0| (=> (<= (LitInt (- 0 1)) |j#0_0@1|) true)) (=> |$w$loop#0_0@1@@0| (<= (LitInt (- 0 1)) |j#0_0@1|)))) (and (and (=> |$w$loop#0_0@1@@0| (<= |i#0_0@1| |N#0@@0|)) (=> |$w$loop#0_0@1@@0| (=> (<= |i#0_0@1| |j#0_0@1|) (forall ((|g#0_1@@4| Int)) (! (=> true (and (=> (<= |i#0_0@1| |g#0_1@@4|) true) (=> (and (<= |i#0_0@1| |g#0_1@@4|) (< |g#0_1@@4| |N#0@@0|)) true))) :qid |Classics.63:35| :skolemid |378|))))) (and (=> |$w$loop#0_0@1@@0| (=> (<= |i#0_0@1| |j#0_0@1|) (exists ((|g#0_1@@5| Int)) (! (and (and (<= |i#0_0@1| |g#0_1@@5|) (< |g#0_1@@5| |N#0@@0|)) (<= |$rhs#0_0@1| (U_2_int ($Unbox intType (MapType1Select $Heap@1 |A#0@@2| (IndexField |g#0_1@@5|)))))) :qid |Classics.63:35| :skolemid |379|)))) (=> |$w$loop#0_0@1@@0| (=> (<= |i#0_0@1| |j#0_0@1|) (forall ((|g#0_3@@4| Int)) (! (=> true (and (=> (<= (LitInt 0) |g#0_3@@4|) true) (=> (and (<= (LitInt 0) |g#0_3@@4|) (<= |g#0_3@@4| |j#0_0@1|)) true))) :qid |Classics.64:35| :skolemid |382|)))))))) (and (and (and (and (=> |$w$loop#0_0@1@@0| (=> (<= |i#0_0@1| |j#0_0@1|) (exists ((|g#0_3@@5| Int)) (! (and (and (<= (LitInt 0) |g#0_3@@5|) (<= |g#0_3@@5| |j#0_0@1|)) (<= (U_2_int ($Unbox intType (MapType1Select $Heap@1 |A#0@@2| (IndexField |g#0_3@@5|)))) |$rhs#0_0@1|)) :qid |Classics.64:35| :skolemid |383|)))) (=> |$w$loop#0_0@1@@0| (forall ((|p#0_1@@4| Int)) (! (=> true (and (=> (<= (LitInt 0) |p#0_1@@4|) true) (=> (and (<= (LitInt 0) |p#0_1@@4|) (< |p#0_1@@4| |i#0_0@1|)) true))) :qid |Classics.65:24| :skolemid |386|)))) (and (=> |$w$loop#0_0@1@@0| (forall ((|p#0_1@@5| Int)) (! (=> true (=> (and (<= (LitInt 0) |p#0_1@@5|) (< |p#0_1@@5| |i#0_0@1|)) (<= (U_2_int ($Unbox intType (MapType1Select $Heap@1 |A#0@@2| (IndexField |p#0_1@@5|)))) |$rhs#0_0@1|))) :qid |Classics.65:24| :skolemid |388|))) (=> |$w$loop#0_0@1@@0| (forall ((|q#0_1@@4| Int)) (! (=> true (and (=> (< |j#0_0@1| |q#0_1@@4|) true) (=> (and (< |j#0_0@1| |q#0_1@@4|) (< |q#0_1@@4| |N#0@@0|)) true))) :qid |Classics.66:24| :skolemid |391|))))) (and (and (=> |$w$loop#0_0@1@@0| (forall ((|q#0_1@@5| Int)) (! (=> true (=> (and (< |j#0_0@1| |q#0_1@@5|) (< |q#0_1@@5| |N#0@@0|)) (<= |$rhs#0_0@1| (U_2_int ($Unbox intType (MapType1Select $Heap@1 |A#0@@2| (IndexField |q#0_1@@5|))))))) :qid |Classics.66:24| :skolemid |393|))) (=> |$w$loop#0_0@1@@0| (forall ((|p#0_3@@4| Int) (|q#0_3@@4| Int)) (! (=> true (and (and (and (=> (<= (LitInt 0) |p#0_3@@4|) true) (=> (and (<= (LitInt 0) |p#0_3@@4|) (< |p#0_3@@4| |m#0@0|)) true)) (=> (and (and (<= (LitInt 0) |p#0_3@@4|) (< |p#0_3@@4| |m#0@0|)) (<= |m#0@0| |q#0_3@@4|)) true)) (=> (and (and (and (<= (LitInt 0) |p#0_3@@4|) (< |p#0_3@@4| |m#0@0|)) (<= |m#0@0| |q#0_3@@4|)) (< |q#0_3@@4| |N#0@@0|)) true))) :qid |Classics.68:24| :skolemid |396|)))) (and (=> |$w$loop#0_0@1@@0| (forall ((|p#0_3@@5| Int) (|q#0_3@@5| Int)) (! (=> true (=> (and (and (and (<= (LitInt 0) |p#0_3@@5|) (< |p#0_3@@5| |m#0@0|)) (<= |m#0@0| |q#0_3@@5|)) (< |q#0_3@@5| |N#0@@0|)) (<= (U_2_int ($Unbox intType (MapType1Select $Heap@1 |A#0@@2| (IndexField |p#0_3@@5|)))) (U_2_int ($Unbox intType (MapType1Select $Heap@1 |A#0@@2| (IndexField |q#0_3@@5|))))))) :qid |Classics.68:24| :skolemid |398|))) (=> |$w$loop#0_0@1@@0| (forall ((|p#0_5@@4| Int) (|q#0_5@@4| Int)) (! (=> true (and (and (and (=> (<= (LitInt 0) |p#0_5@@4|) true) (=> (and (<= (LitInt 0) |p#0_5@@4|) (<= |p#0_5@@4| |n#0@0|)) true)) (=> (and (and (<= (LitInt 0) |p#0_5@@4|) (<= |p#0_5@@4| |n#0@0|)) (< |n#0@0| |q#0_5@@4|)) true)) (=> (and (and (and (<= (LitInt 0) |p#0_5@@4|) (<= |p#0_5@@4| |n#0@0|)) (< |n#0@0| |q#0_5@@4|)) (< |q#0_5@@4| |N#0@@0|)) true))) :qid |Classics.69:24| :skolemid |401|)))))) (and (and (and (=> |$w$loop#0_0@1@@0| (forall ((|p#0_5@@5| Int) (|q#0_5@@5| Int)) (! (=> true (=> (and (and (and (<= (LitInt 0) |p#0_5@@5|) (<= |p#0_5@@5| |n#0@0|)) (< |n#0@0| |q#0_5@@5|)) (< |q#0_5@@5| |N#0@@0|)) (<= (U_2_int ($Unbox intType (MapType1Select $Heap@1 |A#0@@2| (IndexField |p#0_5@@5|)))) (U_2_int ($Unbox intType (MapType1Select $Heap@1 |A#0@@2| (IndexField |q#0_5@@5|))))))) :qid |Classics.69:24| :skolemid |403|))) (=> |$w$loop#0_0@1@@0| (and (and (=> (= |i#0_0@1| |m#0@0|) true) (=> (and (= |i#0_0@1| |m#0@0|) (= |j#0_0@1| |n#0@0|)) true)) (=> (not (and (and (= |i#0_0@1| |m#0@0|) (= |j#0_0@1| |n#0@0|)) (= |$rhs#0_0@1| (U_2_int ($Unbox intType (MapType1Select $Heap@1 |A#0@@2| (IndexField |f#0@@0|))))))) (=> (< |m#0@0| |i#0_0@1|) true))))) (and (=> |$w$loop#0_0@1@@0| (or (and (and (= |i#0_0@1| |m#0@0|) (= |j#0_0@1| |n#0@0|)) (= |$rhs#0_0@1| (U_2_int ($Unbox intType (MapType1Select $Heap@1 |A#0@@2| (IndexField |f#0@@0|)))))) (and (< |m#0@0| |i#0_0@1|) (< |j#0_0@1| |n#0@0|)))) (forall (($o@@26 T@U) ($f@@18 T@U)) (! (let ((alpha@@25 (FieldTypeInv0 (type $f@@18)))) (=> (and (and (= (type $o@@26) refType) (= (type $f@@18) (FieldType alpha@@25))) (and (not (= $o@@26 null)) (U_2_bool (MapType1Select $Heap@@12 $o@@26 alloc)))) (or (= (MapType1Select $Heap@1 $o@@26 $f@@18) (MapType1Select $Heap@0@@1 $o@@26 $f@@18)) (= $o@@26 |A#0@@2|)))) :qid |Classics.60:5| :skolemid |404| :pattern ((MapType1Select $Heap@1 $o@@26 $f@@18)))))) (and (and ($HeapSucc $Heap@0@@1 $Heap@1) (forall (($o@@27 T@U) ($f@@19 T@U)) (! (let ((alpha@@26 (FieldTypeInv0 (type $f@@19)))) (=> (and (and (= (type $o@@27) refType) (= (type $f@@19) (FieldType alpha@@26))) (and (not (= $o@@27 null)) (U_2_bool (MapType1Select $Heap@0@@1 $o@@27 alloc)))) (or (= (MapType1Select $Heap@1 $o@@27 $f@@19) (MapType1Select $Heap@0@@1 $o@@27 $f@@19)) (U_2_bool (MapType3Select $_Frame@0@@4 $o@@27 $f@@19))))) :qid |Classics.60:5| :skolemid |405| :pattern ((MapType1Select $Heap@1 $o@@27 $f@@19))))) (and (<= (- |j#0_0@1| |i#0_0@1|) |$decr_init$loop#0_00@1@@0|) (=> (= (- |j#0_0@1| |i#0_0@1|) |$decr_init$loop#0_00@1@@0|) true)))))) (and anon155_LoopDone_correct anon155_LoopBody_correct)))))) (let ((anon154_Else_correct (=> (! (and %lbl%+20575 true) :lblpos +20575) (=> (and (< |m#0@0| |n#0@0|) (= |$decr$loop#00@1@@0| (- |n#0@0| |m#0@0|))) (and (! (or %lbl%@42105 (not (= |A#0@@2| null))) :lblneg @42105) (=> (not (= |A#0@@2| null)) (and (! (or %lbl%@42111 (and (<= 0 |f#0@@0|) (< |f#0@@0| (_System.array.Length |A#0@@2|)))) :lblneg @42111) (=> (and (<= 0 |f#0@@0|) (< |f#0@@0| (_System.array.Length |A#0@@2|))) (=> (and (= |$rhs#0_0@1| (U_2_int ($Unbox intType (MapType1Select $Heap@0@@1 |A#0@@2| (IndexField |f#0@@0|))))) (= |$decr_init$loop#0_00@1@@0| (- |n#0@0| |m#0@0|))) (and (! (or %lbl%@42185 (=> |$w$loop#0_0@1@@0| (<= |m#0@0| |m#0@0|))) :lblneg @42185) (=> (=> |$w$loop#0_0@1@@0| (<= |m#0@0| |m#0@0|)) (and (! (or %lbl%@42192 (=> |$w$loop#0_0@1@@0| (<= |n#0@0| |n#0@0|))) :lblneg @42192) (=> (=> |$w$loop#0_0@1@@0| (<= |n#0@0| |n#0@0|)) (and (! (or %lbl%@42199 (=> |$w$loop#0_0@1@@0| (<= (LitInt (- 0 1)) |n#0@0|))) :lblneg @42199) (=> (=> |$w$loop#0_0@1@@0| (<= (LitInt (- 0 1)) |n#0@0|)) (and (! (or %lbl%@42213 (=> |$w$loop#0_0@1@@0| (<= |m#0@0| |N#0@@0|))) :lblneg @42213) (=> (=> |$w$loop#0_0@1@@0| (<= |m#0@0| |N#0@@0|)) (and (! (or %lbl%@42221 (=> |$w$loop#0_0@1@@0| (=> (<= |m#0@0| |n#0@0|) (exists ((|g#0_1@@6| Int)) (! (and (and (<= |m#0@0| |g#0_1@@6|) (< |g#0_1@@6| |N#0@@0|)) (<= |$rhs#0_0@1| (U_2_int ($Unbox intType (MapType1Select $Heap@0@@1 |A#0@@2| (IndexField |g#0_1@@6|)))))) :qid |Classics.63:35| :skolemid |379|))))) :lblneg @42221) (=> (=> |$w$loop#0_0@1@@0| (=> (<= |m#0@0| |n#0@0|) (exists ((|g#0_1@@7| Int)) (! (and (and (<= |m#0@0| |g#0_1@@7|) (< |g#0_1@@7| |N#0@@0|)) (<= |$rhs#0_0@1| (U_2_int ($Unbox intType (MapType1Select $Heap@0@@1 |A#0@@2| (IndexField |g#0_1@@7|)))))) :qid |Classics.63:35| :skolemid |379|)))) (and (! (or %lbl%@42264 (=> |$w$loop#0_0@1@@0| (=> (<= |m#0@0| |n#0@0|) (exists ((|g#0_3@@6| Int)) (! (and (and (<= (LitInt 0) |g#0_3@@6|) (<= |g#0_3@@6| |n#0@0|)) (<= (U_2_int ($Unbox intType (MapType1Select $Heap@0@@1 |A#0@@2| (IndexField |g#0_3@@6|)))) |$rhs#0_0@1|)) :qid |Classics.64:35| :skolemid |383|))))) :lblneg @42264) (=> (=> |$w$loop#0_0@1@@0| (=> (<= |m#0@0| |n#0@0|) (exists ((|g#0_3@@7| Int)) (! (and (and (<= (LitInt 0) |g#0_3@@7|) (<= |g#0_3@@7| |n#0@0|)) (<= (U_2_int ($Unbox intType (MapType1Select $Heap@0@@1 |A#0@@2| (IndexField |g#0_3@@7|)))) |$rhs#0_0@1|)) :qid |Classics.64:35| :skolemid |383|)))) (and (! (or %lbl%@42309 (=> |$w$loop#0_0@1@@0| (forall ((|p#0_1@@6| Int)) (! (=> true (=> (and (<= (LitInt 0) |p#0_1@@6|) (< |p#0_1@@6| |m#0@0|)) (<= (U_2_int ($Unbox intType (MapType1Select $Heap@0@@1 |A#0@@2| (IndexField |p#0_1@@6|)))) |$rhs#0_0@1|))) :qid |Classics.65:24| :skolemid |388|)))) :lblneg @42309) (=> (=> |$w$loop#0_0@1@@0| (forall ((|p#0_1@@7| Int)) (! (=> true (=> (and (<= (LitInt 0) |p#0_1@@7|) (< |p#0_1@@7| |m#0@0|)) (<= (U_2_int ($Unbox intType (MapType1Select $Heap@0@@1 |A#0@@2| (IndexField |p#0_1@@7|)))) |$rhs#0_0@1|))) :qid |Classics.65:24| :skolemid |388|))) (and (! (or %lbl%@42352 (=> |$w$loop#0_0@1@@0| (forall ((|q#0_1@@6| Int)) (! (=> true (=> (and (< |n#0@0| |q#0_1@@6|) (< |q#0_1@@6| |N#0@@0|)) (<= |$rhs#0_0@1| (U_2_int ($Unbox intType (MapType1Select $Heap@0@@1 |A#0@@2| (IndexField |q#0_1@@6|))))))) :qid |Classics.66:24| :skolemid |393|)))) :lblneg @42352) (=> (=> |$w$loop#0_0@1@@0| (forall ((|q#0_1@@7| Int)) (! (=> true (=> (and (< |n#0@0| |q#0_1@@7|) (< |q#0_1@@7| |N#0@@0|)) (<= |$rhs#0_0@1| (U_2_int ($Unbox intType (MapType1Select $Heap@0@@1 |A#0@@2| (IndexField |q#0_1@@7|))))))) :qid |Classics.66:24| :skolemid |393|))) (and (! (or %lbl%@42393 (=> |$w$loop#0_0@1@@0| (forall ((|p#0_3@@6| Int) (|q#0_3@@6| Int)) (! (=> true (=> (and (and (and (<= (LitInt 0) |p#0_3@@6|) (< |p#0_3@@6| |m#0@0|)) (<= |m#0@0| |q#0_3@@6|)) (< |q#0_3@@6| |N#0@@0|)) (<= (U_2_int ($Unbox intType (MapType1Select $Heap@0@@1 |A#0@@2| (IndexField |p#0_3@@6|)))) (U_2_int ($Unbox intType (MapType1Select $Heap@0@@1 |A#0@@2| (IndexField |q#0_3@@6|))))))) :qid |Classics.68:24| :skolemid |398|)))) :lblneg @42393) (=> (=> |$w$loop#0_0@1@@0| (forall ((|p#0_3@@7| Int) (|q#0_3@@7| Int)) (! (=> true (=> (and (and (and (<= (LitInt 0) |p#0_3@@7|) (< |p#0_3@@7| |m#0@0|)) (<= |m#0@0| |q#0_3@@7|)) (< |q#0_3@@7| |N#0@@0|)) (<= (U_2_int ($Unbox intType (MapType1Select $Heap@0@@1 |A#0@@2| (IndexField |p#0_3@@7|)))) (U_2_int ($Unbox intType (MapType1Select $Heap@0@@1 |A#0@@2| (IndexField |q#0_3@@7|))))))) :qid |Classics.68:24| :skolemid |398|))) (and (! (or %lbl%@42463 (=> |$w$loop#0_0@1@@0| (forall ((|p#0_5@@6| Int) (|q#0_5@@6| Int)) (! (=> true (=> (and (and (and (<= (LitInt 0) |p#0_5@@6|) (<= |p#0_5@@6| |n#0@0|)) (< |n#0@0| |q#0_5@@6|)) (< |q#0_5@@6| |N#0@@0|)) (<= (U_2_int ($Unbox intType (MapType1Select $Heap@0@@1 |A#0@@2| (IndexField |p#0_5@@6|)))) (U_2_int ($Unbox intType (MapType1Select $Heap@0@@1 |A#0@@2| (IndexField |q#0_5@@6|))))))) :qid |Classics.69:24| :skolemid |403|)))) :lblneg @42463) (=> (=> |$w$loop#0_0@1@@0| (forall ((|p#0_5@@7| Int) (|q#0_5@@7| Int)) (! (=> true (=> (and (and (and (<= (LitInt 0) |p#0_5@@7|) (<= |p#0_5@@7| |n#0@0|)) (< |n#0@0| |q#0_5@@7|)) (< |q#0_5@@7| |N#0@@0|)) (<= (U_2_int ($Unbox intType (MapType1Select $Heap@0@@1 |A#0@@2| (IndexField |p#0_5@@7|)))) (U_2_int ($Unbox intType (MapType1Select $Heap@0@@1 |A#0@@2| (IndexField |q#0_5@@7|))))))) :qid |Classics.69:24| :skolemid |403|))) (and (! (or %lbl%@42533 (=> |$w$loop#0_0@1@@0| (or (and (and (= |m#0@0| |m#0@0|) (= |n#0@0| |n#0@0|)) (= |$rhs#0_0@1| (U_2_int ($Unbox intType (MapType1Select $Heap@0@@1 |A#0@@2| (IndexField |f#0@@0|)))))) (and (< |m#0@0| |m#0@0|) (< |n#0@0| |n#0@0|))))) :lblneg @42533) (=> (=> |$w$loop#0_0@1@@0| (or (and (and (= |m#0@0| |m#0@0|) (= |n#0@0| |n#0@0|)) (= |$rhs#0_0@1| (U_2_int ($Unbox intType (MapType1Select $Heap@0@@1 |A#0@@2| (IndexField |f#0@@0|)))))) (and (< |m#0@0| |m#0@0|) (< |n#0@0| |n#0@0|)))) anon155_LoopHead_correct))))))))))))))))))))))))))))))) (let ((anon142_Else_correct (=> (! (and %lbl%+20564 true) :lblpos +20564) (=> |$w$loop#0@0@@0| (and anon154_Then_correct anon154_Else_correct))))) (let ((anon141_LoopBody_correct (=> (! (and %lbl%+20439 true) :lblpos +20439) (and anon142_Then_correct anon142_Else_correct)))) (let ((anon141_LoopDone_correct (=> (! (and %lbl%+21196 true) :lblpos +21196) true))) (let ((anon141_LoopHead_correct (=> (! (and %lbl%+20433 true) :lblpos +20433) (=> (and ($IsGoodHeap $Heap@0@@1) ($IsHeapAnchor $Heap@0@@1)) (=> (and (and (and (and (and (and (and (and (not false) (<= 0 |m#0@0|)) (<= 0 |n#0@0|)) (= |$rhs#0@0| 0)) (<= 0 |$rhs#1@0|)) (<= 0 |$decr_init$loop#00@0@@0|)) (and (=> |$w$loop#0@0@@0| (and (and (=> (<= (LitInt 0) |m#0@0|) true) (=> (and (<= (LitInt 0) |m#0@0|) (<= |m#0@0| |f#0@@0|)) true)) (=> (and (and (<= (LitInt 0) |m#0@0|) (<= |m#0@0| |f#0@@0|)) (<= |f#0@@0| |n#0@0|)) true))) (=> |$w$loop#0@0@@0| (<= (LitInt 0) |m#0@0|)))) (and (and (=> |$w$loop#0@0@@0| (<= |m#0@0| |f#0@@0|)) (=> |$w$loop#0@0@@0| (<= |f#0@@0| |n#0@0|))) (and (=> |$w$loop#0@0@@0| (< |n#0@0| |N#0@@0|)) (=> |$w$loop#0@0@@0| (forall ((|p#3@@4| Int) (|q#3@@4| Int)) (! (=> true (and (and (and (=> (<= (LitInt 0) |p#3@@4|) true) (=> (and (<= (LitInt 0) |p#3@@4|) (< |p#3@@4| |m#0@0|)) true)) (=> (and (and (<= (LitInt 0) |p#3@@4|) (< |p#3@@4| |m#0@0|)) (<= |m#0@0| |q#3@@4|)) true)) (=> (and (and (and (<= (LitInt 0) |p#3@@4|) (< |p#3@@4| |m#0@0|)) (<= |m#0@0| |q#3@@4|)) (< |q#3@@4| |N#0@@0|)) true))) :qid |Classics.56:22| :skolemid |366|)))))) (and (and (and (=> |$w$loop#0@0@@0| (forall ((|p#3@@5| Int) (|q#3@@5| Int)) (! (=> true (=> (and (and (and (<= (LitInt 0) |p#3@@5|) (< |p#3@@5| |m#0@0|)) (<= |m#0@0| |q#3@@5|)) (< |q#3@@5| |N#0@@0|)) (<= (U_2_int ($Unbox intType (MapType1Select $Heap@0@@1 |A#0@@2| (IndexField |p#3@@5|)))) (U_2_int ($Unbox intType (MapType1Select $Heap@0@@1 |A#0@@2| (IndexField |q#3@@5|))))))) :qid |Classics.56:22| :skolemid |368|))) (=> |$w$loop#0@0@@0| (forall ((|p#5@@1| Int) (|q#5@@1| Int)) (! (=> true (and (and (and (=> (<= (LitInt 0) |p#5@@1|) true) (=> (and (<= (LitInt 0) |p#5@@1|) (<= |p#5@@1| |n#0@0|)) true)) (=> (and (and (<= (LitInt 0) |p#5@@1|) (<= |p#5@@1| |n#0@0|)) (< |n#0@0| |q#5@@1|)) true)) (=> (and (and (and (<= (LitInt 0) |p#5@@1|) (<= |p#5@@1| |n#0@0|)) (< |n#0@0| |q#5@@1|)) (< |q#5@@1| |N#0@@0|)) true))) :qid |Classics.57:22| :skolemid |371|)))) (and (=> |$w$loop#0@0@@0| (forall ((|p#5@@2| Int) (|q#5@@2| Int)) (! (=> true (=> (and (and (and (<= (LitInt 0) |p#5@@2|) (<= |p#5@@2| |n#0@0|)) (< |n#0@0| |q#5@@2|)) (< |q#5@@2| |N#0@@0|)) (<= (U_2_int ($Unbox intType (MapType1Select $Heap@0@@1 |A#0@@2| (IndexField |p#5@@2|)))) (U_2_int ($Unbox intType (MapType1Select $Heap@0@@1 |A#0@@2| (IndexField |q#5@@2|))))))) :qid |Classics.57:22| :skolemid |373|))) (forall (($o@@28 T@U) ($f@@20 T@U)) (! (let ((alpha@@27 (FieldTypeInv0 (type $f@@20)))) (=> (and (and (= (type $o@@28) refType) (= (type $f@@20) (FieldType alpha@@27))) (and (not (= $o@@28 null)) (U_2_bool (MapType1Select $Heap@@12 $o@@28 alloc)))) (or (= (MapType1Select $Heap@0@@1 $o@@28 $f@@20) (MapType1Select $Heap@@12 $o@@28 $f@@20)) (= $o@@28 |A#0@@2|)))) :qid |Classics.54:3| :skolemid |374| :pattern ((MapType1Select $Heap@0@@1 $o@@28 $f@@20)))))) (and (and ($HeapSucc $Heap@@12 $Heap@0@@1) (forall (($o@@29 T@U) ($f@@21 T@U)) (! (let ((alpha@@28 (FieldTypeInv0 (type $f@@21)))) (=> (and (and (= (type $o@@29) refType) (= (type $f@@21) (FieldType alpha@@28))) (and (not (= $o@@29 null)) (U_2_bool (MapType1Select $Heap@@12 $o@@29 alloc)))) (or (= (MapType1Select $Heap@0@@1 $o@@29 $f@@21) (MapType1Select $Heap@@12 $o@@29 $f@@21)) (U_2_bool (MapType3Select $_Frame@0@@4 $o@@29 $f@@21))))) :qid |Classics.54:3| :skolemid |375| :pattern ((MapType1Select $Heap@0@@1 $o@@29 $f@@21))))) (and (<= (- |n#0@0| |m#0@0|) |$decr_init$loop#00@0@@0|) (=> (= (- |n#0@0| |m#0@0|) |$decr_init$loop#00@0@@0|) true))))) (and anon141_LoopDone_correct anon141_LoopBody_correct)))))) (let ((anon0_correct@@3 (=> (! (and %lbl%+20431 true) :lblpos +20431) (=> (and (and (= $_Frame@0@@4 (|lambda#5| |A#0@@2| null $Heap@@12 alloc)) (= |$rhs#0@0| (LitInt 0))) (and (= |$rhs#1@0| (- |N#0@@0| 1)) (= |$decr_init$loop#00@0@@0| (- |$rhs#1@0| |$rhs#0@0|)))) (and (! (or %lbl%@41183 (=> |$w$loop#0@0@@0| (<= (LitInt 0) |$rhs#0@0|))) :lblneg @41183) (=> (=> |$w$loop#0@0@@0| (<= (LitInt 0) |$rhs#0@0|)) (and (! (or %lbl%@41193 (=> |$w$loop#0@0@@0| (<= |$rhs#0@0| |f#0@@0|))) :lblneg @41193) (=> (=> |$w$loop#0@0@@0| (<= |$rhs#0@0| |f#0@@0|)) (and (! (or %lbl%@41201 (=> |$w$loop#0@0@@0| (<= |f#0@@0| |$rhs#1@0|))) :lblneg @41201) (=> (=> |$w$loop#0@0@@0| (<= |f#0@@0| |$rhs#1@0|)) (and (! (or %lbl%@41209 (=> |$w$loop#0@0@@0| (< |$rhs#1@0| |N#0@@0|))) :lblneg @41209) (=> (=> |$w$loop#0@0@@0| (< |$rhs#1@0| |N#0@@0|)) (and (! (or %lbl%@41217 (=> |$w$loop#0@0@@0| (forall ((|p#3@@6| Int) (|q#3@@6| Int)) (! (=> true (=> (and (and (and (<= (LitInt 0) |p#3@@6|) (< |p#3@@6| |$rhs#0@0|)) (<= |$rhs#0@0| |q#3@@6|)) (< |q#3@@6| |N#0@@0|)) (<= (U_2_int ($Unbox intType (MapType1Select $Heap@@12 |A#0@@2| (IndexField |p#3@@6|)))) (U_2_int ($Unbox intType (MapType1Select $Heap@@12 |A#0@@2| (IndexField |q#3@@6|))))))) :qid |Classics.56:22| :skolemid |368|)))) :lblneg @41217) (=> (=> |$w$loop#0@0@@0| (forall ((|p#3@@7| Int) (|q#3@@7| Int)) (! (=> true (=> (and (and (and (<= (LitInt 0) |p#3@@7|) (< |p#3@@7| |$rhs#0@0|)) (<= |$rhs#0@0| |q#3@@7|)) (< |q#3@@7| |N#0@@0|)) (<= (U_2_int ($Unbox intType (MapType1Select $Heap@@12 |A#0@@2| (IndexField |p#3@@7|)))) (U_2_int ($Unbox intType (MapType1Select $Heap@@12 |A#0@@2| (IndexField |q#3@@7|))))))) :qid |Classics.56:22| :skolemid |368|))) (and (! (or %lbl%@41289 (=> |$w$loop#0@0@@0| (forall ((|p#5@@3| Int) (|q#5@@3| Int)) (! (=> true (=> (and (and (and (<= (LitInt 0) |p#5@@3|) (<= |p#5@@3| |$rhs#1@0|)) (< |$rhs#1@0| |q#5@@3|)) (< |q#5@@3| |N#0@@0|)) (<= (U_2_int ($Unbox intType (MapType1Select $Heap@@12 |A#0@@2| (IndexField |p#5@@3|)))) (U_2_int ($Unbox intType (MapType1Select $Heap@@12 |A#0@@2| (IndexField |q#5@@3|))))))) :qid |Classics.57:22| :skolemid |373|)))) :lblneg @41289) (=> (=> |$w$loop#0@0@@0| (forall ((|p#5@@4| Int) (|q#5@@4| Int)) (! (=> true (=> (and (and (and (<= (LitInt 0) |p#5@@4|) (<= |p#5@@4| |$rhs#1@0|)) (< |$rhs#1@0| |q#5@@4|)) (< |q#5@@4| |N#0@@0|)) (<= (U_2_int ($Unbox intType (MapType1Select $Heap@@12 |A#0@@2| (IndexField |p#5@@4|)))) (U_2_int ($Unbox intType (MapType1Select $Heap@@12 |A#0@@2| (IndexField |q#5@@4|))))))) :qid |Classics.57:22| :skolemid |373|))) anon141_LoopHead_correct)))))))))))))))) (let ((PreconditionGeneratedEntry_correct@@3 (=> (! (and %lbl%+40854 true) :lblpos +40854) (=> (and ($IsGoodHeap $Heap@@12) ($IsHeapAnchor $Heap@@12)) (=> (and (and (and ($Is |A#0@@2| (Tclass._System.array TInt)) ($IsAlloc |A#0@@2| (Tclass._System.array TInt) $Heap@@12)) (and (= 0 $ModuleContextHeight) (= 2 $FunctionContextHeight))) (and (and (not (= |A#0@@2| null)) (= (_System.array.Length |A#0@@2|) |N#0@@0|)) (and (<= (LitInt 0) |f#0@@0|) (< |f#0@@0| |N#0@@0|)))) anon0_correct@@3))))) PreconditionGeneratedEntry_correct@@3)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(check-sat)
(pop 1)
