(set-option :global-decls false)
(set-option :smt.mbqi false)
(set-option :produce-unsat-cores true)
(declare-sort Ref 0)
(declare-fun Ref_constr_id (Ref) Int)
(declare-sort String 0)
(declare-fun String_constr_id (String) Int)
(declare-sort Term 0)
(declare-fun Term_constr_id (Term) Int)
(declare-datatypes () ((Fuel (ZFuel) (SFuel (prec Fuel)))))
(declare-fun MaxIFuel () Fuel)
(declare-fun MaxFuel () Fuel)
(declare-fun PreType (Term) Term)
(declare-fun Valid (Term) Bool)
(declare-fun HasTypeFuel (Fuel Term Term) Bool)
(define-fun HasTypeZ ((x Term) (t Term)) Bool (HasTypeFuel ZFuel x t))
(define-fun HasType ((x Term) (t Term)) Bool (HasTypeFuel MaxIFuel x t))
(assert (forall ((f Fuel) (x Term) (t Term)) (! (= (HasTypeFuel (SFuel f) x t) (HasTypeZ x t)) :pattern ((HasTypeFuel (SFuel f) x t)))))
(define-fun IsTyped ((x Term)) Bool (exists ((t Term)) (HasTypeZ x t)))
(declare-fun ApplyTF (Term Fuel) Term)
(declare-fun ApplyTT (Term Term) Term)
(declare-fun Rank (Term) Int)
(declare-fun Closure (Term) Term)
(declare-fun ConsTerm (Term Term) Term)
(declare-fun ConsFuel (Fuel Term) Term)
(declare-fun Precedes (Term Term) Term)
(define-fun Reify ((x Term)) Term x)
(assert (forall ((t Term)) (! (implies (exists ((e Term)) (HasType e t)) (Valid t)) :pattern ((Valid t)))))
(assert (forall ((t1 Term) (t2 Term)) (! (iff (Valid (Precedes t1 t2)) (< (Rank t1) (Rank t2))) :pattern ((Precedes t1 t2)))))
(define-fun Prims.precedes ((a Term) (b Term) (t1 Term) (t2 Term)) Term (Precedes t1 t2))
(declare-fun Range_const () Term)
(declare-fun String_const (Int) String)
(assert (! (forall ((@u0 Int)) (! (= 0 (String_constr_id (String_const @u0))) :pattern ((String_const @u0)))) :named constructor_distinct_String_const))
(declare-fun String_const_proj_0 (String) Int)
(assert (! (forall ((@u0 Int)) (! (= (String_const_proj_0 (String_const @u0)) @u0) :pattern ((String_const @u0)))) :named projection_inverse_String_const_proj_0))
(define-fun is-String_const ((@u0 String)) Bool (and (= (String_constr_id @u0) 0) (= @u0 (String_const (String_const_proj_0 @u0)))))
(declare-fun Tm_type () Term)
(assert (! (= 2 (Term_constr_id Tm_type)) :named constructor_distinct_Tm_type))
(define-fun is-Tm_type ((@x0 Term)) Bool (and (= (Term_constr_id @x0) 2) (= @x0 Tm_type)))
(declare-fun Tm_arrow (Int) Term)
(assert (! (forall ((@u0 Int)) (! (= 3 (Term_constr_id (Tm_arrow @u0))) :pattern ((Tm_arrow @u0)))) :named constructor_distinct_Tm_arrow))
(declare-fun Tm_arrow_id (Term) Int)
(assert (! (forall ((@u0 Int)) (! (= (Tm_arrow_id (Tm_arrow @u0)) @u0) :pattern ((Tm_arrow @u0)))) :named projection_inverse_Tm_arrow_id))
(define-fun is-Tm_arrow ((@x0 Term)) Bool (and (= (Term_constr_id @x0) 3) (= @x0 (Tm_arrow (Tm_arrow_id @x0)))))
(declare-fun Tm_uvar (Int) Term)
(assert (! (forall ((@u0 Int)) (! (= 5 (Term_constr_id (Tm_uvar @u0))) :pattern ((Tm_uvar @u0)))) :named constructor_distinct_Tm_uvar))
(declare-fun Tm_uvar_fst (Term) Int)
(assert (! (forall ((@u0 Int)) (! (= (Tm_uvar_fst (Tm_uvar @u0)) @u0) :pattern ((Tm_uvar @u0)))) :named projection_inverse_Tm_uvar_fst))
(define-fun is-Tm_uvar ((@x0 Term)) Bool (and (= (Term_constr_id @x0) 5) (= @x0 (Tm_uvar (Tm_uvar_fst @x0)))))
(declare-fun Tm_unit () Term)
(assert (! (= 6 (Term_constr_id Tm_unit)) :named constructor_distinct_Tm_unit))
(define-fun is-Tm_unit ((@x0 Term)) Bool (and (= (Term_constr_id @x0) 6) (= @x0 Tm_unit)))
(declare-fun BoxInt (Int) Term)
(assert (! (forall ((@u0 Int)) (! (= 7 (Term_constr_id (BoxInt @u0))) :pattern ((BoxInt @u0)))) :named constructor_distinct_BoxInt))
(declare-fun BoxInt_proj_0 (Term) Int)
(assert (! (forall ((@u0 Int)) (! (= (BoxInt_proj_0 (BoxInt @u0)) @u0) :pattern ((BoxInt @u0)))) :named projection_inverse_BoxInt_proj_0))
(define-fun is-BoxInt ((@x0 Term)) Bool (and (= (Term_constr_id @x0) 7) (= @x0 (BoxInt (BoxInt_proj_0 @x0)))))
(declare-fun BoxBool (Bool) Term)
(assert (! (forall ((@u0 Bool)) (! (= 8 (Term_constr_id (BoxBool @u0))) :pattern ((BoxBool @u0)))) :named constructor_distinct_BoxBool))
(declare-fun BoxBool_proj_0 (Term) Bool)
(assert (! (forall ((@u0 Bool)) (! (= (BoxBool_proj_0 (BoxBool @u0)) @u0) :pattern ((BoxBool @u0)))) :named projection_inverse_BoxBool_proj_0))
(define-fun is-BoxBool ((@x0 Term)) Bool (and (= (Term_constr_id @x0) 8) (= @x0 (BoxBool (BoxBool_proj_0 @x0)))))
(declare-fun BoxString (String) Term)
(assert (! (forall ((@u0 String)) (! (= 9 (Term_constr_id (BoxString @u0))) :pattern ((BoxString @u0)))) :named constructor_distinct_BoxString))
(declare-fun BoxString_proj_0 (Term) String)
(assert (! (forall ((@u0 String)) (! (= (BoxString_proj_0 (BoxString @u0)) @u0) :pattern ((BoxString @u0)))) :named projection_inverse_BoxString_proj_0))
(define-fun is-BoxString ((@x0 Term)) Bool (and (= (Term_constr_id @x0) 9) (= @x0 (BoxString (BoxString_proj_0 @x0)))))
(declare-fun BoxRef (Ref) Term)
(assert (! (forall ((@u0 Ref)) (! (= 10 (Term_constr_id (BoxRef @u0))) :pattern ((BoxRef @u0)))) :named constructor_distinct_BoxRef))
(declare-fun BoxRef_proj_0 (Term) Ref)
(assert (! (forall ((@u0 Ref)) (! (= (BoxRef_proj_0 (BoxRef @u0)) @u0) :pattern ((BoxRef @u0)))) :named projection_inverse_BoxRef_proj_0))
(define-fun is-BoxRef ((@x0 Term)) Bool (and (= (Term_constr_id @x0) 10) (= @x0 (BoxRef (BoxRef_proj_0 @x0)))))
(declare-fun LexCons (Term Term) Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= 11 (Term_constr_id (LexCons @x0 @x1))) :pattern ((LexCons @x0 @x1)))) :named constructor_distinct_LexCons))
(declare-fun LexCons_0 (Term) Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (LexCons_0 (LexCons @x0 @x1)) @x0) :pattern ((LexCons @x0 @x1)))) :named projection_inverse_LexCons_0))
(declare-fun LexCons_1 (Term) Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (LexCons_1 (LexCons @x0 @x1)) @x1) :pattern ((LexCons @x0 @x1)))) :named projection_inverse_LexCons_1))
(define-fun is-LexCons ((@x0 Term)) Bool (and (= (Term_constr_id @x0) 11) (= @x0 (LexCons (LexCons_0 @x0) (LexCons_1 @x0)))))
(define-fun is-Prims.LexCons ((t Term)) Bool (is-LexCons t))
(assert (forall ((x1 Term) (x2 Term) (y1 Term) (y2 Term)) (iff (Valid (Precedes (LexCons x1 x2) (LexCons y1 y2))) (or (Valid (Precedes x1 y1)) (and (= x1 y1) (Valid (Precedes x2 y2)))))))
(declare-fun Prims.hasEq (Term) Term)
(declare-fun Tm_arrow_105 () Term)
(assert (! (HasType Tm_arrow_105 Tm_type) :named kinding_Tm_arrow_105))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_105) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_105)))) :named pre_typing_Tm_arrow_105))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_105) (forall ((@x1 Term)) (! (implies (HasType @x1 Tm_type) (HasType (ApplyTT @x0 @x1) Tm_type)) :pattern ((ApplyTT @x0 @x1))))) :pattern ((HasTypeZ @x0 Tm_arrow_105)))) :named interpretation_Tm_arrow_105))
(declare-fun Prims.hasEq@tok () Term)
(assert (! (= 107 (Term_constr_id Prims.hasEq@tok)) :named fresh_token_Prims.hasEq@tok))
(assert (! (forall ((@x0 Term)) (! (= (ApplyTT Prims.hasEq@tok @x0) (Prims.hasEq @x0)) :pattern ((ApplyTT Prims.hasEq@tok @x0)))) :named token_correspondence_Prims.hasEq))
(assert (! (HasType Prims.hasEq@tok Tm_arrow_105) :named function_token_typing_Prims.hasEq))
(assert (! (forall ((@x0 Term)) (! (= 108 (Term_constr_id (Prims.hasEq @x0))) :pattern ((Prims.hasEq @x0)))) :named constructor_distinct_Prims.hasEq))
(assert (! (forall ((@x0 Term) (@u1 Fuel) (@x2 Term)) (! (implies (HasTypeFuel @u1 @x0 (Prims.hasEq @x2)) (= (Prims.hasEq @x2) (PreType @x0))) :pattern ((HasTypeFuel @u1 @x0 (Prims.hasEq @x2))))) :named @pretyping__111))
(assert (! (forall ((@x0 Term)) (! (implies (HasType @x0 Tm_type) (HasType (Prims.hasEq @x0) Tm_type)) :pattern ((Prims.hasEq @x0)))) :named typing_Prims.hasEq))
(declare-fun Prims.eqtype () Term)
(assert (! (HasType Prims.eqtype Tm_type) :named function_token_typing_Prims.eqtype))
(assert (! (HasType Prims.eqtype Tm_type) :named typing_Prims.eqtype))
(declare-fun Tm_refine_113 () Term)
(assert (! (HasType Tm_refine_113 Tm_type) :named refinement_kinding_Tm_refine_113))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (iff (HasTypeFuel @u0 @x1 Tm_refine_113) (and (HasTypeFuel @u0 @x1 Tm_type) (Valid (Prims.hasEq @x1)))) :pattern ((HasTypeFuel @u0 @x1 Tm_refine_113)))) :named refinement_interpretation_Tm_refine_113))
(assert (! (iff (Valid (Prims.hasEq Tm_refine_113)) (Valid (Prims.hasEq Tm_type))) :named haseqTm_refine_113))
(assert (! (= Prims.eqtype Tm_refine_113) :named equation_Prims.eqtype))
(declare-fun Prims.c_False () Term)
(assert (! (= 114 (Term_constr_id Prims.c_False)) :named constructor_distinct_Prims.c_False))
(define-fun is-Prims.c_False ((@x0 Term)) Bool (and (= (Term_constr_id @x0) 114) (= @x0 Prims.c_False)))
(assert (! (HasType Prims.c_False Tm_type) :named kinding_Prims.c_False@tok))
(assert (! (forall ((@x0 Term) (@u1 Fuel)) (! (implies (HasTypeFuel @u1 @x0 Prims.c_False) (= Prims.c_False (PreType @x0))) :pattern ((HasTypeFuel @u1 @x0 Prims.c_False)))) :named @pretyping__120))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Prims.c_False) false) :pattern ((HasTypeFuel @u0 @x1 Prims.c_False)))) :named fuel_guarded_inversion_Prims.c_False_117))
(declare-fun Prims.c_True () Term)
(declare-fun Prims.T () Term)
(declare-fun Prims.T@tok () Term)
(assert (! (= 121 (Term_constr_id Prims.c_True)) :named constructor_distinct_Prims.c_True))
(define-fun is-Prims.c_True ((@x0 Term)) Bool (and (= (Term_constr_id @x0) 121) (= @x0 Prims.c_True)))
(assert (! (HasType Prims.c_True Tm_type) :named kinding_Prims.c_True@tok))
(assert (! (forall ((@x0 Term) (@u1 Fuel)) (! (implies (HasTypeFuel @u1 @x0 Prims.c_True) (= Prims.c_True (PreType @x0))) :pattern ((HasTypeFuel @u1 @x0 Prims.c_True)))) :named @pretyping__127))
(assert (! (= 129 (Term_constr_id Prims.T)) :named constructor_distinct_Prims.T))
(define-fun is-Prims.T ((@x0 Term)) Bool (and (= (Term_constr_id @x0) 129) (= @x0 Prims.T)))
(assert (! (HasType Prims.T@tok Prims.c_True) :named typing_tok_Prims.T@tok))
(assert (! (= Prims.T@tok Prims.T) :named equality_tok_Prims.T@tok))
(assert (! (forall ((@u0 Fuel)) (! (HasTypeFuel @u0 Prims.T Prims.c_True) :pattern ((HasTypeFuel @u0 Prims.T Prims.c_True)))) :named data_typing_intro_Prims.T@tok))
(assert (! true :named data_elim_Prims.T))
(assert (! true :named subterm_ordering_Prims.T))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Prims.c_True) (is-Prims.T @x1)) :pattern ((HasTypeFuel @u0 @x1 Prims.c_True)))) :named fuel_guarded_inversion_Prims.c_True_124))
(declare-fun Prims.l_True () Term)
(assert (! (HasType Prims.l_True Tm_type) :named function_token_typing_Prims.l_True))
(assert (! (HasType Prims.l_True Tm_type) :named typing_Prims.l_True))
(assert (! (= Prims.l_True Prims.c_True) :named equation_Prims.l_True))
(declare-fun Prims.l_False () Term)
(assert (! (HasType Prims.l_False Tm_type) :named function_token_typing_Prims.l_False))
(assert (! (HasType Prims.l_False Tm_type) :named typing_Prims.l_False))
(assert (! (= Prims.l_False Prims.c_False) :named equation_Prims.l_False))
(assert (! (iff false (Valid Prims.l_False)) :named false_interp))
(declare-fun Prims.unit () Term)
(assert (! (HasType Prims.unit Tm_type) :named function_token_typing_Prims.unit))
(assert (! (= 130 (Term_constr_id Prims.unit)) :named constructor_distinct_Prims.unit))
(assert (! (forall ((@x0 Term) (@u1 Fuel)) (! (implies (HasTypeFuel @u1 @x0 Prims.unit) (= Prims.unit (PreType @x0))) :pattern ((HasTypeFuel @u1 @x0 Prims.unit)))) :named @pretyping__133))
(assert (! (HasType Prims.unit Tm_type) :named typing_Prims.unit))
(assert (! (HasType Tm_unit Prims.unit) :named unit_typing))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Prims.unit) (= @x1 Tm_unit)) :pattern ((HasTypeFuel @u0 @x1 Prims.unit)))) :named unit_inversion))
(assert (! (Valid (Prims.hasEq Prims.unit)) :named assumption_Prims.HasEq_unit_135))
(declare-fun Prims.squash (Term) Term)
(declare-fun Prims.squash@tok () Term)
(assert (! (= 137 (Term_constr_id Prims.squash@tok)) :named fresh_token_Prims.squash@tok))
(assert (! (forall ((@x0 Term)) (! (= (ApplyTT Prims.squash@tok @x0) (Prims.squash @x0)) :pattern ((ApplyTT Prims.squash@tok @x0)))) :named token_correspondence_Prims.squash))
(assert (! (HasType Prims.squash@tok Tm_arrow_105) :named function_token_typing_Prims.squash))
(assert (! (forall ((@x0 Term)) (! (implies (HasType @x0 Tm_type) (HasType (Prims.squash @x0) Tm_type)) :pattern ((Prims.squash @x0)))) :named typing_Prims.squash))
(declare-fun Tm_refine_139 (Term Term) Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (HasType (Tm_refine_139 @x0 @x1) Tm_type) :pattern ((HasType (Tm_refine_139 @x0 @x1) Tm_type)))) :named refinement_kinding_Tm_refine_139))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (iff (HasTypeFuel @u0 @x1 (Tm_refine_139 @x2 @x3)) (and (HasTypeFuel @u0 @x1 @x3) (Valid @x2))) :pattern ((HasTypeFuel @u0 @x1 (Tm_refine_139 @x2 @x3))))) :named refinement_interpretation_Tm_refine_139))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (Valid (Prims.hasEq (Tm_refine_139 @x0 @x1))) (Valid (Prims.hasEq @x1))) :pattern ((Valid (Prims.hasEq (Tm_refine_139 @x0 @x1)))))) :named haseqTm_refine_139))
(assert (! (forall ((@x0 Term)) (! (= (Prims.squash @x0) (Tm_refine_139 @x0 Prims.unit)) :pattern ((Prims.squash @x0)))) :named equation_Prims.squash))
(declare-fun Prims.inversion (Term) Term)
(declare-fun Prims.inversion@tok () Term)
(assert (! (= 141 (Term_constr_id Prims.inversion@tok)) :named fresh_token_Prims.inversion@tok))
(assert (! (forall ((@x0 Term)) (! (= (ApplyTT Prims.inversion@tok @x0) (Prims.inversion @x0)) :pattern ((ApplyTT Prims.inversion@tok @x0)))) :named token_correspondence_Prims.inversion))
(assert (! (HasType Prims.inversion@tok Tm_arrow_105) :named function_token_typing_Prims.inversion))
(assert (! (forall ((@x0 Term)) (! (implies (HasType @x0 Tm_type) (HasType (Prims.inversion @x0) Tm_type)) :pattern ((Prims.inversion @x0)))) :named typing_Prims.inversion))
(assert (! (forall ((@x0 Term)) (! (= (Prims.inversion @x0) Prims.l_True) :pattern ((Prims.inversion @x0)))) :named equation_Prims.inversion))
(declare-fun Prims.eq2 (Term Term Term) Term)
(declare-fun Tm_arrow_143 () Term)
(assert (! (HasType Tm_arrow_143 Tm_type) :named kinding_Tm_arrow_143))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_143) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_143)))) :named pre_typing_Tm_arrow_143))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_143) (forall ((@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 @x1) (HasType @x3 @x1)) (HasType (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) Tm_type)) :pattern ((ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3))))) :pattern ((HasTypeZ @x0 Tm_arrow_143)))) :named interpretation_Tm_arrow_143))
(declare-fun Prims.eq2@tok () Term)
(assert (! (= 145 (Term_constr_id Prims.eq2@tok)) :named fresh_token_Prims.eq2@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT Prims.eq2@tok @x0) @x1) @x2) (Prims.eq2 @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT Prims.eq2@tok @x0) @x1) @x2)))) :named token_correspondence_Prims.eq2))
(assert (! (HasType Prims.eq2@tok Tm_arrow_143) :named function_token_typing_Prims.eq2))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 @x0) (HasType @x2 @x0)) (HasType (Prims.eq2 @x0 @x1 @x2) Tm_type)) :pattern ((Prims.eq2 @x0 @x1 @x2)))) :named typing_Prims.eq2))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (iff (= @x1 @x2) (Valid (Prims.eq2 @x0 @x1 @x2))) :pattern ((Valid (Prims.eq2 @x0 @x1 @x2))))) :named eq2-interp))
(declare-fun Prims.eq3 (Term Term Term Term) Term)
(declare-fun Tm_arrow_147 () Term)
(assert (! (HasType Tm_arrow_147 Tm_type) :named kinding_Tm_arrow_147))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_147) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_147)))) :named pre_typing_Tm_arrow_147))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_147) (forall ((@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 @x1) (HasType @x4 @x2)) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) Tm_type)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4))))) :pattern ((HasTypeZ @x0 Tm_arrow_147)))) :named interpretation_Tm_arrow_147))
(declare-fun Prims.eq3@tok () Term)
(assert (! (= 149 (Term_constr_id Prims.eq3@tok)) :named fresh_token_Prims.eq3@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.eq3@tok @x0) @x1) @x2) @x3) (Prims.eq3 @x0 @x1 @x2 @x3)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.eq3@tok @x0) @x1) @x2) @x3)))) :named token_correspondence_Prims.eq3))
(assert (! (HasType Prims.eq3@tok Tm_arrow_147) :named function_token_typing_Prims.eq3))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 @x0) (HasType @x3 @x1)) (HasType (Prims.eq3 @x0 @x1 @x2 @x3) Tm_type)) :pattern ((Prims.eq3 @x0 @x1 @x2 @x3)))) :named typing_Prims.eq3))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (iff (= @x2 @x3) (Valid (Prims.eq3 @x0 @x1 @x2 @x3))) :pattern ((Valid (Prims.eq3 @x0 @x1 @x2 @x3))))) :named eq3-interp))
(declare-fun Prims.bool () Term)
(assert (! (HasType Prims.bool Tm_type) :named function_token_typing_Prims.bool))
(assert (! (= 150 (Term_constr_id Prims.bool)) :named constructor_distinct_Prims.bool))
(assert (! (forall ((@x0 Term) (@u1 Fuel)) (! (implies (HasTypeFuel @u1 @x0 Prims.bool) (= Prims.bool (PreType @x0))) :pattern ((HasTypeFuel @u1 @x0 Prims.bool)))) :named @pretyping__153))
(assert (! (HasType Prims.bool Tm_type) :named typing_Prims.bool))
(assert (! (forall ((@u0 Bool)) (! (HasType (BoxBool @u0) Prims.bool) :pattern ((BoxBool @u0)))) :named bool_typing))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Prims.bool) (is-BoxBool @x1)) :pattern ((HasTypeFuel @u0 @x1 Prims.bool)))) :named bool_inversion))
(assert (! (Valid (Prims.hasEq Prims.bool)) :named assumption_Prims.HasEq_bool_155))
(declare-fun Prims.b2t (Term) Term)
(assert (! (forall ((@x0 Term)) (! (= (Valid (Prims.b2t @x0)) (BoxBool_proj_0 @x0)) :pattern ((Valid (Prims.b2t @x0))))) :named b2t_def))
(declare-fun Prims.c_and (Term Term) Term)
(declare-fun Prims.c_and@x0 (Term) Term)
(declare-fun Prims.c_and@x1 (Term) Term)
(declare-fun Prims.c_and@tok () Term)
(declare-fun Prims.And (Term Term Term Term) Term)
(declare-fun Prims.And_p (Term) Term)
(declare-fun Prims.And_q (Term) Term)
(declare-fun Prims.And__0 (Term) Term)
(declare-fun Prims.And__1 (Term) Term)
(declare-fun Tm_arrow_167 () Term)
(declare-fun Prims.And@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= 156 (Term_constr_id (Prims.c_and @x0 @x1))) :pattern ((Prims.c_and @x0 @x1)))) :named constructor_distinct_Prims.c_and))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (Prims.c_and@x0 (Prims.c_and @x0 @x1)) @x0) :pattern ((Prims.c_and @x0 @x1)))) :named projection_inverse_Prims.c_and@x0))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (Prims.c_and@x1 (Prims.c_and @x0 @x1)) @x1) :pattern ((Prims.c_and @x0 @x1)))) :named projection_inverse_Prims.c_and@x1))
(define-fun is-Prims.c_and ((@x0 Term)) Bool (and (= (Term_constr_id @x0) 156) (= @x0 (Prims.c_and (Prims.c_and@x0 @x0) (Prims.c_and@x1 @x0)))))
(assert (! (= 157 (Term_constr_id Prims.c_and@tok)) :named fresh_token_Prims.c_and@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (ApplyTT (ApplyTT Prims.c_and@tok @x0) @x1) (Prims.c_and @x0 @x1)) :pattern ((ApplyTT (ApplyTT Prims.c_and@tok @x0) @x1)) :pattern ((Prims.c_and @x0 @x1)))) :named token_correspondence_Prims.c_and@tok))
(assert (! (is-Tm_arrow (PreType Prims.c_and@tok)) :named pre_kinding_Prims.c_and@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type)) (HasType (Prims.c_and @x0 @x1) Tm_type)) :pattern ((Prims.c_and @x0 @x1)))) :named kinding_Prims.c_and@tok))
(assert (! (forall ((@x0 Term) (@u1 Fuel) (@x2 Term) (@x3 Term)) (! (implies (HasTypeFuel @u1 @x0 (Prims.c_and @x2 @x3)) (= (Prims.c_and @x2 @x3) (PreType @x0))) :pattern ((HasTypeFuel @u1 @x0 (Prims.c_and @x2 @x3))))) :named @pretyping__163))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= 165 (Term_constr_id (Prims.And @x0 @x1 @x2 @x3))) :pattern ((Prims.And @x0 @x1 @x2 @x3)))) :named constructor_distinct_Prims.And))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (Prims.And_p (Prims.And @x0 @x1 @x2 @x3)) @x0) :pattern ((Prims.And @x0 @x1 @x2 @x3)))) :named projection_inverse_Prims.And_p))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (Prims.And_q (Prims.And @x0 @x1 @x2 @x3)) @x1) :pattern ((Prims.And @x0 @x1 @x2 @x3)))) :named projection_inverse_Prims.And_q))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (Prims.And__0 (Prims.And @x0 @x1 @x2 @x3)) @x2) :pattern ((Prims.And @x0 @x1 @x2 @x3)))) :named projection_inverse_Prims.And__0))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (Prims.And__1 (Prims.And @x0 @x1 @x2 @x3)) @x3) :pattern ((Prims.And @x0 @x1 @x2 @x3)))) :named projection_inverse_Prims.And__1))
(define-fun is-Prims.And ((@x0 Term)) Bool (and (= (Term_constr_id @x0) 165) (= @x0 (Prims.And (Prims.And_p @x0) (Prims.And_q @x0) (Prims.And__0 @x0) (Prims.And__1 @x0)))))
(assert (! (HasType Tm_arrow_167 Tm_type) :named kinding_Tm_arrow_167))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_167) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_167)))) :named pre_typing_Tm_arrow_167))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_167) (forall ((@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 @x1) (HasType @x4 @x2)) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) (Prims.c_and @x1 @x2))) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4))))) :pattern ((HasTypeZ @x0 Tm_arrow_167)))) :named interpretation_Tm_arrow_167))
(assert (! (= 169 (Term_constr_id Prims.And@tok)) :named fresh_token_Prims.And@tok))
(assert (! (HasType Prims.And@tok Tm_arrow_167) :named typing_tok_Prims.And@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.And@tok @x0) @x1) @x2) @x3) (Prims.And @x0 @x1 @x2 @x3)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.And@tok @x0) @x1) @x2) @x3)))) :named equality_tok_Prims.And@tok))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasTypeFuel @u0 @x1 Tm_type) (HasTypeFuel @u0 @x2 Tm_type) (HasTypeFuel @u0 @x3 @x1) (HasTypeFuel @u0 @x4 @x2)) (HasTypeFuel @u0 (Prims.And @x1 @x2 @x3 @x4) (Prims.c_and @x1 @x2))) :pattern ((HasTypeFuel @u0 (Prims.And @x1 @x2 @x3 @x4) (Prims.c_and @x1 @x2))))) :named data_typing_intro_Prims.And@tok))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term)) (! (implies (HasTypeFuel (SFuel @u0) (Prims.And @x1 @x2 @x3 @x4) (Prims.c_and @x5 @x6)) (and (= @x2 @x6) (= @x1 @x5) (HasTypeFuel @u0 @x1 Tm_type) (HasTypeFuel @u0 @x2 Tm_type) (HasTypeFuel @u0 @x3 @x1) (HasTypeFuel @u0 @x4 @x2))) :pattern ((HasTypeFuel (SFuel @u0) (Prims.And @x1 @x2 @x3 @x4) (Prims.c_and @x5 @x6))))) :named data_elim_Prims.And))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term)) (! (implies (HasTypeFuel (SFuel @u0) (Prims.And @x1 @x2 @x3 @x4) (Prims.c_and @x5 @x6)) (and (Valid (Precedes @x1 (Prims.And @x1 @x2 @x3 @x4))) (Valid (Precedes @x2 (Prims.And @x1 @x2 @x3 @x4))) (Valid (Precedes @x3 (Prims.And @x1 @x2 @x3 @x4))) (Valid (Precedes @x4 (Prims.And @x1 @x2 @x3 @x4))))) :pattern ((HasTypeFuel (SFuel @u0) (Prims.And @x1 @x2 @x3 @x4) (Prims.c_and @x5 @x6))))) :named subterm_ordering_Prims.And))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (HasTypeFuel @u0 @x1 (Prims.c_and @x2 @x3)) (and (is-Prims.And @x1) (= @x2 (Prims.And_p @x1)) (= @x3 (Prims.And_q @x1)))) :pattern ((HasTypeFuel @u0 @x1 (Prims.c_and @x2 @x3))))) :named fuel_guarded_inversion_Prims.c_and_160))
(declare-fun Prims.And._0 (Term Term Term) Term)
(declare-fun Tm_arrow_171 () Term)
(assert (! (HasType Tm_arrow_171 Tm_type) :named kinding_Tm_arrow_171))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_171) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_171)))) :named pre_typing_Tm_arrow_171))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_171) (forall ((@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 (Prims.c_and @x1 @x2))) (HasType (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x1)) :pattern ((ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3))))) :pattern ((HasTypeZ @x0 Tm_arrow_171)))) :named interpretation_Tm_arrow_171))
(declare-fun Prims.And._0@tok () Term)
(assert (! (= 173 (Term_constr_id Prims.And._0@tok)) :named fresh_token_Prims.And._0@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT Prims.And._0@tok @x0) @x1) @x2) (Prims.And._0 @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT Prims.And._0@tok @x0) @x1) @x2)))) :named token_correspondence_Prims.And._0))
(assert (! (HasType Prims.And._0@tok Tm_arrow_171) :named function_token_typing_Prims.And._0))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 (Prims.c_and @x0 @x1))) (HasType (Prims.And._0 @x0 @x1 @x2) @x0)) :pattern ((Prims.And._0 @x0 @x1 @x2)))) :named typing_Prims.And._0))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (Prims.And._0 @x0 @x1 @x2) (Prims.And__0 @x2)) :pattern ((Prims.And._0 @x0 @x1 @x2)))) :named proj_equation_Prims.And__0))
(declare-fun Prims.And._1 (Term Term Term) Term)
(declare-fun Tm_arrow_175 () Term)
(assert (! (HasType Tm_arrow_175 Tm_type) :named kinding_Tm_arrow_175))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_175) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_175)))) :named pre_typing_Tm_arrow_175))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_175) (forall ((@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 (Prims.c_and @x1 @x2))) (HasType (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3))))) :pattern ((HasTypeZ @x0 Tm_arrow_175)))) :named interpretation_Tm_arrow_175))
(declare-fun Prims.And._1@tok () Term)
(assert (! (= 177 (Term_constr_id Prims.And._1@tok)) :named fresh_token_Prims.And._1@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT Prims.And._1@tok @x0) @x1) @x2) (Prims.And._1 @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT Prims.And._1@tok @x0) @x1) @x2)))) :named token_correspondence_Prims.And._1))
(assert (! (HasType Prims.And._1@tok Tm_arrow_175) :named function_token_typing_Prims.And._1))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 (Prims.c_and @x0 @x1))) (HasType (Prims.And._1 @x0 @x1 @x2) @x1)) :pattern ((Prims.And._1 @x0 @x1 @x2)))) :named typing_Prims.And._1))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (Prims.And._1 @x0 @x1 @x2) (Prims.And__1 @x2)) :pattern ((Prims.And._1 @x0 @x1 @x2)))) :named proj_equation_Prims.And__1))
(declare-fun Prims.l_and (Term Term) Term)
(declare-fun Tm_arrow_179 () Term)
(assert (! (HasType Tm_arrow_179 Tm_type) :named kinding_Tm_arrow_179))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_179) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_179)))) :named pre_typing_Tm_arrow_179))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_179) (forall ((@x1 Term) (@x2 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type)) (HasType (ApplyTT (ApplyTT @x0 @x1) @x2) Tm_type)) :pattern ((ApplyTT (ApplyTT @x0 @x1) @x2))))) :pattern ((HasTypeZ @x0 Tm_arrow_179)))) :named interpretation_Tm_arrow_179))
(declare-fun Prims.l_and@tok () Term)
(assert (! (= 181 (Term_constr_id Prims.l_and@tok)) :named fresh_token_Prims.l_and@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (ApplyTT (ApplyTT Prims.l_and@tok @x0) @x1) (Prims.l_and @x0 @x1)) :pattern ((ApplyTT (ApplyTT Prims.l_and@tok @x0) @x1)))) :named token_correspondence_Prims.l_and))
(assert (! (HasType Prims.l_and@tok Tm_arrow_179) :named function_token_typing_Prims.l_and))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type)) (HasType (Prims.l_and @x0 @x1) Tm_type)) :pattern ((Prims.l_and @x0 @x1)))) :named typing_Prims.l_and))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (Prims.l_and @x0 @x1) (Prims.squash (Prims.c_and @x0 @x1))) :pattern ((Prims.l_and @x0 @x1)))) :named equation_Prims.l_and))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (and (Valid @x0) (Valid @x1)) (Valid (Prims.l_and @x0 @x1))) :pattern ((Valid (Prims.l_and @x0 @x1))))) :named l_and-interp))
(declare-fun Prims.c_or (Term Term) Term)
(declare-fun Prims.c_or@x0 (Term) Term)
(declare-fun Prims.c_or@x1 (Term) Term)
(declare-fun Prims.c_or@tok () Term)
(declare-fun Prims.Left (Term Term Term) Term)
(declare-fun Prims.Left_p (Term) Term)
(declare-fun Prims.Left_q (Term) Term)
(declare-fun Prims.Left__0 (Term) Term)
(declare-fun Tm_arrow_194 () Term)
(declare-fun Prims.Left@tok () Term)
(declare-fun Prims.Right (Term Term Term) Term)
(declare-fun Prims.Right_p (Term) Term)
(declare-fun Prims.Right_q (Term) Term)
(declare-fun Prims.Right__0 (Term) Term)
(declare-fun Tm_arrow_200 () Term)
(declare-fun Prims.Right@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= 182 (Term_constr_id (Prims.c_or @x0 @x1))) :pattern ((Prims.c_or @x0 @x1)))) :named constructor_distinct_Prims.c_or))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (Prims.c_or@x0 (Prims.c_or @x0 @x1)) @x0) :pattern ((Prims.c_or @x0 @x1)))) :named projection_inverse_Prims.c_or@x0))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (Prims.c_or@x1 (Prims.c_or @x0 @x1)) @x1) :pattern ((Prims.c_or @x0 @x1)))) :named projection_inverse_Prims.c_or@x1))
(define-fun is-Prims.c_or ((@x0 Term)) Bool (and (= (Term_constr_id @x0) 182) (= @x0 (Prims.c_or (Prims.c_or@x0 @x0) (Prims.c_or@x1 @x0)))))
(assert (! (= 183 (Term_constr_id Prims.c_or@tok)) :named fresh_token_Prims.c_or@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (ApplyTT (ApplyTT Prims.c_or@tok @x0) @x1) (Prims.c_or @x0 @x1)) :pattern ((ApplyTT (ApplyTT Prims.c_or@tok @x0) @x1)) :pattern ((Prims.c_or @x0 @x1)))) :named token_correspondence_Prims.c_or@tok))
(assert (! (is-Tm_arrow (PreType Prims.c_or@tok)) :named pre_kinding_Prims.c_or@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type)) (HasType (Prims.c_or @x0 @x1) Tm_type)) :pattern ((Prims.c_or @x0 @x1)))) :named kinding_Prims.c_or@tok))
(assert (! (forall ((@x0 Term) (@u1 Fuel) (@x2 Term) (@x3 Term)) (! (implies (HasTypeFuel @u1 @x0 (Prims.c_or @x2 @x3)) (= (Prims.c_or @x2 @x3) (PreType @x0))) :pattern ((HasTypeFuel @u1 @x0 (Prims.c_or @x2 @x3))))) :named @pretyping__190))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= 192 (Term_constr_id (Prims.Left @x0 @x1 @x2))) :pattern ((Prims.Left @x0 @x1 @x2)))) :named constructor_distinct_Prims.Left))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (Prims.Left_p (Prims.Left @x0 @x1 @x2)) @x0) :pattern ((Prims.Left @x0 @x1 @x2)))) :named projection_inverse_Prims.Left_p))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (Prims.Left_q (Prims.Left @x0 @x1 @x2)) @x1) :pattern ((Prims.Left @x0 @x1 @x2)))) :named projection_inverse_Prims.Left_q))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (Prims.Left__0 (Prims.Left @x0 @x1 @x2)) @x2) :pattern ((Prims.Left @x0 @x1 @x2)))) :named projection_inverse_Prims.Left__0))
(define-fun is-Prims.Left ((@x0 Term)) Bool (and (= (Term_constr_id @x0) 192) (= @x0 (Prims.Left (Prims.Left_p @x0) (Prims.Left_q @x0) (Prims.Left__0 @x0)))))
(assert (! (HasType Tm_arrow_194 Tm_type) :named kinding_Tm_arrow_194))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_194) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_194)))) :named pre_typing_Tm_arrow_194))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_194) (forall ((@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 @x1)) (HasType (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) (Prims.c_or @x1 @x2))) :pattern ((ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3))))) :pattern ((HasTypeZ @x0 Tm_arrow_194)))) :named interpretation_Tm_arrow_194))
(assert (! (= 196 (Term_constr_id Prims.Left@tok)) :named fresh_token_Prims.Left@tok))
(assert (! (HasType Prims.Left@tok Tm_arrow_194) :named typing_tok_Prims.Left@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT Prims.Left@tok @x0) @x1) @x2) (Prims.Left @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT Prims.Left@tok @x0) @x1) @x2)))) :named equality_tok_Prims.Left@tok))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasTypeFuel @u0 @x1 Tm_type) (HasTypeFuel @u0 @x2 Tm_type) (HasTypeFuel @u0 @x3 @x1)) (HasTypeFuel @u0 (Prims.Left @x1 @x2 @x3) (Prims.c_or @x1 @x2))) :pattern ((HasTypeFuel @u0 (Prims.Left @x1 @x2 @x3) (Prims.c_or @x1 @x2))))) :named data_typing_intro_Prims.Left@tok))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (implies (HasTypeFuel (SFuel @u0) (Prims.Left @x1 @x2 @x3) (Prims.c_or @x4 @x5)) (and (= @x2 @x5) (= @x1 @x4) (HasTypeFuel @u0 @x1 Tm_type) (HasTypeFuel @u0 @x2 Tm_type) (HasTypeFuel @u0 @x3 @x1))) :pattern ((HasTypeFuel (SFuel @u0) (Prims.Left @x1 @x2 @x3) (Prims.c_or @x4 @x5))))) :named data_elim_Prims.Left))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (implies (HasTypeFuel (SFuel @u0) (Prims.Left @x1 @x2 @x3) (Prims.c_or @x4 @x5)) (and (Valid (Precedes @x1 (Prims.Left @x1 @x2 @x3))) (Valid (Precedes @x2 (Prims.Left @x1 @x2 @x3))) (Valid (Precedes @x3 (Prims.Left @x1 @x2 @x3))))) :pattern ((HasTypeFuel (SFuel @u0) (Prims.Left @x1 @x2 @x3) (Prims.c_or @x4 @x5))))) :named subterm_ordering_Prims.Left))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= 198 (Term_constr_id (Prims.Right @x0 @x1 @x2))) :pattern ((Prims.Right @x0 @x1 @x2)))) :named constructor_distinct_Prims.Right))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (Prims.Right_p (Prims.Right @x0 @x1 @x2)) @x0) :pattern ((Prims.Right @x0 @x1 @x2)))) :named projection_inverse_Prims.Right_p))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (Prims.Right_q (Prims.Right @x0 @x1 @x2)) @x1) :pattern ((Prims.Right @x0 @x1 @x2)))) :named projection_inverse_Prims.Right_q))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (Prims.Right__0 (Prims.Right @x0 @x1 @x2)) @x2) :pattern ((Prims.Right @x0 @x1 @x2)))) :named projection_inverse_Prims.Right__0))
(define-fun is-Prims.Right ((@x0 Term)) Bool (and (= (Term_constr_id @x0) 198) (= @x0 (Prims.Right (Prims.Right_p @x0) (Prims.Right_q @x0) (Prims.Right__0 @x0)))))
(assert (! (HasType Tm_arrow_200 Tm_type) :named kinding_Tm_arrow_200))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_200) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_200)))) :named pre_typing_Tm_arrow_200))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_200) (forall ((@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 @x2)) (HasType (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) (Prims.c_or @x1 @x2))) :pattern ((ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3))))) :pattern ((HasTypeZ @x0 Tm_arrow_200)))) :named interpretation_Tm_arrow_200))
(assert (! (= 202 (Term_constr_id Prims.Right@tok)) :named fresh_token_Prims.Right@tok))
(assert (! (HasType Prims.Right@tok Tm_arrow_200) :named typing_tok_Prims.Right@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT Prims.Right@tok @x0) @x1) @x2) (Prims.Right @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT Prims.Right@tok @x0) @x1) @x2)))) :named equality_tok_Prims.Right@tok))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasTypeFuel @u0 @x1 Tm_type) (HasTypeFuel @u0 @x2 Tm_type) (HasTypeFuel @u0 @x3 @x2)) (HasTypeFuel @u0 (Prims.Right @x1 @x2 @x3) (Prims.c_or @x1 @x2))) :pattern ((HasTypeFuel @u0 (Prims.Right @x1 @x2 @x3) (Prims.c_or @x1 @x2))))) :named data_typing_intro_Prims.Right@tok))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (implies (HasTypeFuel (SFuel @u0) (Prims.Right @x1 @x2 @x3) (Prims.c_or @x4 @x5)) (and (= @x2 @x5) (= @x1 @x4) (HasTypeFuel @u0 @x1 Tm_type) (HasTypeFuel @u0 @x2 Tm_type) (HasTypeFuel @u0 @x3 @x2))) :pattern ((HasTypeFuel (SFuel @u0) (Prims.Right @x1 @x2 @x3) (Prims.c_or @x4 @x5))))) :named data_elim_Prims.Right))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (implies (HasTypeFuel (SFuel @u0) (Prims.Right @x1 @x2 @x3) (Prims.c_or @x4 @x5)) (and (Valid (Precedes @x1 (Prims.Right @x1 @x2 @x3))) (Valid (Precedes @x2 (Prims.Right @x1 @x2 @x3))) (Valid (Precedes @x3 (Prims.Right @x1 @x2 @x3))))) :pattern ((HasTypeFuel (SFuel @u0) (Prims.Right @x1 @x2 @x3) (Prims.c_or @x4 @x5))))) :named subterm_ordering_Prims.Right))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (HasTypeFuel (SFuel @u0) @x1 (Prims.c_or @x2 @x3)) (or (and (is-Prims.Left @x1) (= @x2 (Prims.Left_p @x1)) (= @x3 (Prims.Left_q @x1))) (and (is-Prims.Right @x1) (= @x2 (Prims.Right_p @x1)) (= @x3 (Prims.Right_q @x1))))) :pattern ((HasTypeFuel (SFuel @u0) @x1 (Prims.c_or @x2 @x3))))) :named fuel_guarded_inversion_Prims.c_or_186))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (HasTypeFuel @u0 @x1 (Prims.c_or @x2 @x3)) (or (and (is-Prims.Left @x1) (= @x2 (Prims.Left_p @x1)) (= @x3 (Prims.Left_q @x1))) (and (is-Prims.Right @x1) (= @x2 (Prims.Right_p @x1)) (= @x3 (Prims.Right_q @x1))))) :pattern ((HasTypeFuel @u0 @x1 (Prims.c_or @x2 @x3)) (Prims.inversion (Prims.c_or @x2 @x3))))) :named pattern_guarded_inversion_Prims.c_or_187))
(declare-fun Prims.is_Left (Term Term Term) Term)
(declare-fun Tm_arrow_204 (Term) Term)
(assert (! (forall ((@x0 Term)) (! (HasType (Tm_arrow_204 @x0) Tm_type) :pattern ((HasType (Tm_arrow_204 @x0) Tm_type)))) :named kinding_Tm_arrow_204))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_204 @x2)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_204 @x2))))) :named pre_typing_Tm_arrow_204))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_204 @x1)) (forall ((@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 (Prims.c_or @x2 @x3))) (HasType (ApplyTT (ApplyTT (ApplyTT @x0 @x2) @x3) @x4) @x1)) :pattern ((ApplyTT (ApplyTT (ApplyTT @x0 @x2) @x3) @x4))))) :pattern ((HasTypeZ @x0 (Tm_arrow_204 @x1))))) :named interpretation_Tm_arrow_204))
(declare-fun Prims.is_Left@tok () Term)
(assert (! (= 206 (Term_constr_id Prims.is_Left@tok)) :named fresh_token_Prims.is_Left@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT Prims.is_Left@tok @x0) @x1) @x2) (Prims.is_Left @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT Prims.is_Left@tok @x0) @x1) @x2)))) :named token_correspondence_Prims.is_Left))
(assert (! (HasType Prims.is_Left@tok (Tm_arrow_204 Prims.bool)) :named function_token_typing_Prims.is_Left))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 (Prims.c_or @x0 @x1))) (HasType (Prims.is_Left @x0 @x1 @x2) Prims.bool)) :pattern ((Prims.is_Left @x0 @x1 @x2)))) :named typing_Prims.is_Left))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (Prims.is_Left @x0 @x1 @x2) (BoxBool (is-Prims.Left @x2))) :pattern ((Prims.is_Left @x0 @x1 @x2)))) :named disc_equation_Prims.Left))
(declare-fun Prims.is_Right (Term Term Term) Term)
(declare-fun Prims.is_Right@tok () Term)
(assert (! (= 208 (Term_constr_id Prims.is_Right@tok)) :named fresh_token_Prims.is_Right@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT Prims.is_Right@tok @x0) @x1) @x2) (Prims.is_Right @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT Prims.is_Right@tok @x0) @x1) @x2)))) :named token_correspondence_Prims.is_Right))
(assert (! (HasType Prims.is_Right@tok (Tm_arrow_204 Prims.bool)) :named function_token_typing_Prims.is_Right))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 (Prims.c_or @x0 @x1))) (HasType (Prims.is_Right @x0 @x1 @x2) Prims.bool)) :pattern ((Prims.is_Right @x0 @x1 @x2)))) :named typing_Prims.is_Right))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (Prims.is_Right @x0 @x1 @x2) (BoxBool (is-Prims.Right @x2))) :pattern ((Prims.is_Right @x0 @x1 @x2)))) :named disc_equation_Prims.Right))
(declare-fun Tm_refine_210 (Term Term) Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (HasType (Tm_refine_210 @x0 @x1) Tm_type) :pattern ((HasType (Tm_refine_210 @x0 @x1) Tm_type)))) :named refinement_kinding_Tm_refine_210))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (iff (HasTypeFuel @u0 @x1 (Tm_refine_210 @x2 @x3)) (and (HasTypeFuel @u0 @x1 (Prims.c_or @x3 @x2)) (BoxBool_proj_0 (Prims.is_Left @x3 @x2 @x1)))) :pattern ((HasTypeFuel @u0 @x1 (Tm_refine_210 @x2 @x3))))) :named refinement_interpretation_Tm_refine_210))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (Valid (Prims.hasEq (Tm_refine_210 @x0 @x1))) (Valid (Prims.hasEq (Prims.c_or @x1 @x0)))) :pattern ((Valid (Prims.hasEq (Tm_refine_210 @x0 @x1)))))) :named haseqTm_refine_210))
(declare-fun Prims.Left._0 (Term Term Term) Term)
(declare-fun Tm_arrow_213 () Term)
(assert (! (HasType Tm_arrow_213 Tm_type) :named kinding_Tm_arrow_213))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_213) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_213)))) :named pre_typing_Tm_arrow_213))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_213) (forall ((@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 (Tm_refine_210 @x2 @x1))) (HasType (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x1)) :pattern ((ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3))))) :pattern ((HasTypeZ @x0 Tm_arrow_213)))) :named interpretation_Tm_arrow_213))
(declare-fun Prims.Left._0@tok () Term)
(assert (! (= 215 (Term_constr_id Prims.Left._0@tok)) :named fresh_token_Prims.Left._0@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT Prims.Left._0@tok @x0) @x1) @x2) (Prims.Left._0 @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT Prims.Left._0@tok @x0) @x1) @x2)))) :named token_correspondence_Prims.Left._0))
(assert (! (HasType Prims.Left._0@tok Tm_arrow_213) :named function_token_typing_Prims.Left._0))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 (Tm_refine_210 @x1 @x0))) (HasType (Prims.Left._0 @x0 @x1 @x2) @x0)) :pattern ((Prims.Left._0 @x0 @x1 @x2)))) :named typing_Prims.Left._0))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (Prims.Left._0 @x0 @x1 @x2) (Prims.Left__0 @x2)) :pattern ((Prims.Left._0 @x0 @x1 @x2)))) :named proj_equation_Prims.Left__0))
(declare-fun Tm_refine_217 (Term Term) Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (HasType (Tm_refine_217 @x0 @x1) Tm_type) :pattern ((HasType (Tm_refine_217 @x0 @x1) Tm_type)))) :named refinement_kinding_Tm_refine_217))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (iff (HasTypeFuel @u0 @x1 (Tm_refine_217 @x2 @x3)) (and (HasTypeFuel @u0 @x1 (Prims.c_or @x3 @x2)) (BoxBool_proj_0 (Prims.is_Right @x3 @x2 @x1)))) :pattern ((HasTypeFuel @u0 @x1 (Tm_refine_217 @x2 @x3))))) :named refinement_interpretation_Tm_refine_217))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (Valid (Prims.hasEq (Tm_refine_217 @x0 @x1))) (Valid (Prims.hasEq (Prims.c_or @x1 @x0)))) :pattern ((Valid (Prims.hasEq (Tm_refine_217 @x0 @x1)))))) :named haseqTm_refine_217))
(declare-fun Prims.Right._0 (Term Term Term) Term)
(declare-fun Tm_arrow_220 () Term)
(assert (! (HasType Tm_arrow_220 Tm_type) :named kinding_Tm_arrow_220))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_220) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_220)))) :named pre_typing_Tm_arrow_220))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_220) (forall ((@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 (Tm_refine_217 @x2 @x1))) (HasType (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3))))) :pattern ((HasTypeZ @x0 Tm_arrow_220)))) :named interpretation_Tm_arrow_220))
(declare-fun Prims.Right._0@tok () Term)
(assert (! (= 222 (Term_constr_id Prims.Right._0@tok)) :named fresh_token_Prims.Right._0@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT Prims.Right._0@tok @x0) @x1) @x2) (Prims.Right._0 @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT Prims.Right._0@tok @x0) @x1) @x2)))) :named token_correspondence_Prims.Right._0))
(assert (! (HasType Prims.Right._0@tok Tm_arrow_220) :named function_token_typing_Prims.Right._0))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 (Tm_refine_217 @x1 @x0))) (HasType (Prims.Right._0 @x0 @x1 @x2) @x1)) :pattern ((Prims.Right._0 @x0 @x1 @x2)))) :named typing_Prims.Right._0))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (Prims.Right._0 @x0 @x1 @x2) (Prims.Right__0 @x2)) :pattern ((Prims.Right._0 @x0 @x1 @x2)))) :named proj_equation_Prims.Right__0))
(declare-fun Prims.l_or (Term Term) Term)
(declare-fun Prims.l_or@tok () Term)
(assert (! (= 224 (Term_constr_id Prims.l_or@tok)) :named fresh_token_Prims.l_or@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (ApplyTT (ApplyTT Prims.l_or@tok @x0) @x1) (Prims.l_or @x0 @x1)) :pattern ((ApplyTT (ApplyTT Prims.l_or@tok @x0) @x1)))) :named token_correspondence_Prims.l_or))
(assert (! (HasType Prims.l_or@tok Tm_arrow_179) :named function_token_typing_Prims.l_or))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type)) (HasType (Prims.l_or @x0 @x1) Tm_type)) :pattern ((Prims.l_or @x0 @x1)))) :named typing_Prims.l_or))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (Prims.l_or @x0 @x1) (Prims.squash (Prims.c_or @x0 @x1))) :pattern ((Prims.l_or @x0 @x1)))) :named equation_Prims.l_or))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (or (Valid @x0) (Valid @x1)) (Valid (Prims.l_or @x0 @x1))) :pattern ((Valid (Prims.l_or @x0 @x1))))) :named l_or-interp))
(declare-fun Prims.l_imp (Term Term) Term)
(declare-fun Prims.l_imp@tok () Term)
(assert (! (= 226 (Term_constr_id Prims.l_imp@tok)) :named fresh_token_Prims.l_imp@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (ApplyTT (ApplyTT Prims.l_imp@tok @x0) @x1) (Prims.l_imp @x0 @x1)) :pattern ((ApplyTT (ApplyTT Prims.l_imp@tok @x0) @x1)))) :named token_correspondence_Prims.l_imp))
(assert (! (HasType Prims.l_imp@tok Tm_arrow_179) :named function_token_typing_Prims.l_imp))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type)) (HasType (Prims.l_imp @x0 @x1) Tm_type)) :pattern ((Prims.l_imp @x0 @x1)))) :named typing_Prims.l_imp))
(declare-fun Tm_arrow_228 (Term Term) Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (HasType (Tm_arrow_228 @x0 @x1) Tm_type) :pattern ((HasType (Tm_arrow_228 @x0 @x1) Tm_type)))) :named kinding_Tm_arrow_228))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_228 @x2 @x3)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_228 @x2 @x3))))) :named pre_typing_Tm_arrow_228))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_228 @x1 @x2)) (forall ((@x3 Term)) (! (implies (HasType @x3 @x2) (HasType (ApplyTT @x0 @x3) @x1)) :pattern ((ApplyTT @x0 @x3))))) :pattern ((HasTypeZ @x0 (Tm_arrow_228 @x1 @x2))))) :named interpretation_Tm_arrow_228))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (Prims.l_imp @x0 @x1) (Prims.squash (Tm_arrow_228 @x1 @x0))) :pattern ((Prims.l_imp @x0 @x1)))) :named equation_Prims.l_imp))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (implies (Valid @x0) (Valid @x1)) (Valid (Prims.l_imp @x0 @x1))) :pattern ((Valid (Prims.l_imp @x0 @x1))))) :named l_imp-interp))
(declare-fun Prims.l_iff (Term Term) Term)
(declare-fun Prims.l_iff@tok () Term)
(assert (! (= 231 (Term_constr_id Prims.l_iff@tok)) :named fresh_token_Prims.l_iff@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (ApplyTT (ApplyTT Prims.l_iff@tok @x0) @x1) (Prims.l_iff @x0 @x1)) :pattern ((ApplyTT (ApplyTT Prims.l_iff@tok @x0) @x1)))) :named token_correspondence_Prims.l_iff))
(assert (! (HasType Prims.l_iff@tok Tm_arrow_179) :named function_token_typing_Prims.l_iff))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type)) (HasType (Prims.l_iff @x0 @x1) Tm_type)) :pattern ((Prims.l_iff @x0 @x1)))) :named typing_Prims.l_iff))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (Valid (Prims.l_iff @x0 @x1)) (and (implies (Valid @x0) (Valid @x1)) (implies (Valid @x1) (Valid @x0)))) :pattern ((Valid (Prims.l_iff @x0 @x1))))) :named equation_Prims.l_iff))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (iff (Valid @x0) (Valid @x1)) (Valid (Prims.l_iff @x0 @x1))) :pattern ((Valid (Prims.l_iff @x0 @x1))))) :named l_iff-interp))
(declare-fun Prims.l_not (Term) Term)
(declare-fun Prims.l_not@tok () Term)
(assert (! (= 233 (Term_constr_id Prims.l_not@tok)) :named fresh_token_Prims.l_not@tok))
(assert (! (forall ((@x0 Term)) (! (= (ApplyTT Prims.l_not@tok @x0) (Prims.l_not @x0)) :pattern ((ApplyTT Prims.l_not@tok @x0)))) :named token_correspondence_Prims.l_not))
(assert (! (HasType Prims.l_not@tok Tm_arrow_105) :named function_token_typing_Prims.l_not))
(assert (! (forall ((@x0 Term)) (! (implies (HasType @x0 Tm_type) (HasType (Prims.l_not @x0) Tm_type)) :pattern ((Prims.l_not @x0)))) :named typing_Prims.l_not))
(assert (! (forall ((@x0 Term)) (! (= (Valid (Prims.l_not @x0)) (implies (Valid @x0) false)) :pattern ((Valid (Prims.l_not @x0))))) :named equation_Prims.l_not))
(declare-fun Prims.has_type (Term Term Term) Term)
(declare-fun Tm_arrow_235 () Term)
(assert (! (HasType Tm_arrow_235 Tm_type) :named kinding_Tm_arrow_235))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_235) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_235)))) :named pre_typing_Tm_arrow_235))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_235) (forall ((@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 @x1) (HasType @x3 Tm_type)) (HasType (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) Tm_type)) :pattern ((ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3))))) :pattern ((HasTypeZ @x0 Tm_arrow_235)))) :named interpretation_Tm_arrow_235))
(declare-fun Prims.has_type@tok () Term)
(assert (! (= 237 (Term_constr_id Prims.has_type@tok)) :named fresh_token_Prims.has_type@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT Prims.has_type@tok @x0) @x1) @x2) (Prims.has_type @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT Prims.has_type@tok @x0) @x1) @x2)))) :named token_correspondence_Prims.has_type))
(assert (! (HasType Prims.has_type@tok Tm_arrow_235) :named function_token_typing_Prims.has_type))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 @x0) (HasType @x2 Tm_type)) (HasType (Prims.has_type @x0 @x1 @x2) Tm_type)) :pattern ((Prims.has_type @x0 @x1 @x2)))) :named typing_Prims.has_type))
(declare-fun Tm_arrow_239 (Term) Term)
(assert (! (forall ((@x0 Term)) (! (HasType (Tm_arrow_239 @x0) Tm_type) :pattern ((HasType (Tm_arrow_239 @x0) Tm_type)))) :named kinding_Tm_arrow_239))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_239 @x2)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_239 @x2))))) :named pre_typing_Tm_arrow_239))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_239 @x1)) (forall ((@x2 Term)) (! (implies (HasType @x2 @x1) (HasType (ApplyTT @x0 @x2) Tm_type)) :pattern ((ApplyTT @x0 @x2))))) :pattern ((HasTypeZ @x0 (Tm_arrow_239 @x1))))) :named interpretation_Tm_arrow_239))
(declare-fun Prims.l_Forall (Term Term) Term)
(declare-fun Tm_arrow_243 () Term)
(assert (! (HasType Tm_arrow_243 Tm_type) :named kinding_Tm_arrow_243))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_243) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_243)))) :named pre_typing_Tm_arrow_243))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_243) (forall ((@x1 Term) (@x2 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 (Tm_arrow_239 @x1))) (HasType (ApplyTT (ApplyTT @x0 @x1) @x2) Tm_type)) :pattern ((ApplyTT (ApplyTT @x0 @x1) @x2))))) :pattern ((HasTypeZ @x0 Tm_arrow_243)))) :named interpretation_Tm_arrow_243))
(declare-fun Prims.l_Forall@tok () Term)
(assert (! (= 245 (Term_constr_id Prims.l_Forall@tok)) :named fresh_token_Prims.l_Forall@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (ApplyTT (ApplyTT Prims.l_Forall@tok @x0) @x1) (Prims.l_Forall @x0 @x1)) :pattern ((ApplyTT (ApplyTT Prims.l_Forall@tok @x0) @x1)))) :named token_correspondence_Prims.l_Forall))
(assert (! (HasType Prims.l_Forall@tok Tm_arrow_243) :named function_token_typing_Prims.l_Forall))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 (Tm_arrow_239 @x0))) (HasType (Prims.l_Forall @x0 @x1) Tm_type)) :pattern ((Prims.l_Forall @x0 @x1)))) :named typing_Prims.l_Forall))
(declare-fun Tm_arrow_248 (Term Term) Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (HasType (Tm_arrow_248 @x0 @x1) Tm_type) :pattern ((HasType (Tm_arrow_248 @x0 @x1) Tm_type)))) :named kinding_Tm_arrow_248))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_248 @x2 @x3)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_248 @x2 @x3))))) :named pre_typing_Tm_arrow_248))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_248 @x1 @x2)) (forall ((@x3 Term)) (! (implies (HasType @x3 @x2) (HasType (ApplyTT @x0 @x3) (ApplyTT @x1 @x3))) :pattern ((ApplyTT @x0 @x3))))) :pattern ((HasTypeZ @x0 (Tm_arrow_248 @x1 @x2))))) :named interpretation_Tm_arrow_248))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (Prims.l_Forall @x0 @x1) (Prims.squash (Tm_arrow_248 @x1 @x0))) :pattern ((Prims.l_Forall @x0 @x1)))) :named equation_Prims.l_Forall))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (forall ((@x2 Term)) (! (implies (HasTypeZ @x2 @x0) (Valid (ApplyTT @x1 @x2))) :pattern ((HasTypeZ @x2 @x0)))) (Valid (Prims.l_Forall @x0 @x1))) :pattern ((Valid (Prims.l_Forall @x0 @x1))))) :named forall-interp))
(declare-fun Prims.dtuple2 (Term Term) Term)
(declare-fun Prims.dtuple2@x0 (Term) Term)
(declare-fun Prims.dtuple2@x1 (Term) Term)
(declare-fun Prims.dtuple2@tok () Term)
(declare-fun Prims.Mkdtuple2 (Term Term Term Term) Term)
(declare-fun Prims.Mkdtuple2_a (Term) Term)
(declare-fun Prims.Mkdtuple2_b (Term) Term)
(declare-fun Prims.Mkdtuple2__1 (Term) Term)
(declare-fun Prims.Mkdtuple2__2 (Term) Term)
(declare-fun Tm_arrow_264 () Term)
(declare-fun Prims.Mkdtuple2@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= 251 (Term_constr_id (Prims.dtuple2 @x0 @x1))) :pattern ((Prims.dtuple2 @x0 @x1)))) :named constructor_distinct_Prims.dtuple2))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (Prims.dtuple2@x0 (Prims.dtuple2 @x0 @x1)) @x0) :pattern ((Prims.dtuple2 @x0 @x1)))) :named projection_inverse_Prims.dtuple2@x0))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (Prims.dtuple2@x1 (Prims.dtuple2 @x0 @x1)) @x1) :pattern ((Prims.dtuple2 @x0 @x1)))) :named projection_inverse_Prims.dtuple2@x1))
(define-fun is-Prims.dtuple2 ((@x0 Term)) Bool (and (= (Term_constr_id @x0) 251) (= @x0 (Prims.dtuple2 (Prims.dtuple2@x0 @x0) (Prims.dtuple2@x1 @x0)))))
(assert (! (= 252 (Term_constr_id Prims.dtuple2@tok)) :named fresh_token_Prims.dtuple2@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (ApplyTT (ApplyTT Prims.dtuple2@tok @x0) @x1) (Prims.dtuple2 @x0 @x1)) :pattern ((ApplyTT (ApplyTT Prims.dtuple2@tok @x0) @x1)) :pattern ((Prims.dtuple2 @x0 @x1)))) :named token_correspondence_Prims.dtuple2@tok))
(assert (! (is-Tm_arrow (PreType Prims.dtuple2@tok)) :named pre_kinding_Prims.dtuple2@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 (Tm_arrow_239 @x0))) (HasType (Prims.dtuple2 @x0 @x1) Tm_type)) :pattern ((Prims.dtuple2 @x0 @x1)))) :named kinding_Prims.dtuple2@tok))
(assert (! (forall ((@x0 Term) (@u1 Fuel) (@x2 Term) (@x3 Term)) (! (implies (HasTypeFuel @u1 @x0 (Prims.dtuple2 @x2 @x3)) (= (Prims.dtuple2 @x2 @x3) (PreType @x0))) :pattern ((HasTypeFuel @u1 @x0 (Prims.dtuple2 @x2 @x3))))) :named @pretyping__258))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= 261 (Term_constr_id (Prims.Mkdtuple2 @x0 @x1 @x2 @x3))) :pattern ((Prims.Mkdtuple2 @x0 @x1 @x2 @x3)))) :named constructor_distinct_Prims.Mkdtuple2))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (Prims.Mkdtuple2_a (Prims.Mkdtuple2 @x0 @x1 @x2 @x3)) @x0) :pattern ((Prims.Mkdtuple2 @x0 @x1 @x2 @x3)))) :named projection_inverse_Prims.Mkdtuple2_a))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (Prims.Mkdtuple2_b (Prims.Mkdtuple2 @x0 @x1 @x2 @x3)) @x1) :pattern ((Prims.Mkdtuple2 @x0 @x1 @x2 @x3)))) :named projection_inverse_Prims.Mkdtuple2_b))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (Prims.Mkdtuple2__1 (Prims.Mkdtuple2 @x0 @x1 @x2 @x3)) @x2) :pattern ((Prims.Mkdtuple2 @x0 @x1 @x2 @x3)))) :named projection_inverse_Prims.Mkdtuple2__1))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (Prims.Mkdtuple2__2 (Prims.Mkdtuple2 @x0 @x1 @x2 @x3)) @x3) :pattern ((Prims.Mkdtuple2 @x0 @x1 @x2 @x3)))) :named projection_inverse_Prims.Mkdtuple2__2))
(define-fun is-Prims.Mkdtuple2 ((@x0 Term)) Bool (and (= (Term_constr_id @x0) 261) (= @x0 (Prims.Mkdtuple2 (Prims.Mkdtuple2_a @x0) (Prims.Mkdtuple2_b @x0) (Prims.Mkdtuple2__1 @x0) (Prims.Mkdtuple2__2 @x0)))))
(assert (! (HasType Tm_arrow_264 Tm_type) :named kinding_Tm_arrow_264))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_264) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_264)))) :named pre_typing_Tm_arrow_264))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_264) (forall ((@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 (Tm_arrow_239 @x1)) (HasType @x3 @x1) (HasType @x4 (ApplyTT @x2 @x3))) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) (Prims.dtuple2 @x1 @x2))) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4))))) :pattern ((HasTypeZ @x0 Tm_arrow_264)))) :named interpretation_Tm_arrow_264))
(assert (! (= 267 (Term_constr_id Prims.Mkdtuple2@tok)) :named fresh_token_Prims.Mkdtuple2@tok))
(assert (! (HasType Prims.Mkdtuple2@tok Tm_arrow_264) :named typing_tok_Prims.Mkdtuple2@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mkdtuple2@tok @x0) @x1) @x2) @x3) (Prims.Mkdtuple2 @x0 @x1 @x2 @x3)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mkdtuple2@tok @x0) @x1) @x2) @x3)))) :named equality_tok_Prims.Mkdtuple2@tok))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasTypeFuel @u0 @x1 Tm_type) (HasTypeFuel @u0 @x2 (Tm_arrow_239 @x1)) (HasTypeFuel @u0 @x3 @x1) (HasTypeFuel @u0 @x4 (ApplyTT @x2 @x3))) (HasTypeFuel @u0 (Prims.Mkdtuple2 @x1 @x2 @x3 @x4) (Prims.dtuple2 @x1 @x2))) :pattern ((HasTypeFuel @u0 (Prims.Mkdtuple2 @x1 @x2 @x3 @x4) (Prims.dtuple2 @x1 @x2))))) :named data_typing_intro_Prims.Mkdtuple2@tok))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term)) (! (implies (HasTypeFuel (SFuel @u0) (Prims.Mkdtuple2 @x1 @x2 @x3 @x4) (Prims.dtuple2 @x5 @x6)) (and (= @x2 @x6) (= @x1 @x5) (HasTypeFuel @u0 @x1 Tm_type) (HasTypeFuel @u0 @x2 (Tm_arrow_239 @x1)) (HasTypeFuel @u0 @x3 @x1) (HasTypeFuel @u0 @x4 (ApplyTT @x2 @x3)))) :pattern ((HasTypeFuel (SFuel @u0) (Prims.Mkdtuple2 @x1 @x2 @x3 @x4) (Prims.dtuple2 @x5 @x6))))) :named data_elim_Prims.Mkdtuple2))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term)) (! (implies (HasTypeFuel (SFuel @u0) (Prims.Mkdtuple2 @x1 @x2 @x3 @x4) (Prims.dtuple2 @x5 @x6)) (and (Valid (Precedes @x1 (Prims.Mkdtuple2 @x1 @x2 @x3 @x4))) (Valid (Precedes @x2 (Prims.Mkdtuple2 @x1 @x2 @x3 @x4))) (Valid (Precedes @x3 (Prims.Mkdtuple2 @x1 @x2 @x3 @x4))) (Valid (Precedes @x4 (Prims.Mkdtuple2 @x1 @x2 @x3 @x4))))) :pattern ((HasTypeFuel (SFuel @u0) (Prims.Mkdtuple2 @x1 @x2 @x3 @x4) (Prims.dtuple2 @x5 @x6))))) :named subterm_ordering_Prims.Mkdtuple2))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (HasTypeFuel @u0 @x1 (Prims.dtuple2 @x2 @x3)) (and (is-Prims.Mkdtuple2 @x1) (= @x2 (Prims.Mkdtuple2_a @x1)) (= @x3 (Prims.Mkdtuple2_b @x1)))) :pattern ((HasTypeFuel @u0 @x1 (Prims.dtuple2 @x2 @x3))))) :named fuel_guarded_inversion_Prims.dtuple2_255))
(declare-fun Prims.Mkdtuple2._1 (Term Term Term) Term)
(declare-fun Tm_arrow_271 () Term)
(assert (! (HasType Tm_arrow_271 Tm_type) :named kinding_Tm_arrow_271))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_271) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_271)))) :named pre_typing_Tm_arrow_271))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_271) (forall ((@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 (Tm_arrow_239 @x1)) (HasType @x3 (Prims.dtuple2 @x1 @x2))) (HasType (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x1)) :pattern ((ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3))))) :pattern ((HasTypeZ @x0 Tm_arrow_271)))) :named interpretation_Tm_arrow_271))
(declare-fun Prims.Mkdtuple2._1@tok () Term)
(assert (! (= 273 (Term_constr_id Prims.Mkdtuple2._1@tok)) :named fresh_token_Prims.Mkdtuple2._1@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT Prims.Mkdtuple2._1@tok @x0) @x1) @x2) (Prims.Mkdtuple2._1 @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT Prims.Mkdtuple2._1@tok @x0) @x1) @x2)))) :named token_correspondence_Prims.Mkdtuple2._1))
(assert (! (HasType Prims.Mkdtuple2._1@tok Tm_arrow_271) :named function_token_typing_Prims.Mkdtuple2._1))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 (Tm_arrow_239 @x0)) (HasType @x2 (Prims.dtuple2 @x0 @x1))) (HasType (Prims.Mkdtuple2._1 @x0 @x1 @x2) @x0)) :pattern ((Prims.Mkdtuple2._1 @x0 @x1 @x2)))) :named typing_Prims.Mkdtuple2._1))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (Prims.Mkdtuple2._1 @x0 @x1 @x2) (Prims.Mkdtuple2__1 @x2)) :pattern ((Prims.Mkdtuple2._1 @x0 @x1 @x2)))) :named proj_equation_Prims.Mkdtuple2__1))
(declare-fun Prims.Mkdtuple2._2 (Term Term Term) Term)
(declare-fun Tm_arrow_277 () Term)
(assert (! (HasType Tm_arrow_277 Tm_type) :named kinding_Tm_arrow_277))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_277) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_277)))) :named pre_typing_Tm_arrow_277))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_277) (forall ((@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 (Tm_arrow_239 @x1)) (HasType @x3 (Prims.dtuple2 @x1 @x2))) (HasType (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) (ApplyTT @x2 (Prims.Mkdtuple2._1 @x1 @x2 @x3)))) :pattern ((ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3))))) :pattern ((HasTypeZ @x0 Tm_arrow_277)))) :named interpretation_Tm_arrow_277))
(declare-fun Prims.Mkdtuple2._2@tok () Term)
(assert (! (= 279 (Term_constr_id Prims.Mkdtuple2._2@tok)) :named fresh_token_Prims.Mkdtuple2._2@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT Prims.Mkdtuple2._2@tok @x0) @x1) @x2) (Prims.Mkdtuple2._2 @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT Prims.Mkdtuple2._2@tok @x0) @x1) @x2)))) :named token_correspondence_Prims.Mkdtuple2._2))
(assert (! (HasType Prims.Mkdtuple2._2@tok Tm_arrow_277) :named function_token_typing_Prims.Mkdtuple2._2))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 (Tm_arrow_239 @x0)) (HasType @x2 (Prims.dtuple2 @x0 @x1))) (HasType (Prims.Mkdtuple2._2 @x0 @x1 @x2) (ApplyTT @x1 (Prims.Mkdtuple2._1 @x0 @x1 @x2)))) :pattern ((Prims.Mkdtuple2._2 @x0 @x1 @x2)))) :named typing_Prims.Mkdtuple2._2))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (Prims.Mkdtuple2._2 @x0 @x1 @x2) (Prims.Mkdtuple2__2 @x2)) :pattern ((Prims.Mkdtuple2._2 @x0 @x1 @x2)))) :named proj_equation_Prims.Mkdtuple2__2))
(declare-fun Prims.l_Exists (Term Term) Term)
(declare-fun Prims.l_Exists@tok () Term)
(assert (! (= 283 (Term_constr_id Prims.l_Exists@tok)) :named fresh_token_Prims.l_Exists@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (ApplyTT (ApplyTT Prims.l_Exists@tok @x0) @x1) (Prims.l_Exists @x0 @x1)) :pattern ((ApplyTT (ApplyTT Prims.l_Exists@tok @x0) @x1)))) :named token_correspondence_Prims.l_Exists))
(assert (! (HasType Prims.l_Exists@tok Tm_arrow_243) :named function_token_typing_Prims.l_Exists))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 (Tm_arrow_239 @x0))) (HasType (Prims.l_Exists @x0 @x1) Tm_type)) :pattern ((Prims.l_Exists @x0 @x1)))) :named typing_Prims.l_Exists))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (Prims.l_Exists @x0 @x1) (Prims.squash (Prims.dtuple2 @x0 @x1))) :pattern ((Prims.l_Exists @x0 @x1)))) :named equation_Prims.l_Exists))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (exists ((@x2 Term)) (! (implies (HasTypeZ @x2 @x0) (Valid (ApplyTT @x1 @x2))) :pattern ((HasTypeZ @x2 @x0)))) (Valid (Prims.l_Exists @x0 @x1))) :pattern ((Valid (Prims.l_Exists @x0 @x1))))) :named exists-interp))
(declare-fun Prims.range () Term)
(assert (! (HasType Prims.range Tm_type) :named function_token_typing_Prims.range))
(assert (! (= 285 (Term_constr_id Prims.range)) :named constructor_distinct_Prims.range))
(assert (! (forall ((@x0 Term) (@u1 Fuel)) (! (implies (HasTypeFuel @u1 @x0 Prims.range) (= Prims.range (PreType @x0))) :pattern ((HasTypeFuel @u1 @x0 Prims.range)))) :named @pretyping__288))
(assert (! (HasType Prims.range Tm_type) :named typing_Prims.range))
(assert (! (HasTypeZ Range_const Prims.range) :named typing_range_const_289))
(declare-fun Prims.range_0 () Term)
(assert (! (HasType Prims.range_0 Prims.range) :named function_token_typing_Prims.range_0))
(assert (! (HasType Prims.range_0 Prims.range) :named typing_Prims.range_0))
(declare-fun Prims.string () Term)
(assert (! (HasType Prims.string Tm_type) :named function_token_typing_Prims.string))
(assert (! (= 290 (Term_constr_id Prims.string)) :named constructor_distinct_Prims.string))
(assert (! (forall ((@x0 Term) (@u1 Fuel)) (! (implies (HasTypeFuel @u1 @x0 Prims.string) (= Prims.string (PreType @x0))) :pattern ((HasTypeFuel @u1 @x0 Prims.string)))) :named @pretyping__293))
(assert (! (HasType Prims.string Tm_type) :named typing_Prims.string))
(assert (! (forall ((@u0 String)) (! (HasType (BoxString @u0) Prims.string) :pattern ((BoxString @u0)))) :named string_typing))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Prims.string) (is-BoxString @x1)) :pattern ((HasTypeFuel @u0 @x1 Prims.string)))) :named string_inversion))
(declare-fun Prims.labeled (Term Term Term) Term)
(declare-fun Tm_arrow_296 (Term Term) Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (HasType (Tm_arrow_296 @x0 @x1) Tm_type) :pattern ((HasType (Tm_arrow_296 @x0 @x1) Tm_type)))) :named kinding_Tm_arrow_296))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_296 @x2 @x3)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_296 @x2 @x3))))) :named pre_typing_Tm_arrow_296))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_296 @x1 @x2)) (forall ((@x3 Term) (@x4 Term) (@x5 Term)) (! (implies (and (HasType @x3 @x2) (HasType @x4 @x1) (HasType @x5 Tm_type)) (HasType (ApplyTT (ApplyTT (ApplyTT @x0 @x3) @x4) @x5) Tm_type)) :pattern ((ApplyTT (ApplyTT (ApplyTT @x0 @x3) @x4) @x5))))) :pattern ((HasTypeZ @x0 (Tm_arrow_296 @x1 @x2))))) :named interpretation_Tm_arrow_296))
(declare-fun Prims.labeled@tok () Term)
(assert (! (= 298 (Term_constr_id Prims.labeled@tok)) :named fresh_token_Prims.labeled@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT Prims.labeled@tok @x0) @x1) @x2) (Prims.labeled @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT Prims.labeled@tok @x0) @x1) @x2)))) :named token_correspondence_Prims.labeled))
(assert (! (HasType Prims.labeled@tok (Tm_arrow_296 Prims.string Prims.range)) :named function_token_typing_Prims.labeled))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Prims.range) (HasType @x1 Prims.string) (HasType @x2 Tm_type)) (HasType (Prims.labeled @x0 @x1 @x2) Tm_type)) :pattern ((Prims.labeled @x0 @x1 @x2)))) :named typing_Prims.labeled))
(declare-fun Prims.range_of (Term Term) Term)
(declare-fun Tm_arrow_300 () Term)
(assert (! (HasType Tm_arrow_300 Tm_type) :named kinding_Tm_arrow_300))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_300) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_300)))) :named pre_typing_Tm_arrow_300))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_300) (forall ((@x1 Term) (@x2 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 @x1)) (HasType (ApplyTT (ApplyTT @x0 @x1) @x2) Tm_type)) :pattern ((ApplyTT (ApplyTT @x0 @x1) @x2))))) :pattern ((HasTypeZ @x0 Tm_arrow_300)))) :named interpretation_Tm_arrow_300))
(declare-fun Prims.range_of@tok () Term)
(assert (! (= 302 (Term_constr_id Prims.range_of@tok)) :named fresh_token_Prims.range_of@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (ApplyTT (ApplyTT Prims.range_of@tok @x0) @x1) (Prims.range_of @x0 @x1)) :pattern ((ApplyTT (ApplyTT Prims.range_of@tok @x0) @x1)))) :named token_correspondence_Prims.range_of))
(assert (! (HasType Prims.range_of@tok Tm_arrow_300) :named function_token_typing_Prims.range_of))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 @x0)) (HasType (Prims.range_of @x0 @x1) Tm_type)) :pattern ((Prims.range_of @x0 @x1)))) :named typing_Prims.range_of))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (Prims.range_of @x0 @x1) Prims.range) :pattern ((Prims.range_of @x0 @x1)))) :named equation_Prims.range_of))
(declare-fun Prims.pure_pre () Term)
(assert (! (HasType Prims.pure_pre Tm_type) :named function_token_typing_Prims.pure_pre))
(assert (! (HasType Prims.pure_pre Tm_type) :named typing_Prims.pure_pre))
(assert (! (= Prims.pure_pre Tm_type) :named equation_Prims.pure_pre))
(declare-fun Prims.pure_post (Term) Term)
(declare-fun Prims.pure_post@tok () Term)
(assert (! (= 304 (Term_constr_id Prims.pure_post@tok)) :named fresh_token_Prims.pure_post@tok))
(assert (! (forall ((@x0 Term)) (! (= (ApplyTT Prims.pure_post@tok @x0) (Prims.pure_post @x0)) :pattern ((ApplyTT Prims.pure_post@tok @x0)))) :named token_correspondence_Prims.pure_post))
(assert (! (HasType Prims.pure_post@tok Tm_arrow_105) :named function_token_typing_Prims.pure_post))
(assert (! (forall ((@x0 Term)) (! (implies (HasType @x0 Tm_type) (HasType (Prims.pure_post @x0) Tm_type)) :pattern ((Prims.pure_post @x0)))) :named typing_Prims.pure_post))
(assert (! (forall ((@x0 Term)) (! (= (Prims.pure_post @x0) (Tm_arrow_239 @x0)) :pattern ((Prims.pure_post @x0)))) :named equation_Prims.pure_post))
(declare-fun Prims.pure_wp (Term) Term)
(declare-fun Prims.pure_wp@tok () Term)
(assert (! (= 307 (Term_constr_id Prims.pure_wp@tok)) :named fresh_token_Prims.pure_wp@tok))
(assert (! (forall ((@x0 Term)) (! (= (ApplyTT Prims.pure_wp@tok @x0) (Prims.pure_wp @x0)) :pattern ((ApplyTT Prims.pure_wp@tok @x0)))) :named token_correspondence_Prims.pure_wp))
(assert (! (HasType Prims.pure_wp@tok Tm_arrow_105) :named function_token_typing_Prims.pure_wp))
(assert (! (forall ((@x0 Term)) (! (implies (HasType @x0 Tm_type) (HasType (Prims.pure_wp @x0) Tm_type)) :pattern ((Prims.pure_wp @x0)))) :named typing_Prims.pure_wp))
(declare-fun Tm_arrow_309 (Term Term) Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (HasType (Tm_arrow_309 @x0 @x1) Tm_type) :pattern ((HasType (Tm_arrow_309 @x0 @x1) Tm_type)))) :named kinding_Tm_arrow_309))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_309 @x2 @x3)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_309 @x2 @x3))))) :named pre_typing_Tm_arrow_309))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_309 @x1 @x2)) (forall ((@x3 Term)) (! (implies (HasType @x3 (Prims.pure_post @x2)) (HasType (ApplyTT @x0 @x3) @x1)) :pattern ((ApplyTT @x0 @x3))))) :pattern ((HasTypeZ @x0 (Tm_arrow_309 @x1 @x2))))) :named interpretation_Tm_arrow_309))
(assert (! (forall ((@x0 Term)) (! (= (Prims.pure_wp @x0) (Tm_arrow_309 Prims.pure_pre @x0)) :pattern ((Prims.pure_wp @x0)))) :named equation_Prims.pure_wp))
(declare-fun Prims.guard_free (Term) Term)
(declare-fun Prims.guard_free@tok () Term)
(assert (! (= 312 (Term_constr_id Prims.guard_free@tok)) :named fresh_token_Prims.guard_free@tok))
(assert (! (forall ((@x0 Term)) (! (= (ApplyTT Prims.guard_free@tok @x0) (Prims.guard_free @x0)) :pattern ((ApplyTT Prims.guard_free@tok @x0)))) :named token_correspondence_Prims.guard_free))
(assert (! (HasType Prims.guard_free@tok Tm_arrow_105) :named function_token_typing_Prims.guard_free))
(assert (! (forall ((@x0 Term)) (! (implies (HasType @x0 Tm_type) (HasType (Prims.guard_free @x0) Tm_type)) :pattern ((Prims.guard_free @x0)))) :named typing_Prims.guard_free))
(declare-fun Prims.int () Term)
(assert (! (HasType Prims.int Tm_type) :named function_token_typing_Prims.int))
(assert (! (= 313 (Term_constr_id Prims.int)) :named constructor_distinct_Prims.int))
(assert (! (forall ((@x0 Term) (@u1 Fuel)) (! (implies (HasTypeFuel @u1 @x0 Prims.int) (= Prims.int (PreType @x0))) :pattern ((HasTypeFuel @u1 @x0 Prims.int)))) :named @pretyping__316))
(assert (! (HasType Prims.int Tm_type) :named typing_Prims.int))
(assert (! (forall ((@u0 Int)) (! (HasType (BoxInt @u0) Prims.int) :pattern ((BoxInt @u0)))) :named int_typing))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Prims.int) (is-BoxInt @x1)) :pattern ((HasTypeFuel @u0 @x1 Prims.int)))) :named int_inversion))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (and (HasTypeFuel @u0 @x1 Prims.int) (HasTypeFuel @u0 @x2 Prims.int) (> (BoxInt_proj_0 @x1) 0) (>= (BoxInt_proj_0 @x2) 0) (< (BoxInt_proj_0 @x2) (BoxInt_proj_0 @x1))) (Valid (Precedes @x2 @x1))) :pattern ((HasTypeFuel @u0 @x1 Prims.int) (HasTypeFuel @u0 @x2 Prims.int) (Valid (Precedes @x2 @x1))))) :named well-founded-ordering-on-nat))
(assert (! (Valid (Prims.hasEq Prims.int)) :named assumption_Prims.HasEq_int_319))
(declare-fun Prims.op_AmpAmp (Term Term) Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (Prims.op_AmpAmp @x0 @x1) (BoxBool (and (BoxBool_proj_0 @x0) (BoxBool_proj_0 @x1)))) :pattern ((Prims.op_AmpAmp @x0 @x1)))) :named primitive_Prims.op_AmpAmp))
(declare-fun Prims.op_BarBar (Term Term) Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (Prims.op_BarBar @x0 @x1) (BoxBool (or (BoxBool_proj_0 @x0) (BoxBool_proj_0 @x1)))) :pattern ((Prims.op_BarBar @x0 @x1)))) :named primitive_Prims.op_BarBar))
(declare-fun Prims.op_Negation (Term) Term)
(assert (! (forall ((@x0 Term)) (! (= (Prims.op_Negation @x0) (BoxBool (not (BoxBool_proj_0 @x0)))) :pattern ((Prims.op_Negation @x0)))) :named primitive_Prims.op_Negation))
(declare-fun Prims.op_Multiply (Term Term) Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (Prims.op_Multiply @x0 @x1) (BoxInt (* (BoxInt_proj_0 @x0) (BoxInt_proj_0 @x1)))) :pattern ((Prims.op_Multiply @x0 @x1)))) :named primitive_Prims.op_Multiply))
(declare-fun Prims.op_Subtraction (Term Term) Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (Prims.op_Subtraction @x0 @x1) (BoxInt (- (BoxInt_proj_0 @x0) (BoxInt_proj_0 @x1)))) :pattern ((Prims.op_Subtraction @x0 @x1)))) :named primitive_Prims.op_Subtraction))
(declare-fun Prims.op_Addition (Term Term) Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (Prims.op_Addition @x0 @x1) (BoxInt (+ (BoxInt_proj_0 @x0) (BoxInt_proj_0 @x1)))) :pattern ((Prims.op_Addition @x0 @x1)))) :named primitive_Prims.op_Addition))
(declare-fun Prims.op_Minus (Term) Term)
(assert (! (forall ((@x0 Term)) (! (= (Prims.op_Minus @x0) (BoxInt (- (BoxInt_proj_0 @x0)))) :pattern ((Prims.op_Minus @x0)))) :named primitive_Prims.op_Minus))
(declare-fun Prims.op_LessThanOrEqual (Term Term) Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (Prims.op_LessThanOrEqual @x0 @x1) (BoxBool (<= (BoxInt_proj_0 @x0) (BoxInt_proj_0 @x1)))) :pattern ((Prims.op_LessThanOrEqual @x0 @x1)))) :named primitive_Prims.op_LessThanOrEqual))
(declare-fun Prims.op_GreaterThan (Term Term) Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (Prims.op_GreaterThan @x0 @x1) (BoxBool (> (BoxInt_proj_0 @x0) (BoxInt_proj_0 @x1)))) :pattern ((Prims.op_GreaterThan @x0 @x1)))) :named primitive_Prims.op_GreaterThan))
(declare-fun Prims.op_GreaterThanOrEqual (Term Term) Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (Prims.op_GreaterThanOrEqual @x0 @x1) (BoxBool (>= (BoxInt_proj_0 @x0) (BoxInt_proj_0 @x1)))) :pattern ((Prims.op_GreaterThanOrEqual @x0 @x1)))) :named primitive_Prims.op_GreaterThanOrEqual))
(declare-fun Prims.op_LessThan (Term Term) Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (Prims.op_LessThan @x0 @x1) (BoxBool (< (BoxInt_proj_0 @x0) (BoxInt_proj_0 @x1)))) :pattern ((Prims.op_LessThan @x0 @x1)))) :named primitive_Prims.op_LessThan))
(declare-fun Prims.op_Equality (Term Term Term) Term)
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (Prims.op_Equality @x0 @x1 @x2) (BoxBool (= @x1 @x2))) :pattern ((Prims.op_Equality @x0 @x1 @x2)))) :named primitive_Prims.op_Equality))
(declare-fun Prims.op_disEquality (Term Term Term) Term)
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (Prims.op_disEquality @x0 @x1 @x2) (BoxBool (not (= @x1 @x2)))) :pattern ((Prims.op_disEquality @x0 @x1 @x2)))) :named primitive_Prims.op_disEquality))
(declare-fun Prims.exn () Term)
(assert (! (HasType Prims.exn Tm_type) :named function_token_typing_Prims.exn))
(assert (! (= 320 (Term_constr_id Prims.exn)) :named constructor_distinct_Prims.exn))
(assert (! (forall ((@x0 Term) (@u1 Fuel)) (! (implies (HasTypeFuel @u1 @x0 Prims.exn) (= Prims.exn (PreType @x0))) :pattern ((HasTypeFuel @u1 @x0 Prims.exn)))) :named @pretyping__323))
(assert (! (HasType Prims.exn Tm_type) :named typing_Prims.exn))
(declare-fun Prims.array (Term) Term)
(declare-fun Prims.array@tok () Term)
(assert (! (= 325 (Term_constr_id Prims.array@tok)) :named fresh_token_Prims.array@tok))
(assert (! (forall ((@x0 Term)) (! (= (ApplyTT Prims.array@tok @x0) (Prims.array @x0)) :pattern ((ApplyTT Prims.array@tok @x0)))) :named token_correspondence_Prims.array))
(assert (! (HasType Prims.array@tok Tm_arrow_105) :named function_token_typing_Prims.array))
(assert (! (forall ((@x0 Term)) (! (= 326 (Term_constr_id (Prims.array @x0))) :pattern ((Prims.array @x0)))) :named constructor_distinct_Prims.array))
(assert (! (forall ((@x0 Term) (@u1 Fuel) (@x2 Term)) (! (implies (HasTypeFuel @u1 @x0 (Prims.array @x2)) (= (Prims.array @x2) (PreType @x0))) :pattern ((HasTypeFuel @u1 @x0 (Prims.array @x2))))) :named @pretyping__329))
(assert (! (forall ((@x0 Term)) (! (implies (HasType @x0 Tm_type) (HasType (Prims.array @x0) Tm_type)) :pattern ((Prims.array @x0)))) :named typing_Prims.array))
(declare-fun Prims.strcat (Term Term) Term)
(declare-fun Tm_arrow_331 (Term) Term)
(assert (! (forall ((@x0 Term)) (! (HasType (Tm_arrow_331 @x0) Tm_type) :pattern ((HasType (Tm_arrow_331 @x0) Tm_type)))) :named kinding_Tm_arrow_331))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_331 @x2)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_331 @x2))))) :named pre_typing_Tm_arrow_331))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_331 @x1)) (forall ((@x2 Term) (@x3 Term)) (! (implies (and (HasType @x2 @x1) (HasType @x3 @x1)) (HasType (ApplyTT (ApplyTT @x0 @x2) @x3) @x1)) :pattern ((ApplyTT (ApplyTT @x0 @x2) @x3))))) :pattern ((HasTypeZ @x0 (Tm_arrow_331 @x1))))) :named interpretation_Tm_arrow_331))
(declare-fun Prims.strcat@tok () Term)
(assert (! (= 333 (Term_constr_id Prims.strcat@tok)) :named fresh_token_Prims.strcat@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (ApplyTT (ApplyTT Prims.strcat@tok @x0) @x1) (Prims.strcat @x0 @x1)) :pattern ((ApplyTT (ApplyTT Prims.strcat@tok @x0) @x1)))) :named token_correspondence_Prims.strcat))
(assert (! (HasType Prims.strcat@tok (Tm_arrow_331 Prims.string)) :named function_token_typing_Prims.strcat))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 Prims.string) (HasType @x1 Prims.string)) (HasType (Prims.strcat @x0 @x1) Prims.string)) :pattern ((Prims.strcat @x0 @x1)))) :named typing_Prims.strcat))
(assert (! (Valid (Prims.hasEq Prims.string)) :named assumption_Prims.HasEq_string_334))
(declare-fun Prims.list (Term) Term)
(declare-fun Prims.list@x0 (Term) Term)
(declare-fun Prims.list@tok () Term)
(declare-fun Prims.Nil (Term) Term)
(declare-fun Prims.Nil_a (Term) Term)
(declare-fun Tm_arrow_347 () Term)
(declare-fun Prims.Nil@tok () Term)
(declare-fun Prims.Cons (Term Term Term) Term)
(declare-fun Prims.Cons_a (Term) Term)
(declare-fun Prims.Cons_hd (Term) Term)
(declare-fun Prims.Cons_tl (Term) Term)
(declare-fun Tm_arrow_353 () Term)
(declare-fun Prims.Cons@tok () Term)
(assert (! (forall ((@x0 Term)) (! (= 335 (Term_constr_id (Prims.list @x0))) :pattern ((Prims.list @x0)))) :named constructor_distinct_Prims.list))
(assert (! (forall ((@x0 Term)) (! (= (Prims.list@x0 (Prims.list @x0)) @x0) :pattern ((Prims.list @x0)))) :named projection_inverse_Prims.list@x0))
(define-fun is-Prims.list ((@x0 Term)) Bool (and (= (Term_constr_id @x0) 335) (= @x0 (Prims.list (Prims.list@x0 @x0)))))
(assert (! (= 336 (Term_constr_id Prims.list@tok)) :named fresh_token_Prims.list@tok))
(assert (! (forall ((@x0 Term)) (! (= (ApplyTT Prims.list@tok @x0) (Prims.list @x0)) :pattern ((ApplyTT Prims.list@tok @x0)) :pattern ((Prims.list @x0)))) :named token_correspondence_Prims.list@tok))
(assert (! (is-Tm_arrow (PreType Prims.list@tok)) :named pre_kinding_Prims.list@tok))
(assert (! (forall ((@x0 Term)) (! (implies (HasType @x0 Tm_type) (HasType (Prims.list @x0) Tm_type)) :pattern ((Prims.list @x0)))) :named kinding_Prims.list@tok))
(assert (! (forall ((@x0 Term) (@u1 Fuel) (@x2 Term)) (! (implies (HasTypeFuel @u1 @x0 (Prims.list @x2)) (= (Prims.list @x2) (PreType @x0))) :pattern ((HasTypeFuel @u1 @x0 (Prims.list @x2))))) :named @pretyping__343))
(assert (! (forall ((@x0 Term)) (! (= 345 (Term_constr_id (Prims.Nil @x0))) :pattern ((Prims.Nil @x0)))) :named constructor_distinct_Prims.Nil))
(assert (! (forall ((@x0 Term)) (! (= (Prims.Nil_a (Prims.Nil @x0)) @x0) :pattern ((Prims.Nil @x0)))) :named projection_inverse_Prims.Nil_a))
(define-fun is-Prims.Nil ((@x0 Term)) Bool (and (= (Term_constr_id @x0) 345) (= @x0 (Prims.Nil (Prims.Nil_a @x0)))))
(assert (! (HasType Tm_arrow_347 Tm_type) :named kinding_Tm_arrow_347))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_347) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_347)))) :named pre_typing_Tm_arrow_347))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_347) (forall ((@x1 Term)) (! (implies (HasType @x1 Tm_type) (HasType (ApplyTT @x0 @x1) (Prims.list @x1))) :pattern ((ApplyTT @x0 @x1))))) :pattern ((HasTypeZ @x0 Tm_arrow_347)))) :named interpretation_Tm_arrow_347))
(assert (! (= 349 (Term_constr_id Prims.Nil@tok)) :named fresh_token_Prims.Nil@tok))
(assert (! (HasType Prims.Nil@tok Tm_arrow_347) :named typing_tok_Prims.Nil@tok))
(assert (! (forall ((@x0 Term)) (! (= (ApplyTT Prims.Nil@tok @x0) (Prims.Nil @x0)) :pattern ((ApplyTT Prims.Nil@tok @x0)))) :named equality_tok_Prims.Nil@tok))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_type) (HasTypeFuel @u0 (Prims.Nil @x1) (Prims.list @x1))) :pattern ((HasTypeFuel @u0 (Prims.Nil @x1) (Prims.list @x1))))) :named data_typing_intro_Prims.Nil@tok))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel (SFuel @u0) (Prims.Nil @x1) (Prims.list @x2)) (and (= @x1 @x2) (HasTypeFuel @u0 @x1 Tm_type))) :pattern ((HasTypeFuel (SFuel @u0) (Prims.Nil @x1) (Prims.list @x2))))) :named data_elim_Prims.Nil))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel (SFuel @u0) (Prims.Nil @x1) (Prims.list @x2)) (Valid (Precedes @x1 (Prims.Nil @x1)))) :pattern ((HasTypeFuel (SFuel @u0) (Prims.Nil @x1) (Prims.list @x2))))) :named subterm_ordering_Prims.Nil))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= 351 (Term_constr_id (Prims.Cons @x0 @x1 @x2))) :pattern ((Prims.Cons @x0 @x1 @x2)))) :named constructor_distinct_Prims.Cons))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (Prims.Cons_a (Prims.Cons @x0 @x1 @x2)) @x0) :pattern ((Prims.Cons @x0 @x1 @x2)))) :named projection_inverse_Prims.Cons_a))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (Prims.Cons_hd (Prims.Cons @x0 @x1 @x2)) @x1) :pattern ((Prims.Cons @x0 @x1 @x2)))) :named projection_inverse_Prims.Cons_hd))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (Prims.Cons_tl (Prims.Cons @x0 @x1 @x2)) @x2) :pattern ((Prims.Cons @x0 @x1 @x2)))) :named projection_inverse_Prims.Cons_tl))
(define-fun is-Prims.Cons ((@x0 Term)) Bool (and (= (Term_constr_id @x0) 351) (= @x0 (Prims.Cons (Prims.Cons_a @x0) (Prims.Cons_hd @x0) (Prims.Cons_tl @x0)))))
(assert (! (HasType Tm_arrow_353 Tm_type) :named kinding_Tm_arrow_353))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_353) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_353)))) :named pre_typing_Tm_arrow_353))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_353) (forall ((@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 @x1) (HasType @x3 (Prims.list @x1))) (HasType (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) (Prims.list @x1))) :pattern ((ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3))))) :pattern ((HasTypeZ @x0 Tm_arrow_353)))) :named interpretation_Tm_arrow_353))
(assert (! (= 355 (Term_constr_id Prims.Cons@tok)) :named fresh_token_Prims.Cons@tok))
(assert (! (HasType Prims.Cons@tok Tm_arrow_353) :named typing_tok_Prims.Cons@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT Prims.Cons@tok @x0) @x1) @x2) (Prims.Cons @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT Prims.Cons@tok @x0) @x1) @x2)))) :named equality_tok_Prims.Cons@tok))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasTypeFuel @u0 @x1 Tm_type) (HasTypeFuel @u0 @x2 @x1) (HasTypeFuel @u0 @x3 (Prims.list @x1))) (HasTypeFuel @u0 (Prims.Cons @x1 @x2 @x3) (Prims.list @x1))) :pattern ((HasTypeFuel @u0 (Prims.Cons @x1 @x2 @x3) (Prims.list @x1))))) :named data_typing_intro_Prims.Cons@tok))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (HasTypeFuel (SFuel @u0) (Prims.Cons @x1 @x2 @x3) (Prims.list @x4)) (and (= @x1 @x4) (HasTypeFuel @u0 @x1 Tm_type) (HasTypeFuel @u0 @x2 @x1) (HasTypeFuel @u0 @x3 (Prims.list @x1)))) :pattern ((HasTypeFuel (SFuel @u0) (Prims.Cons @x1 @x2 @x3) (Prims.list @x4))))) :named data_elim_Prims.Cons))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (HasTypeFuel (SFuel @u0) (Prims.Cons @x1 @x2 @x3) (Prims.list @x4)) (and (Valid (Precedes @x1 (Prims.Cons @x1 @x2 @x3))) (Valid (Precedes @x2 (Prims.Cons @x1 @x2 @x3))) (Valid (Precedes @x3 (Prims.Cons @x1 @x2 @x3))))) :pattern ((HasTypeFuel (SFuel @u0) (Prims.Cons @x1 @x2 @x3) (Prims.list @x4))))) :named subterm_ordering_Prims.Cons))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel (SFuel @u0) @x1 (Prims.list @x2)) (or (and (is-Prims.Nil @x1) (= @x2 (Prims.Nil_a @x1))) (and (is-Prims.Cons @x1) (= @x2 (Prims.Cons_a @x1))))) :pattern ((HasTypeFuel (SFuel @u0) @x1 (Prims.list @x2))))) :named fuel_guarded_inversion_Prims.list_339))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel @u0 @x1 (Prims.list @x2)) (or (and (is-Prims.Nil @x1) (= @x2 (Prims.Nil_a @x1))) (and (is-Prims.Cons @x1) (= @x2 (Prims.Cons_a @x1))))) :pattern ((HasTypeFuel @u0 @x1 (Prims.list @x2)) (Prims.inversion (Prims.list @x2))))) :named pattern_guarded_inversion_Prims.list_340))
(declare-fun Prims.is_Nil (Term Term) Term)
(declare-fun Tm_arrow_357 (Term) Term)
(assert (! (forall ((@x0 Term)) (! (HasType (Tm_arrow_357 @x0) Tm_type) :pattern ((HasType (Tm_arrow_357 @x0) Tm_type)))) :named kinding_Tm_arrow_357))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_357 @x2)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_357 @x2))))) :named pre_typing_Tm_arrow_357))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_357 @x1)) (forall ((@x2 Term) (@x3 Term)) (! (implies (and (HasType @x2 Tm_type) (HasType @x3 (Prims.list @x2))) (HasType (ApplyTT (ApplyTT @x0 @x2) @x3) @x1)) :pattern ((ApplyTT (ApplyTT @x0 @x2) @x3))))) :pattern ((HasTypeZ @x0 (Tm_arrow_357 @x1))))) :named interpretation_Tm_arrow_357))
(declare-fun Prims.is_Nil@tok () Term)
(assert (! (= 359 (Term_constr_id Prims.is_Nil@tok)) :named fresh_token_Prims.is_Nil@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (ApplyTT (ApplyTT Prims.is_Nil@tok @x0) @x1) (Prims.is_Nil @x0 @x1)) :pattern ((ApplyTT (ApplyTT Prims.is_Nil@tok @x0) @x1)))) :named token_correspondence_Prims.is_Nil))
(assert (! (HasType Prims.is_Nil@tok (Tm_arrow_357 Prims.bool)) :named function_token_typing_Prims.is_Nil))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 (Prims.list @x0))) (HasType (Prims.is_Nil @x0 @x1) Prims.bool)) :pattern ((Prims.is_Nil @x0 @x1)))) :named typing_Prims.is_Nil))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (Prims.is_Nil @x0 @x1) (BoxBool (is-Prims.Nil @x1))) :pattern ((Prims.is_Nil @x0 @x1)))) :named disc_equation_Prims.Nil))
(declare-fun Prims.is_Cons (Term Term) Term)
(declare-fun Prims.is_Cons@tok () Term)
(assert (! (= 361 (Term_constr_id Prims.is_Cons@tok)) :named fresh_token_Prims.is_Cons@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (ApplyTT (ApplyTT Prims.is_Cons@tok @x0) @x1) (Prims.is_Cons @x0 @x1)) :pattern ((ApplyTT (ApplyTT Prims.is_Cons@tok @x0) @x1)))) :named token_correspondence_Prims.is_Cons))
(assert (! (HasType Prims.is_Cons@tok (Tm_arrow_357 Prims.bool)) :named function_token_typing_Prims.is_Cons))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 (Prims.list @x0))) (HasType (Prims.is_Cons @x0 @x1) Prims.bool)) :pattern ((Prims.is_Cons @x0 @x1)))) :named typing_Prims.is_Cons))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (Prims.is_Cons @x0 @x1) (BoxBool (is-Prims.Cons @x1))) :pattern ((Prims.is_Cons @x0 @x1)))) :named disc_equation_Prims.Cons))
(declare-fun Tm_refine_363 (Term) Term)
(assert (! (forall ((@x0 Term)) (! (HasType (Tm_refine_363 @x0) Tm_type) :pattern ((HasType (Tm_refine_363 @x0) Tm_type)))) :named refinement_kinding_Tm_refine_363))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (iff (HasTypeFuel @u0 @x1 (Tm_refine_363 @x2)) (and (HasTypeFuel @u0 @x1 (Prims.list @x2)) (BoxBool_proj_0 (Prims.is_Cons @x2 @x1)))) :pattern ((HasTypeFuel @u0 @x1 (Tm_refine_363 @x2))))) :named refinement_interpretation_Tm_refine_363))
(assert (! (forall ((@x0 Term)) (! (iff (Valid (Prims.hasEq (Tm_refine_363 @x0))) (Valid (Prims.hasEq (Prims.list @x0)))) :pattern ((Valid (Prims.hasEq (Tm_refine_363 @x0)))))) :named haseqTm_refine_363))
(declare-fun Prims.Cons.hd (Term Term) Term)
(declare-fun Tm_arrow_366 () Term)
(assert (! (HasType Tm_arrow_366 Tm_type) :named kinding_Tm_arrow_366))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_366) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_366)))) :named pre_typing_Tm_arrow_366))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_366) (forall ((@x1 Term) (@x2 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 (Tm_refine_363 @x1))) (HasType (ApplyTT (ApplyTT @x0 @x1) @x2) @x1)) :pattern ((ApplyTT (ApplyTT @x0 @x1) @x2))))) :pattern ((HasTypeZ @x0 Tm_arrow_366)))) :named interpretation_Tm_arrow_366))
(declare-fun Prims.Cons.hd@tok () Term)
(assert (! (= 368 (Term_constr_id Prims.Cons.hd@tok)) :named fresh_token_Prims.Cons.hd@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (ApplyTT (ApplyTT Prims.Cons.hd@tok @x0) @x1) (Prims.Cons.hd @x0 @x1)) :pattern ((ApplyTT (ApplyTT Prims.Cons.hd@tok @x0) @x1)))) :named token_correspondence_Prims.Cons.hd))
(assert (! (HasType Prims.Cons.hd@tok Tm_arrow_366) :named function_token_typing_Prims.Cons.hd))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 (Tm_refine_363 @x0))) (HasType (Prims.Cons.hd @x0 @x1) @x0)) :pattern ((Prims.Cons.hd @x0 @x1)))) :named typing_Prims.Cons.hd))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (Prims.Cons.hd @x0 @x1) (Prims.Cons_hd @x1)) :pattern ((Prims.Cons.hd @x0 @x1)))) :named proj_equation_Prims.Cons_hd))
(declare-fun Prims.Cons.tl (Term Term) Term)
(declare-fun Tm_arrow_372 () Term)
(assert (! (HasType Tm_arrow_372 Tm_type) :named kinding_Tm_arrow_372))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_372) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_372)))) :named pre_typing_Tm_arrow_372))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_372) (forall ((@x1 Term) (@x2 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 (Tm_refine_363 @x1))) (HasType (ApplyTT (ApplyTT @x0 @x1) @x2) (Prims.list @x1))) :pattern ((ApplyTT (ApplyTT @x0 @x1) @x2))))) :pattern ((HasTypeZ @x0 Tm_arrow_372)))) :named interpretation_Tm_arrow_372))
(declare-fun Prims.Cons.tl@tok () Term)
(assert (! (= 374 (Term_constr_id Prims.Cons.tl@tok)) :named fresh_token_Prims.Cons.tl@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (ApplyTT (ApplyTT Prims.Cons.tl@tok @x0) @x1) (Prims.Cons.tl @x0 @x1)) :pattern ((ApplyTT (ApplyTT Prims.Cons.tl@tok @x0) @x1)))) :named token_correspondence_Prims.Cons.tl))
(assert (! (HasType Prims.Cons.tl@tok Tm_arrow_372) :named function_token_typing_Prims.Cons.tl))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 (Tm_refine_363 @x0))) (HasType (Prims.Cons.tl @x0 @x1) (Prims.list @x0))) :pattern ((Prims.Cons.tl @x0 @x1)))) :named typing_Prims.Cons.tl))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (Prims.Cons.tl @x0 @x1) (Prims.Cons_tl @x1)) :pattern ((Prims.Cons.tl @x0 @x1)))) :named proj_equation_Prims.Cons_tl))
(assert (! (forall ((@x0 Term)) (! (implies (and (HasType @x0 Tm_type) (Valid (Prims.hasEq @x0))) (Valid (Prims.hasEq (Prims.list @x0)))) :pattern ((Prims.hasEq (Prims.list @x0))))) :named assumption_Prims.HasEq_list_375))
(declare-fun Prims.pattern () Term)
(declare-fun Prims.SMTPat (Term Term) Term)
(declare-fun Prims.SMTPat_a (Term) Term)
(declare-fun Prims.SMTPat__1 (Term) Term)
(declare-fun Tm_arrow_387 () Term)
(declare-fun Prims.SMTPat@tok () Term)
(declare-fun Prims.SMTPatT (Term) Term)
(declare-fun Prims.SMTPatT_a (Term) Term)
(declare-fun Tm_arrow_393 () Term)
(declare-fun Prims.SMTPatT@tok () Term)
(declare-fun Prims.SMTPatOr (Term) Term)
(declare-fun Prims.SMTPatOr__0 (Term) Term)
(declare-fun Tm_arrow_399 () Term)
(declare-fun Prims.SMTPatOr@tok () Term)
(assert (! (= 376 (Term_constr_id Prims.pattern)) :named constructor_distinct_Prims.pattern))
(define-fun is-Prims.pattern ((@x0 Term)) Bool (and (= (Term_constr_id @x0) 376) (= @x0 Prims.pattern)))
(assert (! (HasType Prims.pattern Tm_type) :named kinding_Prims.pattern@tok))
(assert (! (forall ((@x0 Term) (@u1 Fuel)) (! (implies (HasTypeFuel @u1 @x0 Prims.pattern) (= Prims.pattern (PreType @x0))) :pattern ((HasTypeFuel @u1 @x0 Prims.pattern)))) :named @pretyping__383))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= 385 (Term_constr_id (Prims.SMTPat @x0 @x1))) :pattern ((Prims.SMTPat @x0 @x1)))) :named constructor_distinct_Prims.SMTPat))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (Prims.SMTPat_a (Prims.SMTPat @x0 @x1)) @x0) :pattern ((Prims.SMTPat @x0 @x1)))) :named projection_inverse_Prims.SMTPat_a))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (Prims.SMTPat__1 (Prims.SMTPat @x0 @x1)) @x1) :pattern ((Prims.SMTPat @x0 @x1)))) :named projection_inverse_Prims.SMTPat__1))
(define-fun is-Prims.SMTPat ((@x0 Term)) Bool (and (= (Term_constr_id @x0) 385) (= @x0 (Prims.SMTPat (Prims.SMTPat_a @x0) (Prims.SMTPat__1 @x0)))))
(assert (! (HasType Tm_arrow_387 Tm_type) :named kinding_Tm_arrow_387))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_387) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_387)))) :named pre_typing_Tm_arrow_387))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_387) (forall ((@x1 Term) (@x2 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 @x1)) (HasType (ApplyTT (ApplyTT @x0 @x1) @x2) Prims.pattern)) :pattern ((ApplyTT (ApplyTT @x0 @x1) @x2))))) :pattern ((HasTypeZ @x0 Tm_arrow_387)))) :named interpretation_Tm_arrow_387))
(assert (! (= 389 (Term_constr_id Prims.SMTPat@tok)) :named fresh_token_Prims.SMTPat@tok))
(assert (! (HasType Prims.SMTPat@tok Tm_arrow_387) :named typing_tok_Prims.SMTPat@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (ApplyTT (ApplyTT Prims.SMTPat@tok @x0) @x1) (Prims.SMTPat @x0 @x1)) :pattern ((ApplyTT (ApplyTT Prims.SMTPat@tok @x0) @x1)))) :named equality_tok_Prims.SMTPat@tok))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (and (HasTypeFuel @u0 @x1 Tm_type) (HasTypeFuel @u0 @x2 @x1)) (HasTypeFuel @u0 (Prims.SMTPat @x1 @x2) Prims.pattern)) :pattern ((HasTypeFuel @u0 (Prims.SMTPat @x1 @x2) Prims.pattern)))) :named data_typing_intro_Prims.SMTPat@tok))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel (SFuel @u0) (Prims.SMTPat @x1 @x2) Prims.pattern) (and (HasTypeFuel @u0 @x1 Tm_type) (HasTypeFuel @u0 @x2 @x1))) :pattern ((HasTypeFuel (SFuel @u0) (Prims.SMTPat @x1 @x2) Prims.pattern)))) :named data_elim_Prims.SMTPat))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel (SFuel @u0) (Prims.SMTPat @x1 @x2) Prims.pattern) (and (Valid (Precedes @x1 (Prims.SMTPat @x1 @x2))) (Valid (Precedes @x2 (Prims.SMTPat @x1 @x2))))) :pattern ((HasTypeFuel (SFuel @u0) (Prims.SMTPat @x1 @x2) Prims.pattern)))) :named subterm_ordering_Prims.SMTPat))
(assert (! (forall ((@x0 Term)) (! (= 391 (Term_constr_id (Prims.SMTPatT @x0))) :pattern ((Prims.SMTPatT @x0)))) :named constructor_distinct_Prims.SMTPatT))
(assert (! (forall ((@x0 Term)) (! (= (Prims.SMTPatT_a (Prims.SMTPatT @x0)) @x0) :pattern ((Prims.SMTPatT @x0)))) :named projection_inverse_Prims.SMTPatT_a))
(define-fun is-Prims.SMTPatT ((@x0 Term)) Bool (and (= (Term_constr_id @x0) 391) (= @x0 (Prims.SMTPatT (Prims.SMTPatT_a @x0)))))
(assert (! (HasType Tm_arrow_393 Tm_type) :named kinding_Tm_arrow_393))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_393) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_393)))) :named pre_typing_Tm_arrow_393))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_393) (forall ((@x1 Term)) (! (implies (HasType @x1 Tm_type) (HasType (ApplyTT @x0 @x1) Prims.pattern)) :pattern ((ApplyTT @x0 @x1))))) :pattern ((HasTypeZ @x0 Tm_arrow_393)))) :named interpretation_Tm_arrow_393))
(assert (! (= 395 (Term_constr_id Prims.SMTPatT@tok)) :named fresh_token_Prims.SMTPatT@tok))
(assert (! (HasType Prims.SMTPatT@tok Tm_arrow_393) :named typing_tok_Prims.SMTPatT@tok))
(assert (! (forall ((@x0 Term)) (! (= (ApplyTT Prims.SMTPatT@tok @x0) (Prims.SMTPatT @x0)) :pattern ((ApplyTT Prims.SMTPatT@tok @x0)))) :named equality_tok_Prims.SMTPatT@tok))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_type) (HasTypeFuel @u0 (Prims.SMTPatT @x1) Prims.pattern)) :pattern ((HasTypeFuel @u0 (Prims.SMTPatT @x1) Prims.pattern)))) :named data_typing_intro_Prims.SMTPatT@tok))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel (SFuel @u0) (Prims.SMTPatT @x1) Prims.pattern) (HasTypeFuel @u0 @x1 Tm_type)) :pattern ((HasTypeFuel (SFuel @u0) (Prims.SMTPatT @x1) Prims.pattern)))) :named data_elim_Prims.SMTPatT))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel (SFuel @u0) (Prims.SMTPatT @x1) Prims.pattern) (Valid (Precedes @x1 (Prims.SMTPatT @x1)))) :pattern ((HasTypeFuel (SFuel @u0) (Prims.SMTPatT @x1) Prims.pattern)))) :named subterm_ordering_Prims.SMTPatT))
(assert (! (forall ((@x0 Term)) (! (= 397 (Term_constr_id (Prims.SMTPatOr @x0))) :pattern ((Prims.SMTPatOr @x0)))) :named constructor_distinct_Prims.SMTPatOr))
(assert (! (forall ((@x0 Term)) (! (= (Prims.SMTPatOr__0 (Prims.SMTPatOr @x0)) @x0) :pattern ((Prims.SMTPatOr @x0)))) :named projection_inverse_Prims.SMTPatOr__0))
(define-fun is-Prims.SMTPatOr ((@x0 Term)) Bool (and (= (Term_constr_id @x0) 397) (= @x0 (Prims.SMTPatOr (Prims.SMTPatOr__0 @x0)))))
(assert (! (HasType Tm_arrow_399 Tm_type) :named kinding_Tm_arrow_399))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_399) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_399)))) :named pre_typing_Tm_arrow_399))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_399) (forall ((@x1 Term)) (! (implies (HasType @x1 (Prims.list (Prims.list Prims.pattern))) (HasType (ApplyTT @x0 @x1) Prims.pattern)) :pattern ((ApplyTT @x0 @x1))))) :pattern ((HasTypeZ @x0 Tm_arrow_399)))) :named interpretation_Tm_arrow_399))
(assert (! (= 401 (Term_constr_id Prims.SMTPatOr@tok)) :named fresh_token_Prims.SMTPatOr@tok))
(assert (! (HasType Prims.SMTPatOr@tok Tm_arrow_399) :named typing_tok_Prims.SMTPatOr@tok))
(assert (! (forall ((@x0 Term)) (! (= (ApplyTT Prims.SMTPatOr@tok @x0) (Prims.SMTPatOr @x0)) :pattern ((ApplyTT Prims.SMTPatOr@tok @x0)))) :named equality_tok_Prims.SMTPatOr@tok))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 (Prims.list (Prims.list Prims.pattern))) (HasTypeFuel @u0 (Prims.SMTPatOr @x1) Prims.pattern)) :pattern ((HasTypeFuel @u0 (Prims.SMTPatOr @x1) Prims.pattern)))) :named data_typing_intro_Prims.SMTPatOr@tok))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel (SFuel @u0) (Prims.SMTPatOr @x1) Prims.pattern) (HasTypeFuel @u0 @x1 (Prims.list (Prims.list Prims.pattern)))) :pattern ((HasTypeFuel (SFuel @u0) (Prims.SMTPatOr @x1) Prims.pattern)))) :named data_elim_Prims.SMTPatOr))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel (SFuel @u0) (Prims.SMTPatOr @x1) Prims.pattern) (Valid (Precedes @x1 (Prims.SMTPatOr @x1)))) :pattern ((HasTypeFuel (SFuel @u0) (Prims.SMTPatOr @x1) Prims.pattern)))) :named subterm_ordering_Prims.SMTPatOr))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel (SFuel @u0) @x1 Prims.pattern) (or (is-Prims.SMTPat @x1) (is-Prims.SMTPatT @x1) (is-Prims.SMTPatOr @x1))) :pattern ((HasTypeFuel (SFuel @u0) @x1 Prims.pattern)))) :named fuel_guarded_inversion_Prims.pattern_379))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Prims.pattern) (or (is-Prims.SMTPat @x1) (is-Prims.SMTPatT @x1) (is-Prims.SMTPatOr @x1))) :pattern ((HasTypeFuel @u0 @x1 Prims.pattern) (Prims.inversion Prims.pattern)))) :named pattern_guarded_inversion_Prims.pattern_380))
(declare-fun Prims.is_SMTPat (Term) Term)
(declare-fun Tm_arrow_403 (Term) Term)
(assert (! (forall ((@x0 Term)) (! (HasType (Tm_arrow_403 @x0) Tm_type) :pattern ((HasType (Tm_arrow_403 @x0) Tm_type)))) :named kinding_Tm_arrow_403))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_403 @x2)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_403 @x2))))) :named pre_typing_Tm_arrow_403))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_403 @x1)) (forall ((@x2 Term)) (! (implies (HasType @x2 Prims.pattern) (HasType (ApplyTT @x0 @x2) @x1)) :pattern ((ApplyTT @x0 @x2))))) :pattern ((HasTypeZ @x0 (Tm_arrow_403 @x1))))) :named interpretation_Tm_arrow_403))
(declare-fun Prims.is_SMTPat@tok () Term)
(assert (! (= 405 (Term_constr_id Prims.is_SMTPat@tok)) :named fresh_token_Prims.is_SMTPat@tok))
(assert (! (forall ((@x0 Term)) (! (= (ApplyTT Prims.is_SMTPat@tok @x0) (Prims.is_SMTPat @x0)) :pattern ((ApplyTT Prims.is_SMTPat@tok @x0)))) :named token_correspondence_Prims.is_SMTPat))
(assert (! (HasType Prims.is_SMTPat@tok (Tm_arrow_403 Prims.bool)) :named function_token_typing_Prims.is_SMTPat))
(assert (! (forall ((@x0 Term)) (! (implies (HasType @x0 Prims.pattern) (HasType (Prims.is_SMTPat @x0) Prims.bool)) :pattern ((Prims.is_SMTPat @x0)))) :named typing_Prims.is_SMTPat))
(assert (! (forall ((@x0 Term)) (! (= (Prims.is_SMTPat @x0) (BoxBool (is-Prims.SMTPat @x0))) :pattern ((Prims.is_SMTPat @x0)))) :named disc_equation_Prims.SMTPat))
(declare-fun Prims.is_SMTPatT (Term) Term)
(declare-fun Prims.is_SMTPatT@tok () Term)
(assert (! (= 407 (Term_constr_id Prims.is_SMTPatT@tok)) :named fresh_token_Prims.is_SMTPatT@tok))
(assert (! (forall ((@x0 Term)) (! (= (ApplyTT Prims.is_SMTPatT@tok @x0) (Prims.is_SMTPatT @x0)) :pattern ((ApplyTT Prims.is_SMTPatT@tok @x0)))) :named token_correspondence_Prims.is_SMTPatT))
(assert (! (HasType Prims.is_SMTPatT@tok (Tm_arrow_403 Prims.bool)) :named function_token_typing_Prims.is_SMTPatT))
(assert (! (forall ((@x0 Term)) (! (implies (HasType @x0 Prims.pattern) (HasType (Prims.is_SMTPatT @x0) Prims.bool)) :pattern ((Prims.is_SMTPatT @x0)))) :named typing_Prims.is_SMTPatT))
(assert (! (forall ((@x0 Term)) (! (= (Prims.is_SMTPatT @x0) (BoxBool (is-Prims.SMTPatT @x0))) :pattern ((Prims.is_SMTPatT @x0)))) :named disc_equation_Prims.SMTPatT))
(declare-fun Prims.is_SMTPatOr (Term) Term)
(declare-fun Prims.is_SMTPatOr@tok () Term)
(assert (! (= 409 (Term_constr_id Prims.is_SMTPatOr@tok)) :named fresh_token_Prims.is_SMTPatOr@tok))
(assert (! (forall ((@x0 Term)) (! (= (ApplyTT Prims.is_SMTPatOr@tok @x0) (Prims.is_SMTPatOr @x0)) :pattern ((ApplyTT Prims.is_SMTPatOr@tok @x0)))) :named token_correspondence_Prims.is_SMTPatOr))
(assert (! (HasType Prims.is_SMTPatOr@tok (Tm_arrow_403 Prims.bool)) :named function_token_typing_Prims.is_SMTPatOr))
(assert (! (forall ((@x0 Term)) (! (implies (HasType @x0 Prims.pattern) (HasType (Prims.is_SMTPatOr @x0) Prims.bool)) :pattern ((Prims.is_SMTPatOr @x0)))) :named typing_Prims.is_SMTPatOr))
(assert (! (forall ((@x0 Term)) (! (= (Prims.is_SMTPatOr @x0) (BoxBool (is-Prims.SMTPatOr @x0))) :pattern ((Prims.is_SMTPatOr @x0)))) :named disc_equation_Prims.SMTPatOr))
(declare-fun Tm_refine_411 () Term)
(assert (! (HasType Tm_refine_411 Tm_type) :named refinement_kinding_Tm_refine_411))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (iff (HasTypeFuel @u0 @x1 Tm_refine_411) (and (HasTypeFuel @u0 @x1 Prims.pattern) (BoxBool_proj_0 (Prims.is_SMTPat @x1)))) :pattern ((HasTypeFuel @u0 @x1 Tm_refine_411)))) :named refinement_interpretation_Tm_refine_411))
(assert (! (iff (Valid (Prims.hasEq Tm_refine_411)) (Valid (Prims.hasEq Prims.pattern))) :named haseqTm_refine_411))
(declare-fun Prims.SMTPat.a (Term) Term)
(declare-fun Tm_arrow_414 () Term)
(assert (! (HasType Tm_arrow_414 Tm_type) :named kinding_Tm_arrow_414))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_414) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_414)))) :named pre_typing_Tm_arrow_414))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_414) (forall ((@x1 Term)) (! (implies (HasType @x1 Tm_refine_411) (HasType (ApplyTT @x0 @x1) Tm_type)) :pattern ((ApplyTT @x0 @x1))))) :pattern ((HasTypeZ @x0 Tm_arrow_414)))) :named interpretation_Tm_arrow_414))
(declare-fun Prims.SMTPat.a@tok () Term)
(assert (! (= 416 (Term_constr_id Prims.SMTPat.a@tok)) :named fresh_token_Prims.SMTPat.a@tok))
(assert (! (forall ((@x0 Term)) (! (= (ApplyTT Prims.SMTPat.a@tok @x0) (Prims.SMTPat.a @x0)) :pattern ((ApplyTT Prims.SMTPat.a@tok @x0)))) :named token_correspondence_Prims.SMTPat.a))
(assert (! (HasType Prims.SMTPat.a@tok Tm_arrow_414) :named function_token_typing_Prims.SMTPat.a))
(assert (! (forall ((@x0 Term)) (! (implies (HasType @x0 Tm_refine_411) (HasType (Prims.SMTPat.a @x0) Tm_type)) :pattern ((Prims.SMTPat.a @x0)))) :named typing_Prims.SMTPat.a))
(assert (! (forall ((@x0 Term)) (! (= (Prims.SMTPat.a @x0) (Prims.SMTPat_a @x0)) :pattern ((Prims.SMTPat.a @x0)))) :named proj_equation_Prims.SMTPat_a))
(declare-fun Prims.SMTPat._1 (Term) Term)
(declare-fun Tm_arrow_420 () Term)
(assert (! (HasType Tm_arrow_420 Tm_type) :named kinding_Tm_arrow_420))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_420) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_420)))) :named pre_typing_Tm_arrow_420))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_420) (forall ((@x1 Term)) (! (implies (HasType @x1 Tm_refine_411) (HasType (ApplyTT @x0 @x1) (Prims.SMTPat.a @x1))) :pattern ((ApplyTT @x0 @x1))))) :pattern ((HasTypeZ @x0 Tm_arrow_420)))) :named interpretation_Tm_arrow_420))
(declare-fun Prims.SMTPat._1@tok () Term)
(assert (! (= 422 (Term_constr_id Prims.SMTPat._1@tok)) :named fresh_token_Prims.SMTPat._1@tok))
(assert (! (forall ((@x0 Term)) (! (= (ApplyTT Prims.SMTPat._1@tok @x0) (Prims.SMTPat._1 @x0)) :pattern ((ApplyTT Prims.SMTPat._1@tok @x0)))) :named token_correspondence_Prims.SMTPat._1))
(assert (! (HasType Prims.SMTPat._1@tok Tm_arrow_420) :named function_token_typing_Prims.SMTPat._1))
(assert (! (forall ((@x0 Term)) (! (implies (HasType @x0 Tm_refine_411) (HasType (Prims.SMTPat._1 @x0) (Prims.SMTPat.a @x0))) :pattern ((Prims.SMTPat._1 @x0)))) :named typing_Prims.SMTPat._1))
(assert (! (forall ((@x0 Term)) (! (= (Prims.SMTPat._1 @x0) (Prims.SMTPat__1 @x0)) :pattern ((Prims.SMTPat._1 @x0)))) :named proj_equation_Prims.SMTPat__1))
(declare-fun Tm_refine_424 () Term)
(assert (! (HasType Tm_refine_424 Tm_type) :named refinement_kinding_Tm_refine_424))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (iff (HasTypeFuel @u0 @x1 Tm_refine_424) (and (HasTypeFuel @u0 @x1 Prims.pattern) (BoxBool_proj_0 (Prims.is_SMTPatT @x1)))) :pattern ((HasTypeFuel @u0 @x1 Tm_refine_424)))) :named refinement_interpretation_Tm_refine_424))
(assert (! (iff (Valid (Prims.hasEq Tm_refine_424)) (Valid (Prims.hasEq Prims.pattern))) :named haseqTm_refine_424))
(declare-fun Prims.SMTPatT.a (Term) Term)
(declare-fun Tm_arrow_427 () Term)
(assert (! (HasType Tm_arrow_427 Tm_type) :named kinding_Tm_arrow_427))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_427) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_427)))) :named pre_typing_Tm_arrow_427))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_427) (forall ((@x1 Term)) (! (implies (HasType @x1 Tm_refine_424) (HasType (ApplyTT @x0 @x1) Tm_type)) :pattern ((ApplyTT @x0 @x1))))) :pattern ((HasTypeZ @x0 Tm_arrow_427)))) :named interpretation_Tm_arrow_427))
(declare-fun Prims.SMTPatT.a@tok () Term)
(assert (! (= 429 (Term_constr_id Prims.SMTPatT.a@tok)) :named fresh_token_Prims.SMTPatT.a@tok))
(assert (! (forall ((@x0 Term)) (! (= (ApplyTT Prims.SMTPatT.a@tok @x0) (Prims.SMTPatT.a @x0)) :pattern ((ApplyTT Prims.SMTPatT.a@tok @x0)))) :named token_correspondence_Prims.SMTPatT.a))
(assert (! (HasType Prims.SMTPatT.a@tok Tm_arrow_427) :named function_token_typing_Prims.SMTPatT.a))
(assert (! (forall ((@x0 Term)) (! (implies (HasType @x0 Tm_refine_424) (HasType (Prims.SMTPatT.a @x0) Tm_type)) :pattern ((Prims.SMTPatT.a @x0)))) :named typing_Prims.SMTPatT.a))
(assert (! (forall ((@x0 Term)) (! (= (Prims.SMTPatT.a @x0) (Prims.SMTPatT_a @x0)) :pattern ((Prims.SMTPatT.a @x0)))) :named proj_equation_Prims.SMTPatT_a))
(declare-fun Tm_refine_431 () Term)
(assert (! (HasType Tm_refine_431 Tm_type) :named refinement_kinding_Tm_refine_431))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (iff (HasTypeFuel @u0 @x1 Tm_refine_431) (and (HasTypeFuel @u0 @x1 Prims.pattern) (BoxBool_proj_0 (Prims.is_SMTPatOr @x1)))) :pattern ((HasTypeFuel @u0 @x1 Tm_refine_431)))) :named refinement_interpretation_Tm_refine_431))
(assert (! (iff (Valid (Prims.hasEq Tm_refine_431)) (Valid (Prims.hasEq Prims.pattern))) :named haseqTm_refine_431))
(declare-fun Prims.SMTPatOr._0 (Term) Term)
(declare-fun Tm_arrow_434 () Term)
(assert (! (HasType Tm_arrow_434 Tm_type) :named kinding_Tm_arrow_434))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_434) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_434)))) :named pre_typing_Tm_arrow_434))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_434) (forall ((@x1 Term)) (! (implies (HasType @x1 Tm_refine_431) (HasType (ApplyTT @x0 @x1) (Prims.list (Prims.list Prims.pattern)))) :pattern ((ApplyTT @x0 @x1))))) :pattern ((HasTypeZ @x0 Tm_arrow_434)))) :named interpretation_Tm_arrow_434))
(declare-fun Prims.SMTPatOr._0@tok () Term)
(assert (! (= 436 (Term_constr_id Prims.SMTPatOr._0@tok)) :named fresh_token_Prims.SMTPatOr._0@tok))
(assert (! (forall ((@x0 Term)) (! (= (ApplyTT Prims.SMTPatOr._0@tok @x0) (Prims.SMTPatOr._0 @x0)) :pattern ((ApplyTT Prims.SMTPatOr._0@tok @x0)))) :named token_correspondence_Prims.SMTPatOr._0))
(assert (! (HasType Prims.SMTPatOr._0@tok Tm_arrow_434) :named function_token_typing_Prims.SMTPatOr._0))
(assert (! (forall ((@x0 Term)) (! (implies (HasType @x0 Tm_refine_431) (HasType (Prims.SMTPatOr._0 @x0) (Prims.list (Prims.list Prims.pattern)))) :pattern ((Prims.SMTPatOr._0 @x0)))) :named typing_Prims.SMTPatOr._0))
(assert (! (forall ((@x0 Term)) (! (= (Prims.SMTPatOr._0 @x0) (Prims.SMTPatOr__0 @x0)) :pattern ((Prims.SMTPatOr._0 @x0)))) :named proj_equation_Prims.SMTPatOr__0))
(declare-fun Prims.decreases (Term Term) Term)
(declare-fun Prims.decreases@tok () Term)
(assert (! (= 438 (Term_constr_id Prims.decreases@tok)) :named fresh_token_Prims.decreases@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (ApplyTT (ApplyTT Prims.decreases@tok @x0) @x1) (Prims.decreases @x0 @x1)) :pattern ((ApplyTT (ApplyTT Prims.decreases@tok @x0) @x1)))) :named token_correspondence_Prims.decreases))
(assert (! (HasType Prims.decreases@tok Tm_arrow_300) :named function_token_typing_Prims.decreases))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 @x0)) (HasType (Prims.decreases @x0 @x1) Tm_type)) :pattern ((Prims.decreases @x0 @x1)))) :named typing_Prims.decreases))
(declare-fun Prims.option (Term) Term)
(declare-fun Prims.option@x0 (Term) Term)
(declare-fun Prims.option@tok () Term)
(declare-fun Prims.None (Term) Term)
(declare-fun Prims.None_a (Term) Term)
(declare-fun Tm_arrow_451 () Term)
(declare-fun Prims.None@tok () Term)
(declare-fun Prims.Some (Term Term) Term)
(declare-fun Prims.Some_a (Term) Term)
(declare-fun Prims.Some_v (Term) Term)
(declare-fun Tm_arrow_457 () Term)
(declare-fun Prims.Some@tok () Term)
(assert (! (forall ((@x0 Term)) (! (= 439 (Term_constr_id (Prims.option @x0))) :pattern ((Prims.option @x0)))) :named constructor_distinct_Prims.option))
(assert (! (forall ((@x0 Term)) (! (= (Prims.option@x0 (Prims.option @x0)) @x0) :pattern ((Prims.option @x0)))) :named projection_inverse_Prims.option@x0))
(define-fun is-Prims.option ((@x0 Term)) Bool (and (= (Term_constr_id @x0) 439) (= @x0 (Prims.option (Prims.option@x0 @x0)))))
(assert (! (= 440 (Term_constr_id Prims.option@tok)) :named fresh_token_Prims.option@tok))
(assert (! (forall ((@x0 Term)) (! (= (ApplyTT Prims.option@tok @x0) (Prims.option @x0)) :pattern ((ApplyTT Prims.option@tok @x0)) :pattern ((Prims.option @x0)))) :named token_correspondence_Prims.option@tok))
(assert (! (is-Tm_arrow (PreType Prims.option@tok)) :named pre_kinding_Prims.option@tok))
(assert (! (forall ((@x0 Term)) (! (implies (HasType @x0 Tm_type) (HasType (Prims.option @x0) Tm_type)) :pattern ((Prims.option @x0)))) :named kinding_Prims.option@tok))
(assert (! (forall ((@x0 Term) (@u1 Fuel) (@x2 Term)) (! (implies (HasTypeFuel @u1 @x0 (Prims.option @x2)) (= (Prims.option @x2) (PreType @x0))) :pattern ((HasTypeFuel @u1 @x0 (Prims.option @x2))))) :named @pretyping__447))
(assert (! (forall ((@x0 Term)) (! (= 449 (Term_constr_id (Prims.None @x0))) :pattern ((Prims.None @x0)))) :named constructor_distinct_Prims.None))
(assert (! (forall ((@x0 Term)) (! (= (Prims.None_a (Prims.None @x0)) @x0) :pattern ((Prims.None @x0)))) :named projection_inverse_Prims.None_a))
(define-fun is-Prims.None ((@x0 Term)) Bool (and (= (Term_constr_id @x0) 449) (= @x0 (Prims.None (Prims.None_a @x0)))))
(assert (! (HasType Tm_arrow_451 Tm_type) :named kinding_Tm_arrow_451))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_451) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_451)))) :named pre_typing_Tm_arrow_451))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_451) (forall ((@x1 Term)) (! (implies (HasType @x1 Tm_type) (HasType (ApplyTT @x0 @x1) (Prims.option @x1))) :pattern ((ApplyTT @x0 @x1))))) :pattern ((HasTypeZ @x0 Tm_arrow_451)))) :named interpretation_Tm_arrow_451))
(assert (! (= 453 (Term_constr_id Prims.None@tok)) :named fresh_token_Prims.None@tok))
(assert (! (HasType Prims.None@tok Tm_arrow_451) :named typing_tok_Prims.None@tok))
(assert (! (forall ((@x0 Term)) (! (= (ApplyTT Prims.None@tok @x0) (Prims.None @x0)) :pattern ((ApplyTT Prims.None@tok @x0)))) :named equality_tok_Prims.None@tok))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_type) (HasTypeFuel @u0 (Prims.None @x1) (Prims.option @x1))) :pattern ((HasTypeFuel @u0 (Prims.None @x1) (Prims.option @x1))))) :named data_typing_intro_Prims.None@tok))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel (SFuel @u0) (Prims.None @x1) (Prims.option @x2)) (and (= @x1 @x2) (HasTypeFuel @u0 @x1 Tm_type))) :pattern ((HasTypeFuel (SFuel @u0) (Prims.None @x1) (Prims.option @x2))))) :named data_elim_Prims.None))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel (SFuel @u0) (Prims.None @x1) (Prims.option @x2)) (Valid (Precedes @x1 (Prims.None @x1)))) :pattern ((HasTypeFuel (SFuel @u0) (Prims.None @x1) (Prims.option @x2))))) :named subterm_ordering_Prims.None))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= 455 (Term_constr_id (Prims.Some @x0 @x1))) :pattern ((Prims.Some @x0 @x1)))) :named constructor_distinct_Prims.Some))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (Prims.Some_a (Prims.Some @x0 @x1)) @x0) :pattern ((Prims.Some @x0 @x1)))) :named projection_inverse_Prims.Some_a))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (Prims.Some_v (Prims.Some @x0 @x1)) @x1) :pattern ((Prims.Some @x0 @x1)))) :named projection_inverse_Prims.Some_v))
(define-fun is-Prims.Some ((@x0 Term)) Bool (and (= (Term_constr_id @x0) 455) (= @x0 (Prims.Some (Prims.Some_a @x0) (Prims.Some_v @x0)))))
(assert (! (HasType Tm_arrow_457 Tm_type) :named kinding_Tm_arrow_457))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_457) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_457)))) :named pre_typing_Tm_arrow_457))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_457) (forall ((@x1 Term) (@x2 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 @x1)) (HasType (ApplyTT (ApplyTT @x0 @x1) @x2) (Prims.option @x1))) :pattern ((ApplyTT (ApplyTT @x0 @x1) @x2))))) :pattern ((HasTypeZ @x0 Tm_arrow_457)))) :named interpretation_Tm_arrow_457))
(assert (! (= 459 (Term_constr_id Prims.Some@tok)) :named fresh_token_Prims.Some@tok))
(assert (! (HasType Prims.Some@tok Tm_arrow_457) :named typing_tok_Prims.Some@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (ApplyTT (ApplyTT Prims.Some@tok @x0) @x1) (Prims.Some @x0 @x1)) :pattern ((ApplyTT (ApplyTT Prims.Some@tok @x0) @x1)))) :named equality_tok_Prims.Some@tok))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (and (HasTypeFuel @u0 @x1 Tm_type) (HasTypeFuel @u0 @x2 @x1)) (HasTypeFuel @u0 (Prims.Some @x1 @x2) (Prims.option @x1))) :pattern ((HasTypeFuel @u0 (Prims.Some @x1 @x2) (Prims.option @x1))))) :named data_typing_intro_Prims.Some@tok))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (HasTypeFuel (SFuel @u0) (Prims.Some @x1 @x2) (Prims.option @x3)) (and (= @x1 @x3) (HasTypeFuel @u0 @x1 Tm_type) (HasTypeFuel @u0 @x2 @x1))) :pattern ((HasTypeFuel (SFuel @u0) (Prims.Some @x1 @x2) (Prims.option @x3))))) :named data_elim_Prims.Some))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (HasTypeFuel (SFuel @u0) (Prims.Some @x1 @x2) (Prims.option @x3)) (and (Valid (Precedes @x1 (Prims.Some @x1 @x2))) (Valid (Precedes @x2 (Prims.Some @x1 @x2))))) :pattern ((HasTypeFuel (SFuel @u0) (Prims.Some @x1 @x2) (Prims.option @x3))))) :named subterm_ordering_Prims.Some))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel (SFuel @u0) @x1 (Prims.option @x2)) (or (and (is-Prims.None @x1) (= @x2 (Prims.None_a @x1))) (and (is-Prims.Some @x1) (= @x2 (Prims.Some_a @x1))))) :pattern ((HasTypeFuel (SFuel @u0) @x1 (Prims.option @x2))))) :named fuel_guarded_inversion_Prims.option_443))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel @u0 @x1 (Prims.option @x2)) (or (and (is-Prims.None @x1) (= @x2 (Prims.None_a @x1))) (and (is-Prims.Some @x1) (= @x2 (Prims.Some_a @x1))))) :pattern ((HasTypeFuel @u0 @x1 (Prims.option @x2)) (Prims.inversion (Prims.option @x2))))) :named pattern_guarded_inversion_Prims.option_444))
(declare-fun Prims.is_None (Term Term) Term)
(declare-fun Tm_arrow_461 (Term) Term)
(assert (! (forall ((@x0 Term)) (! (HasType (Tm_arrow_461 @x0) Tm_type) :pattern ((HasType (Tm_arrow_461 @x0) Tm_type)))) :named kinding_Tm_arrow_461))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_461 @x2)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_461 @x2))))) :named pre_typing_Tm_arrow_461))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_461 @x1)) (forall ((@x2 Term) (@x3 Term)) (! (implies (and (HasType @x2 Tm_type) (HasType @x3 (Prims.option @x2))) (HasType (ApplyTT (ApplyTT @x0 @x2) @x3) @x1)) :pattern ((ApplyTT (ApplyTT @x0 @x2) @x3))))) :pattern ((HasTypeZ @x0 (Tm_arrow_461 @x1))))) :named interpretation_Tm_arrow_461))
(declare-fun Prims.is_None@tok () Term)
(assert (! (= 463 (Term_constr_id Prims.is_None@tok)) :named fresh_token_Prims.is_None@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (ApplyTT (ApplyTT Prims.is_None@tok @x0) @x1) (Prims.is_None @x0 @x1)) :pattern ((ApplyTT (ApplyTT Prims.is_None@tok @x0) @x1)))) :named token_correspondence_Prims.is_None))
(assert (! (HasType Prims.is_None@tok (Tm_arrow_461 Prims.bool)) :named function_token_typing_Prims.is_None))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 (Prims.option @x0))) (HasType (Prims.is_None @x0 @x1) Prims.bool)) :pattern ((Prims.is_None @x0 @x1)))) :named typing_Prims.is_None))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (Prims.is_None @x0 @x1) (BoxBool (is-Prims.None @x1))) :pattern ((Prims.is_None @x0 @x1)))) :named disc_equation_Prims.None))
(declare-fun Prims.is_Some (Term Term) Term)
(declare-fun Prims.is_Some@tok () Term)
(assert (! (= 465 (Term_constr_id Prims.is_Some@tok)) :named fresh_token_Prims.is_Some@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (ApplyTT (ApplyTT Prims.is_Some@tok @x0) @x1) (Prims.is_Some @x0 @x1)) :pattern ((ApplyTT (ApplyTT Prims.is_Some@tok @x0) @x1)))) :named token_correspondence_Prims.is_Some))
(assert (! (HasType Prims.is_Some@tok (Tm_arrow_461 Prims.bool)) :named function_token_typing_Prims.is_Some))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 (Prims.option @x0))) (HasType (Prims.is_Some @x0 @x1) Prims.bool)) :pattern ((Prims.is_Some @x0 @x1)))) :named typing_Prims.is_Some))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (Prims.is_Some @x0 @x1) (BoxBool (is-Prims.Some @x1))) :pattern ((Prims.is_Some @x0 @x1)))) :named disc_equation_Prims.Some))
(declare-fun Tm_refine_467 (Term) Term)
(assert (! (forall ((@x0 Term)) (! (HasType (Tm_refine_467 @x0) Tm_type) :pattern ((HasType (Tm_refine_467 @x0) Tm_type)))) :named refinement_kinding_Tm_refine_467))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (iff (HasTypeFuel @u0 @x1 (Tm_refine_467 @x2)) (and (HasTypeFuel @u0 @x1 (Prims.option @x2)) (BoxBool_proj_0 (Prims.is_Some @x2 @x1)))) :pattern ((HasTypeFuel @u0 @x1 (Tm_refine_467 @x2))))) :named refinement_interpretation_Tm_refine_467))
(assert (! (forall ((@x0 Term)) (! (iff (Valid (Prims.hasEq (Tm_refine_467 @x0))) (Valid (Prims.hasEq (Prims.option @x0)))) :pattern ((Valid (Prims.hasEq (Tm_refine_467 @x0)))))) :named haseqTm_refine_467))
(declare-fun Prims.Some.v (Term Term) Term)
(declare-fun Tm_arrow_470 () Term)
(assert (! (HasType Tm_arrow_470 Tm_type) :named kinding_Tm_arrow_470))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_470) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_470)))) :named pre_typing_Tm_arrow_470))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_470) (forall ((@x1 Term) (@x2 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 (Tm_refine_467 @x1))) (HasType (ApplyTT (ApplyTT @x0 @x1) @x2) @x1)) :pattern ((ApplyTT (ApplyTT @x0 @x1) @x2))))) :pattern ((HasTypeZ @x0 Tm_arrow_470)))) :named interpretation_Tm_arrow_470))
(declare-fun Prims.Some.v@tok () Term)
(assert (! (= 472 (Term_constr_id Prims.Some.v@tok)) :named fresh_token_Prims.Some.v@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (ApplyTT (ApplyTT Prims.Some.v@tok @x0) @x1) (Prims.Some.v @x0 @x1)) :pattern ((ApplyTT (ApplyTT Prims.Some.v@tok @x0) @x1)))) :named token_correspondence_Prims.Some.v))
(assert (! (HasType Prims.Some.v@tok Tm_arrow_470) :named function_token_typing_Prims.Some.v))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 (Tm_refine_467 @x0))) (HasType (Prims.Some.v @x0 @x1) @x0)) :pattern ((Prims.Some.v @x0 @x1)))) :named typing_Prims.Some.v))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (Prims.Some.v @x0 @x1) (Prims.Some_v @x1)) :pattern ((Prims.Some.v @x0 @x1)))) :named proj_equation_Prims.Some_v))
(assert (! (forall ((@x0 Term)) (! (implies (and (HasType @x0 Tm_type) (Valid (Prims.hasEq @x0))) (Valid (Prims.hasEq (Prims.option @x0)))) :pattern ((Prims.hasEq (Prims.option @x0))))) :named assumption_Prims.HasEq_option_473))
(declare-fun Prims.either (Term Term) Term)
(declare-fun Prims.either@x0 (Term) Term)
(declare-fun Prims.either@x1 (Term) Term)
(declare-fun Prims.either@tok () Term)
(declare-fun Prims.Inl (Term Term Term) Term)
(declare-fun Prims.Inl__a (Term) Term)
(declare-fun Prims.Inl__b (Term) Term)
(declare-fun Prims.Inl_v (Term) Term)
(declare-fun Tm_arrow_486 () Term)
(declare-fun Prims.Inl@tok () Term)
(declare-fun Prims.Inr (Term Term Term) Term)
(declare-fun Prims.Inr__a (Term) Term)
(declare-fun Prims.Inr__b (Term) Term)
(declare-fun Prims.Inr_v (Term) Term)
(declare-fun Tm_arrow_492 () Term)
(declare-fun Prims.Inr@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= 474 (Term_constr_id (Prims.either @x0 @x1))) :pattern ((Prims.either @x0 @x1)))) :named constructor_distinct_Prims.either))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (Prims.either@x0 (Prims.either @x0 @x1)) @x0) :pattern ((Prims.either @x0 @x1)))) :named projection_inverse_Prims.either@x0))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (Prims.either@x1 (Prims.either @x0 @x1)) @x1) :pattern ((Prims.either @x0 @x1)))) :named projection_inverse_Prims.either@x1))
(define-fun is-Prims.either ((@x0 Term)) Bool (and (= (Term_constr_id @x0) 474) (= @x0 (Prims.either (Prims.either@x0 @x0) (Prims.either@x1 @x0)))))
(assert (! (= 475 (Term_constr_id Prims.either@tok)) :named fresh_token_Prims.either@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (ApplyTT (ApplyTT Prims.either@tok @x0) @x1) (Prims.either @x0 @x1)) :pattern ((ApplyTT (ApplyTT Prims.either@tok @x0) @x1)) :pattern ((Prims.either @x0 @x1)))) :named token_correspondence_Prims.either@tok))
(assert (! (is-Tm_arrow (PreType Prims.either@tok)) :named pre_kinding_Prims.either@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type)) (HasType (Prims.either @x0 @x1) Tm_type)) :pattern ((Prims.either @x0 @x1)))) :named kinding_Prims.either@tok))
(assert (! (forall ((@x0 Term) (@u1 Fuel) (@x2 Term) (@x3 Term)) (! (implies (HasTypeFuel @u1 @x0 (Prims.either @x2 @x3)) (= (Prims.either @x2 @x3) (PreType @x0))) :pattern ((HasTypeFuel @u1 @x0 (Prims.either @x2 @x3))))) :named @pretyping__482))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= 484 (Term_constr_id (Prims.Inl @x0 @x1 @x2))) :pattern ((Prims.Inl @x0 @x1 @x2)))) :named constructor_distinct_Prims.Inl))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (Prims.Inl__a (Prims.Inl @x0 @x1 @x2)) @x0) :pattern ((Prims.Inl @x0 @x1 @x2)))) :named projection_inverse_Prims.Inl__a))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (Prims.Inl__b (Prims.Inl @x0 @x1 @x2)) @x1) :pattern ((Prims.Inl @x0 @x1 @x2)))) :named projection_inverse_Prims.Inl__b))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (Prims.Inl_v (Prims.Inl @x0 @x1 @x2)) @x2) :pattern ((Prims.Inl @x0 @x1 @x2)))) :named projection_inverse_Prims.Inl_v))
(define-fun is-Prims.Inl ((@x0 Term)) Bool (and (= (Term_constr_id @x0) 484) (= @x0 (Prims.Inl (Prims.Inl__a @x0) (Prims.Inl__b @x0) (Prims.Inl_v @x0)))))
(assert (! (HasType Tm_arrow_486 Tm_type) :named kinding_Tm_arrow_486))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_486) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_486)))) :named pre_typing_Tm_arrow_486))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_486) (forall ((@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 @x1)) (HasType (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) (Prims.either @x1 @x2))) :pattern ((ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3))))) :pattern ((HasTypeZ @x0 Tm_arrow_486)))) :named interpretation_Tm_arrow_486))
(assert (! (= 488 (Term_constr_id Prims.Inl@tok)) :named fresh_token_Prims.Inl@tok))
(assert (! (HasType Prims.Inl@tok Tm_arrow_486) :named typing_tok_Prims.Inl@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT Prims.Inl@tok @x0) @x1) @x2) (Prims.Inl @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT Prims.Inl@tok @x0) @x1) @x2)))) :named equality_tok_Prims.Inl@tok))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasTypeFuel @u0 @x1 Tm_type) (HasTypeFuel @u0 @x2 Tm_type) (HasTypeFuel @u0 @x3 @x1)) (HasTypeFuel @u0 (Prims.Inl @x1 @x2 @x3) (Prims.either @x1 @x2))) :pattern ((HasTypeFuel @u0 (Prims.Inl @x1 @x2 @x3) (Prims.either @x1 @x2))))) :named data_typing_intro_Prims.Inl@tok))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (implies (HasTypeFuel (SFuel @u0) (Prims.Inl @x1 @x2 @x3) (Prims.either @x4 @x5)) (and (= @x2 @x5) (= @x1 @x4) (HasTypeFuel @u0 @x1 Tm_type) (HasTypeFuel @u0 @x2 Tm_type) (HasTypeFuel @u0 @x3 @x1))) :pattern ((HasTypeFuel (SFuel @u0) (Prims.Inl @x1 @x2 @x3) (Prims.either @x4 @x5))))) :named data_elim_Prims.Inl))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (implies (HasTypeFuel (SFuel @u0) (Prims.Inl @x1 @x2 @x3) (Prims.either @x4 @x5)) (and (Valid (Precedes @x1 (Prims.Inl @x1 @x2 @x3))) (Valid (Precedes @x2 (Prims.Inl @x1 @x2 @x3))) (Valid (Precedes @x3 (Prims.Inl @x1 @x2 @x3))))) :pattern ((HasTypeFuel (SFuel @u0) (Prims.Inl @x1 @x2 @x3) (Prims.either @x4 @x5))))) :named subterm_ordering_Prims.Inl))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= 490 (Term_constr_id (Prims.Inr @x0 @x1 @x2))) :pattern ((Prims.Inr @x0 @x1 @x2)))) :named constructor_distinct_Prims.Inr))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (Prims.Inr__a (Prims.Inr @x0 @x1 @x2)) @x0) :pattern ((Prims.Inr @x0 @x1 @x2)))) :named projection_inverse_Prims.Inr__a))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (Prims.Inr__b (Prims.Inr @x0 @x1 @x2)) @x1) :pattern ((Prims.Inr @x0 @x1 @x2)))) :named projection_inverse_Prims.Inr__b))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (Prims.Inr_v (Prims.Inr @x0 @x1 @x2)) @x2) :pattern ((Prims.Inr @x0 @x1 @x2)))) :named projection_inverse_Prims.Inr_v))
(define-fun is-Prims.Inr ((@x0 Term)) Bool (and (= (Term_constr_id @x0) 490) (= @x0 (Prims.Inr (Prims.Inr__a @x0) (Prims.Inr__b @x0) (Prims.Inr_v @x0)))))
(assert (! (HasType Tm_arrow_492 Tm_type) :named kinding_Tm_arrow_492))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_492) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_492)))) :named pre_typing_Tm_arrow_492))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_492) (forall ((@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 @x2)) (HasType (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) (Prims.either @x1 @x2))) :pattern ((ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3))))) :pattern ((HasTypeZ @x0 Tm_arrow_492)))) :named interpretation_Tm_arrow_492))
(assert (! (= 494 (Term_constr_id Prims.Inr@tok)) :named fresh_token_Prims.Inr@tok))
(assert (! (HasType Prims.Inr@tok Tm_arrow_492) :named typing_tok_Prims.Inr@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT Prims.Inr@tok @x0) @x1) @x2) (Prims.Inr @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT Prims.Inr@tok @x0) @x1) @x2)))) :named equality_tok_Prims.Inr@tok))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasTypeFuel @u0 @x1 Tm_type) (HasTypeFuel @u0 @x2 Tm_type) (HasTypeFuel @u0 @x3 @x2)) (HasTypeFuel @u0 (Prims.Inr @x1 @x2 @x3) (Prims.either @x1 @x2))) :pattern ((HasTypeFuel @u0 (Prims.Inr @x1 @x2 @x3) (Prims.either @x1 @x2))))) :named data_typing_intro_Prims.Inr@tok))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (implies (HasTypeFuel (SFuel @u0) (Prims.Inr @x1 @x2 @x3) (Prims.either @x4 @x5)) (and (= @x2 @x5) (= @x1 @x4) (HasTypeFuel @u0 @x1 Tm_type) (HasTypeFuel @u0 @x2 Tm_type) (HasTypeFuel @u0 @x3 @x2))) :pattern ((HasTypeFuel (SFuel @u0) (Prims.Inr @x1 @x2 @x3) (Prims.either @x4 @x5))))) :named data_elim_Prims.Inr))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (implies (HasTypeFuel (SFuel @u0) (Prims.Inr @x1 @x2 @x3) (Prims.either @x4 @x5)) (and (Valid (Precedes @x1 (Prims.Inr @x1 @x2 @x3))) (Valid (Precedes @x2 (Prims.Inr @x1 @x2 @x3))) (Valid (Precedes @x3 (Prims.Inr @x1 @x2 @x3))))) :pattern ((HasTypeFuel (SFuel @u0) (Prims.Inr @x1 @x2 @x3) (Prims.either @x4 @x5))))) :named subterm_ordering_Prims.Inr))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (HasTypeFuel (SFuel @u0) @x1 (Prims.either @x2 @x3)) (or (and (is-Prims.Inl @x1) (= @x2 (Prims.Inl__a @x1)) (= @x3 (Prims.Inl__b @x1))) (and (is-Prims.Inr @x1) (= @x2 (Prims.Inr__a @x1)) (= @x3 (Prims.Inr__b @x1))))) :pattern ((HasTypeFuel (SFuel @u0) @x1 (Prims.either @x2 @x3))))) :named fuel_guarded_inversion_Prims.either_478))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (HasTypeFuel @u0 @x1 (Prims.either @x2 @x3)) (or (and (is-Prims.Inl @x1) (= @x2 (Prims.Inl__a @x1)) (= @x3 (Prims.Inl__b @x1))) (and (is-Prims.Inr @x1) (= @x2 (Prims.Inr__a @x1)) (= @x3 (Prims.Inr__b @x1))))) :pattern ((HasTypeFuel @u0 @x1 (Prims.either @x2 @x3)) (Prims.inversion (Prims.either @x2 @x3))))) :named pattern_guarded_inversion_Prims.either_479))
(declare-fun Prims.is_Inl (Term Term Term) Term)
(declare-fun Tm_arrow_496 (Term) Term)
(assert (! (forall ((@x0 Term)) (! (HasType (Tm_arrow_496 @x0) Tm_type) :pattern ((HasType (Tm_arrow_496 @x0) Tm_type)))) :named kinding_Tm_arrow_496))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_496 @x2)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_496 @x2))))) :named pre_typing_Tm_arrow_496))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_496 @x1)) (forall ((@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 (Prims.either @x2 @x3))) (HasType (ApplyTT (ApplyTT (ApplyTT @x0 @x2) @x3) @x4) @x1)) :pattern ((ApplyTT (ApplyTT (ApplyTT @x0 @x2) @x3) @x4))))) :pattern ((HasTypeZ @x0 (Tm_arrow_496 @x1))))) :named interpretation_Tm_arrow_496))
(declare-fun Prims.is_Inl@tok () Term)
(assert (! (= 498 (Term_constr_id Prims.is_Inl@tok)) :named fresh_token_Prims.is_Inl@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT Prims.is_Inl@tok @x0) @x1) @x2) (Prims.is_Inl @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT Prims.is_Inl@tok @x0) @x1) @x2)))) :named token_correspondence_Prims.is_Inl))
(assert (! (HasType Prims.is_Inl@tok (Tm_arrow_496 Prims.bool)) :named function_token_typing_Prims.is_Inl))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 (Prims.either @x0 @x1))) (HasType (Prims.is_Inl @x0 @x1 @x2) Prims.bool)) :pattern ((Prims.is_Inl @x0 @x1 @x2)))) :named typing_Prims.is_Inl))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (Prims.is_Inl @x0 @x1 @x2) (BoxBool (is-Prims.Inl @x2))) :pattern ((Prims.is_Inl @x0 @x1 @x2)))) :named disc_equation_Prims.Inl))
(declare-fun Prims.is_Inr (Term Term Term) Term)
(declare-fun Prims.is_Inr@tok () Term)
(assert (! (= 500 (Term_constr_id Prims.is_Inr@tok)) :named fresh_token_Prims.is_Inr@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT Prims.is_Inr@tok @x0) @x1) @x2) (Prims.is_Inr @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT Prims.is_Inr@tok @x0) @x1) @x2)))) :named token_correspondence_Prims.is_Inr))
(assert (! (HasType Prims.is_Inr@tok (Tm_arrow_496 Prims.bool)) :named function_token_typing_Prims.is_Inr))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 (Prims.either @x0 @x1))) (HasType (Prims.is_Inr @x0 @x1 @x2) Prims.bool)) :pattern ((Prims.is_Inr @x0 @x1 @x2)))) :named typing_Prims.is_Inr))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (Prims.is_Inr @x0 @x1 @x2) (BoxBool (is-Prims.Inr @x2))) :pattern ((Prims.is_Inr @x0 @x1 @x2)))) :named disc_equation_Prims.Inr))
(declare-fun Tm_refine_502 (Term Term) Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (HasType (Tm_refine_502 @x0 @x1) Tm_type) :pattern ((HasType (Tm_refine_502 @x0 @x1) Tm_type)))) :named refinement_kinding_Tm_refine_502))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (iff (HasTypeFuel @u0 @x1 (Tm_refine_502 @x2 @x3)) (and (HasTypeFuel @u0 @x1 (Prims.either @x3 @x2)) (BoxBool_proj_0 (Prims.is_Inl @x3 @x2 @x1)))) :pattern ((HasTypeFuel @u0 @x1 (Tm_refine_502 @x2 @x3))))) :named refinement_interpretation_Tm_refine_502))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (Valid (Prims.hasEq (Tm_refine_502 @x0 @x1))) (Valid (Prims.hasEq (Prims.either @x1 @x0)))) :pattern ((Valid (Prims.hasEq (Tm_refine_502 @x0 @x1)))))) :named haseqTm_refine_502))
(declare-fun Prims.Inl.v (Term Term Term) Term)
(declare-fun Tm_arrow_505 () Term)
(assert (! (HasType Tm_arrow_505 Tm_type) :named kinding_Tm_arrow_505))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_505) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_505)))) :named pre_typing_Tm_arrow_505))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_505) (forall ((@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 (Tm_refine_502 @x2 @x1))) (HasType (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x1)) :pattern ((ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3))))) :pattern ((HasTypeZ @x0 Tm_arrow_505)))) :named interpretation_Tm_arrow_505))
(declare-fun Prims.Inl.v@tok () Term)
(assert (! (= 507 (Term_constr_id Prims.Inl.v@tok)) :named fresh_token_Prims.Inl.v@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT Prims.Inl.v@tok @x0) @x1) @x2) (Prims.Inl.v @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT Prims.Inl.v@tok @x0) @x1) @x2)))) :named token_correspondence_Prims.Inl.v))
(assert (! (HasType Prims.Inl.v@tok Tm_arrow_505) :named function_token_typing_Prims.Inl.v))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 (Tm_refine_502 @x1 @x0))) (HasType (Prims.Inl.v @x0 @x1 @x2) @x0)) :pattern ((Prims.Inl.v @x0 @x1 @x2)))) :named typing_Prims.Inl.v))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (Prims.Inl.v @x0 @x1 @x2) (Prims.Inl_v @x2)) :pattern ((Prims.Inl.v @x0 @x1 @x2)))) :named proj_equation_Prims.Inl_v))
(declare-fun Tm_refine_509 (Term Term) Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (HasType (Tm_refine_509 @x0 @x1) Tm_type) :pattern ((HasType (Tm_refine_509 @x0 @x1) Tm_type)))) :named refinement_kinding_Tm_refine_509))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (iff (HasTypeFuel @u0 @x1 (Tm_refine_509 @x2 @x3)) (and (HasTypeFuel @u0 @x1 (Prims.either @x3 @x2)) (BoxBool_proj_0 (Prims.is_Inr @x3 @x2 @x1)))) :pattern ((HasTypeFuel @u0 @x1 (Tm_refine_509 @x2 @x3))))) :named refinement_interpretation_Tm_refine_509))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (Valid (Prims.hasEq (Tm_refine_509 @x0 @x1))) (Valid (Prims.hasEq (Prims.either @x1 @x0)))) :pattern ((Valid (Prims.hasEq (Tm_refine_509 @x0 @x1)))))) :named haseqTm_refine_509))
(declare-fun Prims.Inr.v (Term Term Term) Term)
(declare-fun Tm_arrow_512 () Term)
(assert (! (HasType Tm_arrow_512 Tm_type) :named kinding_Tm_arrow_512))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_512) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_512)))) :named pre_typing_Tm_arrow_512))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_512) (forall ((@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 (Tm_refine_509 @x2 @x1))) (HasType (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3))))) :pattern ((HasTypeZ @x0 Tm_arrow_512)))) :named interpretation_Tm_arrow_512))
(declare-fun Prims.Inr.v@tok () Term)
(assert (! (= 514 (Term_constr_id Prims.Inr.v@tok)) :named fresh_token_Prims.Inr.v@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT Prims.Inr.v@tok @x0) @x1) @x2) (Prims.Inr.v @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT Prims.Inr.v@tok @x0) @x1) @x2)))) :named token_correspondence_Prims.Inr.v))
(assert (! (HasType Prims.Inr.v@tok Tm_arrow_512) :named function_token_typing_Prims.Inr.v))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 (Tm_refine_509 @x1 @x0))) (HasType (Prims.Inr.v @x0 @x1 @x2) @x1)) :pattern ((Prims.Inr.v @x0 @x1 @x2)))) :named typing_Prims.Inr.v))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (Prims.Inr.v @x0 @x1 @x2) (Prims.Inr_v @x2)) :pattern ((Prims.Inr.v @x0 @x1 @x2)))) :named proj_equation_Prims.Inr_v))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (Valid (Prims.hasEq @x0)) (Valid (Prims.hasEq @x1))) (Valid (Prims.hasEq (Prims.either @x0 @x1)))) :pattern ((Prims.hasEq (Prims.either @x0 @x1))))) :named assumption_Prims.HasEq_either_515))
(declare-fun Prims.result (Term) Term)
(declare-fun Prims.result@x0 (Term) Term)
(declare-fun Prims.result@tok () Term)
(declare-fun Prims.V (Term Term) Term)
(declare-fun Prims.V_a (Term) Term)
(declare-fun Prims.V_v (Term) Term)
(declare-fun Tm_arrow_528 () Term)
(declare-fun Prims.V@tok () Term)
(declare-fun Prims.E (Term Term) Term)
(declare-fun Prims.E_a (Term) Term)
(declare-fun Prims.E_e (Term) Term)
(declare-fun Tm_arrow_534 (Term) Term)
(declare-fun Prims.E@tok () Term)
(declare-fun Prims.Err (Term Term) Term)
(declare-fun Prims.Err_a (Term) Term)
(declare-fun Prims.Err_msg (Term) Term)
(declare-fun Prims.Err@tok () Term)
(assert (! (forall ((@x0 Term)) (! (= 516 (Term_constr_id (Prims.result @x0))) :pattern ((Prims.result @x0)))) :named constructor_distinct_Prims.result))
(assert (! (forall ((@x0 Term)) (! (= (Prims.result@x0 (Prims.result @x0)) @x0) :pattern ((Prims.result @x0)))) :named projection_inverse_Prims.result@x0))
(define-fun is-Prims.result ((@x0 Term)) Bool (and (= (Term_constr_id @x0) 516) (= @x0 (Prims.result (Prims.result@x0 @x0)))))
(assert (! (= 517 (Term_constr_id Prims.result@tok)) :named fresh_token_Prims.result@tok))
(assert (! (forall ((@x0 Term)) (! (= (ApplyTT Prims.result@tok @x0) (Prims.result @x0)) :pattern ((ApplyTT Prims.result@tok @x0)) :pattern ((Prims.result @x0)))) :named token_correspondence_Prims.result@tok))
(assert (! (is-Tm_arrow (PreType Prims.result@tok)) :named pre_kinding_Prims.result@tok))
(assert (! (forall ((@x0 Term)) (! (implies (HasType @x0 Tm_type) (HasType (Prims.result @x0) Tm_type)) :pattern ((Prims.result @x0)))) :named kinding_Prims.result@tok))
(assert (! (forall ((@x0 Term) (@u1 Fuel) (@x2 Term)) (! (implies (HasTypeFuel @u1 @x0 (Prims.result @x2)) (= (Prims.result @x2) (PreType @x0))) :pattern ((HasTypeFuel @u1 @x0 (Prims.result @x2))))) :named @pretyping__524))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= 526 (Term_constr_id (Prims.V @x0 @x1))) :pattern ((Prims.V @x0 @x1)))) :named constructor_distinct_Prims.V))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (Prims.V_a (Prims.V @x0 @x1)) @x0) :pattern ((Prims.V @x0 @x1)))) :named projection_inverse_Prims.V_a))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (Prims.V_v (Prims.V @x0 @x1)) @x1) :pattern ((Prims.V @x0 @x1)))) :named projection_inverse_Prims.V_v))
(define-fun is-Prims.V ((@x0 Term)) Bool (and (= (Term_constr_id @x0) 526) (= @x0 (Prims.V (Prims.V_a @x0) (Prims.V_v @x0)))))
(assert (! (HasType Tm_arrow_528 Tm_type) :named kinding_Tm_arrow_528))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_528) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_528)))) :named pre_typing_Tm_arrow_528))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_528) (forall ((@x1 Term) (@x2 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 @x1)) (HasType (ApplyTT (ApplyTT @x0 @x1) @x2) (Prims.result @x1))) :pattern ((ApplyTT (ApplyTT @x0 @x1) @x2))))) :pattern ((HasTypeZ @x0 Tm_arrow_528)))) :named interpretation_Tm_arrow_528))
(assert (! (= 530 (Term_constr_id Prims.V@tok)) :named fresh_token_Prims.V@tok))
(assert (! (HasType Prims.V@tok Tm_arrow_528) :named typing_tok_Prims.V@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (ApplyTT (ApplyTT Prims.V@tok @x0) @x1) (Prims.V @x0 @x1)) :pattern ((ApplyTT (ApplyTT Prims.V@tok @x0) @x1)))) :named equality_tok_Prims.V@tok))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (and (HasTypeFuel @u0 @x1 Tm_type) (HasTypeFuel @u0 @x2 @x1)) (HasTypeFuel @u0 (Prims.V @x1 @x2) (Prims.result @x1))) :pattern ((HasTypeFuel @u0 (Prims.V @x1 @x2) (Prims.result @x1))))) :named data_typing_intro_Prims.V@tok))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (HasTypeFuel (SFuel @u0) (Prims.V @x1 @x2) (Prims.result @x3)) (and (= @x1 @x3) (HasTypeFuel @u0 @x1 Tm_type) (HasTypeFuel @u0 @x2 @x1))) :pattern ((HasTypeFuel (SFuel @u0) (Prims.V @x1 @x2) (Prims.result @x3))))) :named data_elim_Prims.V))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (HasTypeFuel (SFuel @u0) (Prims.V @x1 @x2) (Prims.result @x3)) (and (Valid (Precedes @x1 (Prims.V @x1 @x2))) (Valid (Precedes @x2 (Prims.V @x1 @x2))))) :pattern ((HasTypeFuel (SFuel @u0) (Prims.V @x1 @x2) (Prims.result @x3))))) :named subterm_ordering_Prims.V))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= 532 (Term_constr_id (Prims.E @x0 @x1))) :pattern ((Prims.E @x0 @x1)))) :named constructor_distinct_Prims.E))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (Prims.E_a (Prims.E @x0 @x1)) @x0) :pattern ((Prims.E @x0 @x1)))) :named projection_inverse_Prims.E_a))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (Prims.E_e (Prims.E @x0 @x1)) @x1) :pattern ((Prims.E @x0 @x1)))) :named projection_inverse_Prims.E_e))
(define-fun is-Prims.E ((@x0 Term)) Bool (and (= (Term_constr_id @x0) 532) (= @x0 (Prims.E (Prims.E_a @x0) (Prims.E_e @x0)))))
(assert (! (forall ((@x0 Term)) (! (HasType (Tm_arrow_534 @x0) Tm_type) :pattern ((HasType (Tm_arrow_534 @x0) Tm_type)))) :named kinding_Tm_arrow_534))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_534 @x2)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_534 @x2))))) :named pre_typing_Tm_arrow_534))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_534 @x1)) (forall ((@x2 Term) (@x3 Term)) (! (implies (and (HasType @x2 Tm_type) (HasType @x3 @x1)) (HasType (ApplyTT (ApplyTT @x0 @x2) @x3) (Prims.result @x2))) :pattern ((ApplyTT (ApplyTT @x0 @x2) @x3))))) :pattern ((HasTypeZ @x0 (Tm_arrow_534 @x1))))) :named interpretation_Tm_arrow_534))
(assert (! (= 536 (Term_constr_id Prims.E@tok)) :named fresh_token_Prims.E@tok))
(assert (! (HasType Prims.E@tok (Tm_arrow_534 Prims.exn)) :named typing_tok_Prims.E@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (ApplyTT (ApplyTT Prims.E@tok @x0) @x1) (Prims.E @x0 @x1)) :pattern ((ApplyTT (ApplyTT Prims.E@tok @x0) @x1)))) :named equality_tok_Prims.E@tok))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (and (HasTypeFuel @u0 @x1 Tm_type) (HasTypeFuel @u0 @x2 Prims.exn)) (HasTypeFuel @u0 (Prims.E @x1 @x2) (Prims.result @x1))) :pattern ((HasTypeFuel @u0 (Prims.E @x1 @x2) (Prims.result @x1))))) :named data_typing_intro_Prims.E@tok))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (HasTypeFuel (SFuel @u0) (Prims.E @x1 @x2) (Prims.result @x3)) (and (= @x1 @x3) (HasTypeFuel @u0 @x1 Tm_type) (HasTypeFuel @u0 @x2 Prims.exn))) :pattern ((HasTypeFuel (SFuel @u0) (Prims.E @x1 @x2) (Prims.result @x3))))) :named data_elim_Prims.E))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (HasTypeFuel (SFuel @u0) (Prims.E @x1 @x2) (Prims.result @x3)) (and (Valid (Precedes @x1 (Prims.E @x1 @x2))) (Valid (Precedes @x2 (Prims.E @x1 @x2))))) :pattern ((HasTypeFuel (SFuel @u0) (Prims.E @x1 @x2) (Prims.result @x3))))) :named subterm_ordering_Prims.E))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= 538 (Term_constr_id (Prims.Err @x0 @x1))) :pattern ((Prims.Err @x0 @x1)))) :named constructor_distinct_Prims.Err))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (Prims.Err_a (Prims.Err @x0 @x1)) @x0) :pattern ((Prims.Err @x0 @x1)))) :named projection_inverse_Prims.Err_a))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (Prims.Err_msg (Prims.Err @x0 @x1)) @x1) :pattern ((Prims.Err @x0 @x1)))) :named projection_inverse_Prims.Err_msg))
(define-fun is-Prims.Err ((@x0 Term)) Bool (and (= (Term_constr_id @x0) 538) (= @x0 (Prims.Err (Prims.Err_a @x0) (Prims.Err_msg @x0)))))
(assert (! (= 540 (Term_constr_id Prims.Err@tok)) :named fresh_token_Prims.Err@tok))
(assert (! (HasType Prims.Err@tok (Tm_arrow_534 Prims.string)) :named typing_tok_Prims.Err@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (ApplyTT (ApplyTT Prims.Err@tok @x0) @x1) (Prims.Err @x0 @x1)) :pattern ((ApplyTT (ApplyTT Prims.Err@tok @x0) @x1)))) :named equality_tok_Prims.Err@tok))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (and (HasTypeFuel @u0 @x1 Tm_type) (HasTypeFuel @u0 @x2 Prims.string)) (HasTypeFuel @u0 (Prims.Err @x1 @x2) (Prims.result @x1))) :pattern ((HasTypeFuel @u0 (Prims.Err @x1 @x2) (Prims.result @x1))))) :named data_typing_intro_Prims.Err@tok))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (HasTypeFuel (SFuel @u0) (Prims.Err @x1 @x2) (Prims.result @x3)) (and (= @x1 @x3) (HasTypeFuel @u0 @x1 Tm_type) (HasTypeFuel @u0 @x2 Prims.string))) :pattern ((HasTypeFuel (SFuel @u0) (Prims.Err @x1 @x2) (Prims.result @x3))))) :named data_elim_Prims.Err))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (HasTypeFuel (SFuel @u0) (Prims.Err @x1 @x2) (Prims.result @x3)) (and (Valid (Precedes @x1 (Prims.Err @x1 @x2))) (Valid (Precedes @x2 (Prims.Err @x1 @x2))))) :pattern ((HasTypeFuel (SFuel @u0) (Prims.Err @x1 @x2) (Prims.result @x3))))) :named subterm_ordering_Prims.Err))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel (SFuel @u0) @x1 (Prims.result @x2)) (or (and (is-Prims.V @x1) (= @x2 (Prims.V_a @x1))) (and (is-Prims.E @x1) (= @x2 (Prims.E_a @x1))) (and (is-Prims.Err @x1) (= @x2 (Prims.Err_a @x1))))) :pattern ((HasTypeFuel (SFuel @u0) @x1 (Prims.result @x2))))) :named fuel_guarded_inversion_Prims.result_520))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel @u0 @x1 (Prims.result @x2)) (or (and (is-Prims.V @x1) (= @x2 (Prims.V_a @x1))) (and (is-Prims.E @x1) (= @x2 (Prims.E_a @x1))) (and (is-Prims.Err @x1) (= @x2 (Prims.Err_a @x1))))) :pattern ((HasTypeFuel @u0 @x1 (Prims.result @x2)) (Prims.inversion (Prims.result @x2))))) :named pattern_guarded_inversion_Prims.result_521))
(declare-fun Prims.is_V (Term Term) Term)
(declare-fun Tm_arrow_542 (Term) Term)
(assert (! (forall ((@x0 Term)) (! (HasType (Tm_arrow_542 @x0) Tm_type) :pattern ((HasType (Tm_arrow_542 @x0) Tm_type)))) :named kinding_Tm_arrow_542))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_542 @x2)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_542 @x2))))) :named pre_typing_Tm_arrow_542))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_542 @x1)) (forall ((@x2 Term) (@x3 Term)) (! (implies (and (HasType @x2 Tm_type) (HasType @x3 (Prims.result @x2))) (HasType (ApplyTT (ApplyTT @x0 @x2) @x3) @x1)) :pattern ((ApplyTT (ApplyTT @x0 @x2) @x3))))) :pattern ((HasTypeZ @x0 (Tm_arrow_542 @x1))))) :named interpretation_Tm_arrow_542))
(declare-fun Prims.is_V@tok () Term)
(assert (! (= 544 (Term_constr_id Prims.is_V@tok)) :named fresh_token_Prims.is_V@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (ApplyTT (ApplyTT Prims.is_V@tok @x0) @x1) (Prims.is_V @x0 @x1)) :pattern ((ApplyTT (ApplyTT Prims.is_V@tok @x0) @x1)))) :named token_correspondence_Prims.is_V))
(assert (! (HasType Prims.is_V@tok (Tm_arrow_542 Prims.bool)) :named function_token_typing_Prims.is_V))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 (Prims.result @x0))) (HasType (Prims.is_V @x0 @x1) Prims.bool)) :pattern ((Prims.is_V @x0 @x1)))) :named typing_Prims.is_V))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (Prims.is_V @x0 @x1) (BoxBool (is-Prims.V @x1))) :pattern ((Prims.is_V @x0 @x1)))) :named disc_equation_Prims.V))
(declare-fun Prims.is_E (Term Term) Term)
(declare-fun Prims.is_E@tok () Term)
(assert (! (= 546 (Term_constr_id Prims.is_E@tok)) :named fresh_token_Prims.is_E@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (ApplyTT (ApplyTT Prims.is_E@tok @x0) @x1) (Prims.is_E @x0 @x1)) :pattern ((ApplyTT (ApplyTT Prims.is_E@tok @x0) @x1)))) :named token_correspondence_Prims.is_E))
(assert (! (HasType Prims.is_E@tok (Tm_arrow_542 Prims.bool)) :named function_token_typing_Prims.is_E))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 (Prims.result @x0))) (HasType (Prims.is_E @x0 @x1) Prims.bool)) :pattern ((Prims.is_E @x0 @x1)))) :named typing_Prims.is_E))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (Prims.is_E @x0 @x1) (BoxBool (is-Prims.E @x1))) :pattern ((Prims.is_E @x0 @x1)))) :named disc_equation_Prims.E))
(declare-fun Prims.is_Err (Term Term) Term)
(declare-fun Prims.is_Err@tok () Term)
(assert (! (= 548 (Term_constr_id Prims.is_Err@tok)) :named fresh_token_Prims.is_Err@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (ApplyTT (ApplyTT Prims.is_Err@tok @x0) @x1) (Prims.is_Err @x0 @x1)) :pattern ((ApplyTT (ApplyTT Prims.is_Err@tok @x0) @x1)))) :named token_correspondence_Prims.is_Err))
(assert (! (HasType Prims.is_Err@tok (Tm_arrow_542 Prims.bool)) :named function_token_typing_Prims.is_Err))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 (Prims.result @x0))) (HasType (Prims.is_Err @x0 @x1) Prims.bool)) :pattern ((Prims.is_Err @x0 @x1)))) :named typing_Prims.is_Err))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (Prims.is_Err @x0 @x1) (BoxBool (is-Prims.Err @x1))) :pattern ((Prims.is_Err @x0 @x1)))) :named disc_equation_Prims.Err))
(declare-fun Tm_refine_550 (Term) Term)
(assert (! (forall ((@x0 Term)) (! (HasType (Tm_refine_550 @x0) Tm_type) :pattern ((HasType (Tm_refine_550 @x0) Tm_type)))) :named refinement_kinding_Tm_refine_550))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (iff (HasTypeFuel @u0 @x1 (Tm_refine_550 @x2)) (and (HasTypeFuel @u0 @x1 (Prims.result @x2)) (BoxBool_proj_0 (Prims.is_V @x2 @x1)))) :pattern ((HasTypeFuel @u0 @x1 (Tm_refine_550 @x2))))) :named refinement_interpretation_Tm_refine_550))
(assert (! (forall ((@x0 Term)) (! (iff (Valid (Prims.hasEq (Tm_refine_550 @x0))) (Valid (Prims.hasEq (Prims.result @x0)))) :pattern ((Valid (Prims.hasEq (Tm_refine_550 @x0)))))) :named haseqTm_refine_550))
(declare-fun Prims.V.v (Term Term) Term)
(declare-fun Tm_arrow_553 () Term)
(assert (! (HasType Tm_arrow_553 Tm_type) :named kinding_Tm_arrow_553))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_553) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_553)))) :named pre_typing_Tm_arrow_553))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_553) (forall ((@x1 Term) (@x2 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 (Tm_refine_550 @x1))) (HasType (ApplyTT (ApplyTT @x0 @x1) @x2) @x1)) :pattern ((ApplyTT (ApplyTT @x0 @x1) @x2))))) :pattern ((HasTypeZ @x0 Tm_arrow_553)))) :named interpretation_Tm_arrow_553))
(declare-fun Prims.V.v@tok () Term)
(assert (! (= 555 (Term_constr_id Prims.V.v@tok)) :named fresh_token_Prims.V.v@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (ApplyTT (ApplyTT Prims.V.v@tok @x0) @x1) (Prims.V.v @x0 @x1)) :pattern ((ApplyTT (ApplyTT Prims.V.v@tok @x0) @x1)))) :named token_correspondence_Prims.V.v))
(assert (! (HasType Prims.V.v@tok Tm_arrow_553) :named function_token_typing_Prims.V.v))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 (Tm_refine_550 @x0))) (HasType (Prims.V.v @x0 @x1) @x0)) :pattern ((Prims.V.v @x0 @x1)))) :named typing_Prims.V.v))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (Prims.V.v @x0 @x1) (Prims.V_v @x1)) :pattern ((Prims.V.v @x0 @x1)))) :named proj_equation_Prims.V_v))
(declare-fun Tm_refine_557 (Term) Term)
(assert (! (forall ((@x0 Term)) (! (HasType (Tm_refine_557 @x0) Tm_type) :pattern ((HasType (Tm_refine_557 @x0) Tm_type)))) :named refinement_kinding_Tm_refine_557))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (iff (HasTypeFuel @u0 @x1 (Tm_refine_557 @x2)) (and (HasTypeFuel @u0 @x1 (Prims.result @x2)) (BoxBool_proj_0 (Prims.is_E @x2 @x1)))) :pattern ((HasTypeFuel @u0 @x1 (Tm_refine_557 @x2))))) :named refinement_interpretation_Tm_refine_557))
(assert (! (forall ((@x0 Term)) (! (iff (Valid (Prims.hasEq (Tm_refine_557 @x0))) (Valid (Prims.hasEq (Prims.result @x0)))) :pattern ((Valid (Prims.hasEq (Tm_refine_557 @x0)))))) :named haseqTm_refine_557))
(declare-fun Prims.E.e (Term Term) Term)
(declare-fun Tm_arrow_560 (Term) Term)
(assert (! (forall ((@x0 Term)) (! (HasType (Tm_arrow_560 @x0) Tm_type) :pattern ((HasType (Tm_arrow_560 @x0) Tm_type)))) :named kinding_Tm_arrow_560))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_560 @x2)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_560 @x2))))) :named pre_typing_Tm_arrow_560))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_560 @x1)) (forall ((@x2 Term) (@x3 Term)) (! (implies (and (HasType @x2 Tm_type) (HasType @x3 (Tm_refine_557 @x2))) (HasType (ApplyTT (ApplyTT @x0 @x2) @x3) @x1)) :pattern ((ApplyTT (ApplyTT @x0 @x2) @x3))))) :pattern ((HasTypeZ @x0 (Tm_arrow_560 @x1))))) :named interpretation_Tm_arrow_560))
(declare-fun Prims.E.e@tok () Term)
(assert (! (= 562 (Term_constr_id Prims.E.e@tok)) :named fresh_token_Prims.E.e@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (ApplyTT (ApplyTT Prims.E.e@tok @x0) @x1) (Prims.E.e @x0 @x1)) :pattern ((ApplyTT (ApplyTT Prims.E.e@tok @x0) @x1)))) :named token_correspondence_Prims.E.e))
(assert (! (HasType Prims.E.e@tok (Tm_arrow_560 Prims.exn)) :named function_token_typing_Prims.E.e))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 (Tm_refine_557 @x0))) (HasType (Prims.E.e @x0 @x1) Prims.exn)) :pattern ((Prims.E.e @x0 @x1)))) :named typing_Prims.E.e))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (Prims.E.e @x0 @x1) (Prims.E_e @x1)) :pattern ((Prims.E.e @x0 @x1)))) :named proj_equation_Prims.E_e))
(declare-fun Tm_refine_564 (Term) Term)
(assert (! (forall ((@x0 Term)) (! (HasType (Tm_refine_564 @x0) Tm_type) :pattern ((HasType (Tm_refine_564 @x0) Tm_type)))) :named refinement_kinding_Tm_refine_564))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (iff (HasTypeFuel @u0 @x1 (Tm_refine_564 @x2)) (and (HasTypeFuel @u0 @x1 (Prims.result @x2)) (BoxBool_proj_0 (Prims.is_Err @x2 @x1)))) :pattern ((HasTypeFuel @u0 @x1 (Tm_refine_564 @x2))))) :named refinement_interpretation_Tm_refine_564))
(assert (! (forall ((@x0 Term)) (! (iff (Valid (Prims.hasEq (Tm_refine_564 @x0))) (Valid (Prims.hasEq (Prims.result @x0)))) :pattern ((Valid (Prims.hasEq (Tm_refine_564 @x0)))))) :named haseqTm_refine_564))
(declare-fun Prims.Err.msg (Term Term) Term)
(declare-fun Tm_arrow_567 (Term) Term)
(assert (! (forall ((@x0 Term)) (! (HasType (Tm_arrow_567 @x0) Tm_type) :pattern ((HasType (Tm_arrow_567 @x0) Tm_type)))) :named kinding_Tm_arrow_567))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_567 @x2)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_567 @x2))))) :named pre_typing_Tm_arrow_567))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_567 @x1)) (forall ((@x2 Term) (@x3 Term)) (! (implies (and (HasType @x2 Tm_type) (HasType @x3 (Tm_refine_564 @x2))) (HasType (ApplyTT (ApplyTT @x0 @x2) @x3) @x1)) :pattern ((ApplyTT (ApplyTT @x0 @x2) @x3))))) :pattern ((HasTypeZ @x0 (Tm_arrow_567 @x1))))) :named interpretation_Tm_arrow_567))
(declare-fun Prims.Err.msg@tok () Term)
(assert (! (= 569 (Term_constr_id Prims.Err.msg@tok)) :named fresh_token_Prims.Err.msg@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (ApplyTT (ApplyTT Prims.Err.msg@tok @x0) @x1) (Prims.Err.msg @x0 @x1)) :pattern ((ApplyTT (ApplyTT Prims.Err.msg@tok @x0) @x1)))) :named token_correspondence_Prims.Err.msg))
(assert (! (HasType Prims.Err.msg@tok (Tm_arrow_567 Prims.string)) :named function_token_typing_Prims.Err.msg))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 (Tm_refine_564 @x0))) (HasType (Prims.Err.msg @x0 @x1) Prims.string)) :pattern ((Prims.Err.msg @x0 @x1)))) :named typing_Prims.Err.msg))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (Prims.Err.msg @x0 @x1) (Prims.Err_msg @x1)) :pattern ((Prims.Err.msg @x0 @x1)))) :named proj_equation_Prims.Err_msg))
(assert (! (forall ((@x0 Term)) (! (implies (and (HasType @x0 Tm_type) (Valid (Prims.hasEq @x0))) (Valid (Prims.hasEq (Prims.result @x0)))) :pattern ((Prims.hasEq (Prims.result @x0))))) :named assumption_Prims.HasEq_result_570))
(declare-fun Prims.st_pre_h (Term) Term)
(declare-fun Prims.st_pre_h@tok () Term)
(assert (! (= 572 (Term_constr_id Prims.st_pre_h@tok)) :named fresh_token_Prims.st_pre_h@tok))
(assert (! (forall ((@x0 Term)) (! (= (ApplyTT Prims.st_pre_h@tok @x0) (Prims.st_pre_h @x0)) :pattern ((ApplyTT Prims.st_pre_h@tok @x0)))) :named token_correspondence_Prims.st_pre_h))
(assert (! (HasType Prims.st_pre_h@tok Tm_arrow_105) :named function_token_typing_Prims.st_pre_h))
(assert (! (forall ((@x0 Term)) (! (implies (HasType @x0 Tm_type) (HasType (Prims.st_pre_h @x0) Tm_type)) :pattern ((Prims.st_pre_h @x0)))) :named typing_Prims.st_pre_h))
(assert (! (forall ((@x0 Term)) (! (= (Prims.st_pre_h @x0) (Tm_arrow_239 @x0)) :pattern ((Prims.st_pre_h @x0)))) :named equation_Prims.st_pre_h))
(declare-fun Prims.st_post_h (Term Term) Term)
(declare-fun Prims.st_post_h@tok () Term)
(assert (! (= 575 (Term_constr_id Prims.st_post_h@tok)) :named fresh_token_Prims.st_post_h@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (ApplyTT (ApplyTT Prims.st_post_h@tok @x0) @x1) (Prims.st_post_h @x0 @x1)) :pattern ((ApplyTT (ApplyTT Prims.st_post_h@tok @x0) @x1)))) :named token_correspondence_Prims.st_post_h))
(assert (! (HasType Prims.st_post_h@tok Tm_arrow_179) :named function_token_typing_Prims.st_post_h))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type)) (HasType (Prims.st_post_h @x0 @x1) Tm_type)) :pattern ((Prims.st_post_h @x0 @x1)))) :named typing_Prims.st_post_h))
(declare-fun Tm_arrow_577 (Term Term) Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (HasType (Tm_arrow_577 @x0 @x1) Tm_type) :pattern ((HasType (Tm_arrow_577 @x0 @x1) Tm_type)))) :named kinding_Tm_arrow_577))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_577 @x2 @x3)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_577 @x2 @x3))))) :named pre_typing_Tm_arrow_577))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_577 @x1 @x2)) (forall ((@x3 Term) (@x4 Term)) (! (implies (and (HasType @x3 @x2) (HasType @x4 @x1)) (HasType (ApplyTT (ApplyTT @x0 @x3) @x4) Tm_type)) :pattern ((ApplyTT (ApplyTT @x0 @x3) @x4))))) :pattern ((HasTypeZ @x0 (Tm_arrow_577 @x1 @x2))))) :named interpretation_Tm_arrow_577))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (Prims.st_post_h @x0 @x1) (Tm_arrow_577 @x0 @x1)) :pattern ((Prims.st_post_h @x0 @x1)))) :named equation_Prims.st_post_h))
(declare-fun Prims.st_wp_h (Term Term) Term)
(declare-fun Prims.st_wp_h@tok () Term)
(assert (! (= 580 (Term_constr_id Prims.st_wp_h@tok)) :named fresh_token_Prims.st_wp_h@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (ApplyTT (ApplyTT Prims.st_wp_h@tok @x0) @x1) (Prims.st_wp_h @x0 @x1)) :pattern ((ApplyTT (ApplyTT Prims.st_wp_h@tok @x0) @x1)))) :named token_correspondence_Prims.st_wp_h))
(assert (! (HasType Prims.st_wp_h@tok Tm_arrow_179) :named function_token_typing_Prims.st_wp_h))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type)) (HasType (Prims.st_wp_h @x0 @x1) Tm_type)) :pattern ((Prims.st_wp_h @x0 @x1)))) :named typing_Prims.st_wp_h))
(declare-fun Tm_arrow_582 (Term Term) Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (HasType (Tm_arrow_582 @x0 @x1) Tm_type) :pattern ((HasType (Tm_arrow_582 @x0 @x1) Tm_type)))) :named kinding_Tm_arrow_582))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_582 @x2 @x3)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_582 @x2 @x3))))) :named pre_typing_Tm_arrow_582))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_582 @x1 @x2)) (forall ((@x3 Term)) (! (implies (HasType @x3 (Prims.st_post_h @x2 @x1)) (HasType (ApplyTT @x0 @x3) (Prims.st_pre_h @x2))) :pattern ((ApplyTT @x0 @x3))))) :pattern ((HasTypeZ @x0 (Tm_arrow_582 @x1 @x2))))) :named interpretation_Tm_arrow_582))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (Prims.st_wp_h @x0 @x1) (Tm_arrow_582 @x1 @x0)) :pattern ((Prims.st_wp_h @x0 @x1)))) :named equation_Prims.st_wp_h))
(declare-fun Prims.ex_pre () Term)
(assert (! (HasType Prims.ex_pre Tm_type) :named function_token_typing_Prims.ex_pre))
(assert (! (HasType Prims.ex_pre Tm_type) :named typing_Prims.ex_pre))
(assert (! (= Prims.ex_pre Tm_type) :named equation_Prims.ex_pre))
(declare-fun Prims.ex_post (Term) Term)
(declare-fun Prims.ex_post@tok () Term)
(assert (! (= 585 (Term_constr_id Prims.ex_post@tok)) :named fresh_token_Prims.ex_post@tok))
(assert (! (forall ((@x0 Term)) (! (= (ApplyTT Prims.ex_post@tok @x0) (Prims.ex_post @x0)) :pattern ((ApplyTT Prims.ex_post@tok @x0)))) :named token_correspondence_Prims.ex_post))
(assert (! (HasType Prims.ex_post@tok Tm_arrow_105) :named function_token_typing_Prims.ex_post))
(assert (! (forall ((@x0 Term)) (! (implies (HasType @x0 Tm_type) (HasType (Prims.ex_post @x0) Tm_type)) :pattern ((Prims.ex_post @x0)))) :named typing_Prims.ex_post))
(declare-fun Tm_arrow_587 (Term) Term)
(assert (! (forall ((@x0 Term)) (! (HasType (Tm_arrow_587 @x0) Tm_type) :pattern ((HasType (Tm_arrow_587 @x0) Tm_type)))) :named kinding_Tm_arrow_587))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_587 @x2)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_587 @x2))))) :named pre_typing_Tm_arrow_587))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_587 @x1)) (forall ((@x2 Term)) (! (implies (HasType @x2 (Prims.result @x1)) (HasType (ApplyTT @x0 @x2) Tm_type)) :pattern ((ApplyTT @x0 @x2))))) :pattern ((HasTypeZ @x0 (Tm_arrow_587 @x1))))) :named interpretation_Tm_arrow_587))
(assert (! (forall ((@x0 Term)) (! (= (Prims.ex_post @x0) (Tm_arrow_587 @x0)) :pattern ((Prims.ex_post @x0)))) :named equation_Prims.ex_post))
(declare-fun Prims.ex_wp (Term) Term)
(declare-fun Prims.ex_wp@tok () Term)
(assert (! (= 590 (Term_constr_id Prims.ex_wp@tok)) :named fresh_token_Prims.ex_wp@tok))
(assert (! (forall ((@x0 Term)) (! (= (ApplyTT Prims.ex_wp@tok @x0) (Prims.ex_wp @x0)) :pattern ((ApplyTT Prims.ex_wp@tok @x0)))) :named token_correspondence_Prims.ex_wp))
(assert (! (HasType Prims.ex_wp@tok Tm_arrow_105) :named function_token_typing_Prims.ex_wp))
(assert (! (forall ((@x0 Term)) (! (implies (HasType @x0 Tm_type) (HasType (Prims.ex_wp @x0) Tm_type)) :pattern ((Prims.ex_wp @x0)))) :named typing_Prims.ex_wp))
(declare-fun Tm_arrow_592 (Term Term) Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (HasType (Tm_arrow_592 @x0 @x1) Tm_type) :pattern ((HasType (Tm_arrow_592 @x0 @x1) Tm_type)))) :named kinding_Tm_arrow_592))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_592 @x2 @x3)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_592 @x2 @x3))))) :named pre_typing_Tm_arrow_592))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_592 @x1 @x2)) (forall ((@x3 Term)) (! (implies (HasType @x3 (Prims.ex_post @x2)) (HasType (ApplyTT @x0 @x3) @x1)) :pattern ((ApplyTT @x0 @x3))))) :pattern ((HasTypeZ @x0 (Tm_arrow_592 @x1 @x2))))) :named interpretation_Tm_arrow_592))
(assert (! (forall ((@x0 Term)) (! (= (Prims.ex_wp @x0) (Tm_arrow_592 Prims.ex_pre @x0)) :pattern ((Prims.ex_wp @x0)))) :named equation_Prims.ex_wp))
(declare-fun Prims.all_pre_h (Term) Term)
(declare-fun Prims.all_pre_h@tok () Term)
(assert (! (= 595 (Term_constr_id Prims.all_pre_h@tok)) :named fresh_token_Prims.all_pre_h@tok))
(assert (! (forall ((@x0 Term)) (! (= (ApplyTT Prims.all_pre_h@tok @x0) (Prims.all_pre_h @x0)) :pattern ((ApplyTT Prims.all_pre_h@tok @x0)))) :named token_correspondence_Prims.all_pre_h))
(assert (! (HasType Prims.all_pre_h@tok Tm_arrow_105) :named function_token_typing_Prims.all_pre_h))
(assert (! (forall ((@x0 Term)) (! (implies (HasType @x0 Tm_type) (HasType (Prims.all_pre_h @x0) Tm_type)) :pattern ((Prims.all_pre_h @x0)))) :named typing_Prims.all_pre_h))
(assert (! (forall ((@x0 Term)) (! (= (Prims.all_pre_h @x0) (Tm_arrow_239 @x0)) :pattern ((Prims.all_pre_h @x0)))) :named equation_Prims.all_pre_h))
(declare-fun Prims.all_post_h (Term Term) Term)
(declare-fun Prims.all_post_h@tok () Term)
(assert (! (= 598 (Term_constr_id Prims.all_post_h@tok)) :named fresh_token_Prims.all_post_h@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (ApplyTT (ApplyTT Prims.all_post_h@tok @x0) @x1) (Prims.all_post_h @x0 @x1)) :pattern ((ApplyTT (ApplyTT Prims.all_post_h@tok @x0) @x1)))) :named token_correspondence_Prims.all_post_h))
(assert (! (HasType Prims.all_post_h@tok Tm_arrow_179) :named function_token_typing_Prims.all_post_h))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type)) (HasType (Prims.all_post_h @x0 @x1) Tm_type)) :pattern ((Prims.all_post_h @x0 @x1)))) :named typing_Prims.all_post_h))
(declare-fun Tm_arrow_600 (Term Term) Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (HasType (Tm_arrow_600 @x0 @x1) Tm_type) :pattern ((HasType (Tm_arrow_600 @x0 @x1) Tm_type)))) :named kinding_Tm_arrow_600))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_600 @x2 @x3)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_600 @x2 @x3))))) :named pre_typing_Tm_arrow_600))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_600 @x1 @x2)) (forall ((@x3 Term) (@x4 Term)) (! (implies (and (HasType @x3 (Prims.result @x2)) (HasType @x4 @x1)) (HasType (ApplyTT (ApplyTT @x0 @x3) @x4) Tm_type)) :pattern ((ApplyTT (ApplyTT @x0 @x3) @x4))))) :pattern ((HasTypeZ @x0 (Tm_arrow_600 @x1 @x2))))) :named interpretation_Tm_arrow_600))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (Prims.all_post_h @x0 @x1) (Tm_arrow_600 @x0 @x1)) :pattern ((Prims.all_post_h @x0 @x1)))) :named equation_Prims.all_post_h))
(declare-fun Prims.all_wp_h (Term Term) Term)
(declare-fun Prims.all_wp_h@tok () Term)
(assert (! (= 603 (Term_constr_id Prims.all_wp_h@tok)) :named fresh_token_Prims.all_wp_h@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (ApplyTT (ApplyTT Prims.all_wp_h@tok @x0) @x1) (Prims.all_wp_h @x0 @x1)) :pattern ((ApplyTT (ApplyTT Prims.all_wp_h@tok @x0) @x1)))) :named token_correspondence_Prims.all_wp_h))
(assert (! (HasType Prims.all_wp_h@tok Tm_arrow_179) :named function_token_typing_Prims.all_wp_h))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type)) (HasType (Prims.all_wp_h @x0 @x1) Tm_type)) :pattern ((Prims.all_wp_h @x0 @x1)))) :named typing_Prims.all_wp_h))
(declare-fun Tm_arrow_605 (Term Term) Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (HasType (Tm_arrow_605 @x0 @x1) Tm_type) :pattern ((HasType (Tm_arrow_605 @x0 @x1) Tm_type)))) :named kinding_Tm_arrow_605))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_605 @x2 @x3)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_605 @x2 @x3))))) :named pre_typing_Tm_arrow_605))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_605 @x1 @x2)) (forall ((@x3 Term)) (! (implies (HasType @x3 (Prims.all_post_h @x2 @x1)) (HasType (ApplyTT @x0 @x3) (Prims.all_pre_h @x2))) :pattern ((ApplyTT @x0 @x3))))) :pattern ((HasTypeZ @x0 (Tm_arrow_605 @x1 @x2))))) :named interpretation_Tm_arrow_605))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (Prims.all_wp_h @x0 @x1) (Tm_arrow_605 @x1 @x0)) :pattern ((Prims.all_wp_h @x0 @x1)))) :named equation_Prims.all_wp_h))
(declare-fun Prims.lex_t () Term)
(declare-fun Prims.LexTop () Term)
(declare-fun Prims.LexTop@tok () Term)
(assert (! (= 607 (Term_constr_id Prims.lex_t)) :named constructor_distinct_Prims.lex_t))
(define-fun is-Prims.lex_t ((@x0 Term)) Bool (and (= (Term_constr_id @x0) 607) (= @x0 Prims.lex_t)))
(assert (! (HasType Prims.lex_t Tm_type) :named kinding_Prims.lex_t@tok))
(assert (! (forall ((@x0 Term) (@u1 Fuel)) (! (implies (HasTypeFuel @u1 @x0 Prims.lex_t) (= Prims.lex_t (PreType @x0))) :pattern ((HasTypeFuel @u1 @x0 Prims.lex_t)))) :named @pretyping__614))
(assert (! (= 616 (Term_constr_id Prims.LexTop)) :named constructor_distinct_Prims.LexTop))
(define-fun is-Prims.LexTop ((@x0 Term)) Bool (and (= (Term_constr_id @x0) 616) (= @x0 Prims.LexTop)))
(assert (! (HasType Prims.LexTop@tok Prims.lex_t) :named typing_tok_Prims.LexTop@tok))
(assert (! (= Prims.LexTop@tok Prims.LexTop) :named equality_tok_Prims.LexTop@tok))
(assert (! (forall ((@u0 Fuel)) (! (HasTypeFuel @u0 Prims.LexTop Prims.lex_t) :pattern ((HasTypeFuel @u0 Prims.LexTop Prims.lex_t)))) :named data_typing_intro_Prims.LexTop@tok))
(assert (! true :named data_elim_Prims.LexTop))
(assert (! (forall ((@x0 Term)) (! (implies (is-LexCons @x0) (Valid (Precedes @x0 Prims.LexTop))) :pattern ((Valid (Precedes @x0 Prims.LexTop))))) :named lextop_618))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel (SFuel @u0) @x1 Prims.lex_t) (or (is-Prims.LexTop @x1) (is-Prims.LexCons @x1))) :pattern ((HasTypeFuel (SFuel @u0) @x1 Prims.lex_t)))) :named fuel_guarded_inversion_Prims.lex_t_610))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Prims.lex_t) (or (is-Prims.LexTop @x1) (is-Prims.LexCons @x1))) :pattern ((HasTypeFuel @u0 @x1 Prims.lex_t) (Prims.inversion Prims.lex_t)))) :named pattern_guarded_inversion_Prims.lex_t_611))
(declare-fun Prims.is_LexTop (Term) Term)
(declare-fun Tm_arrow_620 (Term) Term)
(assert (! (forall ((@x0 Term)) (! (HasType (Tm_arrow_620 @x0) Tm_type) :pattern ((HasType (Tm_arrow_620 @x0) Tm_type)))) :named kinding_Tm_arrow_620))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_620 @x2)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_620 @x2))))) :named pre_typing_Tm_arrow_620))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_620 @x1)) (forall ((@x2 Term)) (! (implies (HasType @x2 Prims.lex_t) (HasType (ApplyTT @x0 @x2) @x1)) :pattern ((ApplyTT @x0 @x2))))) :pattern ((HasTypeZ @x0 (Tm_arrow_620 @x1))))) :named interpretation_Tm_arrow_620))
(declare-fun Prims.is_LexTop@tok () Term)
(assert (! (= 622 (Term_constr_id Prims.is_LexTop@tok)) :named fresh_token_Prims.is_LexTop@tok))
(assert (! (forall ((@x0 Term)) (! (= (ApplyTT Prims.is_LexTop@tok @x0) (Prims.is_LexTop @x0)) :pattern ((ApplyTT Prims.is_LexTop@tok @x0)))) :named token_correspondence_Prims.is_LexTop))
(assert (! (HasType Prims.is_LexTop@tok (Tm_arrow_620 Prims.bool)) :named function_token_typing_Prims.is_LexTop))
(assert (! (forall ((@x0 Term)) (! (implies (HasType @x0 Prims.lex_t) (HasType (Prims.is_LexTop @x0) Prims.bool)) :pattern ((Prims.is_LexTop @x0)))) :named typing_Prims.is_LexTop))
(assert (! (forall ((@x0 Term)) (! (= (Prims.is_LexTop @x0) (BoxBool (is-Prims.LexTop @x0))) :pattern ((Prims.is_LexTop @x0)))) :named disc_equation_Prims.LexTop))
(declare-fun Prims.is_LexCons (Term) Term)
(declare-fun Prims.is_LexCons@tok () Term)
(assert (! (= 624 (Term_constr_id Prims.is_LexCons@tok)) :named fresh_token_Prims.is_LexCons@tok))
(assert (! (forall ((@x0 Term)) (! (= (ApplyTT Prims.is_LexCons@tok @x0) (Prims.is_LexCons @x0)) :pattern ((ApplyTT Prims.is_LexCons@tok @x0)))) :named token_correspondence_Prims.is_LexCons))
(assert (! (HasType Prims.is_LexCons@tok (Tm_arrow_620 Prims.bool)) :named function_token_typing_Prims.is_LexCons))
(assert (! (forall ((@x0 Term)) (! (implies (HasType @x0 Prims.lex_t) (HasType (Prims.is_LexCons @x0) Prims.bool)) :pattern ((Prims.is_LexCons @x0)))) :named typing_Prims.is_LexCons))
(assert (! (forall ((@x0 Term)) (! (= (Prims.is_LexCons @x0) (BoxBool (is-Prims.LexCons @x0))) :pattern ((Prims.is_LexCons @x0)))) :named disc_equation_Prims.LexCons))
(declare-fun Prims.tuple2 (Term Term) Term)
(declare-fun Prims.tuple2@x0 (Term) Term)
(declare-fun Prims.tuple2@x1 (Term) Term)
(declare-fun Prims.tuple2@tok () Term)
(declare-fun Prims.Mktuple2 (Term Term Term Term) Term)
(declare-fun Prims.Mktuple2__a (Term) Term)
(declare-fun Prims.Mktuple2__b (Term) Term)
(declare-fun Prims.Mktuple2__1 (Term) Term)
(declare-fun Prims.Mktuple2__2 (Term) Term)
(declare-fun Tm_arrow_636 () Term)
(declare-fun Prims.Mktuple2@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= 625 (Term_constr_id (Prims.tuple2 @x0 @x1))) :pattern ((Prims.tuple2 @x0 @x1)))) :named constructor_distinct_Prims.tuple2))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (Prims.tuple2@x0 (Prims.tuple2 @x0 @x1)) @x0) :pattern ((Prims.tuple2 @x0 @x1)))) :named projection_inverse_Prims.tuple2@x0))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (Prims.tuple2@x1 (Prims.tuple2 @x0 @x1)) @x1) :pattern ((Prims.tuple2 @x0 @x1)))) :named projection_inverse_Prims.tuple2@x1))
(define-fun is-Prims.tuple2 ((@x0 Term)) Bool (and (= (Term_constr_id @x0) 625) (= @x0 (Prims.tuple2 (Prims.tuple2@x0 @x0) (Prims.tuple2@x1 @x0)))))
(assert (! (= 626 (Term_constr_id Prims.tuple2@tok)) :named fresh_token_Prims.tuple2@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (ApplyTT (ApplyTT Prims.tuple2@tok @x0) @x1) (Prims.tuple2 @x0 @x1)) :pattern ((ApplyTT (ApplyTT Prims.tuple2@tok @x0) @x1)) :pattern ((Prims.tuple2 @x0 @x1)))) :named token_correspondence_Prims.tuple2@tok))
(assert (! (is-Tm_arrow (PreType Prims.tuple2@tok)) :named pre_kinding_Prims.tuple2@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type)) (HasType (Prims.tuple2 @x0 @x1) Tm_type)) :pattern ((Prims.tuple2 @x0 @x1)))) :named kinding_Prims.tuple2@tok))
(assert (! (forall ((@x0 Term) (@u1 Fuel) (@x2 Term) (@x3 Term)) (! (implies (HasTypeFuel @u1 @x0 (Prims.tuple2 @x2 @x3)) (= (Prims.tuple2 @x2 @x3) (PreType @x0))) :pattern ((HasTypeFuel @u1 @x0 (Prims.tuple2 @x2 @x3))))) :named @pretyping__632))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= 634 (Term_constr_id (Prims.Mktuple2 @x0 @x1 @x2 @x3))) :pattern ((Prims.Mktuple2 @x0 @x1 @x2 @x3)))) :named constructor_distinct_Prims.Mktuple2))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (Prims.Mktuple2__a (Prims.Mktuple2 @x0 @x1 @x2 @x3)) @x0) :pattern ((Prims.Mktuple2 @x0 @x1 @x2 @x3)))) :named projection_inverse_Prims.Mktuple2__a))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (Prims.Mktuple2__b (Prims.Mktuple2 @x0 @x1 @x2 @x3)) @x1) :pattern ((Prims.Mktuple2 @x0 @x1 @x2 @x3)))) :named projection_inverse_Prims.Mktuple2__b))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (Prims.Mktuple2__1 (Prims.Mktuple2 @x0 @x1 @x2 @x3)) @x2) :pattern ((Prims.Mktuple2 @x0 @x1 @x2 @x3)))) :named projection_inverse_Prims.Mktuple2__1))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (Prims.Mktuple2__2 (Prims.Mktuple2 @x0 @x1 @x2 @x3)) @x3) :pattern ((Prims.Mktuple2 @x0 @x1 @x2 @x3)))) :named projection_inverse_Prims.Mktuple2__2))
(define-fun is-Prims.Mktuple2 ((@x0 Term)) Bool (and (= (Term_constr_id @x0) 634) (= @x0 (Prims.Mktuple2 (Prims.Mktuple2__a @x0) (Prims.Mktuple2__b @x0) (Prims.Mktuple2__1 @x0) (Prims.Mktuple2__2 @x0)))))
(assert (! (HasType Tm_arrow_636 Tm_type) :named kinding_Tm_arrow_636))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_636) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_636)))) :named pre_typing_Tm_arrow_636))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_636) (forall ((@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 @x1) (HasType @x4 @x2)) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) (Prims.tuple2 @x1 @x2))) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4))))) :pattern ((HasTypeZ @x0 Tm_arrow_636)))) :named interpretation_Tm_arrow_636))
(assert (! (= 638 (Term_constr_id Prims.Mktuple2@tok)) :named fresh_token_Prims.Mktuple2@tok))
(assert (! (HasType Prims.Mktuple2@tok Tm_arrow_636) :named typing_tok_Prims.Mktuple2@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple2@tok @x0) @x1) @x2) @x3) (Prims.Mktuple2 @x0 @x1 @x2 @x3)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple2@tok @x0) @x1) @x2) @x3)))) :named equality_tok_Prims.Mktuple2@tok))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasTypeFuel @u0 @x1 Tm_type) (HasTypeFuel @u0 @x2 Tm_type) (HasTypeFuel @u0 @x3 @x1) (HasTypeFuel @u0 @x4 @x2)) (HasTypeFuel @u0 (Prims.Mktuple2 @x1 @x2 @x3 @x4) (Prims.tuple2 @x1 @x2))) :pattern ((HasTypeFuel @u0 (Prims.Mktuple2 @x1 @x2 @x3 @x4) (Prims.tuple2 @x1 @x2))))) :named data_typing_intro_Prims.Mktuple2@tok))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term)) (! (implies (HasTypeFuel (SFuel @u0) (Prims.Mktuple2 @x1 @x2 @x3 @x4) (Prims.tuple2 @x5 @x6)) (and (= @x2 @x6) (= @x1 @x5) (HasTypeFuel @u0 @x1 Tm_type) (HasTypeFuel @u0 @x2 Tm_type) (HasTypeFuel @u0 @x3 @x1) (HasTypeFuel @u0 @x4 @x2))) :pattern ((HasTypeFuel (SFuel @u0) (Prims.Mktuple2 @x1 @x2 @x3 @x4) (Prims.tuple2 @x5 @x6))))) :named data_elim_Prims.Mktuple2))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term)) (! (implies (HasTypeFuel (SFuel @u0) (Prims.Mktuple2 @x1 @x2 @x3 @x4) (Prims.tuple2 @x5 @x6)) (and (Valid (Precedes @x1 (Prims.Mktuple2 @x1 @x2 @x3 @x4))) (Valid (Precedes @x2 (Prims.Mktuple2 @x1 @x2 @x3 @x4))) (Valid (Precedes @x3 (Prims.Mktuple2 @x1 @x2 @x3 @x4))) (Valid (Precedes @x4 (Prims.Mktuple2 @x1 @x2 @x3 @x4))))) :pattern ((HasTypeFuel (SFuel @u0) (Prims.Mktuple2 @x1 @x2 @x3 @x4) (Prims.tuple2 @x5 @x6))))) :named subterm_ordering_Prims.Mktuple2))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (HasTypeFuel @u0 @x1 (Prims.tuple2 @x2 @x3)) (and (is-Prims.Mktuple2 @x1) (= @x2 (Prims.Mktuple2__a @x1)) (= @x3 (Prims.Mktuple2__b @x1)))) :pattern ((HasTypeFuel @u0 @x1 (Prims.tuple2 @x2 @x3))))) :named fuel_guarded_inversion_Prims.tuple2_629))
(declare-fun Prims.Mktuple2._1 (Term Term Term) Term)
(declare-fun Tm_arrow_640 () Term)
(assert (! (HasType Tm_arrow_640 Tm_type) :named kinding_Tm_arrow_640))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_640) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_640)))) :named pre_typing_Tm_arrow_640))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_640) (forall ((@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 (Prims.tuple2 @x1 @x2))) (HasType (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x1)) :pattern ((ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3))))) :pattern ((HasTypeZ @x0 Tm_arrow_640)))) :named interpretation_Tm_arrow_640))
(declare-fun Prims.Mktuple2._1@tok () Term)
(assert (! (= 642 (Term_constr_id Prims.Mktuple2._1@tok)) :named fresh_token_Prims.Mktuple2._1@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple2._1@tok @x0) @x1) @x2) (Prims.Mktuple2._1 @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT Prims.Mktuple2._1@tok @x0) @x1) @x2)))) :named token_correspondence_Prims.Mktuple2._1))
(assert (! (HasType Prims.Mktuple2._1@tok Tm_arrow_640) :named function_token_typing_Prims.Mktuple2._1))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 (Prims.tuple2 @x0 @x1))) (HasType (Prims.Mktuple2._1 @x0 @x1 @x2) @x0)) :pattern ((Prims.Mktuple2._1 @x0 @x1 @x2)))) :named typing_Prims.Mktuple2._1))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (Prims.Mktuple2._1 @x0 @x1 @x2) (Prims.Mktuple2__1 @x2)) :pattern ((Prims.Mktuple2._1 @x0 @x1 @x2)))) :named proj_equation_Prims.Mktuple2__1))
(declare-fun Prims.Mktuple2._2 (Term Term Term) Term)
(declare-fun Tm_arrow_644 () Term)
(assert (! (HasType Tm_arrow_644 Tm_type) :named kinding_Tm_arrow_644))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_644) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_644)))) :named pre_typing_Tm_arrow_644))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_644) (forall ((@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 (Prims.tuple2 @x1 @x2))) (HasType (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3))))) :pattern ((HasTypeZ @x0 Tm_arrow_644)))) :named interpretation_Tm_arrow_644))
(declare-fun Prims.Mktuple2._2@tok () Term)
(assert (! (= 646 (Term_constr_id Prims.Mktuple2._2@tok)) :named fresh_token_Prims.Mktuple2._2@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple2._2@tok @x0) @x1) @x2) (Prims.Mktuple2._2 @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT Prims.Mktuple2._2@tok @x0) @x1) @x2)))) :named token_correspondence_Prims.Mktuple2._2))
(assert (! (HasType Prims.Mktuple2._2@tok Tm_arrow_644) :named function_token_typing_Prims.Mktuple2._2))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 (Prims.tuple2 @x0 @x1))) (HasType (Prims.Mktuple2._2 @x0 @x1 @x2) @x1)) :pattern ((Prims.Mktuple2._2 @x0 @x1 @x2)))) :named typing_Prims.Mktuple2._2))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (Prims.Mktuple2._2 @x0 @x1 @x2) (Prims.Mktuple2__2 @x2)) :pattern ((Prims.Mktuple2._2 @x0 @x1 @x2)))) :named proj_equation_Prims.Mktuple2__2))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (Valid (Prims.hasEq @x0)) (Valid (Prims.hasEq @x1))) (Valid (Prims.hasEq (Prims.tuple2 @x0 @x1)))) :pattern ((Prims.hasEq (Prims.tuple2 @x0 @x1))))) :named assumption_Prims.HasEq_tuple2_647))
(declare-fun Prims.tuple3 (Term Term Term) Term)
(declare-fun Prims.tuple3@x0 (Term) Term)
(declare-fun Prims.tuple3@x1 (Term) Term)
(declare-fun Prims.tuple3@x2 (Term) Term)
(declare-fun Prims.tuple3@tok () Term)
(declare-fun Prims.Mktuple3 (Term Term Term Term Term Term) Term)
(declare-fun Prims.Mktuple3__a (Term) Term)
(declare-fun Prims.Mktuple3__b (Term) Term)
(declare-fun Prims.Mktuple3__c (Term) Term)
(declare-fun Prims.Mktuple3__1 (Term) Term)
(declare-fun Prims.Mktuple3__2 (Term) Term)
(declare-fun Prims.Mktuple3__3 (Term) Term)
(declare-fun Tm_arrow_659 () Term)
(declare-fun Prims.Mktuple3@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= 648 (Term_constr_id (Prims.tuple3 @x0 @x1 @x2))) :pattern ((Prims.tuple3 @x0 @x1 @x2)))) :named constructor_distinct_Prims.tuple3))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (Prims.tuple3@x0 (Prims.tuple3 @x0 @x1 @x2)) @x0) :pattern ((Prims.tuple3 @x0 @x1 @x2)))) :named projection_inverse_Prims.tuple3@x0))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (Prims.tuple3@x1 (Prims.tuple3 @x0 @x1 @x2)) @x1) :pattern ((Prims.tuple3 @x0 @x1 @x2)))) :named projection_inverse_Prims.tuple3@x1))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (Prims.tuple3@x2 (Prims.tuple3 @x0 @x1 @x2)) @x2) :pattern ((Prims.tuple3 @x0 @x1 @x2)))) :named projection_inverse_Prims.tuple3@x2))
(define-fun is-Prims.tuple3 ((@x0 Term)) Bool (and (= (Term_constr_id @x0) 648) (= @x0 (Prims.tuple3 (Prims.tuple3@x0 @x0) (Prims.tuple3@x1 @x0) (Prims.tuple3@x2 @x0)))))
(assert (! (= 649 (Term_constr_id Prims.tuple3@tok)) :named fresh_token_Prims.tuple3@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT Prims.tuple3@tok @x0) @x1) @x2) (Prims.tuple3 @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT Prims.tuple3@tok @x0) @x1) @x2)) :pattern ((Prims.tuple3 @x0 @x1 @x2)))) :named token_correspondence_Prims.tuple3@tok))
(assert (! (is-Tm_arrow (PreType Prims.tuple3@tok)) :named pre_kinding_Prims.tuple3@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 Tm_type)) (HasType (Prims.tuple3 @x0 @x1 @x2) Tm_type)) :pattern ((Prims.tuple3 @x0 @x1 @x2)))) :named kinding_Prims.tuple3@tok))
(assert (! (forall ((@x0 Term) (@u1 Fuel) (@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (HasTypeFuel @u1 @x0 (Prims.tuple3 @x2 @x3 @x4)) (= (Prims.tuple3 @x2 @x3 @x4) (PreType @x0))) :pattern ((HasTypeFuel @u1 @x0 (Prims.tuple3 @x2 @x3 @x4))))) :named @pretyping__655))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (= 657 (Term_constr_id (Prims.Mktuple3 @x0 @x1 @x2 @x3 @x4 @x5))) :pattern ((Prims.Mktuple3 @x0 @x1 @x2 @x3 @x4 @x5)))) :named constructor_distinct_Prims.Mktuple3))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (= (Prims.Mktuple3__a (Prims.Mktuple3 @x0 @x1 @x2 @x3 @x4 @x5)) @x0) :pattern ((Prims.Mktuple3 @x0 @x1 @x2 @x3 @x4 @x5)))) :named projection_inverse_Prims.Mktuple3__a))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (= (Prims.Mktuple3__b (Prims.Mktuple3 @x0 @x1 @x2 @x3 @x4 @x5)) @x1) :pattern ((Prims.Mktuple3 @x0 @x1 @x2 @x3 @x4 @x5)))) :named projection_inverse_Prims.Mktuple3__b))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (= (Prims.Mktuple3__c (Prims.Mktuple3 @x0 @x1 @x2 @x3 @x4 @x5)) @x2) :pattern ((Prims.Mktuple3 @x0 @x1 @x2 @x3 @x4 @x5)))) :named projection_inverse_Prims.Mktuple3__c))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (= (Prims.Mktuple3__1 (Prims.Mktuple3 @x0 @x1 @x2 @x3 @x4 @x5)) @x3) :pattern ((Prims.Mktuple3 @x0 @x1 @x2 @x3 @x4 @x5)))) :named projection_inverse_Prims.Mktuple3__1))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (= (Prims.Mktuple3__2 (Prims.Mktuple3 @x0 @x1 @x2 @x3 @x4 @x5)) @x4) :pattern ((Prims.Mktuple3 @x0 @x1 @x2 @x3 @x4 @x5)))) :named projection_inverse_Prims.Mktuple3__2))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (= (Prims.Mktuple3__3 (Prims.Mktuple3 @x0 @x1 @x2 @x3 @x4 @x5)) @x5) :pattern ((Prims.Mktuple3 @x0 @x1 @x2 @x3 @x4 @x5)))) :named projection_inverse_Prims.Mktuple3__3))
(define-fun is-Prims.Mktuple3 ((@x0 Term)) Bool (and (= (Term_constr_id @x0) 657) (= @x0 (Prims.Mktuple3 (Prims.Mktuple3__a @x0) (Prims.Mktuple3__b @x0) (Prims.Mktuple3__c @x0) (Prims.Mktuple3__1 @x0) (Prims.Mktuple3__2 @x0) (Prims.Mktuple3__3 @x0)))))
(assert (! (HasType Tm_arrow_659 Tm_type) :named kinding_Tm_arrow_659))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_659) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_659)))) :named pre_typing_Tm_arrow_659))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_659) (forall ((@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 @x1) (HasType @x5 @x2) (HasType @x6 @x3)) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x6) (Prims.tuple3 @x1 @x2 @x3))) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x6))))) :pattern ((HasTypeZ @x0 Tm_arrow_659)))) :named interpretation_Tm_arrow_659))
(assert (! (= 661 (Term_constr_id Prims.Mktuple3@tok)) :named fresh_token_Prims.Mktuple3@tok))
(assert (! (HasType Prims.Mktuple3@tok Tm_arrow_659) :named typing_tok_Prims.Mktuple3@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple3@tok @x0) @x1) @x2) @x3) @x4) @x5) (Prims.Mktuple3 @x0 @x1 @x2 @x3 @x4 @x5)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple3@tok @x0) @x1) @x2) @x3) @x4) @x5)))) :named equality_tok_Prims.Mktuple3@tok))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term)) (! (implies (and (HasTypeFuel @u0 @x1 Tm_type) (HasTypeFuel @u0 @x2 Tm_type) (HasTypeFuel @u0 @x3 Tm_type) (HasTypeFuel @u0 @x4 @x1) (HasTypeFuel @u0 @x5 @x2) (HasTypeFuel @u0 @x6 @x3)) (HasTypeFuel @u0 (Prims.Mktuple3 @x1 @x2 @x3 @x4 @x5 @x6) (Prims.tuple3 @x1 @x2 @x3))) :pattern ((HasTypeFuel @u0 (Prims.Mktuple3 @x1 @x2 @x3 @x4 @x5 @x6) (Prims.tuple3 @x1 @x2 @x3))))) :named data_typing_intro_Prims.Mktuple3@tok))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term)) (! (implies (HasTypeFuel (SFuel @u0) (Prims.Mktuple3 @x1 @x2 @x3 @x4 @x5 @x6) (Prims.tuple3 @x7 @x8 @x9)) (and (= @x3 @x9) (= @x2 @x8) (= @x1 @x7) (HasTypeFuel @u0 @x1 Tm_type) (HasTypeFuel @u0 @x2 Tm_type) (HasTypeFuel @u0 @x3 Tm_type) (HasTypeFuel @u0 @x4 @x1) (HasTypeFuel @u0 @x5 @x2) (HasTypeFuel @u0 @x6 @x3))) :pattern ((HasTypeFuel (SFuel @u0) (Prims.Mktuple3 @x1 @x2 @x3 @x4 @x5 @x6) (Prims.tuple3 @x7 @x8 @x9))))) :named data_elim_Prims.Mktuple3))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term)) (! (implies (HasTypeFuel (SFuel @u0) (Prims.Mktuple3 @x1 @x2 @x3 @x4 @x5 @x6) (Prims.tuple3 @x7 @x8 @x9)) (and (Valid (Precedes @x1 (Prims.Mktuple3 @x1 @x2 @x3 @x4 @x5 @x6))) (Valid (Precedes @x2 (Prims.Mktuple3 @x1 @x2 @x3 @x4 @x5 @x6))) (Valid (Precedes @x3 (Prims.Mktuple3 @x1 @x2 @x3 @x4 @x5 @x6))) (Valid (Precedes @x4 (Prims.Mktuple3 @x1 @x2 @x3 @x4 @x5 @x6))) (Valid (Precedes @x5 (Prims.Mktuple3 @x1 @x2 @x3 @x4 @x5 @x6))) (Valid (Precedes @x6 (Prims.Mktuple3 @x1 @x2 @x3 @x4 @x5 @x6))))) :pattern ((HasTypeFuel (SFuel @u0) (Prims.Mktuple3 @x1 @x2 @x3 @x4 @x5 @x6) (Prims.tuple3 @x7 @x8 @x9))))) :named subterm_ordering_Prims.Mktuple3))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (HasTypeFuel @u0 @x1 (Prims.tuple3 @x2 @x3 @x4)) (and (is-Prims.Mktuple3 @x1) (= @x2 (Prims.Mktuple3__a @x1)) (= @x3 (Prims.Mktuple3__b @x1)) (= @x4 (Prims.Mktuple3__c @x1)))) :pattern ((HasTypeFuel @u0 @x1 (Prims.tuple3 @x2 @x3 @x4))))) :named fuel_guarded_inversion_Prims.tuple3_652))
(declare-fun Prims.Mktuple3._1 (Term Term Term Term) Term)
(declare-fun Tm_arrow_663 () Term)
(assert (! (HasType Tm_arrow_663 Tm_type) :named kinding_Tm_arrow_663))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_663) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_663)))) :named pre_typing_Tm_arrow_663))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_663) (forall ((@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 (Prims.tuple3 @x1 @x2 @x3))) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x1)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4))))) :pattern ((HasTypeZ @x0 Tm_arrow_663)))) :named interpretation_Tm_arrow_663))
(declare-fun Prims.Mktuple3._1@tok () Term)
(assert (! (= 665 (Term_constr_id Prims.Mktuple3._1@tok)) :named fresh_token_Prims.Mktuple3._1@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple3._1@tok @x0) @x1) @x2) @x3) (Prims.Mktuple3._1 @x0 @x1 @x2 @x3)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple3._1@tok @x0) @x1) @x2) @x3)))) :named token_correspondence_Prims.Mktuple3._1))
(assert (! (HasType Prims.Mktuple3._1@tok Tm_arrow_663) :named function_token_typing_Prims.Mktuple3._1))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 (Prims.tuple3 @x0 @x1 @x2))) (HasType (Prims.Mktuple3._1 @x0 @x1 @x2 @x3) @x0)) :pattern ((Prims.Mktuple3._1 @x0 @x1 @x2 @x3)))) :named typing_Prims.Mktuple3._1))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (Prims.Mktuple3._1 @x0 @x1 @x2 @x3) (Prims.Mktuple3__1 @x3)) :pattern ((Prims.Mktuple3._1 @x0 @x1 @x2 @x3)))) :named proj_equation_Prims.Mktuple3__1))
(declare-fun Prims.Mktuple3._2 (Term Term Term Term) Term)
(declare-fun Tm_arrow_667 () Term)
(assert (! (HasType Tm_arrow_667 Tm_type) :named kinding_Tm_arrow_667))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_667) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_667)))) :named pre_typing_Tm_arrow_667))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_667) (forall ((@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 (Prims.tuple3 @x1 @x2 @x3))) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4))))) :pattern ((HasTypeZ @x0 Tm_arrow_667)))) :named interpretation_Tm_arrow_667))
(declare-fun Prims.Mktuple3._2@tok () Term)
(assert (! (= 669 (Term_constr_id Prims.Mktuple3._2@tok)) :named fresh_token_Prims.Mktuple3._2@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple3._2@tok @x0) @x1) @x2) @x3) (Prims.Mktuple3._2 @x0 @x1 @x2 @x3)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple3._2@tok @x0) @x1) @x2) @x3)))) :named token_correspondence_Prims.Mktuple3._2))
(assert (! (HasType Prims.Mktuple3._2@tok Tm_arrow_667) :named function_token_typing_Prims.Mktuple3._2))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 (Prims.tuple3 @x0 @x1 @x2))) (HasType (Prims.Mktuple3._2 @x0 @x1 @x2 @x3) @x1)) :pattern ((Prims.Mktuple3._2 @x0 @x1 @x2 @x3)))) :named typing_Prims.Mktuple3._2))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (Prims.Mktuple3._2 @x0 @x1 @x2 @x3) (Prims.Mktuple3__2 @x3)) :pattern ((Prims.Mktuple3._2 @x0 @x1 @x2 @x3)))) :named proj_equation_Prims.Mktuple3__2))
(declare-fun Prims.Mktuple3._3 (Term Term Term Term) Term)
(declare-fun Tm_arrow_671 () Term)
(assert (! (HasType Tm_arrow_671 Tm_type) :named kinding_Tm_arrow_671))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_671) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_671)))) :named pre_typing_Tm_arrow_671))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_671) (forall ((@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 (Prims.tuple3 @x1 @x2 @x3))) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x3)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4))))) :pattern ((HasTypeZ @x0 Tm_arrow_671)))) :named interpretation_Tm_arrow_671))
(declare-fun Prims.Mktuple3._3@tok () Term)
(assert (! (= 673 (Term_constr_id Prims.Mktuple3._3@tok)) :named fresh_token_Prims.Mktuple3._3@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple3._3@tok @x0) @x1) @x2) @x3) (Prims.Mktuple3._3 @x0 @x1 @x2 @x3)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple3._3@tok @x0) @x1) @x2) @x3)))) :named token_correspondence_Prims.Mktuple3._3))
(assert (! (HasType Prims.Mktuple3._3@tok Tm_arrow_671) :named function_token_typing_Prims.Mktuple3._3))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 (Prims.tuple3 @x0 @x1 @x2))) (HasType (Prims.Mktuple3._3 @x0 @x1 @x2 @x3) @x2)) :pattern ((Prims.Mktuple3._3 @x0 @x1 @x2 @x3)))) :named typing_Prims.Mktuple3._3))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (Prims.Mktuple3._3 @x0 @x1 @x2 @x3) (Prims.Mktuple3__3 @x3)) :pattern ((Prims.Mktuple3._3 @x0 @x1 @x2 @x3)))) :named proj_equation_Prims.Mktuple3__3))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 Tm_type) (Valid (Prims.hasEq @x0)) (Valid (Prims.hasEq @x1)) (Valid (Prims.hasEq @x2))) (Valid (Prims.hasEq (Prims.tuple3 @x0 @x1 @x2)))) :pattern ((Prims.hasEq (Prims.tuple3 @x0 @x1 @x2))))) :named assumption_Prims.HasEq_tuple3_674))
(declare-fun Prims.tuple4 (Term Term Term Term) Term)
(declare-fun Prims.tuple4@x0 (Term) Term)
(declare-fun Prims.tuple4@x1 (Term) Term)
(declare-fun Prims.tuple4@x2 (Term) Term)
(declare-fun Prims.tuple4@x3 (Term) Term)
(declare-fun Prims.tuple4@tok () Term)
(declare-fun Prims.Mktuple4 (Term Term Term Term Term Term Term Term) Term)
(declare-fun Prims.Mktuple4__a (Term) Term)
(declare-fun Prims.Mktuple4__b (Term) Term)
(declare-fun Prims.Mktuple4__c (Term) Term)
(declare-fun Prims.Mktuple4__d (Term) Term)
(declare-fun Prims.Mktuple4__1 (Term) Term)
(declare-fun Prims.Mktuple4__2 (Term) Term)
(declare-fun Prims.Mktuple4__3 (Term) Term)
(declare-fun Prims.Mktuple4__4 (Term) Term)
(declare-fun Tm_arrow_686 () Term)
(declare-fun Prims.Mktuple4@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= 675 (Term_constr_id (Prims.tuple4 @x0 @x1 @x2 @x3))) :pattern ((Prims.tuple4 @x0 @x1 @x2 @x3)))) :named constructor_distinct_Prims.tuple4))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (Prims.tuple4@x0 (Prims.tuple4 @x0 @x1 @x2 @x3)) @x0) :pattern ((Prims.tuple4 @x0 @x1 @x2 @x3)))) :named projection_inverse_Prims.tuple4@x0))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (Prims.tuple4@x1 (Prims.tuple4 @x0 @x1 @x2 @x3)) @x1) :pattern ((Prims.tuple4 @x0 @x1 @x2 @x3)))) :named projection_inverse_Prims.tuple4@x1))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (Prims.tuple4@x2 (Prims.tuple4 @x0 @x1 @x2 @x3)) @x2) :pattern ((Prims.tuple4 @x0 @x1 @x2 @x3)))) :named projection_inverse_Prims.tuple4@x2))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (Prims.tuple4@x3 (Prims.tuple4 @x0 @x1 @x2 @x3)) @x3) :pattern ((Prims.tuple4 @x0 @x1 @x2 @x3)))) :named projection_inverse_Prims.tuple4@x3))
(define-fun is-Prims.tuple4 ((@x0 Term)) Bool (and (= (Term_constr_id @x0) 675) (= @x0 (Prims.tuple4 (Prims.tuple4@x0 @x0) (Prims.tuple4@x1 @x0) (Prims.tuple4@x2 @x0) (Prims.tuple4@x3 @x0)))))
(assert (! (= 676 (Term_constr_id Prims.tuple4@tok)) :named fresh_token_Prims.tuple4@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.tuple4@tok @x0) @x1) @x2) @x3) (Prims.tuple4 @x0 @x1 @x2 @x3)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.tuple4@tok @x0) @x1) @x2) @x3)) :pattern ((Prims.tuple4 @x0 @x1 @x2 @x3)))) :named token_correspondence_Prims.tuple4@tok))
(assert (! (is-Tm_arrow (PreType Prims.tuple4@tok)) :named pre_kinding_Prims.tuple4@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type)) (HasType (Prims.tuple4 @x0 @x1 @x2 @x3) Tm_type)) :pattern ((Prims.tuple4 @x0 @x1 @x2 @x3)))) :named kinding_Prims.tuple4@tok))
(assert (! (forall ((@x0 Term) (@u1 Fuel) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (implies (HasTypeFuel @u1 @x0 (Prims.tuple4 @x2 @x3 @x4 @x5)) (= (Prims.tuple4 @x2 @x3 @x4 @x5) (PreType @x0))) :pattern ((HasTypeFuel @u1 @x0 (Prims.tuple4 @x2 @x3 @x4 @x5))))) :named @pretyping__682))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term)) (! (= 684 (Term_constr_id (Prims.Mktuple4 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7))) :pattern ((Prims.Mktuple4 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)))) :named constructor_distinct_Prims.Mktuple4))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term)) (! (= (Prims.Mktuple4__a (Prims.Mktuple4 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)) @x0) :pattern ((Prims.Mktuple4 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)))) :named projection_inverse_Prims.Mktuple4__a))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term)) (! (= (Prims.Mktuple4__b (Prims.Mktuple4 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)) @x1) :pattern ((Prims.Mktuple4 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)))) :named projection_inverse_Prims.Mktuple4__b))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term)) (! (= (Prims.Mktuple4__c (Prims.Mktuple4 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)) @x2) :pattern ((Prims.Mktuple4 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)))) :named projection_inverse_Prims.Mktuple4__c))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term)) (! (= (Prims.Mktuple4__d (Prims.Mktuple4 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)) @x3) :pattern ((Prims.Mktuple4 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)))) :named projection_inverse_Prims.Mktuple4__d))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term)) (! (= (Prims.Mktuple4__1 (Prims.Mktuple4 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)) @x4) :pattern ((Prims.Mktuple4 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)))) :named projection_inverse_Prims.Mktuple4__1))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term)) (! (= (Prims.Mktuple4__2 (Prims.Mktuple4 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)) @x5) :pattern ((Prims.Mktuple4 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)))) :named projection_inverse_Prims.Mktuple4__2))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term)) (! (= (Prims.Mktuple4__3 (Prims.Mktuple4 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)) @x6) :pattern ((Prims.Mktuple4 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)))) :named projection_inverse_Prims.Mktuple4__3))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term)) (! (= (Prims.Mktuple4__4 (Prims.Mktuple4 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)) @x7) :pattern ((Prims.Mktuple4 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)))) :named projection_inverse_Prims.Mktuple4__4))
(define-fun is-Prims.Mktuple4 ((@x0 Term)) Bool (and (= (Term_constr_id @x0) 684) (= @x0 (Prims.Mktuple4 (Prims.Mktuple4__a @x0) (Prims.Mktuple4__b @x0) (Prims.Mktuple4__c @x0) (Prims.Mktuple4__d @x0) (Prims.Mktuple4__1 @x0) (Prims.Mktuple4__2 @x0) (Prims.Mktuple4__3 @x0) (Prims.Mktuple4__4 @x0)))))
(assert (! (HasType Tm_arrow_686 Tm_type) :named kinding_Tm_arrow_686))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_686) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_686)))) :named pre_typing_Tm_arrow_686))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_686) (forall ((@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 Tm_type) (HasType @x5 @x1) (HasType @x6 @x2) (HasType @x7 @x3) (HasType @x8 @x4)) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x8) (Prims.tuple4 @x1 @x2 @x3 @x4))) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x8))))) :pattern ((HasTypeZ @x0 Tm_arrow_686)))) :named interpretation_Tm_arrow_686))
(assert (! (= 688 (Term_constr_id Prims.Mktuple4@tok)) :named fresh_token_Prims.Mktuple4@tok))
(assert (! (HasType Prims.Mktuple4@tok Tm_arrow_686) :named typing_tok_Prims.Mktuple4@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple4@tok @x0) @x1) @x2) @x3) @x4) @x5) @x6) @x7) (Prims.Mktuple4 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple4@tok @x0) @x1) @x2) @x3) @x4) @x5) @x6) @x7)))) :named equality_tok_Prims.Mktuple4@tok))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term)) (! (implies (and (HasTypeFuel @u0 @x1 Tm_type) (HasTypeFuel @u0 @x2 Tm_type) (HasTypeFuel @u0 @x3 Tm_type) (HasTypeFuel @u0 @x4 Tm_type) (HasTypeFuel @u0 @x5 @x1) (HasTypeFuel @u0 @x6 @x2) (HasTypeFuel @u0 @x7 @x3) (HasTypeFuel @u0 @x8 @x4)) (HasTypeFuel @u0 (Prims.Mktuple4 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8) (Prims.tuple4 @x1 @x2 @x3 @x4))) :pattern ((HasTypeFuel @u0 (Prims.Mktuple4 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8) (Prims.tuple4 @x1 @x2 @x3 @x4))))) :named data_typing_intro_Prims.Mktuple4@tok))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term) (@x10 Term) (@x11 Term) (@x12 Term)) (! (implies (HasTypeFuel (SFuel @u0) (Prims.Mktuple4 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8) (Prims.tuple4 @x9 @x10 @x11 @x12)) (and (= @x4 @x12) (= @x3 @x11) (= @x2 @x10) (= @x1 @x9) (HasTypeFuel @u0 @x1 Tm_type) (HasTypeFuel @u0 @x2 Tm_type) (HasTypeFuel @u0 @x3 Tm_type) (HasTypeFuel @u0 @x4 Tm_type) (HasTypeFuel @u0 @x5 @x1) (HasTypeFuel @u0 @x6 @x2) (HasTypeFuel @u0 @x7 @x3) (HasTypeFuel @u0 @x8 @x4))) :pattern ((HasTypeFuel (SFuel @u0) (Prims.Mktuple4 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8) (Prims.tuple4 @x9 @x10 @x11 @x12))))) :named data_elim_Prims.Mktuple4))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term) (@x10 Term) (@x11 Term) (@x12 Term)) (! (implies (HasTypeFuel (SFuel @u0) (Prims.Mktuple4 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8) (Prims.tuple4 @x9 @x10 @x11 @x12)) (and (Valid (Precedes @x1 (Prims.Mktuple4 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8))) (Valid (Precedes @x2 (Prims.Mktuple4 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8))) (Valid (Precedes @x3 (Prims.Mktuple4 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8))) (Valid (Precedes @x4 (Prims.Mktuple4 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8))) (Valid (Precedes @x5 (Prims.Mktuple4 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8))) (Valid (Precedes @x6 (Prims.Mktuple4 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8))) (Valid (Precedes @x7 (Prims.Mktuple4 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8))) (Valid (Precedes @x8 (Prims.Mktuple4 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8))))) :pattern ((HasTypeFuel (SFuel @u0) (Prims.Mktuple4 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8) (Prims.tuple4 @x9 @x10 @x11 @x12))))) :named subterm_ordering_Prims.Mktuple4))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (implies (HasTypeFuel @u0 @x1 (Prims.tuple4 @x2 @x3 @x4 @x5)) (and (is-Prims.Mktuple4 @x1) (= @x2 (Prims.Mktuple4__a @x1)) (= @x3 (Prims.Mktuple4__b @x1)) (= @x4 (Prims.Mktuple4__c @x1)) (= @x5 (Prims.Mktuple4__d @x1)))) :pattern ((HasTypeFuel @u0 @x1 (Prims.tuple4 @x2 @x3 @x4 @x5))))) :named fuel_guarded_inversion_Prims.tuple4_679))
(declare-fun Prims.Mktuple4._1 (Term Term Term Term Term) Term)
(declare-fun Tm_arrow_690 () Term)
(assert (! (HasType Tm_arrow_690 Tm_type) :named kinding_Tm_arrow_690))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_690) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_690)))) :named pre_typing_Tm_arrow_690))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_690) (forall ((@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 Tm_type) (HasType @x5 (Prims.tuple4 @x1 @x2 @x3 @x4))) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x1)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5))))) :pattern ((HasTypeZ @x0 Tm_arrow_690)))) :named interpretation_Tm_arrow_690))
(declare-fun Prims.Mktuple4._1@tok () Term)
(assert (! (= 692 (Term_constr_id Prims.Mktuple4._1@tok)) :named fresh_token_Prims.Mktuple4._1@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple4._1@tok @x0) @x1) @x2) @x3) @x4) (Prims.Mktuple4._1 @x0 @x1 @x2 @x3 @x4)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple4._1@tok @x0) @x1) @x2) @x3) @x4)))) :named token_correspondence_Prims.Mktuple4._1))
(assert (! (HasType Prims.Mktuple4._1@tok Tm_arrow_690) :named function_token_typing_Prims.Mktuple4._1))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 (Prims.tuple4 @x0 @x1 @x2 @x3))) (HasType (Prims.Mktuple4._1 @x0 @x1 @x2 @x3 @x4) @x0)) :pattern ((Prims.Mktuple4._1 @x0 @x1 @x2 @x3 @x4)))) :named typing_Prims.Mktuple4._1))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (= (Prims.Mktuple4._1 @x0 @x1 @x2 @x3 @x4) (Prims.Mktuple4__1 @x4)) :pattern ((Prims.Mktuple4._1 @x0 @x1 @x2 @x3 @x4)))) :named proj_equation_Prims.Mktuple4__1))
(declare-fun Prims.Mktuple4._2 (Term Term Term Term Term) Term)
(declare-fun Tm_arrow_694 () Term)
(assert (! (HasType Tm_arrow_694 Tm_type) :named kinding_Tm_arrow_694))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_694) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_694)))) :named pre_typing_Tm_arrow_694))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_694) (forall ((@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 Tm_type) (HasType @x5 (Prims.tuple4 @x1 @x2 @x3 @x4))) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5))))) :pattern ((HasTypeZ @x0 Tm_arrow_694)))) :named interpretation_Tm_arrow_694))
(declare-fun Prims.Mktuple4._2@tok () Term)
(assert (! (= 696 (Term_constr_id Prims.Mktuple4._2@tok)) :named fresh_token_Prims.Mktuple4._2@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple4._2@tok @x0) @x1) @x2) @x3) @x4) (Prims.Mktuple4._2 @x0 @x1 @x2 @x3 @x4)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple4._2@tok @x0) @x1) @x2) @x3) @x4)))) :named token_correspondence_Prims.Mktuple4._2))
(assert (! (HasType Prims.Mktuple4._2@tok Tm_arrow_694) :named function_token_typing_Prims.Mktuple4._2))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 (Prims.tuple4 @x0 @x1 @x2 @x3))) (HasType (Prims.Mktuple4._2 @x0 @x1 @x2 @x3 @x4) @x1)) :pattern ((Prims.Mktuple4._2 @x0 @x1 @x2 @x3 @x4)))) :named typing_Prims.Mktuple4._2))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (= (Prims.Mktuple4._2 @x0 @x1 @x2 @x3 @x4) (Prims.Mktuple4__2 @x4)) :pattern ((Prims.Mktuple4._2 @x0 @x1 @x2 @x3 @x4)))) :named proj_equation_Prims.Mktuple4__2))
(declare-fun Prims.Mktuple4._3 (Term Term Term Term Term) Term)
(declare-fun Tm_arrow_698 () Term)
(assert (! (HasType Tm_arrow_698 Tm_type) :named kinding_Tm_arrow_698))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_698) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_698)))) :named pre_typing_Tm_arrow_698))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_698) (forall ((@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 Tm_type) (HasType @x5 (Prims.tuple4 @x1 @x2 @x3 @x4))) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x3)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5))))) :pattern ((HasTypeZ @x0 Tm_arrow_698)))) :named interpretation_Tm_arrow_698))
(declare-fun Prims.Mktuple4._3@tok () Term)
(assert (! (= 700 (Term_constr_id Prims.Mktuple4._3@tok)) :named fresh_token_Prims.Mktuple4._3@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple4._3@tok @x0) @x1) @x2) @x3) @x4) (Prims.Mktuple4._3 @x0 @x1 @x2 @x3 @x4)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple4._3@tok @x0) @x1) @x2) @x3) @x4)))) :named token_correspondence_Prims.Mktuple4._3))
(assert (! (HasType Prims.Mktuple4._3@tok Tm_arrow_698) :named function_token_typing_Prims.Mktuple4._3))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 (Prims.tuple4 @x0 @x1 @x2 @x3))) (HasType (Prims.Mktuple4._3 @x0 @x1 @x2 @x3 @x4) @x2)) :pattern ((Prims.Mktuple4._3 @x0 @x1 @x2 @x3 @x4)))) :named typing_Prims.Mktuple4._3))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (= (Prims.Mktuple4._3 @x0 @x1 @x2 @x3 @x4) (Prims.Mktuple4__3 @x4)) :pattern ((Prims.Mktuple4._3 @x0 @x1 @x2 @x3 @x4)))) :named proj_equation_Prims.Mktuple4__3))
(declare-fun Prims.Mktuple4._4 (Term Term Term Term Term) Term)
(declare-fun Tm_arrow_702 () Term)
(assert (! (HasType Tm_arrow_702 Tm_type) :named kinding_Tm_arrow_702))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_702) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_702)))) :named pre_typing_Tm_arrow_702))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_702) (forall ((@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 Tm_type) (HasType @x5 (Prims.tuple4 @x1 @x2 @x3 @x4))) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x4)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5))))) :pattern ((HasTypeZ @x0 Tm_arrow_702)))) :named interpretation_Tm_arrow_702))
(declare-fun Prims.Mktuple4._4@tok () Term)
(assert (! (= 704 (Term_constr_id Prims.Mktuple4._4@tok)) :named fresh_token_Prims.Mktuple4._4@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple4._4@tok @x0) @x1) @x2) @x3) @x4) (Prims.Mktuple4._4 @x0 @x1 @x2 @x3 @x4)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple4._4@tok @x0) @x1) @x2) @x3) @x4)))) :named token_correspondence_Prims.Mktuple4._4))
(assert (! (HasType Prims.Mktuple4._4@tok Tm_arrow_702) :named function_token_typing_Prims.Mktuple4._4))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 (Prims.tuple4 @x0 @x1 @x2 @x3))) (HasType (Prims.Mktuple4._4 @x0 @x1 @x2 @x3 @x4) @x3)) :pattern ((Prims.Mktuple4._4 @x0 @x1 @x2 @x3 @x4)))) :named typing_Prims.Mktuple4._4))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (= (Prims.Mktuple4._4 @x0 @x1 @x2 @x3 @x4) (Prims.Mktuple4__4 @x4)) :pattern ((Prims.Mktuple4._4 @x0 @x1 @x2 @x3 @x4)))) :named proj_equation_Prims.Mktuple4__4))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (Valid (Prims.hasEq @x0)) (Valid (Prims.hasEq @x1)) (Valid (Prims.hasEq @x2)) (Valid (Prims.hasEq @x3))) (Valid (Prims.hasEq (Prims.tuple4 @x0 @x1 @x2 @x3)))) :pattern ((Prims.hasEq (Prims.tuple4 @x0 @x1 @x2 @x3))))) :named assumption_Prims.HasEq_tuple4_705))
(declare-fun Prims.tuple5 (Term Term Term Term Term) Term)
(declare-fun Prims.tuple5@x0 (Term) Term)
(declare-fun Prims.tuple5@x1 (Term) Term)
(declare-fun Prims.tuple5@x2 (Term) Term)
(declare-fun Prims.tuple5@x3 (Term) Term)
(declare-fun Prims.tuple5@x4 (Term) Term)
(declare-fun Prims.tuple5@tok () Term)
(declare-fun Prims.Mktuple5 (Term Term Term Term Term Term Term Term Term Term) Term)
(declare-fun Prims.Mktuple5__a (Term) Term)
(declare-fun Prims.Mktuple5__b (Term) Term)
(declare-fun Prims.Mktuple5__c (Term) Term)
(declare-fun Prims.Mktuple5__d (Term) Term)
(declare-fun Prims.Mktuple5__e (Term) Term)
(declare-fun Prims.Mktuple5__1 (Term) Term)
(declare-fun Prims.Mktuple5__2 (Term) Term)
(declare-fun Prims.Mktuple5__3 (Term) Term)
(declare-fun Prims.Mktuple5__4 (Term) Term)
(declare-fun Prims.Mktuple5__5 (Term) Term)
(declare-fun Tm_arrow_717 () Term)
(declare-fun Prims.Mktuple5@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (= 706 (Term_constr_id (Prims.tuple5 @x0 @x1 @x2 @x3 @x4))) :pattern ((Prims.tuple5 @x0 @x1 @x2 @x3 @x4)))) :named constructor_distinct_Prims.tuple5))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (= (Prims.tuple5@x0 (Prims.tuple5 @x0 @x1 @x2 @x3 @x4)) @x0) :pattern ((Prims.tuple5 @x0 @x1 @x2 @x3 @x4)))) :named projection_inverse_Prims.tuple5@x0))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (= (Prims.tuple5@x1 (Prims.tuple5 @x0 @x1 @x2 @x3 @x4)) @x1) :pattern ((Prims.tuple5 @x0 @x1 @x2 @x3 @x4)))) :named projection_inverse_Prims.tuple5@x1))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (= (Prims.tuple5@x2 (Prims.tuple5 @x0 @x1 @x2 @x3 @x4)) @x2) :pattern ((Prims.tuple5 @x0 @x1 @x2 @x3 @x4)))) :named projection_inverse_Prims.tuple5@x2))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (= (Prims.tuple5@x3 (Prims.tuple5 @x0 @x1 @x2 @x3 @x4)) @x3) :pattern ((Prims.tuple5 @x0 @x1 @x2 @x3 @x4)))) :named projection_inverse_Prims.tuple5@x3))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (= (Prims.tuple5@x4 (Prims.tuple5 @x0 @x1 @x2 @x3 @x4)) @x4) :pattern ((Prims.tuple5 @x0 @x1 @x2 @x3 @x4)))) :named projection_inverse_Prims.tuple5@x4))
(define-fun is-Prims.tuple5 ((@x0 Term)) Bool (and (= (Term_constr_id @x0) 706) (= @x0 (Prims.tuple5 (Prims.tuple5@x0 @x0) (Prims.tuple5@x1 @x0) (Prims.tuple5@x2 @x0) (Prims.tuple5@x3 @x0) (Prims.tuple5@x4 @x0)))))
(assert (! (= 707 (Term_constr_id Prims.tuple5@tok)) :named fresh_token_Prims.tuple5@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.tuple5@tok @x0) @x1) @x2) @x3) @x4) (Prims.tuple5 @x0 @x1 @x2 @x3 @x4)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.tuple5@tok @x0) @x1) @x2) @x3) @x4)) :pattern ((Prims.tuple5 @x0 @x1 @x2 @x3 @x4)))) :named token_correspondence_Prims.tuple5@tok))
(assert (! (is-Tm_arrow (PreType Prims.tuple5@tok)) :named pre_kinding_Prims.tuple5@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 Tm_type)) (HasType (Prims.tuple5 @x0 @x1 @x2 @x3 @x4) Tm_type)) :pattern ((Prims.tuple5 @x0 @x1 @x2 @x3 @x4)))) :named kinding_Prims.tuple5@tok))
(assert (! (forall ((@x0 Term) (@u1 Fuel) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term)) (! (implies (HasTypeFuel @u1 @x0 (Prims.tuple5 @x2 @x3 @x4 @x5 @x6)) (= (Prims.tuple5 @x2 @x3 @x4 @x5 @x6) (PreType @x0))) :pattern ((HasTypeFuel @u1 @x0 (Prims.tuple5 @x2 @x3 @x4 @x5 @x6))))) :named @pretyping__713))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term)) (! (= 715 (Term_constr_id (Prims.Mktuple5 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9))) :pattern ((Prims.Mktuple5 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9)))) :named constructor_distinct_Prims.Mktuple5))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term)) (! (= (Prims.Mktuple5__a (Prims.Mktuple5 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9)) @x0) :pattern ((Prims.Mktuple5 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9)))) :named projection_inverse_Prims.Mktuple5__a))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term)) (! (= (Prims.Mktuple5__b (Prims.Mktuple5 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9)) @x1) :pattern ((Prims.Mktuple5 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9)))) :named projection_inverse_Prims.Mktuple5__b))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term)) (! (= (Prims.Mktuple5__c (Prims.Mktuple5 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9)) @x2) :pattern ((Prims.Mktuple5 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9)))) :named projection_inverse_Prims.Mktuple5__c))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term)) (! (= (Prims.Mktuple5__d (Prims.Mktuple5 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9)) @x3) :pattern ((Prims.Mktuple5 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9)))) :named projection_inverse_Prims.Mktuple5__d))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term)) (! (= (Prims.Mktuple5__e (Prims.Mktuple5 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9)) @x4) :pattern ((Prims.Mktuple5 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9)))) :named projection_inverse_Prims.Mktuple5__e))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term)) (! (= (Prims.Mktuple5__1 (Prims.Mktuple5 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9)) @x5) :pattern ((Prims.Mktuple5 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9)))) :named projection_inverse_Prims.Mktuple5__1))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term)) (! (= (Prims.Mktuple5__2 (Prims.Mktuple5 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9)) @x6) :pattern ((Prims.Mktuple5 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9)))) :named projection_inverse_Prims.Mktuple5__2))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term)) (! (= (Prims.Mktuple5__3 (Prims.Mktuple5 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9)) @x7) :pattern ((Prims.Mktuple5 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9)))) :named projection_inverse_Prims.Mktuple5__3))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term)) (! (= (Prims.Mktuple5__4 (Prims.Mktuple5 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9)) @x8) :pattern ((Prims.Mktuple5 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9)))) :named projection_inverse_Prims.Mktuple5__4))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term)) (! (= (Prims.Mktuple5__5 (Prims.Mktuple5 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9)) @x9) :pattern ((Prims.Mktuple5 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9)))) :named projection_inverse_Prims.Mktuple5__5))
(define-fun is-Prims.Mktuple5 ((@x0 Term)) Bool (and (= (Term_constr_id @x0) 715) (= @x0 (Prims.Mktuple5 (Prims.Mktuple5__a @x0) (Prims.Mktuple5__b @x0) (Prims.Mktuple5__c @x0) (Prims.Mktuple5__d @x0) (Prims.Mktuple5__e @x0) (Prims.Mktuple5__1 @x0) (Prims.Mktuple5__2 @x0) (Prims.Mktuple5__3 @x0) (Prims.Mktuple5__4 @x0) (Prims.Mktuple5__5 @x0)))))
(assert (! (HasType Tm_arrow_717 Tm_type) :named kinding_Tm_arrow_717))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_717) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_717)))) :named pre_typing_Tm_arrow_717))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_717) (forall ((@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term) (@x10 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 Tm_type) (HasType @x5 Tm_type) (HasType @x6 @x1) (HasType @x7 @x2) (HasType @x8 @x3) (HasType @x9 @x4) (HasType @x10 @x5)) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x8) @x9) @x10) (Prims.tuple5 @x1 @x2 @x3 @x4 @x5))) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x8) @x9) @x10))))) :pattern ((HasTypeZ @x0 Tm_arrow_717)))) :named interpretation_Tm_arrow_717))
(assert (! (= 719 (Term_constr_id Prims.Mktuple5@tok)) :named fresh_token_Prims.Mktuple5@tok))
(assert (! (HasType Prims.Mktuple5@tok Tm_arrow_717) :named typing_tok_Prims.Mktuple5@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple5@tok @x0) @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x8) @x9) (Prims.Mktuple5 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple5@tok @x0) @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x8) @x9)))) :named equality_tok_Prims.Mktuple5@tok))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term) (@x10 Term)) (! (implies (and (HasTypeFuel @u0 @x1 Tm_type) (HasTypeFuel @u0 @x2 Tm_type) (HasTypeFuel @u0 @x3 Tm_type) (HasTypeFuel @u0 @x4 Tm_type) (HasTypeFuel @u0 @x5 Tm_type) (HasTypeFuel @u0 @x6 @x1) (HasTypeFuel @u0 @x7 @x2) (HasTypeFuel @u0 @x8 @x3) (HasTypeFuel @u0 @x9 @x4) (HasTypeFuel @u0 @x10 @x5)) (HasTypeFuel @u0 (Prims.Mktuple5 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10) (Prims.tuple5 @x1 @x2 @x3 @x4 @x5))) :pattern ((HasTypeFuel @u0 (Prims.Mktuple5 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10) (Prims.tuple5 @x1 @x2 @x3 @x4 @x5))))) :named data_typing_intro_Prims.Mktuple5@tok))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term) (@x10 Term) (@x11 Term) (@x12 Term) (@x13 Term) (@x14 Term) (@x15 Term)) (! (implies (HasTypeFuel (SFuel @u0) (Prims.Mktuple5 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10) (Prims.tuple5 @x11 @x12 @x13 @x14 @x15)) (and (= @x5 @x15) (= @x4 @x14) (= @x3 @x13) (= @x2 @x12) (= @x1 @x11) (HasTypeFuel @u0 @x1 Tm_type) (HasTypeFuel @u0 @x2 Tm_type) (HasTypeFuel @u0 @x3 Tm_type) (HasTypeFuel @u0 @x4 Tm_type) (HasTypeFuel @u0 @x5 Tm_type) (HasTypeFuel @u0 @x6 @x1) (HasTypeFuel @u0 @x7 @x2) (HasTypeFuel @u0 @x8 @x3) (HasTypeFuel @u0 @x9 @x4) (HasTypeFuel @u0 @x10 @x5))) :pattern ((HasTypeFuel (SFuel @u0) (Prims.Mktuple5 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10) (Prims.tuple5 @x11 @x12 @x13 @x14 @x15))))) :named data_elim_Prims.Mktuple5))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term) (@x10 Term) (@x11 Term) (@x12 Term) (@x13 Term) (@x14 Term) (@x15 Term)) (! (implies (HasTypeFuel (SFuel @u0) (Prims.Mktuple5 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10) (Prims.tuple5 @x11 @x12 @x13 @x14 @x15)) (and (Valid (Precedes @x1 (Prims.Mktuple5 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10))) (Valid (Precedes @x2 (Prims.Mktuple5 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10))) (Valid (Precedes @x3 (Prims.Mktuple5 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10))) (Valid (Precedes @x4 (Prims.Mktuple5 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10))) (Valid (Precedes @x5 (Prims.Mktuple5 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10))) (Valid (Precedes @x6 (Prims.Mktuple5 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10))) (Valid (Precedes @x7 (Prims.Mktuple5 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10))) (Valid (Precedes @x8 (Prims.Mktuple5 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10))) (Valid (Precedes @x9 (Prims.Mktuple5 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10))) (Valid (Precedes @x10 (Prims.Mktuple5 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10))))) :pattern ((HasTypeFuel (SFuel @u0) (Prims.Mktuple5 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10) (Prims.tuple5 @x11 @x12 @x13 @x14 @x15))))) :named subterm_ordering_Prims.Mktuple5))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term)) (! (implies (HasTypeFuel @u0 @x1 (Prims.tuple5 @x2 @x3 @x4 @x5 @x6)) (and (is-Prims.Mktuple5 @x1) (= @x2 (Prims.Mktuple5__a @x1)) (= @x3 (Prims.Mktuple5__b @x1)) (= @x4 (Prims.Mktuple5__c @x1)) (= @x5 (Prims.Mktuple5__d @x1)) (= @x6 (Prims.Mktuple5__e @x1)))) :pattern ((HasTypeFuel @u0 @x1 (Prims.tuple5 @x2 @x3 @x4 @x5 @x6))))) :named fuel_guarded_inversion_Prims.tuple5_710))
(declare-fun Prims.Mktuple5._1 (Term Term Term Term Term Term) Term)
(declare-fun Tm_arrow_721 () Term)
(assert (! (HasType Tm_arrow_721 Tm_type) :named kinding_Tm_arrow_721))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_721) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_721)))) :named pre_typing_Tm_arrow_721))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_721) (forall ((@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 Tm_type) (HasType @x5 Tm_type) (HasType @x6 (Prims.tuple5 @x1 @x2 @x3 @x4 @x5))) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x6) @x1)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x6))))) :pattern ((HasTypeZ @x0 Tm_arrow_721)))) :named interpretation_Tm_arrow_721))
(declare-fun Prims.Mktuple5._1@tok () Term)
(assert (! (= 723 (Term_constr_id Prims.Mktuple5._1@tok)) :named fresh_token_Prims.Mktuple5._1@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple5._1@tok @x0) @x1) @x2) @x3) @x4) @x5) (Prims.Mktuple5._1 @x0 @x1 @x2 @x3 @x4 @x5)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple5._1@tok @x0) @x1) @x2) @x3) @x4) @x5)))) :named token_correspondence_Prims.Mktuple5._1))
(assert (! (HasType Prims.Mktuple5._1@tok Tm_arrow_721) :named function_token_typing_Prims.Mktuple5._1))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 Tm_type) (HasType @x5 (Prims.tuple5 @x0 @x1 @x2 @x3 @x4))) (HasType (Prims.Mktuple5._1 @x0 @x1 @x2 @x3 @x4 @x5) @x0)) :pattern ((Prims.Mktuple5._1 @x0 @x1 @x2 @x3 @x4 @x5)))) :named typing_Prims.Mktuple5._1))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (= (Prims.Mktuple5._1 @x0 @x1 @x2 @x3 @x4 @x5) (Prims.Mktuple5__1 @x5)) :pattern ((Prims.Mktuple5._1 @x0 @x1 @x2 @x3 @x4 @x5)))) :named proj_equation_Prims.Mktuple5__1))
(declare-fun Prims.Mktuple5._2 (Term Term Term Term Term Term) Term)
(declare-fun Tm_arrow_725 () Term)
(assert (! (HasType Tm_arrow_725 Tm_type) :named kinding_Tm_arrow_725))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_725) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_725)))) :named pre_typing_Tm_arrow_725))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_725) (forall ((@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 Tm_type) (HasType @x5 Tm_type) (HasType @x6 (Prims.tuple5 @x1 @x2 @x3 @x4 @x5))) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x6) @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x6))))) :pattern ((HasTypeZ @x0 Tm_arrow_725)))) :named interpretation_Tm_arrow_725))
(declare-fun Prims.Mktuple5._2@tok () Term)
(assert (! (= 727 (Term_constr_id Prims.Mktuple5._2@tok)) :named fresh_token_Prims.Mktuple5._2@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple5._2@tok @x0) @x1) @x2) @x3) @x4) @x5) (Prims.Mktuple5._2 @x0 @x1 @x2 @x3 @x4 @x5)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple5._2@tok @x0) @x1) @x2) @x3) @x4) @x5)))) :named token_correspondence_Prims.Mktuple5._2))
(assert (! (HasType Prims.Mktuple5._2@tok Tm_arrow_725) :named function_token_typing_Prims.Mktuple5._2))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 Tm_type) (HasType @x5 (Prims.tuple5 @x0 @x1 @x2 @x3 @x4))) (HasType (Prims.Mktuple5._2 @x0 @x1 @x2 @x3 @x4 @x5) @x1)) :pattern ((Prims.Mktuple5._2 @x0 @x1 @x2 @x3 @x4 @x5)))) :named typing_Prims.Mktuple5._2))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (= (Prims.Mktuple5._2 @x0 @x1 @x2 @x3 @x4 @x5) (Prims.Mktuple5__2 @x5)) :pattern ((Prims.Mktuple5._2 @x0 @x1 @x2 @x3 @x4 @x5)))) :named proj_equation_Prims.Mktuple5__2))
(declare-fun Prims.Mktuple5._3 (Term Term Term Term Term Term) Term)
(declare-fun Tm_arrow_729 () Term)
(assert (! (HasType Tm_arrow_729 Tm_type) :named kinding_Tm_arrow_729))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_729) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_729)))) :named pre_typing_Tm_arrow_729))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_729) (forall ((@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 Tm_type) (HasType @x5 Tm_type) (HasType @x6 (Prims.tuple5 @x1 @x2 @x3 @x4 @x5))) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x6) @x3)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x6))))) :pattern ((HasTypeZ @x0 Tm_arrow_729)))) :named interpretation_Tm_arrow_729))
(declare-fun Prims.Mktuple5._3@tok () Term)
(assert (! (= 731 (Term_constr_id Prims.Mktuple5._3@tok)) :named fresh_token_Prims.Mktuple5._3@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple5._3@tok @x0) @x1) @x2) @x3) @x4) @x5) (Prims.Mktuple5._3 @x0 @x1 @x2 @x3 @x4 @x5)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple5._3@tok @x0) @x1) @x2) @x3) @x4) @x5)))) :named token_correspondence_Prims.Mktuple5._3))
(assert (! (HasType Prims.Mktuple5._3@tok Tm_arrow_729) :named function_token_typing_Prims.Mktuple5._3))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 Tm_type) (HasType @x5 (Prims.tuple5 @x0 @x1 @x2 @x3 @x4))) (HasType (Prims.Mktuple5._3 @x0 @x1 @x2 @x3 @x4 @x5) @x2)) :pattern ((Prims.Mktuple5._3 @x0 @x1 @x2 @x3 @x4 @x5)))) :named typing_Prims.Mktuple5._3))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (= (Prims.Mktuple5._3 @x0 @x1 @x2 @x3 @x4 @x5) (Prims.Mktuple5__3 @x5)) :pattern ((Prims.Mktuple5._3 @x0 @x1 @x2 @x3 @x4 @x5)))) :named proj_equation_Prims.Mktuple5__3))
(declare-fun Prims.Mktuple5._4 (Term Term Term Term Term Term) Term)
(declare-fun Tm_arrow_733 () Term)
(assert (! (HasType Tm_arrow_733 Tm_type) :named kinding_Tm_arrow_733))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_733) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_733)))) :named pre_typing_Tm_arrow_733))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_733) (forall ((@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 Tm_type) (HasType @x5 Tm_type) (HasType @x6 (Prims.tuple5 @x1 @x2 @x3 @x4 @x5))) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x6) @x4)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x6))))) :pattern ((HasTypeZ @x0 Tm_arrow_733)))) :named interpretation_Tm_arrow_733))
(declare-fun Prims.Mktuple5._4@tok () Term)
(assert (! (= 735 (Term_constr_id Prims.Mktuple5._4@tok)) :named fresh_token_Prims.Mktuple5._4@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple5._4@tok @x0) @x1) @x2) @x3) @x4) @x5) (Prims.Mktuple5._4 @x0 @x1 @x2 @x3 @x4 @x5)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple5._4@tok @x0) @x1) @x2) @x3) @x4) @x5)))) :named token_correspondence_Prims.Mktuple5._4))
(assert (! (HasType Prims.Mktuple5._4@tok Tm_arrow_733) :named function_token_typing_Prims.Mktuple5._4))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 Tm_type) (HasType @x5 (Prims.tuple5 @x0 @x1 @x2 @x3 @x4))) (HasType (Prims.Mktuple5._4 @x0 @x1 @x2 @x3 @x4 @x5) @x3)) :pattern ((Prims.Mktuple5._4 @x0 @x1 @x2 @x3 @x4 @x5)))) :named typing_Prims.Mktuple5._4))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (= (Prims.Mktuple5._4 @x0 @x1 @x2 @x3 @x4 @x5) (Prims.Mktuple5__4 @x5)) :pattern ((Prims.Mktuple5._4 @x0 @x1 @x2 @x3 @x4 @x5)))) :named proj_equation_Prims.Mktuple5__4))
(declare-fun Prims.Mktuple5._5 (Term Term Term Term Term Term) Term)
(declare-fun Tm_arrow_737 () Term)
(assert (! (HasType Tm_arrow_737 Tm_type) :named kinding_Tm_arrow_737))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_737) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_737)))) :named pre_typing_Tm_arrow_737))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_737) (forall ((@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 Tm_type) (HasType @x5 Tm_type) (HasType @x6 (Prims.tuple5 @x1 @x2 @x3 @x4 @x5))) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x6) @x5)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x6))))) :pattern ((HasTypeZ @x0 Tm_arrow_737)))) :named interpretation_Tm_arrow_737))
(declare-fun Prims.Mktuple5._5@tok () Term)
(assert (! (= 739 (Term_constr_id Prims.Mktuple5._5@tok)) :named fresh_token_Prims.Mktuple5._5@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple5._5@tok @x0) @x1) @x2) @x3) @x4) @x5) (Prims.Mktuple5._5 @x0 @x1 @x2 @x3 @x4 @x5)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple5._5@tok @x0) @x1) @x2) @x3) @x4) @x5)))) :named token_correspondence_Prims.Mktuple5._5))
(assert (! (HasType Prims.Mktuple5._5@tok Tm_arrow_737) :named function_token_typing_Prims.Mktuple5._5))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 Tm_type) (HasType @x5 (Prims.tuple5 @x0 @x1 @x2 @x3 @x4))) (HasType (Prims.Mktuple5._5 @x0 @x1 @x2 @x3 @x4 @x5) @x4)) :pattern ((Prims.Mktuple5._5 @x0 @x1 @x2 @x3 @x4 @x5)))) :named typing_Prims.Mktuple5._5))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (= (Prims.Mktuple5._5 @x0 @x1 @x2 @x3 @x4 @x5) (Prims.Mktuple5__5 @x5)) :pattern ((Prims.Mktuple5._5 @x0 @x1 @x2 @x3 @x4 @x5)))) :named proj_equation_Prims.Mktuple5__5))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 Tm_type) (Valid (Prims.hasEq @x0)) (Valid (Prims.hasEq @x1)) (Valid (Prims.hasEq @x2)) (Valid (Prims.hasEq @x3)) (Valid (Prims.hasEq @x4))) (Valid (Prims.hasEq (Prims.tuple5 @x0 @x1 @x2 @x3 @x4)))) :pattern ((Prims.hasEq (Prims.tuple5 @x0 @x1 @x2 @x3 @x4))))) :named assumption_Prims.HasEq_tuple5_740))
(declare-fun Prims.tuple6 (Term Term Term Term Term Term) Term)
(declare-fun Prims.tuple6@x0 (Term) Term)
(declare-fun Prims.tuple6@x1 (Term) Term)
(declare-fun Prims.tuple6@x2 (Term) Term)
(declare-fun Prims.tuple6@x3 (Term) Term)
(declare-fun Prims.tuple6@x4 (Term) Term)
(declare-fun Prims.tuple6@x5 (Term) Term)
(declare-fun Prims.tuple6@tok () Term)
(declare-fun Prims.Mktuple6 (Term Term Term Term Term Term Term Term Term Term Term Term) Term)
(declare-fun Prims.Mktuple6__a (Term) Term)
(declare-fun Prims.Mktuple6__b (Term) Term)
(declare-fun Prims.Mktuple6__c (Term) Term)
(declare-fun Prims.Mktuple6__d (Term) Term)
(declare-fun Prims.Mktuple6__e (Term) Term)
(declare-fun Prims.Mktuple6__f (Term) Term)
(declare-fun Prims.Mktuple6__1 (Term) Term)
(declare-fun Prims.Mktuple6__2 (Term) Term)
(declare-fun Prims.Mktuple6__3 (Term) Term)
(declare-fun Prims.Mktuple6__4 (Term) Term)
(declare-fun Prims.Mktuple6__5 (Term) Term)
(declare-fun Prims.Mktuple6__6 (Term) Term)
(declare-fun Tm_arrow_752 () Term)
(declare-fun Prims.Mktuple6@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (= 741 (Term_constr_id (Prims.tuple6 @x0 @x1 @x2 @x3 @x4 @x5))) :pattern ((Prims.tuple6 @x0 @x1 @x2 @x3 @x4 @x5)))) :named constructor_distinct_Prims.tuple6))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (= (Prims.tuple6@x0 (Prims.tuple6 @x0 @x1 @x2 @x3 @x4 @x5)) @x0) :pattern ((Prims.tuple6 @x0 @x1 @x2 @x3 @x4 @x5)))) :named projection_inverse_Prims.tuple6@x0))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (= (Prims.tuple6@x1 (Prims.tuple6 @x0 @x1 @x2 @x3 @x4 @x5)) @x1) :pattern ((Prims.tuple6 @x0 @x1 @x2 @x3 @x4 @x5)))) :named projection_inverse_Prims.tuple6@x1))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (= (Prims.tuple6@x2 (Prims.tuple6 @x0 @x1 @x2 @x3 @x4 @x5)) @x2) :pattern ((Prims.tuple6 @x0 @x1 @x2 @x3 @x4 @x5)))) :named projection_inverse_Prims.tuple6@x2))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (= (Prims.tuple6@x3 (Prims.tuple6 @x0 @x1 @x2 @x3 @x4 @x5)) @x3) :pattern ((Prims.tuple6 @x0 @x1 @x2 @x3 @x4 @x5)))) :named projection_inverse_Prims.tuple6@x3))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (= (Prims.tuple6@x4 (Prims.tuple6 @x0 @x1 @x2 @x3 @x4 @x5)) @x4) :pattern ((Prims.tuple6 @x0 @x1 @x2 @x3 @x4 @x5)))) :named projection_inverse_Prims.tuple6@x4))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (= (Prims.tuple6@x5 (Prims.tuple6 @x0 @x1 @x2 @x3 @x4 @x5)) @x5) :pattern ((Prims.tuple6 @x0 @x1 @x2 @x3 @x4 @x5)))) :named projection_inverse_Prims.tuple6@x5))
(define-fun is-Prims.tuple6 ((@x0 Term)) Bool (and (= (Term_constr_id @x0) 741) (= @x0 (Prims.tuple6 (Prims.tuple6@x0 @x0) (Prims.tuple6@x1 @x0) (Prims.tuple6@x2 @x0) (Prims.tuple6@x3 @x0) (Prims.tuple6@x4 @x0) (Prims.tuple6@x5 @x0)))))
(assert (! (= 742 (Term_constr_id Prims.tuple6@tok)) :named fresh_token_Prims.tuple6@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.tuple6@tok @x0) @x1) @x2) @x3) @x4) @x5) (Prims.tuple6 @x0 @x1 @x2 @x3 @x4 @x5)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.tuple6@tok @x0) @x1) @x2) @x3) @x4) @x5)) :pattern ((Prims.tuple6 @x0 @x1 @x2 @x3 @x4 @x5)))) :named token_correspondence_Prims.tuple6@tok))
(assert (! (is-Tm_arrow (PreType Prims.tuple6@tok)) :named pre_kinding_Prims.tuple6@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 Tm_type) (HasType @x5 Tm_type)) (HasType (Prims.tuple6 @x0 @x1 @x2 @x3 @x4 @x5) Tm_type)) :pattern ((Prims.tuple6 @x0 @x1 @x2 @x3 @x4 @x5)))) :named kinding_Prims.tuple6@tok))
(assert (! (forall ((@x0 Term) (@u1 Fuel) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term)) (! (implies (HasTypeFuel @u1 @x0 (Prims.tuple6 @x2 @x3 @x4 @x5 @x6 @x7)) (= (Prims.tuple6 @x2 @x3 @x4 @x5 @x6 @x7) (PreType @x0))) :pattern ((HasTypeFuel @u1 @x0 (Prims.tuple6 @x2 @x3 @x4 @x5 @x6 @x7))))) :named @pretyping__748))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term) (@x10 Term) (@x11 Term)) (! (= 750 (Term_constr_id (Prims.Mktuple6 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11))) :pattern ((Prims.Mktuple6 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11)))) :named constructor_distinct_Prims.Mktuple6))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term) (@x10 Term) (@x11 Term)) (! (= (Prims.Mktuple6__a (Prims.Mktuple6 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11)) @x0) :pattern ((Prims.Mktuple6 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11)))) :named projection_inverse_Prims.Mktuple6__a))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term) (@x10 Term) (@x11 Term)) (! (= (Prims.Mktuple6__b (Prims.Mktuple6 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11)) @x1) :pattern ((Prims.Mktuple6 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11)))) :named projection_inverse_Prims.Mktuple6__b))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term) (@x10 Term) (@x11 Term)) (! (= (Prims.Mktuple6__c (Prims.Mktuple6 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11)) @x2) :pattern ((Prims.Mktuple6 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11)))) :named projection_inverse_Prims.Mktuple6__c))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term) (@x10 Term) (@x11 Term)) (! (= (Prims.Mktuple6__d (Prims.Mktuple6 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11)) @x3) :pattern ((Prims.Mktuple6 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11)))) :named projection_inverse_Prims.Mktuple6__d))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term) (@x10 Term) (@x11 Term)) (! (= (Prims.Mktuple6__e (Prims.Mktuple6 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11)) @x4) :pattern ((Prims.Mktuple6 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11)))) :named projection_inverse_Prims.Mktuple6__e))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term) (@x10 Term) (@x11 Term)) (! (= (Prims.Mktuple6__f (Prims.Mktuple6 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11)) @x5) :pattern ((Prims.Mktuple6 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11)))) :named projection_inverse_Prims.Mktuple6__f))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term) (@x10 Term) (@x11 Term)) (! (= (Prims.Mktuple6__1 (Prims.Mktuple6 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11)) @x6) :pattern ((Prims.Mktuple6 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11)))) :named projection_inverse_Prims.Mktuple6__1))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term) (@x10 Term) (@x11 Term)) (! (= (Prims.Mktuple6__2 (Prims.Mktuple6 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11)) @x7) :pattern ((Prims.Mktuple6 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11)))) :named projection_inverse_Prims.Mktuple6__2))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term) (@x10 Term) (@x11 Term)) (! (= (Prims.Mktuple6__3 (Prims.Mktuple6 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11)) @x8) :pattern ((Prims.Mktuple6 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11)))) :named projection_inverse_Prims.Mktuple6__3))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term) (@x10 Term) (@x11 Term)) (! (= (Prims.Mktuple6__4 (Prims.Mktuple6 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11)) @x9) :pattern ((Prims.Mktuple6 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11)))) :named projection_inverse_Prims.Mktuple6__4))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term) (@x10 Term) (@x11 Term)) (! (= (Prims.Mktuple6__5 (Prims.Mktuple6 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11)) @x10) :pattern ((Prims.Mktuple6 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11)))) :named projection_inverse_Prims.Mktuple6__5))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term) (@x10 Term) (@x11 Term)) (! (= (Prims.Mktuple6__6 (Prims.Mktuple6 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11)) @x11) :pattern ((Prims.Mktuple6 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11)))) :named projection_inverse_Prims.Mktuple6__6))
(define-fun is-Prims.Mktuple6 ((@x0 Term)) Bool (and (= (Term_constr_id @x0) 750) (= @x0 (Prims.Mktuple6 (Prims.Mktuple6__a @x0) (Prims.Mktuple6__b @x0) (Prims.Mktuple6__c @x0) (Prims.Mktuple6__d @x0) (Prims.Mktuple6__e @x0) (Prims.Mktuple6__f @x0) (Prims.Mktuple6__1 @x0) (Prims.Mktuple6__2 @x0) (Prims.Mktuple6__3 @x0) (Prims.Mktuple6__4 @x0) (Prims.Mktuple6__5 @x0) (Prims.Mktuple6__6 @x0)))))
(assert (! (HasType Tm_arrow_752 Tm_type) :named kinding_Tm_arrow_752))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_752) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_752)))) :named pre_typing_Tm_arrow_752))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_752) (forall ((@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term) (@x10 Term) (@x11 Term) (@x12 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 Tm_type) (HasType @x5 Tm_type) (HasType @x6 Tm_type) (HasType @x7 @x1) (HasType @x8 @x2) (HasType @x9 @x3) (HasType @x10 @x4) (HasType @x11 @x5) (HasType @x12 @x6)) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x8) @x9) @x10) @x11) @x12) (Prims.tuple6 @x1 @x2 @x3 @x4 @x5 @x6))) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x8) @x9) @x10) @x11) @x12))))) :pattern ((HasTypeZ @x0 Tm_arrow_752)))) :named interpretation_Tm_arrow_752))
(assert (! (= 754 (Term_constr_id Prims.Mktuple6@tok)) :named fresh_token_Prims.Mktuple6@tok))
(assert (! (HasType Prims.Mktuple6@tok Tm_arrow_752) :named typing_tok_Prims.Mktuple6@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term) (@x10 Term) (@x11 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple6@tok @x0) @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x8) @x9) @x10) @x11) (Prims.Mktuple6 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple6@tok @x0) @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x8) @x9) @x10) @x11)))) :named equality_tok_Prims.Mktuple6@tok))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term) (@x10 Term) (@x11 Term) (@x12 Term)) (! (implies (and (HasTypeFuel @u0 @x1 Tm_type) (HasTypeFuel @u0 @x2 Tm_type) (HasTypeFuel @u0 @x3 Tm_type) (HasTypeFuel @u0 @x4 Tm_type) (HasTypeFuel @u0 @x5 Tm_type) (HasTypeFuel @u0 @x6 Tm_type) (HasTypeFuel @u0 @x7 @x1) (HasTypeFuel @u0 @x8 @x2) (HasTypeFuel @u0 @x9 @x3) (HasTypeFuel @u0 @x10 @x4) (HasTypeFuel @u0 @x11 @x5) (HasTypeFuel @u0 @x12 @x6)) (HasTypeFuel @u0 (Prims.Mktuple6 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12) (Prims.tuple6 @x1 @x2 @x3 @x4 @x5 @x6))) :pattern ((HasTypeFuel @u0 (Prims.Mktuple6 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12) (Prims.tuple6 @x1 @x2 @x3 @x4 @x5 @x6))))) :named data_typing_intro_Prims.Mktuple6@tok))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term) (@x10 Term) (@x11 Term) (@x12 Term) (@x13 Term) (@x14 Term) (@x15 Term) (@x16 Term) (@x17 Term) (@x18 Term)) (! (implies (HasTypeFuel (SFuel @u0) (Prims.Mktuple6 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12) (Prims.tuple6 @x13 @x14 @x15 @x16 @x17 @x18)) (and (= @x6 @x18) (= @x5 @x17) (= @x4 @x16) (= @x3 @x15) (= @x2 @x14) (= @x1 @x13) (HasTypeFuel @u0 @x1 Tm_type) (HasTypeFuel @u0 @x2 Tm_type) (HasTypeFuel @u0 @x3 Tm_type) (HasTypeFuel @u0 @x4 Tm_type) (HasTypeFuel @u0 @x5 Tm_type) (HasTypeFuel @u0 @x6 Tm_type) (HasTypeFuel @u0 @x7 @x1) (HasTypeFuel @u0 @x8 @x2) (HasTypeFuel @u0 @x9 @x3) (HasTypeFuel @u0 @x10 @x4) (HasTypeFuel @u0 @x11 @x5) (HasTypeFuel @u0 @x12 @x6))) :pattern ((HasTypeFuel (SFuel @u0) (Prims.Mktuple6 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12) (Prims.tuple6 @x13 @x14 @x15 @x16 @x17 @x18))))) :named data_elim_Prims.Mktuple6))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term) (@x10 Term) (@x11 Term) (@x12 Term) (@x13 Term) (@x14 Term) (@x15 Term) (@x16 Term) (@x17 Term) (@x18 Term)) (! (implies (HasTypeFuel (SFuel @u0) (Prims.Mktuple6 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12) (Prims.tuple6 @x13 @x14 @x15 @x16 @x17 @x18)) (and (Valid (Precedes @x1 (Prims.Mktuple6 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12))) (Valid (Precedes @x2 (Prims.Mktuple6 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12))) (Valid (Precedes @x3 (Prims.Mktuple6 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12))) (Valid (Precedes @x4 (Prims.Mktuple6 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12))) (Valid (Precedes @x5 (Prims.Mktuple6 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12))) (Valid (Precedes @x6 (Prims.Mktuple6 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12))) (Valid (Precedes @x7 (Prims.Mktuple6 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12))) (Valid (Precedes @x8 (Prims.Mktuple6 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12))) (Valid (Precedes @x9 (Prims.Mktuple6 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12))) (Valid (Precedes @x10 (Prims.Mktuple6 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12))) (Valid (Precedes @x11 (Prims.Mktuple6 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12))) (Valid (Precedes @x12 (Prims.Mktuple6 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12))))) :pattern ((HasTypeFuel (SFuel @u0) (Prims.Mktuple6 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12) (Prims.tuple6 @x13 @x14 @x15 @x16 @x17 @x18))))) :named subterm_ordering_Prims.Mktuple6))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term)) (! (implies (HasTypeFuel @u0 @x1 (Prims.tuple6 @x2 @x3 @x4 @x5 @x6 @x7)) (and (is-Prims.Mktuple6 @x1) (= @x2 (Prims.Mktuple6__a @x1)) (= @x3 (Prims.Mktuple6__b @x1)) (= @x4 (Prims.Mktuple6__c @x1)) (= @x5 (Prims.Mktuple6__d @x1)) (= @x6 (Prims.Mktuple6__e @x1)) (= @x7 (Prims.Mktuple6__f @x1)))) :pattern ((HasTypeFuel @u0 @x1 (Prims.tuple6 @x2 @x3 @x4 @x5 @x6 @x7))))) :named fuel_guarded_inversion_Prims.tuple6_745))
(declare-fun Prims.Mktuple6._1 (Term Term Term Term Term Term Term) Term)
(declare-fun Tm_arrow_756 () Term)
(assert (! (HasType Tm_arrow_756 Tm_type) :named kinding_Tm_arrow_756))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_756) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_756)))) :named pre_typing_Tm_arrow_756))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_756) (forall ((@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 Tm_type) (HasType @x5 Tm_type) (HasType @x6 Tm_type) (HasType @x7 (Prims.tuple6 @x1 @x2 @x3 @x4 @x5 @x6))) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x1)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x6) @x7))))) :pattern ((HasTypeZ @x0 Tm_arrow_756)))) :named interpretation_Tm_arrow_756))
(declare-fun Prims.Mktuple6._1@tok () Term)
(assert (! (= 758 (Term_constr_id Prims.Mktuple6._1@tok)) :named fresh_token_Prims.Mktuple6._1@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple6._1@tok @x0) @x1) @x2) @x3) @x4) @x5) @x6) (Prims.Mktuple6._1 @x0 @x1 @x2 @x3 @x4 @x5 @x6)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple6._1@tok @x0) @x1) @x2) @x3) @x4) @x5) @x6)))) :named token_correspondence_Prims.Mktuple6._1))
(assert (! (HasType Prims.Mktuple6._1@tok Tm_arrow_756) :named function_token_typing_Prims.Mktuple6._1))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 Tm_type) (HasType @x5 Tm_type) (HasType @x6 (Prims.tuple6 @x0 @x1 @x2 @x3 @x4 @x5))) (HasType (Prims.Mktuple6._1 @x0 @x1 @x2 @x3 @x4 @x5 @x6) @x0)) :pattern ((Prims.Mktuple6._1 @x0 @x1 @x2 @x3 @x4 @x5 @x6)))) :named typing_Prims.Mktuple6._1))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term)) (! (= (Prims.Mktuple6._1 @x0 @x1 @x2 @x3 @x4 @x5 @x6) (Prims.Mktuple6__1 @x6)) :pattern ((Prims.Mktuple6._1 @x0 @x1 @x2 @x3 @x4 @x5 @x6)))) :named proj_equation_Prims.Mktuple6__1))
(declare-fun Prims.Mktuple6._2 (Term Term Term Term Term Term Term) Term)
(declare-fun Tm_arrow_760 () Term)
(assert (! (HasType Tm_arrow_760 Tm_type) :named kinding_Tm_arrow_760))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_760) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_760)))) :named pre_typing_Tm_arrow_760))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_760) (forall ((@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 Tm_type) (HasType @x5 Tm_type) (HasType @x6 Tm_type) (HasType @x7 (Prims.tuple6 @x1 @x2 @x3 @x4 @x5 @x6))) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x6) @x7))))) :pattern ((HasTypeZ @x0 Tm_arrow_760)))) :named interpretation_Tm_arrow_760))
(declare-fun Prims.Mktuple6._2@tok () Term)
(assert (! (= 762 (Term_constr_id Prims.Mktuple6._2@tok)) :named fresh_token_Prims.Mktuple6._2@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple6._2@tok @x0) @x1) @x2) @x3) @x4) @x5) @x6) (Prims.Mktuple6._2 @x0 @x1 @x2 @x3 @x4 @x5 @x6)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple6._2@tok @x0) @x1) @x2) @x3) @x4) @x5) @x6)))) :named token_correspondence_Prims.Mktuple6._2))
(assert (! (HasType Prims.Mktuple6._2@tok Tm_arrow_760) :named function_token_typing_Prims.Mktuple6._2))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 Tm_type) (HasType @x5 Tm_type) (HasType @x6 (Prims.tuple6 @x0 @x1 @x2 @x3 @x4 @x5))) (HasType (Prims.Mktuple6._2 @x0 @x1 @x2 @x3 @x4 @x5 @x6) @x1)) :pattern ((Prims.Mktuple6._2 @x0 @x1 @x2 @x3 @x4 @x5 @x6)))) :named typing_Prims.Mktuple6._2))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term)) (! (= (Prims.Mktuple6._2 @x0 @x1 @x2 @x3 @x4 @x5 @x6) (Prims.Mktuple6__2 @x6)) :pattern ((Prims.Mktuple6._2 @x0 @x1 @x2 @x3 @x4 @x5 @x6)))) :named proj_equation_Prims.Mktuple6__2))
(declare-fun Prims.Mktuple6._3 (Term Term Term Term Term Term Term) Term)
(declare-fun Tm_arrow_764 () Term)
(assert (! (HasType Tm_arrow_764 Tm_type) :named kinding_Tm_arrow_764))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_764) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_764)))) :named pre_typing_Tm_arrow_764))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_764) (forall ((@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 Tm_type) (HasType @x5 Tm_type) (HasType @x6 Tm_type) (HasType @x7 (Prims.tuple6 @x1 @x2 @x3 @x4 @x5 @x6))) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x3)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x6) @x7))))) :pattern ((HasTypeZ @x0 Tm_arrow_764)))) :named interpretation_Tm_arrow_764))
(declare-fun Prims.Mktuple6._3@tok () Term)
(assert (! (= 766 (Term_constr_id Prims.Mktuple6._3@tok)) :named fresh_token_Prims.Mktuple6._3@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple6._3@tok @x0) @x1) @x2) @x3) @x4) @x5) @x6) (Prims.Mktuple6._3 @x0 @x1 @x2 @x3 @x4 @x5 @x6)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple6._3@tok @x0) @x1) @x2) @x3) @x4) @x5) @x6)))) :named token_correspondence_Prims.Mktuple6._3))
(assert (! (HasType Prims.Mktuple6._3@tok Tm_arrow_764) :named function_token_typing_Prims.Mktuple6._3))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 Tm_type) (HasType @x5 Tm_type) (HasType @x6 (Prims.tuple6 @x0 @x1 @x2 @x3 @x4 @x5))) (HasType (Prims.Mktuple6._3 @x0 @x1 @x2 @x3 @x4 @x5 @x6) @x2)) :pattern ((Prims.Mktuple6._3 @x0 @x1 @x2 @x3 @x4 @x5 @x6)))) :named typing_Prims.Mktuple6._3))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term)) (! (= (Prims.Mktuple6._3 @x0 @x1 @x2 @x3 @x4 @x5 @x6) (Prims.Mktuple6__3 @x6)) :pattern ((Prims.Mktuple6._3 @x0 @x1 @x2 @x3 @x4 @x5 @x6)))) :named proj_equation_Prims.Mktuple6__3))
(declare-fun Prims.Mktuple6._4 (Term Term Term Term Term Term Term) Term)
(declare-fun Tm_arrow_768 () Term)
(assert (! (HasType Tm_arrow_768 Tm_type) :named kinding_Tm_arrow_768))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_768) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_768)))) :named pre_typing_Tm_arrow_768))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_768) (forall ((@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 Tm_type) (HasType @x5 Tm_type) (HasType @x6 Tm_type) (HasType @x7 (Prims.tuple6 @x1 @x2 @x3 @x4 @x5 @x6))) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x4)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x6) @x7))))) :pattern ((HasTypeZ @x0 Tm_arrow_768)))) :named interpretation_Tm_arrow_768))
(declare-fun Prims.Mktuple6._4@tok () Term)
(assert (! (= 770 (Term_constr_id Prims.Mktuple6._4@tok)) :named fresh_token_Prims.Mktuple6._4@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple6._4@tok @x0) @x1) @x2) @x3) @x4) @x5) @x6) (Prims.Mktuple6._4 @x0 @x1 @x2 @x3 @x4 @x5 @x6)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple6._4@tok @x0) @x1) @x2) @x3) @x4) @x5) @x6)))) :named token_correspondence_Prims.Mktuple6._4))
(assert (! (HasType Prims.Mktuple6._4@tok Tm_arrow_768) :named function_token_typing_Prims.Mktuple6._4))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 Tm_type) (HasType @x5 Tm_type) (HasType @x6 (Prims.tuple6 @x0 @x1 @x2 @x3 @x4 @x5))) (HasType (Prims.Mktuple6._4 @x0 @x1 @x2 @x3 @x4 @x5 @x6) @x3)) :pattern ((Prims.Mktuple6._4 @x0 @x1 @x2 @x3 @x4 @x5 @x6)))) :named typing_Prims.Mktuple6._4))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term)) (! (= (Prims.Mktuple6._4 @x0 @x1 @x2 @x3 @x4 @x5 @x6) (Prims.Mktuple6__4 @x6)) :pattern ((Prims.Mktuple6._4 @x0 @x1 @x2 @x3 @x4 @x5 @x6)))) :named proj_equation_Prims.Mktuple6__4))
(declare-fun Prims.Mktuple6._5 (Term Term Term Term Term Term Term) Term)
(declare-fun Tm_arrow_772 () Term)
(assert (! (HasType Tm_arrow_772 Tm_type) :named kinding_Tm_arrow_772))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_772) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_772)))) :named pre_typing_Tm_arrow_772))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_772) (forall ((@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 Tm_type) (HasType @x5 Tm_type) (HasType @x6 Tm_type) (HasType @x7 (Prims.tuple6 @x1 @x2 @x3 @x4 @x5 @x6))) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x5)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x6) @x7))))) :pattern ((HasTypeZ @x0 Tm_arrow_772)))) :named interpretation_Tm_arrow_772))
(declare-fun Prims.Mktuple6._5@tok () Term)
(assert (! (= 774 (Term_constr_id Prims.Mktuple6._5@tok)) :named fresh_token_Prims.Mktuple6._5@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple6._5@tok @x0) @x1) @x2) @x3) @x4) @x5) @x6) (Prims.Mktuple6._5 @x0 @x1 @x2 @x3 @x4 @x5 @x6)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple6._5@tok @x0) @x1) @x2) @x3) @x4) @x5) @x6)))) :named token_correspondence_Prims.Mktuple6._5))
(assert (! (HasType Prims.Mktuple6._5@tok Tm_arrow_772) :named function_token_typing_Prims.Mktuple6._5))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 Tm_type) (HasType @x5 Tm_type) (HasType @x6 (Prims.tuple6 @x0 @x1 @x2 @x3 @x4 @x5))) (HasType (Prims.Mktuple6._5 @x0 @x1 @x2 @x3 @x4 @x5 @x6) @x4)) :pattern ((Prims.Mktuple6._5 @x0 @x1 @x2 @x3 @x4 @x5 @x6)))) :named typing_Prims.Mktuple6._5))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term)) (! (= (Prims.Mktuple6._5 @x0 @x1 @x2 @x3 @x4 @x5 @x6) (Prims.Mktuple6__5 @x6)) :pattern ((Prims.Mktuple6._5 @x0 @x1 @x2 @x3 @x4 @x5 @x6)))) :named proj_equation_Prims.Mktuple6__5))
(declare-fun Prims.Mktuple6._6 (Term Term Term Term Term Term Term) Term)
(declare-fun Tm_arrow_776 () Term)
(assert (! (HasType Tm_arrow_776 Tm_type) :named kinding_Tm_arrow_776))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_776) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_776)))) :named pre_typing_Tm_arrow_776))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_776) (forall ((@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 Tm_type) (HasType @x5 Tm_type) (HasType @x6 Tm_type) (HasType @x7 (Prims.tuple6 @x1 @x2 @x3 @x4 @x5 @x6))) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x6)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x6) @x7))))) :pattern ((HasTypeZ @x0 Tm_arrow_776)))) :named interpretation_Tm_arrow_776))
(declare-fun Prims.Mktuple6._6@tok () Term)
(assert (! (= 778 (Term_constr_id Prims.Mktuple6._6@tok)) :named fresh_token_Prims.Mktuple6._6@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple6._6@tok @x0) @x1) @x2) @x3) @x4) @x5) @x6) (Prims.Mktuple6._6 @x0 @x1 @x2 @x3 @x4 @x5 @x6)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple6._6@tok @x0) @x1) @x2) @x3) @x4) @x5) @x6)))) :named token_correspondence_Prims.Mktuple6._6))
(assert (! (HasType Prims.Mktuple6._6@tok Tm_arrow_776) :named function_token_typing_Prims.Mktuple6._6))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 Tm_type) (HasType @x5 Tm_type) (HasType @x6 (Prims.tuple6 @x0 @x1 @x2 @x3 @x4 @x5))) (HasType (Prims.Mktuple6._6 @x0 @x1 @x2 @x3 @x4 @x5 @x6) @x5)) :pattern ((Prims.Mktuple6._6 @x0 @x1 @x2 @x3 @x4 @x5 @x6)))) :named typing_Prims.Mktuple6._6))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term)) (! (= (Prims.Mktuple6._6 @x0 @x1 @x2 @x3 @x4 @x5 @x6) (Prims.Mktuple6__6 @x6)) :pattern ((Prims.Mktuple6._6 @x0 @x1 @x2 @x3 @x4 @x5 @x6)))) :named proj_equation_Prims.Mktuple6__6))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 Tm_type) (HasType @x5 Tm_type) (Valid (Prims.hasEq @x0)) (Valid (Prims.hasEq @x1)) (Valid (Prims.hasEq @x2)) (Valid (Prims.hasEq @x3)) (Valid (Prims.hasEq @x4)) (Valid (Prims.hasEq @x5))) (Valid (Prims.hasEq (Prims.tuple6 @x0 @x1 @x2 @x3 @x4 @x5)))) :pattern ((Prims.hasEq (Prims.tuple6 @x0 @x1 @x2 @x3 @x4 @x5))))) :named assumption_Prims.HasEq_tuple6_779))
(declare-fun Prims.tuple7 (Term Term Term Term Term Term Term) Term)
(declare-fun Prims.tuple7@x0 (Term) Term)
(declare-fun Prims.tuple7@x1 (Term) Term)
(declare-fun Prims.tuple7@x2 (Term) Term)
(declare-fun Prims.tuple7@x3 (Term) Term)
(declare-fun Prims.tuple7@x4 (Term) Term)
(declare-fun Prims.tuple7@x5 (Term) Term)
(declare-fun Prims.tuple7@x6 (Term) Term)
(declare-fun Prims.tuple7@tok () Term)
(declare-fun Prims.Mktuple7 (Term Term Term Term Term Term Term Term Term Term Term Term Term Term) Term)
(declare-fun Prims.Mktuple7__a (Term) Term)
(declare-fun Prims.Mktuple7__b (Term) Term)
(declare-fun Prims.Mktuple7__c (Term) Term)
(declare-fun Prims.Mktuple7__d (Term) Term)
(declare-fun Prims.Mktuple7__e (Term) Term)
(declare-fun Prims.Mktuple7__f (Term) Term)
(declare-fun Prims.Mktuple7__g (Term) Term)
(declare-fun Prims.Mktuple7__1 (Term) Term)
(declare-fun Prims.Mktuple7__2 (Term) Term)
(declare-fun Prims.Mktuple7__3 (Term) Term)
(declare-fun Prims.Mktuple7__4 (Term) Term)
(declare-fun Prims.Mktuple7__5 (Term) Term)
(declare-fun Prims.Mktuple7__6 (Term) Term)
(declare-fun Prims.Mktuple7__7 (Term) Term)
(declare-fun Tm_arrow_791 () Term)
(declare-fun Prims.Mktuple7@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term)) (! (= 780 (Term_constr_id (Prims.tuple7 @x0 @x1 @x2 @x3 @x4 @x5 @x6))) :pattern ((Prims.tuple7 @x0 @x1 @x2 @x3 @x4 @x5 @x6)))) :named constructor_distinct_Prims.tuple7))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term)) (! (= (Prims.tuple7@x0 (Prims.tuple7 @x0 @x1 @x2 @x3 @x4 @x5 @x6)) @x0) :pattern ((Prims.tuple7 @x0 @x1 @x2 @x3 @x4 @x5 @x6)))) :named projection_inverse_Prims.tuple7@x0))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term)) (! (= (Prims.tuple7@x1 (Prims.tuple7 @x0 @x1 @x2 @x3 @x4 @x5 @x6)) @x1) :pattern ((Prims.tuple7 @x0 @x1 @x2 @x3 @x4 @x5 @x6)))) :named projection_inverse_Prims.tuple7@x1))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term)) (! (= (Prims.tuple7@x2 (Prims.tuple7 @x0 @x1 @x2 @x3 @x4 @x5 @x6)) @x2) :pattern ((Prims.tuple7 @x0 @x1 @x2 @x3 @x4 @x5 @x6)))) :named projection_inverse_Prims.tuple7@x2))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term)) (! (= (Prims.tuple7@x3 (Prims.tuple7 @x0 @x1 @x2 @x3 @x4 @x5 @x6)) @x3) :pattern ((Prims.tuple7 @x0 @x1 @x2 @x3 @x4 @x5 @x6)))) :named projection_inverse_Prims.tuple7@x3))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term)) (! (= (Prims.tuple7@x4 (Prims.tuple7 @x0 @x1 @x2 @x3 @x4 @x5 @x6)) @x4) :pattern ((Prims.tuple7 @x0 @x1 @x2 @x3 @x4 @x5 @x6)))) :named projection_inverse_Prims.tuple7@x4))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term)) (! (= (Prims.tuple7@x5 (Prims.tuple7 @x0 @x1 @x2 @x3 @x4 @x5 @x6)) @x5) :pattern ((Prims.tuple7 @x0 @x1 @x2 @x3 @x4 @x5 @x6)))) :named projection_inverse_Prims.tuple7@x5))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term)) (! (= (Prims.tuple7@x6 (Prims.tuple7 @x0 @x1 @x2 @x3 @x4 @x5 @x6)) @x6) :pattern ((Prims.tuple7 @x0 @x1 @x2 @x3 @x4 @x5 @x6)))) :named projection_inverse_Prims.tuple7@x6))
(define-fun is-Prims.tuple7 ((@x0 Term)) Bool (and (= (Term_constr_id @x0) 780) (= @x0 (Prims.tuple7 (Prims.tuple7@x0 @x0) (Prims.tuple7@x1 @x0) (Prims.tuple7@x2 @x0) (Prims.tuple7@x3 @x0) (Prims.tuple7@x4 @x0) (Prims.tuple7@x5 @x0) (Prims.tuple7@x6 @x0)))))
(assert (! (= 781 (Term_constr_id Prims.tuple7@tok)) :named fresh_token_Prims.tuple7@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.tuple7@tok @x0) @x1) @x2) @x3) @x4) @x5) @x6) (Prims.tuple7 @x0 @x1 @x2 @x3 @x4 @x5 @x6)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.tuple7@tok @x0) @x1) @x2) @x3) @x4) @x5) @x6)) :pattern ((Prims.tuple7 @x0 @x1 @x2 @x3 @x4 @x5 @x6)))) :named token_correspondence_Prims.tuple7@tok))
(assert (! (is-Tm_arrow (PreType Prims.tuple7@tok)) :named pre_kinding_Prims.tuple7@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 Tm_type) (HasType @x5 Tm_type) (HasType @x6 Tm_type)) (HasType (Prims.tuple7 @x0 @x1 @x2 @x3 @x4 @x5 @x6) Tm_type)) :pattern ((Prims.tuple7 @x0 @x1 @x2 @x3 @x4 @x5 @x6)))) :named kinding_Prims.tuple7@tok))
(assert (! (forall ((@x0 Term) (@u1 Fuel) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term)) (! (implies (HasTypeFuel @u1 @x0 (Prims.tuple7 @x2 @x3 @x4 @x5 @x6 @x7 @x8)) (= (Prims.tuple7 @x2 @x3 @x4 @x5 @x6 @x7 @x8) (PreType @x0))) :pattern ((HasTypeFuel @u1 @x0 (Prims.tuple7 @x2 @x3 @x4 @x5 @x6 @x7 @x8))))) :named @pretyping__787))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term) (@x10 Term) (@x11 Term) (@x12 Term) (@x13 Term)) (! (= 789 (Term_constr_id (Prims.Mktuple7 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13))) :pattern ((Prims.Mktuple7 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13)))) :named constructor_distinct_Prims.Mktuple7))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term) (@x10 Term) (@x11 Term) (@x12 Term) (@x13 Term)) (! (= (Prims.Mktuple7__a (Prims.Mktuple7 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13)) @x0) :pattern ((Prims.Mktuple7 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13)))) :named projection_inverse_Prims.Mktuple7__a))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term) (@x10 Term) (@x11 Term) (@x12 Term) (@x13 Term)) (! (= (Prims.Mktuple7__b (Prims.Mktuple7 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13)) @x1) :pattern ((Prims.Mktuple7 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13)))) :named projection_inverse_Prims.Mktuple7__b))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term) (@x10 Term) (@x11 Term) (@x12 Term) (@x13 Term)) (! (= (Prims.Mktuple7__c (Prims.Mktuple7 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13)) @x2) :pattern ((Prims.Mktuple7 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13)))) :named projection_inverse_Prims.Mktuple7__c))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term) (@x10 Term) (@x11 Term) (@x12 Term) (@x13 Term)) (! (= (Prims.Mktuple7__d (Prims.Mktuple7 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13)) @x3) :pattern ((Prims.Mktuple7 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13)))) :named projection_inverse_Prims.Mktuple7__d))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term) (@x10 Term) (@x11 Term) (@x12 Term) (@x13 Term)) (! (= (Prims.Mktuple7__e (Prims.Mktuple7 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13)) @x4) :pattern ((Prims.Mktuple7 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13)))) :named projection_inverse_Prims.Mktuple7__e))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term) (@x10 Term) (@x11 Term) (@x12 Term) (@x13 Term)) (! (= (Prims.Mktuple7__f (Prims.Mktuple7 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13)) @x5) :pattern ((Prims.Mktuple7 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13)))) :named projection_inverse_Prims.Mktuple7__f))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term) (@x10 Term) (@x11 Term) (@x12 Term) (@x13 Term)) (! (= (Prims.Mktuple7__g (Prims.Mktuple7 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13)) @x6) :pattern ((Prims.Mktuple7 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13)))) :named projection_inverse_Prims.Mktuple7__g))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term) (@x10 Term) (@x11 Term) (@x12 Term) (@x13 Term)) (! (= (Prims.Mktuple7__1 (Prims.Mktuple7 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13)) @x7) :pattern ((Prims.Mktuple7 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13)))) :named projection_inverse_Prims.Mktuple7__1))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term) (@x10 Term) (@x11 Term) (@x12 Term) (@x13 Term)) (! (= (Prims.Mktuple7__2 (Prims.Mktuple7 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13)) @x8) :pattern ((Prims.Mktuple7 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13)))) :named projection_inverse_Prims.Mktuple7__2))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term) (@x10 Term) (@x11 Term) (@x12 Term) (@x13 Term)) (! (= (Prims.Mktuple7__3 (Prims.Mktuple7 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13)) @x9) :pattern ((Prims.Mktuple7 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13)))) :named projection_inverse_Prims.Mktuple7__3))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term) (@x10 Term) (@x11 Term) (@x12 Term) (@x13 Term)) (! (= (Prims.Mktuple7__4 (Prims.Mktuple7 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13)) @x10) :pattern ((Prims.Mktuple7 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13)))) :named projection_inverse_Prims.Mktuple7__4))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term) (@x10 Term) (@x11 Term) (@x12 Term) (@x13 Term)) (! (= (Prims.Mktuple7__5 (Prims.Mktuple7 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13)) @x11) :pattern ((Prims.Mktuple7 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13)))) :named projection_inverse_Prims.Mktuple7__5))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term) (@x10 Term) (@x11 Term) (@x12 Term) (@x13 Term)) (! (= (Prims.Mktuple7__6 (Prims.Mktuple7 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13)) @x12) :pattern ((Prims.Mktuple7 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13)))) :named projection_inverse_Prims.Mktuple7__6))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term) (@x10 Term) (@x11 Term) (@x12 Term) (@x13 Term)) (! (= (Prims.Mktuple7__7 (Prims.Mktuple7 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13)) @x13) :pattern ((Prims.Mktuple7 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13)))) :named projection_inverse_Prims.Mktuple7__7))
(define-fun is-Prims.Mktuple7 ((@x0 Term)) Bool (and (= (Term_constr_id @x0) 789) (= @x0 (Prims.Mktuple7 (Prims.Mktuple7__a @x0) (Prims.Mktuple7__b @x0) (Prims.Mktuple7__c @x0) (Prims.Mktuple7__d @x0) (Prims.Mktuple7__e @x0) (Prims.Mktuple7__f @x0) (Prims.Mktuple7__g @x0) (Prims.Mktuple7__1 @x0) (Prims.Mktuple7__2 @x0) (Prims.Mktuple7__3 @x0) (Prims.Mktuple7__4 @x0) (Prims.Mktuple7__5 @x0) (Prims.Mktuple7__6 @x0) (Prims.Mktuple7__7 @x0)))))
(assert (! (HasType Tm_arrow_791 Tm_type) :named kinding_Tm_arrow_791))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_791) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_791)))) :named pre_typing_Tm_arrow_791))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_791) (forall ((@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term) (@x10 Term) (@x11 Term) (@x12 Term) (@x13 Term) (@x14 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 Tm_type) (HasType @x5 Tm_type) (HasType @x6 Tm_type) (HasType @x7 Tm_type) (HasType @x8 @x1) (HasType @x9 @x2) (HasType @x10 @x3) (HasType @x11 @x4) (HasType @x12 @x5) (HasType @x13 @x6) (HasType @x14 @x7)) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x8) @x9) @x10) @x11) @x12) @x13) @x14) (Prims.tuple7 @x1 @x2 @x3 @x4 @x5 @x6 @x7))) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x8) @x9) @x10) @x11) @x12) @x13) @x14))))) :pattern ((HasTypeZ @x0 Tm_arrow_791)))) :named interpretation_Tm_arrow_791))
(assert (! (= 793 (Term_constr_id Prims.Mktuple7@tok)) :named fresh_token_Prims.Mktuple7@tok))
(assert (! (HasType Prims.Mktuple7@tok Tm_arrow_791) :named typing_tok_Prims.Mktuple7@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term) (@x10 Term) (@x11 Term) (@x12 Term) (@x13 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple7@tok @x0) @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x8) @x9) @x10) @x11) @x12) @x13) (Prims.Mktuple7 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple7@tok @x0) @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x8) @x9) @x10) @x11) @x12) @x13)))) :named equality_tok_Prims.Mktuple7@tok))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term) (@x10 Term) (@x11 Term) (@x12 Term) (@x13 Term) (@x14 Term)) (! (implies (and (HasTypeFuel @u0 @x1 Tm_type) (HasTypeFuel @u0 @x2 Tm_type) (HasTypeFuel @u0 @x3 Tm_type) (HasTypeFuel @u0 @x4 Tm_type) (HasTypeFuel @u0 @x5 Tm_type) (HasTypeFuel @u0 @x6 Tm_type) (HasTypeFuel @u0 @x7 Tm_type) (HasTypeFuel @u0 @x8 @x1) (HasTypeFuel @u0 @x9 @x2) (HasTypeFuel @u0 @x10 @x3) (HasTypeFuel @u0 @x11 @x4) (HasTypeFuel @u0 @x12 @x5) (HasTypeFuel @u0 @x13 @x6) (HasTypeFuel @u0 @x14 @x7)) (HasTypeFuel @u0 (Prims.Mktuple7 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14) (Prims.tuple7 @x1 @x2 @x3 @x4 @x5 @x6 @x7))) :pattern ((HasTypeFuel @u0 (Prims.Mktuple7 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14) (Prims.tuple7 @x1 @x2 @x3 @x4 @x5 @x6 @x7))))) :named data_typing_intro_Prims.Mktuple7@tok))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term) (@x10 Term) (@x11 Term) (@x12 Term) (@x13 Term) (@x14 Term) (@x15 Term) (@x16 Term) (@x17 Term) (@x18 Term) (@x19 Term) (@x20 Term) (@x21 Term)) (! (implies (HasTypeFuel (SFuel @u0) (Prims.Mktuple7 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14) (Prims.tuple7 @x15 @x16 @x17 @x18 @x19 @x20 @x21)) (and (= @x7 @x21) (= @x6 @x20) (= @x5 @x19) (= @x4 @x18) (= @x3 @x17) (= @x2 @x16) (= @x1 @x15) (HasTypeFuel @u0 @x1 Tm_type) (HasTypeFuel @u0 @x2 Tm_type) (HasTypeFuel @u0 @x3 Tm_type) (HasTypeFuel @u0 @x4 Tm_type) (HasTypeFuel @u0 @x5 Tm_type) (HasTypeFuel @u0 @x6 Tm_type) (HasTypeFuel @u0 @x7 Tm_type) (HasTypeFuel @u0 @x8 @x1) (HasTypeFuel @u0 @x9 @x2) (HasTypeFuel @u0 @x10 @x3) (HasTypeFuel @u0 @x11 @x4) (HasTypeFuel @u0 @x12 @x5) (HasTypeFuel @u0 @x13 @x6) (HasTypeFuel @u0 @x14 @x7))) :pattern ((HasTypeFuel (SFuel @u0) (Prims.Mktuple7 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14) (Prims.tuple7 @x15 @x16 @x17 @x18 @x19 @x20 @x21))))) :named data_elim_Prims.Mktuple7))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term) (@x10 Term) (@x11 Term) (@x12 Term) (@x13 Term) (@x14 Term) (@x15 Term) (@x16 Term) (@x17 Term) (@x18 Term) (@x19 Term) (@x20 Term) (@x21 Term)) (! (implies (HasTypeFuel (SFuel @u0) (Prims.Mktuple7 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14) (Prims.tuple7 @x15 @x16 @x17 @x18 @x19 @x20 @x21)) (and (Valid (Precedes @x1 (Prims.Mktuple7 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14))) (Valid (Precedes @x2 (Prims.Mktuple7 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14))) (Valid (Precedes @x3 (Prims.Mktuple7 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14))) (Valid (Precedes @x4 (Prims.Mktuple7 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14))) (Valid (Precedes @x5 (Prims.Mktuple7 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14))) (Valid (Precedes @x6 (Prims.Mktuple7 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14))) (Valid (Precedes @x7 (Prims.Mktuple7 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14))) (Valid (Precedes @x8 (Prims.Mktuple7 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14))) (Valid (Precedes @x9 (Prims.Mktuple7 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14))) (Valid (Precedes @x10 (Prims.Mktuple7 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14))) (Valid (Precedes @x11 (Prims.Mktuple7 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14))) (Valid (Precedes @x12 (Prims.Mktuple7 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14))) (Valid (Precedes @x13 (Prims.Mktuple7 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14))) (Valid (Precedes @x14 (Prims.Mktuple7 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14))))) :pattern ((HasTypeFuel (SFuel @u0) (Prims.Mktuple7 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14) (Prims.tuple7 @x15 @x16 @x17 @x18 @x19 @x20 @x21))))) :named subterm_ordering_Prims.Mktuple7))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term)) (! (implies (HasTypeFuel @u0 @x1 (Prims.tuple7 @x2 @x3 @x4 @x5 @x6 @x7 @x8)) (and (is-Prims.Mktuple7 @x1) (= @x2 (Prims.Mktuple7__a @x1)) (= @x3 (Prims.Mktuple7__b @x1)) (= @x4 (Prims.Mktuple7__c @x1)) (= @x5 (Prims.Mktuple7__d @x1)) (= @x6 (Prims.Mktuple7__e @x1)) (= @x7 (Prims.Mktuple7__f @x1)) (= @x8 (Prims.Mktuple7__g @x1)))) :pattern ((HasTypeFuel @u0 @x1 (Prims.tuple7 @x2 @x3 @x4 @x5 @x6 @x7 @x8))))) :named fuel_guarded_inversion_Prims.tuple7_784))
(declare-fun Prims.Mktuple7._1 (Term Term Term Term Term Term Term Term) Term)
(declare-fun Tm_arrow_795 () Term)
(assert (! (HasType Tm_arrow_795 Tm_type) :named kinding_Tm_arrow_795))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_795) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_795)))) :named pre_typing_Tm_arrow_795))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_795) (forall ((@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 Tm_type) (HasType @x5 Tm_type) (HasType @x6 Tm_type) (HasType @x7 Tm_type) (HasType @x8 (Prims.tuple7 @x1 @x2 @x3 @x4 @x5 @x6 @x7))) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x8) @x1)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x8))))) :pattern ((HasTypeZ @x0 Tm_arrow_795)))) :named interpretation_Tm_arrow_795))
(declare-fun Prims.Mktuple7._1@tok () Term)
(assert (! (= 797 (Term_constr_id Prims.Mktuple7._1@tok)) :named fresh_token_Prims.Mktuple7._1@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple7._1@tok @x0) @x1) @x2) @x3) @x4) @x5) @x6) @x7) (Prims.Mktuple7._1 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple7._1@tok @x0) @x1) @x2) @x3) @x4) @x5) @x6) @x7)))) :named token_correspondence_Prims.Mktuple7._1))
(assert (! (HasType Prims.Mktuple7._1@tok Tm_arrow_795) :named function_token_typing_Prims.Mktuple7._1))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 Tm_type) (HasType @x5 Tm_type) (HasType @x6 Tm_type) (HasType @x7 (Prims.tuple7 @x0 @x1 @x2 @x3 @x4 @x5 @x6))) (HasType (Prims.Mktuple7._1 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7) @x0)) :pattern ((Prims.Mktuple7._1 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)))) :named typing_Prims.Mktuple7._1))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term)) (! (= (Prims.Mktuple7._1 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7) (Prims.Mktuple7__1 @x7)) :pattern ((Prims.Mktuple7._1 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)))) :named proj_equation_Prims.Mktuple7__1))
(declare-fun Prims.Mktuple7._2 (Term Term Term Term Term Term Term Term) Term)
(declare-fun Tm_arrow_799 () Term)
(assert (! (HasType Tm_arrow_799 Tm_type) :named kinding_Tm_arrow_799))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_799) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_799)))) :named pre_typing_Tm_arrow_799))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_799) (forall ((@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 Tm_type) (HasType @x5 Tm_type) (HasType @x6 Tm_type) (HasType @x7 Tm_type) (HasType @x8 (Prims.tuple7 @x1 @x2 @x3 @x4 @x5 @x6 @x7))) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x8) @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x8))))) :pattern ((HasTypeZ @x0 Tm_arrow_799)))) :named interpretation_Tm_arrow_799))
(declare-fun Prims.Mktuple7._2@tok () Term)
(assert (! (= 801 (Term_constr_id Prims.Mktuple7._2@tok)) :named fresh_token_Prims.Mktuple7._2@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple7._2@tok @x0) @x1) @x2) @x3) @x4) @x5) @x6) @x7) (Prims.Mktuple7._2 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple7._2@tok @x0) @x1) @x2) @x3) @x4) @x5) @x6) @x7)))) :named token_correspondence_Prims.Mktuple7._2))
(assert (! (HasType Prims.Mktuple7._2@tok Tm_arrow_799) :named function_token_typing_Prims.Mktuple7._2))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 Tm_type) (HasType @x5 Tm_type) (HasType @x6 Tm_type) (HasType @x7 (Prims.tuple7 @x0 @x1 @x2 @x3 @x4 @x5 @x6))) (HasType (Prims.Mktuple7._2 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7) @x1)) :pattern ((Prims.Mktuple7._2 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)))) :named typing_Prims.Mktuple7._2))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term)) (! (= (Prims.Mktuple7._2 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7) (Prims.Mktuple7__2 @x7)) :pattern ((Prims.Mktuple7._2 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)))) :named proj_equation_Prims.Mktuple7__2))
(declare-fun Prims.Mktuple7._3 (Term Term Term Term Term Term Term Term) Term)
(declare-fun Tm_arrow_803 () Term)
(assert (! (HasType Tm_arrow_803 Tm_type) :named kinding_Tm_arrow_803))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_803) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_803)))) :named pre_typing_Tm_arrow_803))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_803) (forall ((@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 Tm_type) (HasType @x5 Tm_type) (HasType @x6 Tm_type) (HasType @x7 Tm_type) (HasType @x8 (Prims.tuple7 @x1 @x2 @x3 @x4 @x5 @x6 @x7))) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x8) @x3)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x8))))) :pattern ((HasTypeZ @x0 Tm_arrow_803)))) :named interpretation_Tm_arrow_803))
(declare-fun Prims.Mktuple7._3@tok () Term)
(assert (! (= 805 (Term_constr_id Prims.Mktuple7._3@tok)) :named fresh_token_Prims.Mktuple7._3@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple7._3@tok @x0) @x1) @x2) @x3) @x4) @x5) @x6) @x7) (Prims.Mktuple7._3 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple7._3@tok @x0) @x1) @x2) @x3) @x4) @x5) @x6) @x7)))) :named token_correspondence_Prims.Mktuple7._3))
(assert (! (HasType Prims.Mktuple7._3@tok Tm_arrow_803) :named function_token_typing_Prims.Mktuple7._3))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 Tm_type) (HasType @x5 Tm_type) (HasType @x6 Tm_type) (HasType @x7 (Prims.tuple7 @x0 @x1 @x2 @x3 @x4 @x5 @x6))) (HasType (Prims.Mktuple7._3 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7) @x2)) :pattern ((Prims.Mktuple7._3 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)))) :named typing_Prims.Mktuple7._3))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term)) (! (= (Prims.Mktuple7._3 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7) (Prims.Mktuple7__3 @x7)) :pattern ((Prims.Mktuple7._3 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)))) :named proj_equation_Prims.Mktuple7__3))
(declare-fun Prims.Mktuple7._4 (Term Term Term Term Term Term Term Term) Term)
(declare-fun Tm_arrow_807 () Term)
(assert (! (HasType Tm_arrow_807 Tm_type) :named kinding_Tm_arrow_807))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_807) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_807)))) :named pre_typing_Tm_arrow_807))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_807) (forall ((@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 Tm_type) (HasType @x5 Tm_type) (HasType @x6 Tm_type) (HasType @x7 Tm_type) (HasType @x8 (Prims.tuple7 @x1 @x2 @x3 @x4 @x5 @x6 @x7))) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x8) @x4)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x8))))) :pattern ((HasTypeZ @x0 Tm_arrow_807)))) :named interpretation_Tm_arrow_807))
(declare-fun Prims.Mktuple7._4@tok () Term)
(assert (! (= 809 (Term_constr_id Prims.Mktuple7._4@tok)) :named fresh_token_Prims.Mktuple7._4@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple7._4@tok @x0) @x1) @x2) @x3) @x4) @x5) @x6) @x7) (Prims.Mktuple7._4 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple7._4@tok @x0) @x1) @x2) @x3) @x4) @x5) @x6) @x7)))) :named token_correspondence_Prims.Mktuple7._4))
(assert (! (HasType Prims.Mktuple7._4@tok Tm_arrow_807) :named function_token_typing_Prims.Mktuple7._4))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 Tm_type) (HasType @x5 Tm_type) (HasType @x6 Tm_type) (HasType @x7 (Prims.tuple7 @x0 @x1 @x2 @x3 @x4 @x5 @x6))) (HasType (Prims.Mktuple7._4 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7) @x3)) :pattern ((Prims.Mktuple7._4 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)))) :named typing_Prims.Mktuple7._4))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term)) (! (= (Prims.Mktuple7._4 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7) (Prims.Mktuple7__4 @x7)) :pattern ((Prims.Mktuple7._4 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)))) :named proj_equation_Prims.Mktuple7__4))
(declare-fun Prims.Mktuple7._5 (Term Term Term Term Term Term Term Term) Term)
(declare-fun Tm_arrow_811 () Term)
(assert (! (HasType Tm_arrow_811 Tm_type) :named kinding_Tm_arrow_811))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_811) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_811)))) :named pre_typing_Tm_arrow_811))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_811) (forall ((@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 Tm_type) (HasType @x5 Tm_type) (HasType @x6 Tm_type) (HasType @x7 Tm_type) (HasType @x8 (Prims.tuple7 @x1 @x2 @x3 @x4 @x5 @x6 @x7))) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x8) @x5)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x8))))) :pattern ((HasTypeZ @x0 Tm_arrow_811)))) :named interpretation_Tm_arrow_811))
(declare-fun Prims.Mktuple7._5@tok () Term)
(assert (! (= 813 (Term_constr_id Prims.Mktuple7._5@tok)) :named fresh_token_Prims.Mktuple7._5@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple7._5@tok @x0) @x1) @x2) @x3) @x4) @x5) @x6) @x7) (Prims.Mktuple7._5 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple7._5@tok @x0) @x1) @x2) @x3) @x4) @x5) @x6) @x7)))) :named token_correspondence_Prims.Mktuple7._5))
(assert (! (HasType Prims.Mktuple7._5@tok Tm_arrow_811) :named function_token_typing_Prims.Mktuple7._5))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 Tm_type) (HasType @x5 Tm_type) (HasType @x6 Tm_type) (HasType @x7 (Prims.tuple7 @x0 @x1 @x2 @x3 @x4 @x5 @x6))) (HasType (Prims.Mktuple7._5 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7) @x4)) :pattern ((Prims.Mktuple7._5 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)))) :named typing_Prims.Mktuple7._5))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term)) (! (= (Prims.Mktuple7._5 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7) (Prims.Mktuple7__5 @x7)) :pattern ((Prims.Mktuple7._5 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)))) :named proj_equation_Prims.Mktuple7__5))
(declare-fun Prims.Mktuple7._6 (Term Term Term Term Term Term Term Term) Term)
(declare-fun Tm_arrow_815 () Term)
(assert (! (HasType Tm_arrow_815 Tm_type) :named kinding_Tm_arrow_815))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_815) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_815)))) :named pre_typing_Tm_arrow_815))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_815) (forall ((@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 Tm_type) (HasType @x5 Tm_type) (HasType @x6 Tm_type) (HasType @x7 Tm_type) (HasType @x8 (Prims.tuple7 @x1 @x2 @x3 @x4 @x5 @x6 @x7))) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x8) @x6)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x8))))) :pattern ((HasTypeZ @x0 Tm_arrow_815)))) :named interpretation_Tm_arrow_815))
(declare-fun Prims.Mktuple7._6@tok () Term)
(assert (! (= 817 (Term_constr_id Prims.Mktuple7._6@tok)) :named fresh_token_Prims.Mktuple7._6@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple7._6@tok @x0) @x1) @x2) @x3) @x4) @x5) @x6) @x7) (Prims.Mktuple7._6 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple7._6@tok @x0) @x1) @x2) @x3) @x4) @x5) @x6) @x7)))) :named token_correspondence_Prims.Mktuple7._6))
(assert (! (HasType Prims.Mktuple7._6@tok Tm_arrow_815) :named function_token_typing_Prims.Mktuple7._6))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 Tm_type) (HasType @x5 Tm_type) (HasType @x6 Tm_type) (HasType @x7 (Prims.tuple7 @x0 @x1 @x2 @x3 @x4 @x5 @x6))) (HasType (Prims.Mktuple7._6 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7) @x5)) :pattern ((Prims.Mktuple7._6 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)))) :named typing_Prims.Mktuple7._6))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term)) (! (= (Prims.Mktuple7._6 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7) (Prims.Mktuple7__6 @x7)) :pattern ((Prims.Mktuple7._6 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)))) :named proj_equation_Prims.Mktuple7__6))
(declare-fun Prims.Mktuple7._7 (Term Term Term Term Term Term Term Term) Term)
(declare-fun Tm_arrow_819 () Term)
(assert (! (HasType Tm_arrow_819 Tm_type) :named kinding_Tm_arrow_819))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_819) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_819)))) :named pre_typing_Tm_arrow_819))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_819) (forall ((@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 Tm_type) (HasType @x5 Tm_type) (HasType @x6 Tm_type) (HasType @x7 Tm_type) (HasType @x8 (Prims.tuple7 @x1 @x2 @x3 @x4 @x5 @x6 @x7))) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x8) @x7)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x8))))) :pattern ((HasTypeZ @x0 Tm_arrow_819)))) :named interpretation_Tm_arrow_819))
(declare-fun Prims.Mktuple7._7@tok () Term)
(assert (! (= 821 (Term_constr_id Prims.Mktuple7._7@tok)) :named fresh_token_Prims.Mktuple7._7@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple7._7@tok @x0) @x1) @x2) @x3) @x4) @x5) @x6) @x7) (Prims.Mktuple7._7 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple7._7@tok @x0) @x1) @x2) @x3) @x4) @x5) @x6) @x7)))) :named token_correspondence_Prims.Mktuple7._7))
(assert (! (HasType Prims.Mktuple7._7@tok Tm_arrow_819) :named function_token_typing_Prims.Mktuple7._7))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 Tm_type) (HasType @x5 Tm_type) (HasType @x6 Tm_type) (HasType @x7 (Prims.tuple7 @x0 @x1 @x2 @x3 @x4 @x5 @x6))) (HasType (Prims.Mktuple7._7 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7) @x6)) :pattern ((Prims.Mktuple7._7 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)))) :named typing_Prims.Mktuple7._7))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term)) (! (= (Prims.Mktuple7._7 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7) (Prims.Mktuple7__7 @x7)) :pattern ((Prims.Mktuple7._7 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)))) :named proj_equation_Prims.Mktuple7__7))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 Tm_type) (HasType @x5 Tm_type) (HasType @x6 Tm_type) (Valid (Prims.hasEq @x0)) (Valid (Prims.hasEq @x1)) (Valid (Prims.hasEq @x2)) (Valid (Prims.hasEq @x3)) (Valid (Prims.hasEq @x4)) (Valid (Prims.hasEq @x5)) (Valid (Prims.hasEq @x6))) (Valid (Prims.hasEq (Prims.tuple7 @x0 @x1 @x2 @x3 @x4 @x5 @x6)))) :pattern ((Prims.hasEq (Prims.tuple7 @x0 @x1 @x2 @x3 @x4 @x5 @x6))))) :named assumption_Prims.HasEq_tuple7_822))
(declare-fun Prims.tuple8 (Term Term Term Term Term Term Term Term) Term)
(declare-fun Prims.tuple8@x0 (Term) Term)
(declare-fun Prims.tuple8@x1 (Term) Term)
(declare-fun Prims.tuple8@x2 (Term) Term)
(declare-fun Prims.tuple8@x3 (Term) Term)
(declare-fun Prims.tuple8@x4 (Term) Term)
(declare-fun Prims.tuple8@x5 (Term) Term)
(declare-fun Prims.tuple8@x6 (Term) Term)
(declare-fun Prims.tuple8@x7 (Term) Term)
(declare-fun Prims.tuple8@tok () Term)
(declare-fun Prims.Mktuple8 (Term Term Term Term Term Term Term Term Term Term Term Term Term Term Term Term) Term)
(declare-fun Prims.Mktuple8__a (Term) Term)
(declare-fun Prims.Mktuple8__b (Term) Term)
(declare-fun Prims.Mktuple8__c (Term) Term)
(declare-fun Prims.Mktuple8__d (Term) Term)
(declare-fun Prims.Mktuple8__e (Term) Term)
(declare-fun Prims.Mktuple8__f (Term) Term)
(declare-fun Prims.Mktuple8__g (Term) Term)
(declare-fun Prims.Mktuple8__h (Term) Term)
(declare-fun Prims.Mktuple8__1 (Term) Term)
(declare-fun Prims.Mktuple8__2 (Term) Term)
(declare-fun Prims.Mktuple8__3 (Term) Term)
(declare-fun Prims.Mktuple8__4 (Term) Term)
(declare-fun Prims.Mktuple8__5 (Term) Term)
(declare-fun Prims.Mktuple8__6 (Term) Term)
(declare-fun Prims.Mktuple8__7 (Term) Term)
(declare-fun Prims.Mktuple8__8 (Term) Term)
(declare-fun Tm_arrow_834 () Term)
(declare-fun Prims.Mktuple8@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term)) (! (= 823 (Term_constr_id (Prims.tuple8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7))) :pattern ((Prims.tuple8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)))) :named constructor_distinct_Prims.tuple8))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term)) (! (= (Prims.tuple8@x0 (Prims.tuple8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)) @x0) :pattern ((Prims.tuple8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)))) :named projection_inverse_Prims.tuple8@x0))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term)) (! (= (Prims.tuple8@x1 (Prims.tuple8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)) @x1) :pattern ((Prims.tuple8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)))) :named projection_inverse_Prims.tuple8@x1))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term)) (! (= (Prims.tuple8@x2 (Prims.tuple8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)) @x2) :pattern ((Prims.tuple8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)))) :named projection_inverse_Prims.tuple8@x2))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term)) (! (= (Prims.tuple8@x3 (Prims.tuple8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)) @x3) :pattern ((Prims.tuple8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)))) :named projection_inverse_Prims.tuple8@x3))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term)) (! (= (Prims.tuple8@x4 (Prims.tuple8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)) @x4) :pattern ((Prims.tuple8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)))) :named projection_inverse_Prims.tuple8@x4))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term)) (! (= (Prims.tuple8@x5 (Prims.tuple8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)) @x5) :pattern ((Prims.tuple8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)))) :named projection_inverse_Prims.tuple8@x5))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term)) (! (= (Prims.tuple8@x6 (Prims.tuple8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)) @x6) :pattern ((Prims.tuple8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)))) :named projection_inverse_Prims.tuple8@x6))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term)) (! (= (Prims.tuple8@x7 (Prims.tuple8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)) @x7) :pattern ((Prims.tuple8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)))) :named projection_inverse_Prims.tuple8@x7))
(define-fun is-Prims.tuple8 ((@x0 Term)) Bool (and (= (Term_constr_id @x0) 823) (= @x0 (Prims.tuple8 (Prims.tuple8@x0 @x0) (Prims.tuple8@x1 @x0) (Prims.tuple8@x2 @x0) (Prims.tuple8@x3 @x0) (Prims.tuple8@x4 @x0) (Prims.tuple8@x5 @x0) (Prims.tuple8@x6 @x0) (Prims.tuple8@x7 @x0)))))
(assert (! (= 824 (Term_constr_id Prims.tuple8@tok)) :named fresh_token_Prims.tuple8@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.tuple8@tok @x0) @x1) @x2) @x3) @x4) @x5) @x6) @x7) (Prims.tuple8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.tuple8@tok @x0) @x1) @x2) @x3) @x4) @x5) @x6) @x7)) :pattern ((Prims.tuple8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)))) :named token_correspondence_Prims.tuple8@tok))
(assert (! (is-Tm_arrow (PreType Prims.tuple8@tok)) :named pre_kinding_Prims.tuple8@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 Tm_type) (HasType @x5 Tm_type) (HasType @x6 Tm_type) (HasType @x7 Tm_type)) (HasType (Prims.tuple8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7) Tm_type)) :pattern ((Prims.tuple8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)))) :named kinding_Prims.tuple8@tok))
(assert (! (forall ((@x0 Term) (@u1 Fuel) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term)) (! (implies (HasTypeFuel @u1 @x0 (Prims.tuple8 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9)) (= (Prims.tuple8 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9) (PreType @x0))) :pattern ((HasTypeFuel @u1 @x0 (Prims.tuple8 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9))))) :named @pretyping__830))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term) (@x10 Term) (@x11 Term) (@x12 Term) (@x13 Term) (@x14 Term) (@x15 Term)) (! (= 832 (Term_constr_id (Prims.Mktuple8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14 @x15))) :pattern ((Prims.Mktuple8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14 @x15)))) :named constructor_distinct_Prims.Mktuple8))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term) (@x10 Term) (@x11 Term) (@x12 Term) (@x13 Term) (@x14 Term) (@x15 Term)) (! (= (Prims.Mktuple8__a (Prims.Mktuple8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14 @x15)) @x0) :pattern ((Prims.Mktuple8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14 @x15)))) :named projection_inverse_Prims.Mktuple8__a))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term) (@x10 Term) (@x11 Term) (@x12 Term) (@x13 Term) (@x14 Term) (@x15 Term)) (! (= (Prims.Mktuple8__b (Prims.Mktuple8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14 @x15)) @x1) :pattern ((Prims.Mktuple8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14 @x15)))) :named projection_inverse_Prims.Mktuple8__b))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term) (@x10 Term) (@x11 Term) (@x12 Term) (@x13 Term) (@x14 Term) (@x15 Term)) (! (= (Prims.Mktuple8__c (Prims.Mktuple8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14 @x15)) @x2) :pattern ((Prims.Mktuple8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14 @x15)))) :named projection_inverse_Prims.Mktuple8__c))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term) (@x10 Term) (@x11 Term) (@x12 Term) (@x13 Term) (@x14 Term) (@x15 Term)) (! (= (Prims.Mktuple8__d (Prims.Mktuple8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14 @x15)) @x3) :pattern ((Prims.Mktuple8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14 @x15)))) :named projection_inverse_Prims.Mktuple8__d))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term) (@x10 Term) (@x11 Term) (@x12 Term) (@x13 Term) (@x14 Term) (@x15 Term)) (! (= (Prims.Mktuple8__e (Prims.Mktuple8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14 @x15)) @x4) :pattern ((Prims.Mktuple8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14 @x15)))) :named projection_inverse_Prims.Mktuple8__e))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term) (@x10 Term) (@x11 Term) (@x12 Term) (@x13 Term) (@x14 Term) (@x15 Term)) (! (= (Prims.Mktuple8__f (Prims.Mktuple8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14 @x15)) @x5) :pattern ((Prims.Mktuple8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14 @x15)))) :named projection_inverse_Prims.Mktuple8__f))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term) (@x10 Term) (@x11 Term) (@x12 Term) (@x13 Term) (@x14 Term) (@x15 Term)) (! (= (Prims.Mktuple8__g (Prims.Mktuple8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14 @x15)) @x6) :pattern ((Prims.Mktuple8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14 @x15)))) :named projection_inverse_Prims.Mktuple8__g))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term) (@x10 Term) (@x11 Term) (@x12 Term) (@x13 Term) (@x14 Term) (@x15 Term)) (! (= (Prims.Mktuple8__h (Prims.Mktuple8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14 @x15)) @x7) :pattern ((Prims.Mktuple8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14 @x15)))) :named projection_inverse_Prims.Mktuple8__h))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term) (@x10 Term) (@x11 Term) (@x12 Term) (@x13 Term) (@x14 Term) (@x15 Term)) (! (= (Prims.Mktuple8__1 (Prims.Mktuple8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14 @x15)) @x8) :pattern ((Prims.Mktuple8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14 @x15)))) :named projection_inverse_Prims.Mktuple8__1))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term) (@x10 Term) (@x11 Term) (@x12 Term) (@x13 Term) (@x14 Term) (@x15 Term)) (! (= (Prims.Mktuple8__2 (Prims.Mktuple8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14 @x15)) @x9) :pattern ((Prims.Mktuple8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14 @x15)))) :named projection_inverse_Prims.Mktuple8__2))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term) (@x10 Term) (@x11 Term) (@x12 Term) (@x13 Term) (@x14 Term) (@x15 Term)) (! (= (Prims.Mktuple8__3 (Prims.Mktuple8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14 @x15)) @x10) :pattern ((Prims.Mktuple8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14 @x15)))) :named projection_inverse_Prims.Mktuple8__3))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term) (@x10 Term) (@x11 Term) (@x12 Term) (@x13 Term) (@x14 Term) (@x15 Term)) (! (= (Prims.Mktuple8__4 (Prims.Mktuple8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14 @x15)) @x11) :pattern ((Prims.Mktuple8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14 @x15)))) :named projection_inverse_Prims.Mktuple8__4))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term) (@x10 Term) (@x11 Term) (@x12 Term) (@x13 Term) (@x14 Term) (@x15 Term)) (! (= (Prims.Mktuple8__5 (Prims.Mktuple8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14 @x15)) @x12) :pattern ((Prims.Mktuple8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14 @x15)))) :named projection_inverse_Prims.Mktuple8__5))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term) (@x10 Term) (@x11 Term) (@x12 Term) (@x13 Term) (@x14 Term) (@x15 Term)) (! (= (Prims.Mktuple8__6 (Prims.Mktuple8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14 @x15)) @x13) :pattern ((Prims.Mktuple8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14 @x15)))) :named projection_inverse_Prims.Mktuple8__6))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term) (@x10 Term) (@x11 Term) (@x12 Term) (@x13 Term) (@x14 Term) (@x15 Term)) (! (= (Prims.Mktuple8__7 (Prims.Mktuple8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14 @x15)) @x14) :pattern ((Prims.Mktuple8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14 @x15)))) :named projection_inverse_Prims.Mktuple8__7))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term) (@x10 Term) (@x11 Term) (@x12 Term) (@x13 Term) (@x14 Term) (@x15 Term)) (! (= (Prims.Mktuple8__8 (Prims.Mktuple8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14 @x15)) @x15) :pattern ((Prims.Mktuple8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14 @x15)))) :named projection_inverse_Prims.Mktuple8__8))
(define-fun is-Prims.Mktuple8 ((@x0 Term)) Bool (and (= (Term_constr_id @x0) 832) (= @x0 (Prims.Mktuple8 (Prims.Mktuple8__a @x0) (Prims.Mktuple8__b @x0) (Prims.Mktuple8__c @x0) (Prims.Mktuple8__d @x0) (Prims.Mktuple8__e @x0) (Prims.Mktuple8__f @x0) (Prims.Mktuple8__g @x0) (Prims.Mktuple8__h @x0) (Prims.Mktuple8__1 @x0) (Prims.Mktuple8__2 @x0) (Prims.Mktuple8__3 @x0) (Prims.Mktuple8__4 @x0) (Prims.Mktuple8__5 @x0) (Prims.Mktuple8__6 @x0) (Prims.Mktuple8__7 @x0) (Prims.Mktuple8__8 @x0)))))
(assert (! (HasType Tm_arrow_834 Tm_type) :named kinding_Tm_arrow_834))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_834) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_834)))) :named pre_typing_Tm_arrow_834))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_834) (forall ((@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term) (@x10 Term) (@x11 Term) (@x12 Term) (@x13 Term) (@x14 Term) (@x15 Term) (@x16 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 Tm_type) (HasType @x5 Tm_type) (HasType @x6 Tm_type) (HasType @x7 Tm_type) (HasType @x8 Tm_type) (HasType @x9 @x1) (HasType @x10 @x2) (HasType @x11 @x3) (HasType @x12 @x4) (HasType @x13 @x5) (HasType @x14 @x6) (HasType @x15 @x7) (HasType @x16 @x8)) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x8) @x9) @x10) @x11) @x12) @x13) @x14) @x15) @x16) (Prims.tuple8 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8))) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x8) @x9) @x10) @x11) @x12) @x13) @x14) @x15) @x16))))) :pattern ((HasTypeZ @x0 Tm_arrow_834)))) :named interpretation_Tm_arrow_834))
(assert (! (= 836 (Term_constr_id Prims.Mktuple8@tok)) :named fresh_token_Prims.Mktuple8@tok))
(assert (! (HasType Prims.Mktuple8@tok Tm_arrow_834) :named typing_tok_Prims.Mktuple8@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term) (@x10 Term) (@x11 Term) (@x12 Term) (@x13 Term) (@x14 Term) (@x15 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple8@tok @x0) @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x8) @x9) @x10) @x11) @x12) @x13) @x14) @x15) (Prims.Mktuple8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14 @x15)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple8@tok @x0) @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x8) @x9) @x10) @x11) @x12) @x13) @x14) @x15)))) :named equality_tok_Prims.Mktuple8@tok))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term) (@x10 Term) (@x11 Term) (@x12 Term) (@x13 Term) (@x14 Term) (@x15 Term) (@x16 Term)) (! (implies (and (HasTypeFuel @u0 @x1 Tm_type) (HasTypeFuel @u0 @x2 Tm_type) (HasTypeFuel @u0 @x3 Tm_type) (HasTypeFuel @u0 @x4 Tm_type) (HasTypeFuel @u0 @x5 Tm_type) (HasTypeFuel @u0 @x6 Tm_type) (HasTypeFuel @u0 @x7 Tm_type) (HasTypeFuel @u0 @x8 Tm_type) (HasTypeFuel @u0 @x9 @x1) (HasTypeFuel @u0 @x10 @x2) (HasTypeFuel @u0 @x11 @x3) (HasTypeFuel @u0 @x12 @x4) (HasTypeFuel @u0 @x13 @x5) (HasTypeFuel @u0 @x14 @x6) (HasTypeFuel @u0 @x15 @x7) (HasTypeFuel @u0 @x16 @x8)) (HasTypeFuel @u0 (Prims.Mktuple8 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14 @x15 @x16) (Prims.tuple8 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8))) :pattern ((HasTypeFuel @u0 (Prims.Mktuple8 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14 @x15 @x16) (Prims.tuple8 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8))))) :named data_typing_intro_Prims.Mktuple8@tok))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term) (@x10 Term) (@x11 Term) (@x12 Term) (@x13 Term) (@x14 Term) (@x15 Term) (@x16 Term) (@x17 Term) (@x18 Term) (@x19 Term) (@x20 Term) (@x21 Term) (@x22 Term) (@x23 Term) (@x24 Term)) (! (implies (HasTypeFuel (SFuel @u0) (Prims.Mktuple8 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14 @x15 @x16) (Prims.tuple8 @x17 @x18 @x19 @x20 @x21 @x22 @x23 @x24)) (and (= @x8 @x24) (= @x7 @x23) (= @x6 @x22) (= @x5 @x21) (= @x4 @x20) (= @x3 @x19) (= @x2 @x18) (= @x1 @x17) (HasTypeFuel @u0 @x1 Tm_type) (HasTypeFuel @u0 @x2 Tm_type) (HasTypeFuel @u0 @x3 Tm_type) (HasTypeFuel @u0 @x4 Tm_type) (HasTypeFuel @u0 @x5 Tm_type) (HasTypeFuel @u0 @x6 Tm_type) (HasTypeFuel @u0 @x7 Tm_type) (HasTypeFuel @u0 @x8 Tm_type) (HasTypeFuel @u0 @x9 @x1) (HasTypeFuel @u0 @x10 @x2) (HasTypeFuel @u0 @x11 @x3) (HasTypeFuel @u0 @x12 @x4) (HasTypeFuel @u0 @x13 @x5) (HasTypeFuel @u0 @x14 @x6) (HasTypeFuel @u0 @x15 @x7) (HasTypeFuel @u0 @x16 @x8))) :pattern ((HasTypeFuel (SFuel @u0) (Prims.Mktuple8 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14 @x15 @x16) (Prims.tuple8 @x17 @x18 @x19 @x20 @x21 @x22 @x23 @x24))))) :named data_elim_Prims.Mktuple8))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term) (@x10 Term) (@x11 Term) (@x12 Term) (@x13 Term) (@x14 Term) (@x15 Term) (@x16 Term) (@x17 Term) (@x18 Term) (@x19 Term) (@x20 Term) (@x21 Term) (@x22 Term) (@x23 Term) (@x24 Term)) (! (implies (HasTypeFuel (SFuel @u0) (Prims.Mktuple8 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14 @x15 @x16) (Prims.tuple8 @x17 @x18 @x19 @x20 @x21 @x22 @x23 @x24)) (and (Valid (Precedes @x1 (Prims.Mktuple8 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14 @x15 @x16))) (Valid (Precedes @x2 (Prims.Mktuple8 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14 @x15 @x16))) (Valid (Precedes @x3 (Prims.Mktuple8 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14 @x15 @x16))) (Valid (Precedes @x4 (Prims.Mktuple8 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14 @x15 @x16))) (Valid (Precedes @x5 (Prims.Mktuple8 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14 @x15 @x16))) (Valid (Precedes @x6 (Prims.Mktuple8 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14 @x15 @x16))) (Valid (Precedes @x7 (Prims.Mktuple8 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14 @x15 @x16))) (Valid (Precedes @x8 (Prims.Mktuple8 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14 @x15 @x16))) (Valid (Precedes @x9 (Prims.Mktuple8 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14 @x15 @x16))) (Valid (Precedes @x10 (Prims.Mktuple8 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14 @x15 @x16))) (Valid (Precedes @x11 (Prims.Mktuple8 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14 @x15 @x16))) (Valid (Precedes @x12 (Prims.Mktuple8 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14 @x15 @x16))) (Valid (Precedes @x13 (Prims.Mktuple8 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14 @x15 @x16))) (Valid (Precedes @x14 (Prims.Mktuple8 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14 @x15 @x16))) (Valid (Precedes @x15 (Prims.Mktuple8 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14 @x15 @x16))) (Valid (Precedes @x16 (Prims.Mktuple8 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14 @x15 @x16))))) :pattern ((HasTypeFuel (SFuel @u0) (Prims.Mktuple8 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9 @x10 @x11 @x12 @x13 @x14 @x15 @x16) (Prims.tuple8 @x17 @x18 @x19 @x20 @x21 @x22 @x23 @x24))))) :named subterm_ordering_Prims.Mktuple8))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term)) (! (implies (HasTypeFuel @u0 @x1 (Prims.tuple8 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9)) (and (is-Prims.Mktuple8 @x1) (= @x2 (Prims.Mktuple8__a @x1)) (= @x3 (Prims.Mktuple8__b @x1)) (= @x4 (Prims.Mktuple8__c @x1)) (= @x5 (Prims.Mktuple8__d @x1)) (= @x6 (Prims.Mktuple8__e @x1)) (= @x7 (Prims.Mktuple8__f @x1)) (= @x8 (Prims.Mktuple8__g @x1)) (= @x9 (Prims.Mktuple8__h @x1)))) :pattern ((HasTypeFuel @u0 @x1 (Prims.tuple8 @x2 @x3 @x4 @x5 @x6 @x7 @x8 @x9))))) :named fuel_guarded_inversion_Prims.tuple8_827))
(declare-fun Prims.Mktuple8._1 (Term Term Term Term Term Term Term Term Term) Term)
(declare-fun Tm_arrow_838 () Term)
(assert (! (HasType Tm_arrow_838 Tm_type) :named kinding_Tm_arrow_838))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_838) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_838)))) :named pre_typing_Tm_arrow_838))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_838) (forall ((@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 Tm_type) (HasType @x5 Tm_type) (HasType @x6 Tm_type) (HasType @x7 Tm_type) (HasType @x8 Tm_type) (HasType @x9 (Prims.tuple8 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8))) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x8) @x9) @x1)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x8) @x9))))) :pattern ((HasTypeZ @x0 Tm_arrow_838)))) :named interpretation_Tm_arrow_838))
(declare-fun Prims.Mktuple8._1@tok () Term)
(assert (! (= 840 (Term_constr_id Prims.Mktuple8._1@tok)) :named fresh_token_Prims.Mktuple8._1@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple8._1@tok @x0) @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x8) (Prims.Mktuple8._1 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple8._1@tok @x0) @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x8)))) :named token_correspondence_Prims.Mktuple8._1))
(assert (! (HasType Prims.Mktuple8._1@tok Tm_arrow_838) :named function_token_typing_Prims.Mktuple8._1))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 Tm_type) (HasType @x5 Tm_type) (HasType @x6 Tm_type) (HasType @x7 Tm_type) (HasType @x8 (Prims.tuple8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7))) (HasType (Prims.Mktuple8._1 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8) @x0)) :pattern ((Prims.Mktuple8._1 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8)))) :named typing_Prims.Mktuple8._1))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term)) (! (= (Prims.Mktuple8._1 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8) (Prims.Mktuple8__1 @x8)) :pattern ((Prims.Mktuple8._1 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8)))) :named proj_equation_Prims.Mktuple8__1))
(declare-fun Prims.Mktuple8._2 (Term Term Term Term Term Term Term Term Term) Term)
(declare-fun Tm_arrow_842 () Term)
(assert (! (HasType Tm_arrow_842 Tm_type) :named kinding_Tm_arrow_842))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_842) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_842)))) :named pre_typing_Tm_arrow_842))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_842) (forall ((@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 Tm_type) (HasType @x5 Tm_type) (HasType @x6 Tm_type) (HasType @x7 Tm_type) (HasType @x8 Tm_type) (HasType @x9 (Prims.tuple8 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8))) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x8) @x9) @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x8) @x9))))) :pattern ((HasTypeZ @x0 Tm_arrow_842)))) :named interpretation_Tm_arrow_842))
(declare-fun Prims.Mktuple8._2@tok () Term)
(assert (! (= 844 (Term_constr_id Prims.Mktuple8._2@tok)) :named fresh_token_Prims.Mktuple8._2@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple8._2@tok @x0) @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x8) (Prims.Mktuple8._2 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple8._2@tok @x0) @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x8)))) :named token_correspondence_Prims.Mktuple8._2))
(assert (! (HasType Prims.Mktuple8._2@tok Tm_arrow_842) :named function_token_typing_Prims.Mktuple8._2))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 Tm_type) (HasType @x5 Tm_type) (HasType @x6 Tm_type) (HasType @x7 Tm_type) (HasType @x8 (Prims.tuple8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7))) (HasType (Prims.Mktuple8._2 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8) @x1)) :pattern ((Prims.Mktuple8._2 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8)))) :named typing_Prims.Mktuple8._2))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term)) (! (= (Prims.Mktuple8._2 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8) (Prims.Mktuple8__2 @x8)) :pattern ((Prims.Mktuple8._2 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8)))) :named proj_equation_Prims.Mktuple8__2))
(declare-fun Prims.Mktuple8._3 (Term Term Term Term Term Term Term Term Term) Term)
(declare-fun Tm_arrow_846 () Term)
(assert (! (HasType Tm_arrow_846 Tm_type) :named kinding_Tm_arrow_846))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_846) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_846)))) :named pre_typing_Tm_arrow_846))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_846) (forall ((@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 Tm_type) (HasType @x5 Tm_type) (HasType @x6 Tm_type) (HasType @x7 Tm_type) (HasType @x8 Tm_type) (HasType @x9 (Prims.tuple8 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8))) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x8) @x9) @x3)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x8) @x9))))) :pattern ((HasTypeZ @x0 Tm_arrow_846)))) :named interpretation_Tm_arrow_846))
(declare-fun Prims.Mktuple8._3@tok () Term)
(assert (! (= 848 (Term_constr_id Prims.Mktuple8._3@tok)) :named fresh_token_Prims.Mktuple8._3@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple8._3@tok @x0) @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x8) (Prims.Mktuple8._3 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple8._3@tok @x0) @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x8)))) :named token_correspondence_Prims.Mktuple8._3))
(assert (! (HasType Prims.Mktuple8._3@tok Tm_arrow_846) :named function_token_typing_Prims.Mktuple8._3))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 Tm_type) (HasType @x5 Tm_type) (HasType @x6 Tm_type) (HasType @x7 Tm_type) (HasType @x8 (Prims.tuple8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7))) (HasType (Prims.Mktuple8._3 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8) @x2)) :pattern ((Prims.Mktuple8._3 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8)))) :named typing_Prims.Mktuple8._3))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term)) (! (= (Prims.Mktuple8._3 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8) (Prims.Mktuple8__3 @x8)) :pattern ((Prims.Mktuple8._3 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8)))) :named proj_equation_Prims.Mktuple8__3))
(declare-fun Prims.Mktuple8._4 (Term Term Term Term Term Term Term Term Term) Term)
(declare-fun Tm_arrow_850 () Term)
(assert (! (HasType Tm_arrow_850 Tm_type) :named kinding_Tm_arrow_850))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_850) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_850)))) :named pre_typing_Tm_arrow_850))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_850) (forall ((@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 Tm_type) (HasType @x5 Tm_type) (HasType @x6 Tm_type) (HasType @x7 Tm_type) (HasType @x8 Tm_type) (HasType @x9 (Prims.tuple8 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8))) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x8) @x9) @x4)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x8) @x9))))) :pattern ((HasTypeZ @x0 Tm_arrow_850)))) :named interpretation_Tm_arrow_850))
(declare-fun Prims.Mktuple8._4@tok () Term)
(assert (! (= 852 (Term_constr_id Prims.Mktuple8._4@tok)) :named fresh_token_Prims.Mktuple8._4@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple8._4@tok @x0) @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x8) (Prims.Mktuple8._4 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple8._4@tok @x0) @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x8)))) :named token_correspondence_Prims.Mktuple8._4))
(assert (! (HasType Prims.Mktuple8._4@tok Tm_arrow_850) :named function_token_typing_Prims.Mktuple8._4))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 Tm_type) (HasType @x5 Tm_type) (HasType @x6 Tm_type) (HasType @x7 Tm_type) (HasType @x8 (Prims.tuple8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7))) (HasType (Prims.Mktuple8._4 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8) @x3)) :pattern ((Prims.Mktuple8._4 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8)))) :named typing_Prims.Mktuple8._4))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term)) (! (= (Prims.Mktuple8._4 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8) (Prims.Mktuple8__4 @x8)) :pattern ((Prims.Mktuple8._4 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8)))) :named proj_equation_Prims.Mktuple8__4))
(declare-fun Prims.Mktuple8._5 (Term Term Term Term Term Term Term Term Term) Term)
(declare-fun Tm_arrow_854 () Term)
(assert (! (HasType Tm_arrow_854 Tm_type) :named kinding_Tm_arrow_854))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_854) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_854)))) :named pre_typing_Tm_arrow_854))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_854) (forall ((@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 Tm_type) (HasType @x5 Tm_type) (HasType @x6 Tm_type) (HasType @x7 Tm_type) (HasType @x8 Tm_type) (HasType @x9 (Prims.tuple8 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8))) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x8) @x9) @x5)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x8) @x9))))) :pattern ((HasTypeZ @x0 Tm_arrow_854)))) :named interpretation_Tm_arrow_854))
(declare-fun Prims.Mktuple8._5@tok () Term)
(assert (! (= 856 (Term_constr_id Prims.Mktuple8._5@tok)) :named fresh_token_Prims.Mktuple8._5@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple8._5@tok @x0) @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x8) (Prims.Mktuple8._5 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple8._5@tok @x0) @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x8)))) :named token_correspondence_Prims.Mktuple8._5))
(assert (! (HasType Prims.Mktuple8._5@tok Tm_arrow_854) :named function_token_typing_Prims.Mktuple8._5))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 Tm_type) (HasType @x5 Tm_type) (HasType @x6 Tm_type) (HasType @x7 Tm_type) (HasType @x8 (Prims.tuple8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7))) (HasType (Prims.Mktuple8._5 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8) @x4)) :pattern ((Prims.Mktuple8._5 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8)))) :named typing_Prims.Mktuple8._5))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term)) (! (= (Prims.Mktuple8._5 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8) (Prims.Mktuple8__5 @x8)) :pattern ((Prims.Mktuple8._5 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8)))) :named proj_equation_Prims.Mktuple8__5))
(declare-fun Prims.Mktuple8._6 (Term Term Term Term Term Term Term Term Term) Term)
(declare-fun Tm_arrow_858 () Term)
(assert (! (HasType Tm_arrow_858 Tm_type) :named kinding_Tm_arrow_858))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_858) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_858)))) :named pre_typing_Tm_arrow_858))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_858) (forall ((@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 Tm_type) (HasType @x5 Tm_type) (HasType @x6 Tm_type) (HasType @x7 Tm_type) (HasType @x8 Tm_type) (HasType @x9 (Prims.tuple8 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8))) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x8) @x9) @x6)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x8) @x9))))) :pattern ((HasTypeZ @x0 Tm_arrow_858)))) :named interpretation_Tm_arrow_858))
(declare-fun Prims.Mktuple8._6@tok () Term)
(assert (! (= 860 (Term_constr_id Prims.Mktuple8._6@tok)) :named fresh_token_Prims.Mktuple8._6@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple8._6@tok @x0) @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x8) (Prims.Mktuple8._6 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple8._6@tok @x0) @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x8)))) :named token_correspondence_Prims.Mktuple8._6))
(assert (! (HasType Prims.Mktuple8._6@tok Tm_arrow_858) :named function_token_typing_Prims.Mktuple8._6))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 Tm_type) (HasType @x5 Tm_type) (HasType @x6 Tm_type) (HasType @x7 Tm_type) (HasType @x8 (Prims.tuple8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7))) (HasType (Prims.Mktuple8._6 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8) @x5)) :pattern ((Prims.Mktuple8._6 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8)))) :named typing_Prims.Mktuple8._6))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term)) (! (= (Prims.Mktuple8._6 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8) (Prims.Mktuple8__6 @x8)) :pattern ((Prims.Mktuple8._6 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8)))) :named proj_equation_Prims.Mktuple8__6))
(declare-fun Prims.Mktuple8._7 (Term Term Term Term Term Term Term Term Term) Term)
(declare-fun Tm_arrow_862 () Term)
(assert (! (HasType Tm_arrow_862 Tm_type) :named kinding_Tm_arrow_862))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_862) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_862)))) :named pre_typing_Tm_arrow_862))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_862) (forall ((@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 Tm_type) (HasType @x5 Tm_type) (HasType @x6 Tm_type) (HasType @x7 Tm_type) (HasType @x8 Tm_type) (HasType @x9 (Prims.tuple8 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8))) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x8) @x9) @x7)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x8) @x9))))) :pattern ((HasTypeZ @x0 Tm_arrow_862)))) :named interpretation_Tm_arrow_862))
(declare-fun Prims.Mktuple8._7@tok () Term)
(assert (! (= 864 (Term_constr_id Prims.Mktuple8._7@tok)) :named fresh_token_Prims.Mktuple8._7@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple8._7@tok @x0) @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x8) (Prims.Mktuple8._7 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple8._7@tok @x0) @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x8)))) :named token_correspondence_Prims.Mktuple8._7))
(assert (! (HasType Prims.Mktuple8._7@tok Tm_arrow_862) :named function_token_typing_Prims.Mktuple8._7))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 Tm_type) (HasType @x5 Tm_type) (HasType @x6 Tm_type) (HasType @x7 Tm_type) (HasType @x8 (Prims.tuple8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7))) (HasType (Prims.Mktuple8._7 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8) @x6)) :pattern ((Prims.Mktuple8._7 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8)))) :named typing_Prims.Mktuple8._7))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term)) (! (= (Prims.Mktuple8._7 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8) (Prims.Mktuple8__7 @x8)) :pattern ((Prims.Mktuple8._7 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8)))) :named proj_equation_Prims.Mktuple8__7))
(declare-fun Prims.Mktuple8._8 (Term Term Term Term Term Term Term Term Term) Term)
(declare-fun Tm_arrow_866 () Term)
(assert (! (HasType Tm_arrow_866 Tm_type) :named kinding_Tm_arrow_866))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_866) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_866)))) :named pre_typing_Tm_arrow_866))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_866) (forall ((@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 Tm_type) (HasType @x5 Tm_type) (HasType @x6 Tm_type) (HasType @x7 Tm_type) (HasType @x8 Tm_type) (HasType @x9 (Prims.tuple8 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8))) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x8) @x9) @x8)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x8) @x9))))) :pattern ((HasTypeZ @x0 Tm_arrow_866)))) :named interpretation_Tm_arrow_866))
(declare-fun Prims.Mktuple8._8@tok () Term)
(assert (! (= 868 (Term_constr_id Prims.Mktuple8._8@tok)) :named fresh_token_Prims.Mktuple8._8@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple8._8@tok @x0) @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x8) (Prims.Mktuple8._8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mktuple8._8@tok @x0) @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x8)))) :named token_correspondence_Prims.Mktuple8._8))
(assert (! (HasType Prims.Mktuple8._8@tok Tm_arrow_866) :named function_token_typing_Prims.Mktuple8._8))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 Tm_type) (HasType @x5 Tm_type) (HasType @x6 Tm_type) (HasType @x7 Tm_type) (HasType @x8 (Prims.tuple8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7))) (HasType (Prims.Mktuple8._8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8) @x7)) :pattern ((Prims.Mktuple8._8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8)))) :named typing_Prims.Mktuple8._8))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term)) (! (= (Prims.Mktuple8._8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8) (Prims.Mktuple8__8 @x8)) :pattern ((Prims.Mktuple8._8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8)))) :named proj_equation_Prims.Mktuple8__8))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 Tm_type) (HasType @x5 Tm_type) (HasType @x6 Tm_type) (HasType @x7 Tm_type) (Valid (Prims.hasEq @x0)) (Valid (Prims.hasEq @x1)) (Valid (Prims.hasEq @x2)) (Valid (Prims.hasEq @x3)) (Valid (Prims.hasEq @x4)) (Valid (Prims.hasEq @x5)) (Valid (Prims.hasEq @x6)) (Valid (Prims.hasEq @x7))) (Valid (Prims.hasEq (Prims.tuple8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)))) :pattern ((Prims.hasEq (Prims.tuple8 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7))))) :named assumption_Prims.HasEq_tuple8_869))
(declare-fun Prims.dtuple3 (Term Term Term) Term)
(declare-fun Prims.dtuple3@x0 (Term) Term)
(declare-fun Prims.dtuple3@x1 (Term) Term)
(declare-fun Prims.dtuple3@x2 (Term) Term)
(declare-fun Prims.dtuple3@tok () Term)
(declare-fun Tm_arrow_872 (Term Term) Term)
(declare-fun Prims.Mkdtuple3 (Term Term Term Term Term Term) Term)
(declare-fun Prims.Mkdtuple3_a (Term) Term)
(declare-fun Prims.Mkdtuple3_b (Term) Term)
(declare-fun Prims.Mkdtuple3_c (Term) Term)
(declare-fun Prims.Mkdtuple3__1 (Term) Term)
(declare-fun Prims.Mkdtuple3__2 (Term) Term)
(declare-fun Prims.Mkdtuple3__3 (Term) Term)
(declare-fun Tm_arrow_889 () Term)
(declare-fun Prims.Mkdtuple3@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= 874 (Term_constr_id (Prims.dtuple3 @x0 @x1 @x2))) :pattern ((Prims.dtuple3 @x0 @x1 @x2)))) :named constructor_distinct_Prims.dtuple3))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (Prims.dtuple3@x0 (Prims.dtuple3 @x0 @x1 @x2)) @x0) :pattern ((Prims.dtuple3 @x0 @x1 @x2)))) :named projection_inverse_Prims.dtuple3@x0))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (Prims.dtuple3@x1 (Prims.dtuple3 @x0 @x1 @x2)) @x1) :pattern ((Prims.dtuple3 @x0 @x1 @x2)))) :named projection_inverse_Prims.dtuple3@x1))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (Prims.dtuple3@x2 (Prims.dtuple3 @x0 @x1 @x2)) @x2) :pattern ((Prims.dtuple3 @x0 @x1 @x2)))) :named projection_inverse_Prims.dtuple3@x2))
(define-fun is-Prims.dtuple3 ((@x0 Term)) Bool (and (= (Term_constr_id @x0) 874) (= @x0 (Prims.dtuple3 (Prims.dtuple3@x0 @x0) (Prims.dtuple3@x1 @x0) (Prims.dtuple3@x2 @x0)))))
(assert (! (= 875 (Term_constr_id Prims.dtuple3@tok)) :named fresh_token_Prims.dtuple3@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT Prims.dtuple3@tok @x0) @x1) @x2) (Prims.dtuple3 @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT Prims.dtuple3@tok @x0) @x1) @x2)) :pattern ((Prims.dtuple3 @x0 @x1 @x2)))) :named token_correspondence_Prims.dtuple3@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (HasType (Tm_arrow_872 @x0 @x1) Tm_type) :pattern ((HasType (Tm_arrow_872 @x0 @x1) Tm_type)))) :named kinding_Tm_arrow_872))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_872 @x2 @x3)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_872 @x2 @x3))))) :named pre_typing_Tm_arrow_872))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_872 @x1 @x2)) (forall ((@x3 Term) (@x4 Term)) (! (implies (and (HasType @x3 @x2) (HasType @x4 (ApplyTT @x1 @x3))) (HasType (ApplyTT (ApplyTT @x0 @x3) @x4) Tm_type)) :pattern ((ApplyTT (ApplyTT @x0 @x3) @x4))))) :pattern ((HasTypeZ @x0 (Tm_arrow_872 @x1 @x2))))) :named interpretation_Tm_arrow_872))
(assert (! (is-Tm_arrow (PreType Prims.dtuple3@tok)) :named pre_kinding_Prims.dtuple3@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 (Tm_arrow_239 @x0)) (HasType @x2 (Tm_arrow_872 @x1 @x0))) (HasType (Prims.dtuple3 @x0 @x1 @x2) Tm_type)) :pattern ((Prims.dtuple3 @x0 @x1 @x2)))) :named kinding_Prims.dtuple3@tok))
(assert (! (forall ((@x0 Term) (@u1 Fuel) (@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (HasTypeFuel @u1 @x0 (Prims.dtuple3 @x2 @x3 @x4)) (= (Prims.dtuple3 @x2 @x3 @x4) (PreType @x0))) :pattern ((HasTypeFuel @u1 @x0 (Prims.dtuple3 @x2 @x3 @x4))))) :named @pretyping__881))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (= 885 (Term_constr_id (Prims.Mkdtuple3 @x0 @x1 @x2 @x3 @x4 @x5))) :pattern ((Prims.Mkdtuple3 @x0 @x1 @x2 @x3 @x4 @x5)))) :named constructor_distinct_Prims.Mkdtuple3))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (= (Prims.Mkdtuple3_a (Prims.Mkdtuple3 @x0 @x1 @x2 @x3 @x4 @x5)) @x0) :pattern ((Prims.Mkdtuple3 @x0 @x1 @x2 @x3 @x4 @x5)))) :named projection_inverse_Prims.Mkdtuple3_a))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (= (Prims.Mkdtuple3_b (Prims.Mkdtuple3 @x0 @x1 @x2 @x3 @x4 @x5)) @x1) :pattern ((Prims.Mkdtuple3 @x0 @x1 @x2 @x3 @x4 @x5)))) :named projection_inverse_Prims.Mkdtuple3_b))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (= (Prims.Mkdtuple3_c (Prims.Mkdtuple3 @x0 @x1 @x2 @x3 @x4 @x5)) @x2) :pattern ((Prims.Mkdtuple3 @x0 @x1 @x2 @x3 @x4 @x5)))) :named projection_inverse_Prims.Mkdtuple3_c))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (= (Prims.Mkdtuple3__1 (Prims.Mkdtuple3 @x0 @x1 @x2 @x3 @x4 @x5)) @x3) :pattern ((Prims.Mkdtuple3 @x0 @x1 @x2 @x3 @x4 @x5)))) :named projection_inverse_Prims.Mkdtuple3__1))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (= (Prims.Mkdtuple3__2 (Prims.Mkdtuple3 @x0 @x1 @x2 @x3 @x4 @x5)) @x4) :pattern ((Prims.Mkdtuple3 @x0 @x1 @x2 @x3 @x4 @x5)))) :named projection_inverse_Prims.Mkdtuple3__2))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (= (Prims.Mkdtuple3__3 (Prims.Mkdtuple3 @x0 @x1 @x2 @x3 @x4 @x5)) @x5) :pattern ((Prims.Mkdtuple3 @x0 @x1 @x2 @x3 @x4 @x5)))) :named projection_inverse_Prims.Mkdtuple3__3))
(define-fun is-Prims.Mkdtuple3 ((@x0 Term)) Bool (and (= (Term_constr_id @x0) 885) (= @x0 (Prims.Mkdtuple3 (Prims.Mkdtuple3_a @x0) (Prims.Mkdtuple3_b @x0) (Prims.Mkdtuple3_c @x0) (Prims.Mkdtuple3__1 @x0) (Prims.Mkdtuple3__2 @x0) (Prims.Mkdtuple3__3 @x0)))))
(assert (! (HasType Tm_arrow_889 Tm_type) :named kinding_Tm_arrow_889))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_889) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_889)))) :named pre_typing_Tm_arrow_889))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_889) (forall ((@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 (Tm_arrow_239 @x1)) (HasType @x3 (Tm_arrow_872 @x2 @x1)) (HasType @x4 @x1) (HasType @x5 (ApplyTT @x2 @x4)) (HasType @x6 (ApplyTT (ApplyTT @x3 @x4) @x5))) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x6) (Prims.dtuple3 @x1 @x2 @x3))) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x6))))) :pattern ((HasTypeZ @x0 Tm_arrow_889)))) :named interpretation_Tm_arrow_889))
(assert (! (= 893 (Term_constr_id Prims.Mkdtuple3@tok)) :named fresh_token_Prims.Mkdtuple3@tok))
(assert (! (HasType Prims.Mkdtuple3@tok Tm_arrow_889) :named typing_tok_Prims.Mkdtuple3@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mkdtuple3@tok @x0) @x1) @x2) @x3) @x4) @x5) (Prims.Mkdtuple3 @x0 @x1 @x2 @x3 @x4 @x5)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mkdtuple3@tok @x0) @x1) @x2) @x3) @x4) @x5)))) :named equality_tok_Prims.Mkdtuple3@tok))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term)) (! (implies (and (HasTypeFuel @u0 @x1 Tm_type) (HasTypeFuel @u0 @x2 (Tm_arrow_239 @x1)) (HasTypeFuel @u0 @x3 (Tm_arrow_872 @x2 @x1)) (HasTypeFuel @u0 @x4 @x1) (HasTypeFuel @u0 @x5 (ApplyTT @x2 @x4)) (HasTypeFuel @u0 @x6 (ApplyTT (ApplyTT @x3 @x4) @x5))) (HasTypeFuel @u0 (Prims.Mkdtuple3 @x1 @x2 @x3 @x4 @x5 @x6) (Prims.dtuple3 @x1 @x2 @x3))) :pattern ((HasTypeFuel @u0 (Prims.Mkdtuple3 @x1 @x2 @x3 @x4 @x5 @x6) (Prims.dtuple3 @x1 @x2 @x3))))) :named data_typing_intro_Prims.Mkdtuple3@tok))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term)) (! (implies (HasTypeFuel (SFuel @u0) (Prims.Mkdtuple3 @x1 @x2 @x3 @x4 @x5 @x6) (Prims.dtuple3 @x7 @x8 @x9)) (and (= @x3 @x9) (= @x2 @x8) (= @x1 @x7) (HasTypeFuel @u0 @x1 Tm_type) (HasTypeFuel @u0 @x2 (Tm_arrow_239 @x1)) (HasTypeFuel @u0 @x3 (Tm_arrow_872 @x2 @x1)) (HasTypeFuel @u0 @x4 @x1) (HasTypeFuel @u0 @x5 (ApplyTT @x2 @x4)) (HasTypeFuel @u0 @x6 (ApplyTT (ApplyTT @x3 @x4) @x5)))) :pattern ((HasTypeFuel (SFuel @u0) (Prims.Mkdtuple3 @x1 @x2 @x3 @x4 @x5 @x6) (Prims.dtuple3 @x7 @x8 @x9))))) :named data_elim_Prims.Mkdtuple3))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term)) (! (implies (HasTypeFuel (SFuel @u0) (Prims.Mkdtuple3 @x1 @x2 @x3 @x4 @x5 @x6) (Prims.dtuple3 @x7 @x8 @x9)) (and (Valid (Precedes @x1 (Prims.Mkdtuple3 @x1 @x2 @x3 @x4 @x5 @x6))) (Valid (Precedes @x2 (Prims.Mkdtuple3 @x1 @x2 @x3 @x4 @x5 @x6))) (Valid (Precedes @x3 (Prims.Mkdtuple3 @x1 @x2 @x3 @x4 @x5 @x6))) (Valid (Precedes @x4 (Prims.Mkdtuple3 @x1 @x2 @x3 @x4 @x5 @x6))) (Valid (Precedes @x5 (Prims.Mkdtuple3 @x1 @x2 @x3 @x4 @x5 @x6))) (Valid (Precedes @x6 (Prims.Mkdtuple3 @x1 @x2 @x3 @x4 @x5 @x6))))) :pattern ((HasTypeFuel (SFuel @u0) (Prims.Mkdtuple3 @x1 @x2 @x3 @x4 @x5 @x6) (Prims.dtuple3 @x7 @x8 @x9))))) :named subterm_ordering_Prims.Mkdtuple3))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (HasTypeFuel @u0 @x1 (Prims.dtuple3 @x2 @x3 @x4)) (and (is-Prims.Mkdtuple3 @x1) (= @x2 (Prims.Mkdtuple3_a @x1)) (= @x3 (Prims.Mkdtuple3_b @x1)) (= @x4 (Prims.Mkdtuple3_c @x1)))) :pattern ((HasTypeFuel @u0 @x1 (Prims.dtuple3 @x2 @x3 @x4))))) :named fuel_guarded_inversion_Prims.dtuple3_878))
(declare-fun Prims.Mkdtuple3._1 (Term Term Term Term) Term)
(declare-fun Tm_arrow_899 () Term)
(assert (! (HasType Tm_arrow_899 Tm_type) :named kinding_Tm_arrow_899))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_899) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_899)))) :named pre_typing_Tm_arrow_899))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_899) (forall ((@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 (Tm_arrow_239 @x1)) (HasType @x3 (Tm_arrow_872 @x2 @x1)) (HasType @x4 (Prims.dtuple3 @x1 @x2 @x3))) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x1)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4))))) :pattern ((HasTypeZ @x0 Tm_arrow_899)))) :named interpretation_Tm_arrow_899))
(declare-fun Prims.Mkdtuple3._1@tok () Term)
(assert (! (= 901 (Term_constr_id Prims.Mkdtuple3._1@tok)) :named fresh_token_Prims.Mkdtuple3._1@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mkdtuple3._1@tok @x0) @x1) @x2) @x3) (Prims.Mkdtuple3._1 @x0 @x1 @x2 @x3)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mkdtuple3._1@tok @x0) @x1) @x2) @x3)))) :named token_correspondence_Prims.Mkdtuple3._1))
(assert (! (HasType Prims.Mkdtuple3._1@tok Tm_arrow_899) :named function_token_typing_Prims.Mkdtuple3._1))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 (Tm_arrow_239 @x0)) (HasType @x2 (Tm_arrow_872 @x1 @x0)) (HasType @x3 (Prims.dtuple3 @x0 @x1 @x2))) (HasType (Prims.Mkdtuple3._1 @x0 @x1 @x2 @x3) @x0)) :pattern ((Prims.Mkdtuple3._1 @x0 @x1 @x2 @x3)))) :named typing_Prims.Mkdtuple3._1))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (Prims.Mkdtuple3._1 @x0 @x1 @x2 @x3) (Prims.Mkdtuple3__1 @x3)) :pattern ((Prims.Mkdtuple3._1 @x0 @x1 @x2 @x3)))) :named proj_equation_Prims.Mkdtuple3__1))
(declare-fun Prims.Mkdtuple3._2 (Term Term Term Term) Term)
(declare-fun Tm_arrow_907 () Term)
(assert (! (HasType Tm_arrow_907 Tm_type) :named kinding_Tm_arrow_907))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_907) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_907)))) :named pre_typing_Tm_arrow_907))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_907) (forall ((@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 (Tm_arrow_239 @x1)) (HasType @x3 (Tm_arrow_872 @x2 @x1)) (HasType @x4 (Prims.dtuple3 @x1 @x2 @x3))) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) (ApplyTT @x2 (Prims.Mkdtuple3._1 @x1 @x2 @x3 @x4)))) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4))))) :pattern ((HasTypeZ @x0 Tm_arrow_907)))) :named interpretation_Tm_arrow_907))
(declare-fun Prims.Mkdtuple3._2@tok () Term)
(assert (! (= 909 (Term_constr_id Prims.Mkdtuple3._2@tok)) :named fresh_token_Prims.Mkdtuple3._2@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mkdtuple3._2@tok @x0) @x1) @x2) @x3) (Prims.Mkdtuple3._2 @x0 @x1 @x2 @x3)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mkdtuple3._2@tok @x0) @x1) @x2) @x3)))) :named token_correspondence_Prims.Mkdtuple3._2))
(assert (! (HasType Prims.Mkdtuple3._2@tok Tm_arrow_907) :named function_token_typing_Prims.Mkdtuple3._2))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 (Tm_arrow_239 @x0)) (HasType @x2 (Tm_arrow_872 @x1 @x0)) (HasType @x3 (Prims.dtuple3 @x0 @x1 @x2))) (HasType (Prims.Mkdtuple3._2 @x0 @x1 @x2 @x3) (ApplyTT @x1 (Prims.Mkdtuple3._1 @x0 @x1 @x2 @x3)))) :pattern ((Prims.Mkdtuple3._2 @x0 @x1 @x2 @x3)))) :named typing_Prims.Mkdtuple3._2))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (Prims.Mkdtuple3._2 @x0 @x1 @x2 @x3) (Prims.Mkdtuple3__2 @x3)) :pattern ((Prims.Mkdtuple3._2 @x0 @x1 @x2 @x3)))) :named proj_equation_Prims.Mkdtuple3__2))
(declare-fun Prims.Mkdtuple3._3 (Term Term Term Term) Term)
(declare-fun Tm_arrow_915 () Term)
(assert (! (HasType Tm_arrow_915 Tm_type) :named kinding_Tm_arrow_915))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_915) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_915)))) :named pre_typing_Tm_arrow_915))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_915) (forall ((@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 (Tm_arrow_239 @x1)) (HasType @x3 (Tm_arrow_872 @x2 @x1)) (HasType @x4 (Prims.dtuple3 @x1 @x2 @x3))) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) (ApplyTT (ApplyTT @x3 (Prims.Mkdtuple3._1 @x1 @x2 @x3 @x4)) (Prims.Mkdtuple3._2 @x1 @x2 @x3 @x4)))) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4))))) :pattern ((HasTypeZ @x0 Tm_arrow_915)))) :named interpretation_Tm_arrow_915))
(declare-fun Prims.Mkdtuple3._3@tok () Term)
(assert (! (= 917 (Term_constr_id Prims.Mkdtuple3._3@tok)) :named fresh_token_Prims.Mkdtuple3._3@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mkdtuple3._3@tok @x0) @x1) @x2) @x3) (Prims.Mkdtuple3._3 @x0 @x1 @x2 @x3)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mkdtuple3._3@tok @x0) @x1) @x2) @x3)))) :named token_correspondence_Prims.Mkdtuple3._3))
(assert (! (HasType Prims.Mkdtuple3._3@tok Tm_arrow_915) :named function_token_typing_Prims.Mkdtuple3._3))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 (Tm_arrow_239 @x0)) (HasType @x2 (Tm_arrow_872 @x1 @x0)) (HasType @x3 (Prims.dtuple3 @x0 @x1 @x2))) (HasType (Prims.Mkdtuple3._3 @x0 @x1 @x2 @x3) (ApplyTT (ApplyTT @x2 (Prims.Mkdtuple3._1 @x0 @x1 @x2 @x3)) (Prims.Mkdtuple3._2 @x0 @x1 @x2 @x3)))) :pattern ((Prims.Mkdtuple3._3 @x0 @x1 @x2 @x3)))) :named typing_Prims.Mkdtuple3._3))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (Prims.Mkdtuple3._3 @x0 @x1 @x2 @x3) (Prims.Mkdtuple3__3 @x3)) :pattern ((Prims.Mkdtuple3._3 @x0 @x1 @x2 @x3)))) :named proj_equation_Prims.Mkdtuple3__3))
(declare-fun Prims.dtuple4 (Term Term Term Term) Term)
(declare-fun Prims.dtuple4@x0 (Term) Term)
(declare-fun Prims.dtuple4@x1 (Term) Term)
(declare-fun Prims.dtuple4@x2 (Term) Term)
(declare-fun Prims.dtuple4@x3 (Term) Term)
(declare-fun Prims.dtuple4@tok () Term)
(declare-fun Tm_arrow_921 (Term Term Term) Term)
(declare-fun Prims.Mkdtuple4 (Term Term Term Term Term Term Term Term) Term)
(declare-fun Prims.Mkdtuple4_a (Term) Term)
(declare-fun Prims.Mkdtuple4_b (Term) Term)
(declare-fun Prims.Mkdtuple4_c (Term) Term)
(declare-fun Prims.Mkdtuple4_d (Term) Term)
(declare-fun Prims.Mkdtuple4__1 (Term) Term)
(declare-fun Prims.Mkdtuple4__2 (Term) Term)
(declare-fun Prims.Mkdtuple4__3 (Term) Term)
(declare-fun Prims.Mkdtuple4__4 (Term) Term)
(declare-fun Tm_arrow_940 () Term)
(declare-fun Prims.Mkdtuple4@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= 923 (Term_constr_id (Prims.dtuple4 @x0 @x1 @x2 @x3))) :pattern ((Prims.dtuple4 @x0 @x1 @x2 @x3)))) :named constructor_distinct_Prims.dtuple4))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (Prims.dtuple4@x0 (Prims.dtuple4 @x0 @x1 @x2 @x3)) @x0) :pattern ((Prims.dtuple4 @x0 @x1 @x2 @x3)))) :named projection_inverse_Prims.dtuple4@x0))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (Prims.dtuple4@x1 (Prims.dtuple4 @x0 @x1 @x2 @x3)) @x1) :pattern ((Prims.dtuple4 @x0 @x1 @x2 @x3)))) :named projection_inverse_Prims.dtuple4@x1))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (Prims.dtuple4@x2 (Prims.dtuple4 @x0 @x1 @x2 @x3)) @x2) :pattern ((Prims.dtuple4 @x0 @x1 @x2 @x3)))) :named projection_inverse_Prims.dtuple4@x2))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (Prims.dtuple4@x3 (Prims.dtuple4 @x0 @x1 @x2 @x3)) @x3) :pattern ((Prims.dtuple4 @x0 @x1 @x2 @x3)))) :named projection_inverse_Prims.dtuple4@x3))
(define-fun is-Prims.dtuple4 ((@x0 Term)) Bool (and (= (Term_constr_id @x0) 923) (= @x0 (Prims.dtuple4 (Prims.dtuple4@x0 @x0) (Prims.dtuple4@x1 @x0) (Prims.dtuple4@x2 @x0) (Prims.dtuple4@x3 @x0)))))
(assert (! (= 924 (Term_constr_id Prims.dtuple4@tok)) :named fresh_token_Prims.dtuple4@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.dtuple4@tok @x0) @x1) @x2) @x3) (Prims.dtuple4 @x0 @x1 @x2 @x3)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.dtuple4@tok @x0) @x1) @x2) @x3)) :pattern ((Prims.dtuple4 @x0 @x1 @x2 @x3)))) :named token_correspondence_Prims.dtuple4@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (HasType (Tm_arrow_921 @x0 @x1 @x2) Tm_type) :pattern ((HasType (Tm_arrow_921 @x0 @x1 @x2) Tm_type)))) :named kinding_Tm_arrow_921))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_921 @x2 @x3 @x4)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_921 @x2 @x3 @x4))))) :named pre_typing_Tm_arrow_921))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_921 @x1 @x2 @x3)) (forall ((@x4 Term) (@x5 Term) (@x6 Term)) (! (implies (and (HasType @x4 @x3) (HasType @x5 (ApplyTT @x2 @x4)) (HasType @x6 (ApplyTT (ApplyTT @x1 @x4) @x5))) (HasType (ApplyTT (ApplyTT (ApplyTT @x0 @x4) @x5) @x6) Tm_type)) :pattern ((ApplyTT (ApplyTT (ApplyTT @x0 @x4) @x5) @x6))))) :pattern ((HasTypeZ @x0 (Tm_arrow_921 @x1 @x2 @x3))))) :named interpretation_Tm_arrow_921))
(assert (! (is-Tm_arrow (PreType Prims.dtuple4@tok)) :named pre_kinding_Prims.dtuple4@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 (Tm_arrow_239 @x0)) (HasType @x2 (Tm_arrow_872 @x1 @x0)) (HasType @x3 (Tm_arrow_921 @x2 @x1 @x0))) (HasType (Prims.dtuple4 @x0 @x1 @x2 @x3) Tm_type)) :pattern ((Prims.dtuple4 @x0 @x1 @x2 @x3)))) :named kinding_Prims.dtuple4@tok))
(assert (! (forall ((@x0 Term) (@u1 Fuel) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (implies (HasTypeFuel @u1 @x0 (Prims.dtuple4 @x2 @x3 @x4 @x5)) (= (Prims.dtuple4 @x2 @x3 @x4 @x5) (PreType @x0))) :pattern ((HasTypeFuel @u1 @x0 (Prims.dtuple4 @x2 @x3 @x4 @x5))))) :named @pretyping__930))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term)) (! (= 935 (Term_constr_id (Prims.Mkdtuple4 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7))) :pattern ((Prims.Mkdtuple4 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)))) :named constructor_distinct_Prims.Mkdtuple4))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term)) (! (= (Prims.Mkdtuple4_a (Prims.Mkdtuple4 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)) @x0) :pattern ((Prims.Mkdtuple4 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)))) :named projection_inverse_Prims.Mkdtuple4_a))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term)) (! (= (Prims.Mkdtuple4_b (Prims.Mkdtuple4 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)) @x1) :pattern ((Prims.Mkdtuple4 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)))) :named projection_inverse_Prims.Mkdtuple4_b))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term)) (! (= (Prims.Mkdtuple4_c (Prims.Mkdtuple4 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)) @x2) :pattern ((Prims.Mkdtuple4 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)))) :named projection_inverse_Prims.Mkdtuple4_c))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term)) (! (= (Prims.Mkdtuple4_d (Prims.Mkdtuple4 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)) @x3) :pattern ((Prims.Mkdtuple4 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)))) :named projection_inverse_Prims.Mkdtuple4_d))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term)) (! (= (Prims.Mkdtuple4__1 (Prims.Mkdtuple4 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)) @x4) :pattern ((Prims.Mkdtuple4 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)))) :named projection_inverse_Prims.Mkdtuple4__1))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term)) (! (= (Prims.Mkdtuple4__2 (Prims.Mkdtuple4 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)) @x5) :pattern ((Prims.Mkdtuple4 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)))) :named projection_inverse_Prims.Mkdtuple4__2))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term)) (! (= (Prims.Mkdtuple4__3 (Prims.Mkdtuple4 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)) @x6) :pattern ((Prims.Mkdtuple4 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)))) :named projection_inverse_Prims.Mkdtuple4__3))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term)) (! (= (Prims.Mkdtuple4__4 (Prims.Mkdtuple4 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)) @x7) :pattern ((Prims.Mkdtuple4 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)))) :named projection_inverse_Prims.Mkdtuple4__4))
(define-fun is-Prims.Mkdtuple4 ((@x0 Term)) Bool (and (= (Term_constr_id @x0) 935) (= @x0 (Prims.Mkdtuple4 (Prims.Mkdtuple4_a @x0) (Prims.Mkdtuple4_b @x0) (Prims.Mkdtuple4_c @x0) (Prims.Mkdtuple4_d @x0) (Prims.Mkdtuple4__1 @x0) (Prims.Mkdtuple4__2 @x0) (Prims.Mkdtuple4__3 @x0) (Prims.Mkdtuple4__4 @x0)))))
(assert (! (HasType Tm_arrow_940 Tm_type) :named kinding_Tm_arrow_940))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_940) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_940)))) :named pre_typing_Tm_arrow_940))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_940) (forall ((@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 (Tm_arrow_239 @x1)) (HasType @x3 (Tm_arrow_872 @x2 @x1)) (HasType @x4 (Tm_arrow_921 @x3 @x2 @x1)) (HasType @x5 @x1) (HasType @x6 (ApplyTT @x2 @x5)) (HasType @x7 (ApplyTT (ApplyTT @x3 @x5) @x6)) (HasType @x8 (ApplyTT (ApplyTT (ApplyTT @x4 @x5) @x6) @x7))) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x8) (Prims.dtuple4 @x1 @x2 @x3 @x4))) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x6) @x7) @x8))))) :pattern ((HasTypeZ @x0 Tm_arrow_940)))) :named interpretation_Tm_arrow_940))
(assert (! (= 945 (Term_constr_id Prims.Mkdtuple4@tok)) :named fresh_token_Prims.Mkdtuple4@tok))
(assert (! (HasType Prims.Mkdtuple4@tok Tm_arrow_940) :named typing_tok_Prims.Mkdtuple4@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mkdtuple4@tok @x0) @x1) @x2) @x3) @x4) @x5) @x6) @x7) (Prims.Mkdtuple4 @x0 @x1 @x2 @x3 @x4 @x5 @x6 @x7)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mkdtuple4@tok @x0) @x1) @x2) @x3) @x4) @x5) @x6) @x7)))) :named equality_tok_Prims.Mkdtuple4@tok))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term)) (! (implies (and (HasTypeFuel @u0 @x1 Tm_type) (HasTypeFuel @u0 @x2 (Tm_arrow_239 @x1)) (HasTypeFuel @u0 @x3 (Tm_arrow_872 @x2 @x1)) (HasTypeFuel @u0 @x4 (Tm_arrow_921 @x3 @x2 @x1)) (HasTypeFuel @u0 @x5 @x1) (HasTypeFuel @u0 @x6 (ApplyTT @x2 @x5)) (HasTypeFuel @u0 @x7 (ApplyTT (ApplyTT @x3 @x5) @x6)) (HasTypeFuel @u0 @x8 (ApplyTT (ApplyTT (ApplyTT @x4 @x5) @x6) @x7))) (HasTypeFuel @u0 (Prims.Mkdtuple4 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8) (Prims.dtuple4 @x1 @x2 @x3 @x4))) :pattern ((HasTypeFuel @u0 (Prims.Mkdtuple4 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8) (Prims.dtuple4 @x1 @x2 @x3 @x4))))) :named data_typing_intro_Prims.Mkdtuple4@tok))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term) (@x10 Term) (@x11 Term) (@x12 Term)) (! (implies (HasTypeFuel (SFuel @u0) (Prims.Mkdtuple4 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8) (Prims.dtuple4 @x9 @x10 @x11 @x12)) (and (= @x4 @x12) (= @x3 @x11) (= @x2 @x10) (= @x1 @x9) (HasTypeFuel @u0 @x1 Tm_type) (HasTypeFuel @u0 @x2 (Tm_arrow_239 @x1)) (HasTypeFuel @u0 @x3 (Tm_arrow_872 @x2 @x1)) (HasTypeFuel @u0 @x4 (Tm_arrow_921 @x3 @x2 @x1)) (HasTypeFuel @u0 @x5 @x1) (HasTypeFuel @u0 @x6 (ApplyTT @x2 @x5)) (HasTypeFuel @u0 @x7 (ApplyTT (ApplyTT @x3 @x5) @x6)) (HasTypeFuel @u0 @x8 (ApplyTT (ApplyTT (ApplyTT @x4 @x5) @x6) @x7)))) :pattern ((HasTypeFuel (SFuel @u0) (Prims.Mkdtuple4 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8) (Prims.dtuple4 @x9 @x10 @x11 @x12))))) :named data_elim_Prims.Mkdtuple4))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term) (@x10 Term) (@x11 Term) (@x12 Term)) (! (implies (HasTypeFuel (SFuel @u0) (Prims.Mkdtuple4 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8) (Prims.dtuple4 @x9 @x10 @x11 @x12)) (and (Valid (Precedes @x1 (Prims.Mkdtuple4 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8))) (Valid (Precedes @x2 (Prims.Mkdtuple4 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8))) (Valid (Precedes @x3 (Prims.Mkdtuple4 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8))) (Valid (Precedes @x4 (Prims.Mkdtuple4 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8))) (Valid (Precedes @x5 (Prims.Mkdtuple4 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8))) (Valid (Precedes @x6 (Prims.Mkdtuple4 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8))) (Valid (Precedes @x7 (Prims.Mkdtuple4 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8))) (Valid (Precedes @x8 (Prims.Mkdtuple4 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8))))) :pattern ((HasTypeFuel (SFuel @u0) (Prims.Mkdtuple4 @x1 @x2 @x3 @x4 @x5 @x6 @x7 @x8) (Prims.dtuple4 @x9 @x10 @x11 @x12))))) :named subterm_ordering_Prims.Mkdtuple4))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (implies (HasTypeFuel @u0 @x1 (Prims.dtuple4 @x2 @x3 @x4 @x5)) (and (is-Prims.Mkdtuple4 @x1) (= @x2 (Prims.Mkdtuple4_a @x1)) (= @x3 (Prims.Mkdtuple4_b @x1)) (= @x4 (Prims.Mkdtuple4_c @x1)) (= @x5 (Prims.Mkdtuple4_d @x1)))) :pattern ((HasTypeFuel @u0 @x1 (Prims.dtuple4 @x2 @x3 @x4 @x5))))) :named fuel_guarded_inversion_Prims.dtuple4_927))
(declare-fun Prims.Mkdtuple4._1 (Term Term Term Term Term) Term)
(declare-fun Tm_arrow_953 () Term)
(assert (! (HasType Tm_arrow_953 Tm_type) :named kinding_Tm_arrow_953))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_953) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_953)))) :named pre_typing_Tm_arrow_953))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_953) (forall ((@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 (Tm_arrow_239 @x1)) (HasType @x3 (Tm_arrow_872 @x2 @x1)) (HasType @x4 (Tm_arrow_921 @x3 @x2 @x1)) (HasType @x5 (Prims.dtuple4 @x1 @x2 @x3 @x4))) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x1)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5))))) :pattern ((HasTypeZ @x0 Tm_arrow_953)))) :named interpretation_Tm_arrow_953))
(declare-fun Prims.Mkdtuple4._1@tok () Term)
(assert (! (= 955 (Term_constr_id Prims.Mkdtuple4._1@tok)) :named fresh_token_Prims.Mkdtuple4._1@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mkdtuple4._1@tok @x0) @x1) @x2) @x3) @x4) (Prims.Mkdtuple4._1 @x0 @x1 @x2 @x3 @x4)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mkdtuple4._1@tok @x0) @x1) @x2) @x3) @x4)))) :named token_correspondence_Prims.Mkdtuple4._1))
(assert (! (HasType Prims.Mkdtuple4._1@tok Tm_arrow_953) :named function_token_typing_Prims.Mkdtuple4._1))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 (Tm_arrow_239 @x0)) (HasType @x2 (Tm_arrow_872 @x1 @x0)) (HasType @x3 (Tm_arrow_921 @x2 @x1 @x0)) (HasType @x4 (Prims.dtuple4 @x0 @x1 @x2 @x3))) (HasType (Prims.Mkdtuple4._1 @x0 @x1 @x2 @x3 @x4) @x0)) :pattern ((Prims.Mkdtuple4._1 @x0 @x1 @x2 @x3 @x4)))) :named typing_Prims.Mkdtuple4._1))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (= (Prims.Mkdtuple4._1 @x0 @x1 @x2 @x3 @x4) (Prims.Mkdtuple4__1 @x4)) :pattern ((Prims.Mkdtuple4._1 @x0 @x1 @x2 @x3 @x4)))) :named proj_equation_Prims.Mkdtuple4__1))
(declare-fun Prims.Mkdtuple4._2 (Term Term Term Term Term) Term)
(declare-fun Tm_arrow_963 () Term)
(assert (! (HasType Tm_arrow_963 Tm_type) :named kinding_Tm_arrow_963))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_963) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_963)))) :named pre_typing_Tm_arrow_963))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_963) (forall ((@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 (Tm_arrow_239 @x1)) (HasType @x3 (Tm_arrow_872 @x2 @x1)) (HasType @x4 (Tm_arrow_921 @x3 @x2 @x1)) (HasType @x5 (Prims.dtuple4 @x1 @x2 @x3 @x4))) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) (ApplyTT @x2 (Prims.Mkdtuple4._1 @x1 @x2 @x3 @x4 @x5)))) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5))))) :pattern ((HasTypeZ @x0 Tm_arrow_963)))) :named interpretation_Tm_arrow_963))
(declare-fun Prims.Mkdtuple4._2@tok () Term)
(assert (! (= 965 (Term_constr_id Prims.Mkdtuple4._2@tok)) :named fresh_token_Prims.Mkdtuple4._2@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mkdtuple4._2@tok @x0) @x1) @x2) @x3) @x4) (Prims.Mkdtuple4._2 @x0 @x1 @x2 @x3 @x4)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mkdtuple4._2@tok @x0) @x1) @x2) @x3) @x4)))) :named token_correspondence_Prims.Mkdtuple4._2))
(assert (! (HasType Prims.Mkdtuple4._2@tok Tm_arrow_963) :named function_token_typing_Prims.Mkdtuple4._2))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 (Tm_arrow_239 @x0)) (HasType @x2 (Tm_arrow_872 @x1 @x0)) (HasType @x3 (Tm_arrow_921 @x2 @x1 @x0)) (HasType @x4 (Prims.dtuple4 @x0 @x1 @x2 @x3))) (HasType (Prims.Mkdtuple4._2 @x0 @x1 @x2 @x3 @x4) (ApplyTT @x1 (Prims.Mkdtuple4._1 @x0 @x1 @x2 @x3 @x4)))) :pattern ((Prims.Mkdtuple4._2 @x0 @x1 @x2 @x3 @x4)))) :named typing_Prims.Mkdtuple4._2))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (= (Prims.Mkdtuple4._2 @x0 @x1 @x2 @x3 @x4) (Prims.Mkdtuple4__2 @x4)) :pattern ((Prims.Mkdtuple4._2 @x0 @x1 @x2 @x3 @x4)))) :named proj_equation_Prims.Mkdtuple4__2))
(declare-fun Prims.Mkdtuple4._3 (Term Term Term Term Term) Term)
(declare-fun Tm_arrow_973 () Term)
(assert (! (HasType Tm_arrow_973 Tm_type) :named kinding_Tm_arrow_973))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_973) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_973)))) :named pre_typing_Tm_arrow_973))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_973) (forall ((@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 (Tm_arrow_239 @x1)) (HasType @x3 (Tm_arrow_872 @x2 @x1)) (HasType @x4 (Tm_arrow_921 @x3 @x2 @x1)) (HasType @x5 (Prims.dtuple4 @x1 @x2 @x3 @x4))) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) (ApplyTT (ApplyTT @x3 (Prims.Mkdtuple4._1 @x1 @x2 @x3 @x4 @x5)) (Prims.Mkdtuple4._2 @x1 @x2 @x3 @x4 @x5)))) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5))))) :pattern ((HasTypeZ @x0 Tm_arrow_973)))) :named interpretation_Tm_arrow_973))
(declare-fun Prims.Mkdtuple4._3@tok () Term)
(assert (! (= 975 (Term_constr_id Prims.Mkdtuple4._3@tok)) :named fresh_token_Prims.Mkdtuple4._3@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mkdtuple4._3@tok @x0) @x1) @x2) @x3) @x4) (Prims.Mkdtuple4._3 @x0 @x1 @x2 @x3 @x4)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mkdtuple4._3@tok @x0) @x1) @x2) @x3) @x4)))) :named token_correspondence_Prims.Mkdtuple4._3))
(assert (! (HasType Prims.Mkdtuple4._3@tok Tm_arrow_973) :named function_token_typing_Prims.Mkdtuple4._3))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 (Tm_arrow_239 @x0)) (HasType @x2 (Tm_arrow_872 @x1 @x0)) (HasType @x3 (Tm_arrow_921 @x2 @x1 @x0)) (HasType @x4 (Prims.dtuple4 @x0 @x1 @x2 @x3))) (HasType (Prims.Mkdtuple4._3 @x0 @x1 @x2 @x3 @x4) (ApplyTT (ApplyTT @x2 (Prims.Mkdtuple4._1 @x0 @x1 @x2 @x3 @x4)) (Prims.Mkdtuple4._2 @x0 @x1 @x2 @x3 @x4)))) :pattern ((Prims.Mkdtuple4._3 @x0 @x1 @x2 @x3 @x4)))) :named typing_Prims.Mkdtuple4._3))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (= (Prims.Mkdtuple4._3 @x0 @x1 @x2 @x3 @x4) (Prims.Mkdtuple4__3 @x4)) :pattern ((Prims.Mkdtuple4._3 @x0 @x1 @x2 @x3 @x4)))) :named proj_equation_Prims.Mkdtuple4__3))
(declare-fun Prims.Mkdtuple4._4 (Term Term Term Term Term) Term)
(declare-fun Tm_arrow_983 () Term)
(assert (! (HasType Tm_arrow_983 Tm_type) :named kinding_Tm_arrow_983))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_983) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_983)))) :named pre_typing_Tm_arrow_983))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_983) (forall ((@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 (Tm_arrow_239 @x1)) (HasType @x3 (Tm_arrow_872 @x2 @x1)) (HasType @x4 (Tm_arrow_921 @x3 @x2 @x1)) (HasType @x5 (Prims.dtuple4 @x1 @x2 @x3 @x4))) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) (ApplyTT (ApplyTT (ApplyTT @x4 (Prims.Mkdtuple4._1 @x1 @x2 @x3 @x4 @x5)) (Prims.Mkdtuple4._2 @x1 @x2 @x3 @x4 @x5)) (Prims.Mkdtuple4._3 @x1 @x2 @x3 @x4 @x5)))) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5))))) :pattern ((HasTypeZ @x0 Tm_arrow_983)))) :named interpretation_Tm_arrow_983))
(declare-fun Prims.Mkdtuple4._4@tok () Term)
(assert (! (= 985 (Term_constr_id Prims.Mkdtuple4._4@tok)) :named fresh_token_Prims.Mkdtuple4._4@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mkdtuple4._4@tok @x0) @x1) @x2) @x3) @x4) (Prims.Mkdtuple4._4 @x0 @x1 @x2 @x3 @x4)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT Prims.Mkdtuple4._4@tok @x0) @x1) @x2) @x3) @x4)))) :named token_correspondence_Prims.Mkdtuple4._4))
(assert (! (HasType Prims.Mkdtuple4._4@tok Tm_arrow_983) :named function_token_typing_Prims.Mkdtuple4._4))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 (Tm_arrow_239 @x0)) (HasType @x2 (Tm_arrow_872 @x1 @x0)) (HasType @x3 (Tm_arrow_921 @x2 @x1 @x0)) (HasType @x4 (Prims.dtuple4 @x0 @x1 @x2 @x3))) (HasType (Prims.Mkdtuple4._4 @x0 @x1 @x2 @x3 @x4) (ApplyTT (ApplyTT (ApplyTT @x3 (Prims.Mkdtuple4._1 @x0 @x1 @x2 @x3 @x4)) (Prims.Mkdtuple4._2 @x0 @x1 @x2 @x3 @x4)) (Prims.Mkdtuple4._3 @x0 @x1 @x2 @x3 @x4)))) :pattern ((Prims.Mkdtuple4._4 @x0 @x1 @x2 @x3 @x4)))) :named typing_Prims.Mkdtuple4._4))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (= (Prims.Mkdtuple4._4 @x0 @x1 @x2 @x3 @x4) (Prims.Mkdtuple4__4 @x4)) :pattern ((Prims.Mkdtuple4._4 @x0 @x1 @x2 @x3 @x4)))) :named proj_equation_Prims.Mkdtuple4__4))
(declare-fun Prims.as_requires (Term Term) Term)
(declare-fun Tm_arrow_987 (Term) Term)
(assert (! (forall ((@x0 Term)) (! (HasType (Tm_arrow_987 @x0) Tm_type) :pattern ((HasType (Tm_arrow_987 @x0) Tm_type)))) :named kinding_Tm_arrow_987))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_987 @x2)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_987 @x2))))) :named pre_typing_Tm_arrow_987))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_987 @x1)) (forall ((@x2 Term) (@x3 Term)) (! (implies (and (HasType @x2 Tm_type) (HasType @x3 (Prims.pure_wp @x2))) (HasType (ApplyTT (ApplyTT @x0 @x2) @x3) @x1)) :pattern ((ApplyTT (ApplyTT @x0 @x2) @x3))))) :pattern ((HasTypeZ @x0 (Tm_arrow_987 @x1))))) :named interpretation_Tm_arrow_987))
(declare-fun Prims.as_requires@tok () Term)
(assert (! (= 989 (Term_constr_id Prims.as_requires@tok)) :named fresh_token_Prims.as_requires@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (ApplyTT (ApplyTT Prims.as_requires@tok @x0) @x1) (Prims.as_requires @x0 @x1)) :pattern ((ApplyTT (ApplyTT Prims.as_requires@tok @x0) @x1)))) :named token_correspondence_Prims.as_requires))
(assert (! (HasType Prims.as_requires@tok (Tm_arrow_987 Prims.pure_pre)) :named function_token_typing_Prims.as_requires))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 (Prims.pure_wp @x0))) (HasType (Prims.as_requires @x0 @x1) Prims.pure_pre)) :pattern ((Prims.as_requires @x0 @x1)))) :named typing_Prims.as_requires))
(declare-fun Exp_abs_990 (Term Term) Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (HasType (Exp_abs_990 @x0 @x1) (Tm_arrow_239 @x1)) :pattern ((Exp_abs_990 @x0 @x1)))) :named typing_Exp_abs_990))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (Exp_abs_990 @x1 @x2) @x0) @x1) :pattern ((ApplyTT (Exp_abs_990 @x1 @x2) @x0)))) :named interpretation_Exp_abs_990))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (Prims.as_requires @x0 @x1) (ApplyTT @x1 (Exp_abs_990 Prims.l_True @x0))) :pattern ((Prims.as_requires @x0 @x1)))) :named equation_Prims.as_requires))
(declare-fun Prims.as_ensures (Term Term Term) Term)
(declare-fun Tm_arrow_993 () Term)
(assert (! (HasType Tm_arrow_993 Tm_type) :named kinding_Tm_arrow_993))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_993) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_993)))) :named pre_typing_Tm_arrow_993))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_993) (forall ((@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 (Prims.pure_wp @x1)) (HasType @x3 @x1)) (HasType (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) Tm_type)) :pattern ((ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3))))) :pattern ((HasTypeZ @x0 Tm_arrow_993)))) :named interpretation_Tm_arrow_993))
(declare-fun Prims.as_ensures@tok () Term)
(assert (! (= 995 (Term_constr_id Prims.as_ensures@tok)) :named fresh_token_Prims.as_ensures@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT Prims.as_ensures@tok @x0) @x1) @x2) (Prims.as_ensures @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT Prims.as_ensures@tok @x0) @x1) @x2)))) :named token_correspondence_Prims.as_ensures))
(assert (! (HasType Prims.as_ensures@tok Tm_arrow_993) :named function_token_typing_Prims.as_ensures))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 (Prims.pure_wp @x0)) (HasType @x2 @x0)) (HasType (Prims.as_ensures @x0 @x1 @x2) Tm_type)) :pattern ((Prims.as_ensures @x0 @x1 @x2)))) :named typing_Prims.as_ensures))
(declare-fun Exp_abs_996 (Term Term) Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (HasType (Exp_abs_996 @x0 @x1) (Tm_arrow_239 @x1)) :pattern ((Exp_abs_996 @x0 @x1)))) :named typing_Exp_abs_996))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (Exp_abs_996 @x1 @x2) @x0) (Prims.l_not (Prims.eq2 @x2 @x0 @x1))) :pattern ((ApplyTT (Exp_abs_996 @x1 @x2) @x0)))) :named interpretation_Exp_abs_996))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (Valid (Prims.as_ensures @x0 @x1 @x2)) (not (Valid (ApplyTT @x1 (Exp_abs_996 @x2 @x0))))) :pattern ((Valid (Prims.as_ensures @x0 @x1 @x2))))) :named equation_Prims.as_ensures))
(declare-fun Prims.fst (Term Term Term) Term)
(declare-fun Prims.fst@tok () Term)
(assert (! (= 999 (Term_constr_id Prims.fst@tok)) :named fresh_token_Prims.fst@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT Prims.fst@tok @x0) @x1) @x2) (Prims.fst @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT Prims.fst@tok @x0) @x1) @x2)))) :named token_correspondence_Prims.fst))
(assert (! (HasType Prims.fst@tok Tm_arrow_640) :named function_token_typing_Prims.fst))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 (Prims.tuple2 @x0 @x1))) (HasType (Prims.fst @x0 @x1 @x2) @x0)) :pattern ((Prims.fst @x0 @x1 @x2)))) :named typing_Prims.fst))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (Prims.fst @x0 @x1 @x2) (Prims.Mktuple2._1 @x0 @x1 @x2)) :pattern ((Prims.fst @x0 @x1 @x2)))) :named equation_Prims.fst))
(declare-fun Prims.snd (Term Term Term) Term)
(declare-fun Prims.snd@tok () Term)
(assert (! (= 1001 (Term_constr_id Prims.snd@tok)) :named fresh_token_Prims.snd@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT Prims.snd@tok @x0) @x1) @x2) (Prims.snd @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT Prims.snd@tok @x0) @x1) @x2)))) :named token_correspondence_Prims.snd))
(assert (! (HasType Prims.snd@tok Tm_arrow_644) :named function_token_typing_Prims.snd))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 (Prims.tuple2 @x0 @x1))) (HasType (Prims.snd @x0 @x1 @x2) @x1)) :pattern ((Prims.snd @x0 @x1 @x2)))) :named typing_Prims.snd))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (Prims.snd @x0 @x1 @x2) (Prims.Mktuple2._2 @x0 @x1 @x2)) :pattern ((Prims.snd @x0 @x1 @x2)))) :named equation_Prims.snd))
(declare-fun Prims.dfst (Term Term Term) Term)
(declare-fun Prims.dfst@tok () Term)
(assert (! (= 1005 (Term_constr_id Prims.dfst@tok)) :named fresh_token_Prims.dfst@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT Prims.dfst@tok @x0) @x1) @x2) (Prims.dfst @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT Prims.dfst@tok @x0) @x1) @x2)))) :named token_correspondence_Prims.dfst))
(assert (! (HasType Prims.dfst@tok Tm_arrow_271) :named function_token_typing_Prims.dfst))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 (Tm_arrow_239 @x0)) (HasType @x2 (Prims.dtuple2 @x0 @x1))) (HasType (Prims.dfst @x0 @x1 @x2) @x0)) :pattern ((Prims.dfst @x0 @x1 @x2)))) :named typing_Prims.dfst))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (Prims.dfst @x0 @x1 @x2) (Prims.Mkdtuple2._1 @x0 @x1 @x2)) :pattern ((Prims.dfst @x0 @x1 @x2)))) :named equation_Prims.dfst))
(declare-fun Prims.dsnd (Term Term Term) Term)
(declare-fun Prims.dsnd@tok () Term)
(assert (! (= 1010 (Term_constr_id Prims.dsnd@tok)) :named fresh_token_Prims.dsnd@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT Prims.dsnd@tok @x0) @x1) @x2) (Prims.dsnd @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT Prims.dsnd@tok @x0) @x1) @x2)))) :named token_correspondence_Prims.dsnd))
(assert (! (HasType Prims.dsnd@tok Tm_arrow_277) :named function_token_typing_Prims.dsnd))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 (Tm_arrow_239 @x0)) (HasType @x2 (Prims.dtuple2 @x0 @x1))) (HasType (Prims.dsnd @x0 @x1 @x2) (ApplyTT @x1 (Prims.Mkdtuple2._1 @x0 @x1 @x2)))) :pattern ((Prims.dsnd @x0 @x1 @x2)))) :named typing_Prims.dsnd))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (Prims.dsnd @x0 @x1 @x2) (Prims.Mkdtuple2._2 @x0 @x1 @x2)) :pattern ((Prims.dsnd @x0 @x1 @x2)))) :named equation_Prims.dsnd))
(declare-fun Prims._assume (Term Term) Term)
(declare-fun Non_total_Tm_arrow_1012 () Term)
(assert (! (HasType Non_total_Tm_arrow_1012 Tm_type) :named non_total_function_typing_Non_total_Tm_arrow_1012))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Non_total_Tm_arrow_1012) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Non_total_Tm_arrow_1012)))) :named pre_typing_Non_total_Tm_arrow_1012))
(declare-fun Prims._assume@tok () Term)
(assert (! (= 1014 (Term_constr_id Prims._assume@tok)) :named fresh_token_Prims._assume@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (ApplyTT (ApplyTT Prims._assume@tok @x0) @x1) (Prims._assume @x0 @x1)) :pattern ((ApplyTT (ApplyTT Prims._assume@tok @x0) @x1)))) :named token_correspondence_Prims._assume))
(assert (! (HasType Prims._assume@tok Non_total_Tm_arrow_1012) :named function_token_typing_Prims._assume))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Prims.unit)) (HasType (Prims._assume @x0 @x1) Prims.unit)) :pattern ((Prims._assume @x0 @x1)))) :named typing_Prims._assume))
(declare-fun Prims.admit (Term Term) Term)
(declare-fun Prims.admit@tok () Term)
(declare-fun Prims.magic (Term Term) Term)
(declare-fun Tm_arrow_1016 (Term) Term)
(assert (! (forall ((@x0 Term)) (! (HasType (Tm_arrow_1016 @x0) Tm_type) :pattern ((HasType (Tm_arrow_1016 @x0) Tm_type)))) :named kinding_Tm_arrow_1016))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_1016 @x2)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_1016 @x2))))) :named pre_typing_Tm_arrow_1016))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_1016 @x1)) (forall ((@x2 Term) (@x3 Term)) (! (implies (and (HasType @x2 Tm_type) (HasType @x3 @x1)) (HasType (ApplyTT (ApplyTT @x0 @x2) @x3) @x2)) :pattern ((ApplyTT (ApplyTT @x0 @x2) @x3))))) :pattern ((HasTypeZ @x0 (Tm_arrow_1016 @x1))))) :named interpretation_Tm_arrow_1016))
(declare-fun Prims.magic@tok () Term)
(assert (! (= 1018 (Term_constr_id Prims.magic@tok)) :named fresh_token_Prims.magic@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (ApplyTT (ApplyTT Prims.magic@tok @x0) @x1) (Prims.magic @x0 @x1)) :pattern ((ApplyTT (ApplyTT Prims.magic@tok @x0) @x1)))) :named token_correspondence_Prims.magic))
(assert (! (HasType Prims.magic@tok (Tm_arrow_1016 Prims.unit)) :named function_token_typing_Prims.magic))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Prims.unit)) (HasType (Prims.magic @x0 @x1) @x0)) :pattern ((Prims.magic @x0 @x1)))) :named typing_Prims.magic))
(declare-fun Prims.unsafe_coerce (Term Term Term) Term)
(declare-fun Tm_arrow_1020 () Term)
(assert (! (HasType Tm_arrow_1020 Tm_type) :named kinding_Tm_arrow_1020))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_1020) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_1020)))) :named pre_typing_Tm_arrow_1020))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_1020) (forall ((@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 @x1)) (HasType (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3))))) :pattern ((HasTypeZ @x0 Tm_arrow_1020)))) :named interpretation_Tm_arrow_1020))
(declare-fun Prims.unsafe_coerce@tok () Term)
(assert (! (= 1022 (Term_constr_id Prims.unsafe_coerce@tok)) :named fresh_token_Prims.unsafe_coerce@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT Prims.unsafe_coerce@tok @x0) @x1) @x2) (Prims.unsafe_coerce @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT Prims.unsafe_coerce@tok @x0) @x1) @x2)))) :named token_correspondence_Prims.unsafe_coerce))
(assert (! (HasType Prims.unsafe_coerce@tok Tm_arrow_1020) :named function_token_typing_Prims.unsafe_coerce))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 @x0)) (HasType (Prims.unsafe_coerce @x0 @x1 @x2) @x1)) :pattern ((Prims.unsafe_coerce @x0 @x1 @x2)))) :named typing_Prims.unsafe_coerce))
(declare-fun Prims.unsafe_coerce__1023 (Term Term Term) Term)
(declare-fun Prims.unsafe_coerce__1023@tok () Term)
(assert (! (= 1025 (Term_constr_id Prims.unsafe_coerce__1023@tok)) :named fresh_token_Prims.unsafe_coerce__1023@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT Prims.unsafe_coerce__1023@tok @x0) @x1) @x2) (Prims.unsafe_coerce__1023 @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT Prims.unsafe_coerce__1023@tok @x0) @x1) @x2)))) :named token_correspondence_Prims.unsafe_coerce__1023))
(assert (! (HasType Prims.unsafe_coerce__1023@tok Tm_arrow_1020) :named function_token_typing_Prims.unsafe_coerce__1023))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 @x0)) (HasType (Prims.unsafe_coerce__1023 @x0 @x1 @x2) @x1)) :pattern ((Prims.unsafe_coerce__1023 @x0 @x1 @x2)))) :named typing_Prims.unsafe_coerce__1023))
(declare-fun Prims.admitP (Term) Term)
(declare-fun Non_total_Tm_arrow_1026 () Term)
(assert (! (HasType Non_total_Tm_arrow_1026 Tm_type) :named non_total_function_typing_Non_total_Tm_arrow_1026))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Non_total_Tm_arrow_1026) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Non_total_Tm_arrow_1026)))) :named pre_typing_Non_total_Tm_arrow_1026))
(declare-fun Prims.admitP@tok () Term)
(assert (! (= 1028 (Term_constr_id Prims.admitP@tok)) :named fresh_token_Prims.admitP@tok))
(assert (! (forall ((@x0 Term)) (! (= (ApplyTT Prims.admitP@tok @x0) (Prims.admitP @x0)) :pattern ((ApplyTT Prims.admitP@tok @x0)))) :named token_correspondence_Prims.admitP))
(assert (! (HasType Prims.admitP@tok Non_total_Tm_arrow_1026) :named function_token_typing_Prims.admitP))
(assert (! (forall ((@x0 Term)) (! (implies (HasType @x0 Tm_type) (HasType (Prims.admitP @x0) Prims.unit)) :pattern ((Prims.admitP @x0)))) :named typing_Prims.admitP))
(declare-fun Prims._assert (Term Term) Term)
(declare-fun Non_total_Tm_arrow_1029 () Term)
(assert (! (HasType Non_total_Tm_arrow_1029 Tm_type) :named non_total_function_typing_Non_total_Tm_arrow_1029))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Non_total_Tm_arrow_1029) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Non_total_Tm_arrow_1029)))) :named pre_typing_Non_total_Tm_arrow_1029))
(declare-fun Prims._assert@tok () Term)
(assert (! (= 1031 (Term_constr_id Prims._assert@tok)) :named fresh_token_Prims._assert@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (ApplyTT (ApplyTT Prims._assert@tok @x0) @x1) (Prims._assert @x0 @x1)) :pattern ((ApplyTT (ApplyTT Prims._assert@tok @x0) @x1)))) :named token_correspondence_Prims._assert))
(assert (! (HasType Prims._assert@tok Non_total_Tm_arrow_1029) :named function_token_typing_Prims._assert))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Prims.unit)) (HasType (Prims._assert @x0 @x1) Prims.unit)) :pattern ((Prims._assert @x0 @x1)))) :named typing_Prims._assert))
(declare-fun Prims.cut (Term) Term)
(declare-fun Non_total_Tm_arrow_1032 () Term)
(assert (! (HasType Non_total_Tm_arrow_1032 Tm_type) :named non_total_function_typing_Non_total_Tm_arrow_1032))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Non_total_Tm_arrow_1032) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Non_total_Tm_arrow_1032)))) :named pre_typing_Non_total_Tm_arrow_1032))
(declare-fun Prims.cut@tok () Term)
(assert (! (= 1034 (Term_constr_id Prims.cut@tok)) :named fresh_token_Prims.cut@tok))
(assert (! (forall ((@x0 Term)) (! (= (ApplyTT Prims.cut@tok @x0) (Prims.cut @x0)) :pattern ((ApplyTT Prims.cut@tok @x0)))) :named token_correspondence_Prims.cut))
(assert (! (HasType Prims.cut@tok Non_total_Tm_arrow_1032) :named function_token_typing_Prims.cut))
(assert (! (forall ((@x0 Term)) (! (implies (HasType @x0 Tm_type) (HasType (Prims.cut @x0) Prims.unit)) :pattern ((Prims.cut @x0)))) :named typing_Prims.cut))
(declare-fun Prims.qintro (Term Term Term) Term)
(declare-fun Prims.qintro@tok () Term)
(declare-fun Prims.ghost_lemma (Term Term Term Term) Term)
(declare-fun Prims.ghost_lemma@tok () Term)
(declare-fun Prims.raise (Term Term) Term)
(declare-fun Prims.raise@tok () Term)
(declare-fun Prims.ignore (Term Term) Term)
(declare-fun Tm_arrow_1036 (Term) Term)
(assert (! (forall ((@x0 Term)) (! (HasType (Tm_arrow_1036 @x0) Tm_type) :pattern ((HasType (Tm_arrow_1036 @x0) Tm_type)))) :named kinding_Tm_arrow_1036))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_1036 @x2)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_1036 @x2))))) :named pre_typing_Tm_arrow_1036))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_1036 @x1)) (forall ((@x2 Term) (@x3 Term)) (! (implies (and (HasType @x2 Tm_type) (HasType @x3 @x2)) (HasType (ApplyTT (ApplyTT @x0 @x2) @x3) @x1)) :pattern ((ApplyTT (ApplyTT @x0 @x2) @x3))))) :pattern ((HasTypeZ @x0 (Tm_arrow_1036 @x1))))) :named interpretation_Tm_arrow_1036))
(declare-fun Prims.ignore@tok () Term)
(assert (! (= 1038 (Term_constr_id Prims.ignore@tok)) :named fresh_token_Prims.ignore@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (ApplyTT (ApplyTT Prims.ignore@tok @x0) @x1) (Prims.ignore @x0 @x1)) :pattern ((ApplyTT (ApplyTT Prims.ignore@tok @x0) @x1)))) :named token_correspondence_Prims.ignore))
(assert (! (HasType Prims.ignore@tok (Tm_arrow_1036 Prims.unit)) :named function_token_typing_Prims.ignore))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 @x0)) (HasType (Prims.ignore @x0 @x1) Prims.unit)) :pattern ((Prims.ignore @x0 @x1)))) :named typing_Prims.ignore))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (Prims.ignore @x0 @x1) Tm_unit) :pattern ((Prims.ignore @x0 @x1)))) :named equation_Prims.ignore))
(declare-fun Prims.nat () Term)
(assert (! (HasType Prims.nat Tm_type) :named function_token_typing_Prims.nat))
(assert (! (HasType Prims.nat Tm_type) :named typing_Prims.nat))
(declare-fun Tm_refine_1040 (Term) Term)
(assert (! (forall ((@x0 Term)) (! (HasType (Tm_refine_1040 @x0) Tm_type) :pattern ((HasType (Tm_refine_1040 @x0) Tm_type)))) :named refinement_kinding_Tm_refine_1040))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (iff (HasTypeFuel @u0 @x1 (Tm_refine_1040 @x2)) (and (HasTypeFuel @u0 @x1 @x2) (>= (BoxInt_proj_0 @x1) (BoxInt_proj_0 (BoxInt 0))))) :pattern ((HasTypeFuel @u0 @x1 (Tm_refine_1040 @x2))))) :named refinement_interpretation_Tm_refine_1040))
(assert (! (forall ((@x0 Term)) (! (iff (Valid (Prims.hasEq (Tm_refine_1040 @x0))) (Valid (Prims.hasEq @x0))) :pattern ((Valid (Prims.hasEq (Tm_refine_1040 @x0)))))) :named haseqTm_refine_1040))
(assert (! (= Prims.nat (Tm_refine_1040 Prims.int)) :named equation_Prims.nat))
(declare-fun Prims.pos () Term)
(assert (! (HasType Prims.pos Tm_type) :named function_token_typing_Prims.pos))
(assert (! (HasType Prims.pos Tm_type) :named typing_Prims.pos))
(declare-fun Tm_refine_1042 (Term) Term)
(assert (! (forall ((@x0 Term)) (! (HasType (Tm_refine_1042 @x0) Tm_type) :pattern ((HasType (Tm_refine_1042 @x0) Tm_type)))) :named refinement_kinding_Tm_refine_1042))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (iff (HasTypeFuel @u0 @x1 (Tm_refine_1042 @x2)) (and (HasTypeFuel @u0 @x1 @x2) (> (BoxInt_proj_0 @x1) (BoxInt_proj_0 (BoxInt 0))))) :pattern ((HasTypeFuel @u0 @x1 (Tm_refine_1042 @x2))))) :named refinement_interpretation_Tm_refine_1042))
(assert (! (forall ((@x0 Term)) (! (iff (Valid (Prims.hasEq (Tm_refine_1042 @x0))) (Valid (Prims.hasEq @x0))) :pattern ((Valid (Prims.hasEq (Tm_refine_1042 @x0)))))) :named haseqTm_refine_1042))
(assert (! (= Prims.pos (Tm_refine_1042 Prims.int)) :named equation_Prims.pos))
(declare-fun Prims.nonzero () Term)
(assert (! (HasType Prims.nonzero Tm_type) :named function_token_typing_Prims.nonzero))
(assert (! (HasType Prims.nonzero Tm_type) :named typing_Prims.nonzero))
(declare-fun Tm_refine_1044 (Term) Term)
(assert (! (forall ((@x0 Term)) (! (HasType (Tm_refine_1044 @x0) Tm_type) :pattern ((HasType (Tm_refine_1044 @x0) Tm_type)))) :named refinement_kinding_Tm_refine_1044))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (iff (HasTypeFuel @u0 @x1 (Tm_refine_1044 @x2)) (and (HasTypeFuel @u0 @x1 @x2) (not (= @x1 (BoxInt 0))))) :pattern ((HasTypeFuel @u0 @x1 (Tm_refine_1044 @x2))))) :named refinement_interpretation_Tm_refine_1044))
(assert (! (forall ((@x0 Term)) (! (iff (Valid (Prims.hasEq (Tm_refine_1044 @x0))) (Valid (Prims.hasEq @x0))) :pattern ((Valid (Prims.hasEq (Tm_refine_1044 @x0)))))) :named haseqTm_refine_1044))
(assert (! (= Prims.nonzero (Tm_refine_1044 Prims.int)) :named equation_Prims.nonzero))
(declare-fun Prims.allow_inversion (Term) Term)
(declare-fun Non_total_Tm_arrow_1045 () Term)
(assert (! (HasType Non_total_Tm_arrow_1045 Tm_type) :named non_total_function_typing_Non_total_Tm_arrow_1045))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Non_total_Tm_arrow_1045) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Non_total_Tm_arrow_1045)))) :named pre_typing_Non_total_Tm_arrow_1045))
(declare-fun Prims.allow_inversion@tok () Term)
(assert (! (= 1047 (Term_constr_id Prims.allow_inversion@tok)) :named fresh_token_Prims.allow_inversion@tok))
(assert (! (forall ((@x0 Term)) (! (= (ApplyTT Prims.allow_inversion@tok @x0) (Prims.allow_inversion @x0)) :pattern ((ApplyTT Prims.allow_inversion@tok @x0)))) :named token_correspondence_Prims.allow_inversion))
(assert (! (HasType Prims.allow_inversion@tok Non_total_Tm_arrow_1045) :named function_token_typing_Prims.allow_inversion))
(assert (! (forall ((@x0 Term)) (! (implies (HasType @x0 Tm_type) (HasType (Prims.allow_inversion @x0) Prims.unit)) :pattern ((Prims.allow_inversion @x0)))) :named typing_Prims.allow_inversion))
(assert (! (forall ((@x0 Term)) (! (= (Prims.allow_inversion @x0) Tm_unit) :pattern ((Prims.allow_inversion @x0)))) :named equation_Prims.allow_inversion))
(declare-fun Prims.invertOption (Term) Term)
(declare-fun Prims.invertOption@tok () Term)
(assert (! (forall ((@x0 Term)) (! (implies (HasType @x0 Tm_type) (forall ((@x1 Term)) (implies (HasType @x1 (Prims.option @x0)) (or (BoxBool_proj_0 (Prims.is_None @x0 @x1)) (BoxBool_proj_0 (Prims.is_Some @x0 @x1)))))) :pattern ((Prims.option @x0)))) :named lemma_Prims.invertOption))
(declare-fun Prims.op_Modulus (Term Term) Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (Prims.op_Modulus @x0 @x1) (BoxInt (mod (BoxInt_proj_0 @x0) (BoxInt_proj_0 @x1)))) :pattern ((Prims.op_Modulus @x0 @x1)))) :named primitive_Prims.op_Modulus))
(declare-fun Prims.op_Division (Term Term) Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (Prims.op_Division @x0 @x1) (BoxInt (div (BoxInt_proj_0 @x0) (BoxInt_proj_0 @x1)))) :pattern ((Prims.op_Division @x0 @x1)))) :named primitive_Prims.op_Division))
(declare-fun Prims.pow2__1051 (Fuel Term) Term)
(declare-fun Prims.pow2__1052 () Term)
(declare-fun Prims.pow2 (Term) Term)
(declare-fun Prims.pow2@tok () Term)
(assert (! (= 1049 (Term_constr_id Prims.pow2@tok)) :named fresh_token_Prims.pow2@tok))
(assert (! (forall ((@x0 Term)) (! (= (ApplyTT Prims.pow2@tok @x0) (Prims.pow2 @x0)) :pattern ((ApplyTT Prims.pow2@tok @x0)))) :named token_correspondence_Prims.pow2))
(assert (! (HasType Prims.pow2@tok (Tm_arrow_228 Prims.pos Prims.nat)) :named function_token_typing_Prims.pow2))
(assert (! (forall ((@x0 Term)) (! (implies (HasType @x0 Prims.nat) (HasType (Prims.pow2 @x0) Prims.pos)) :pattern ((Prims.pow2 @x0)))) :named typing_Prims.pow2))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (= (ApplyTT (ApplyTF Prims.pow2__1052 @u0) @x1) (Prims.pow2__1051 @u0 @x1)) :pattern ((ApplyTT (ApplyTF Prims.pow2__1052 @u0) @x1)))) :named fuel_tokem_correspondence_Prims.pow2__1052))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasType @x1 Prims.nat) (HasType (Prims.pow2__1051 @u0 @x1) Prims.pos)) :pattern ((Prims.pow2__1051 @u0 @x1)))) :named token_correspondence_Prims.pow2__1051))
(assert (! (forall ((@x0 Term)) (! (= (Prims.pow2 @x0) (Prims.pow2__1051 MaxFuel @x0)) :pattern ((Prims.pow2 @x0)))) :named fuel_correspondence_Prims.pow2__1051))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (= (Prims.pow2__1051 (SFuel @u0) @x1) (Prims.pow2__1051 ZFuel @x1)) :pattern ((Prims.pow2__1051 (SFuel @u0) @x1)))) :named fuel_irrelevance_Prims.pow2__1051))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (= (Prims.pow2__1051 (SFuel @u0) @x1) (ite (= (Prims.op_Equality Prims.int @x1 (BoxInt 0)) (BoxBool true)) (BoxInt 1) (ite true (Prims.op_Multiply (BoxInt 2) (Prims.pow2__1051 @u0 (Prims.op_Subtraction @x1 (BoxInt 1)))) Tm_unit))) :pattern ((Prims.pow2__1051 (SFuel @u0) @x1)))) :named equation_with_fuel_Prims.pow2__1051))
(declare-fun Prims.abs (Term) Term)
(declare-fun Tm_arrow_1054 (Term) Term)
(assert (! (forall ((@x0 Term)) (! (HasType (Tm_arrow_1054 @x0) Tm_type) :pattern ((HasType (Tm_arrow_1054 @x0) Tm_type)))) :named kinding_Tm_arrow_1054))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_1054 @x2)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_1054 @x2))))) :named pre_typing_Tm_arrow_1054))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_1054 @x1)) (forall ((@x2 Term)) (! (implies (HasType @x2 @x1) (HasType (ApplyTT @x0 @x2) @x1)) :pattern ((ApplyTT @x0 @x2))))) :pattern ((HasTypeZ @x0 (Tm_arrow_1054 @x1))))) :named interpretation_Tm_arrow_1054))
(declare-fun Prims.abs@tok () Term)
(assert (! (= 1056 (Term_constr_id Prims.abs@tok)) :named fresh_token_Prims.abs@tok))
(assert (! (forall ((@x0 Term)) (! (= (ApplyTT Prims.abs@tok @x0) (Prims.abs @x0)) :pattern ((ApplyTT Prims.abs@tok @x0)))) :named token_correspondence_Prims.abs))
(assert (! (HasType Prims.abs@tok (Tm_arrow_1054 Prims.int)) :named function_token_typing_Prims.abs))
(assert (! (forall ((@x0 Term)) (! (implies (HasType @x0 Prims.int) (HasType (Prims.abs @x0) Prims.int)) :pattern ((Prims.abs @x0)))) :named typing_Prims.abs))
(assert (! (forall ((@x0 Term)) (! (= (Prims.abs @x0) (ite (= (Prims.op_GreaterThanOrEqual @x0 (BoxInt 0)) (BoxBool true)) @x0 (ite true (Prims.op_Minus @x0) Tm_unit))) :pattern ((Prims.abs @x0)))) :named equation_Prims.abs))
(declare-fun Prims.string_of_bool (Term) Term)
(declare-fun Prims.string_of_bool@tok () Term)
(assert (! (= 1058 (Term_constr_id Prims.string_of_bool@tok)) :named fresh_token_Prims.string_of_bool@tok))
(assert (! (forall ((@x0 Term)) (! (= (ApplyTT Prims.string_of_bool@tok @x0) (Prims.string_of_bool @x0)) :pattern ((ApplyTT Prims.string_of_bool@tok @x0)))) :named token_correspondence_Prims.string_of_bool))
(assert (! (HasType Prims.string_of_bool@tok (Tm_arrow_228 Prims.string Prims.bool)) :named function_token_typing_Prims.string_of_bool))
(assert (! (forall ((@x0 Term)) (! (implies (HasType @x0 Prims.bool) (HasType (Prims.string_of_bool @x0) Prims.string)) :pattern ((Prims.string_of_bool @x0)))) :named typing_Prims.string_of_bool))
(declare-fun Prims.string_of_int (Term) Term)
(declare-fun Prims.string_of_int@tok () Term)
(assert (! (= 1060 (Term_constr_id Prims.string_of_int@tok)) :named fresh_token_Prims.string_of_int@tok))
(assert (! (forall ((@x0 Term)) (! (= (ApplyTT Prims.string_of_int@tok @x0) (Prims.string_of_int @x0)) :pattern ((ApplyTT Prims.string_of_int@tok @x0)))) :named token_correspondence_Prims.string_of_int))
(assert (! (HasType Prims.string_of_int@tok (Tm_arrow_228 Prims.string Prims.int)) :named function_token_typing_Prims.string_of_int))
(assert (! (forall ((@x0 Term)) (! (implies (HasType @x0 Prims.int) (HasType (Prims.string_of_int @x0) Prims.string)) :pattern ((Prims.string_of_int @x0)))) :named typing_Prims.string_of_int))
(declare-fun FStar.FunctionalExtensionality.efun (Term Term) Term)
(declare-fun FStar.FunctionalExtensionality.efun@tok () Term)
(assert (! (= 1070 (Term_constr_id FStar.FunctionalExtensionality.efun@tok)) :named fresh_token_FStar.FunctionalExtensionality.efun@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (ApplyTT (ApplyTT FStar.FunctionalExtensionality.efun@tok @x0) @x1) (FStar.FunctionalExtensionality.efun @x0 @x1)) :pattern ((ApplyTT (ApplyTT FStar.FunctionalExtensionality.efun@tok @x0) @x1)))) :named token_correspondence_FStar.FunctionalExtensionality.efun))
(assert (! (HasType FStar.FunctionalExtensionality.efun@tok Tm_arrow_179) :named function_token_typing_FStar.FunctionalExtensionality.efun))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type)) (HasType (FStar.FunctionalExtensionality.efun @x0 @x1) Tm_type)) :pattern ((FStar.FunctionalExtensionality.efun @x0 @x1)))) :named typing_FStar.FunctionalExtensionality.efun))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (FStar.FunctionalExtensionality.efun @x0 @x1) (Tm_arrow_228 @x1 @x0)) :pattern ((FStar.FunctionalExtensionality.efun @x0 @x1)))) :named equation_FStar.FunctionalExtensionality.efun))
(declare-fun FStar.FunctionalExtensionality.feq (Term Term Term Term) Term)
(declare-fun Tm_arrow_1073 () Term)
(assert (! (HasType Tm_arrow_1073 Tm_type) :named kinding_Tm_arrow_1073))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_1073) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_1073)))) :named pre_typing_Tm_arrow_1073))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_1073) (forall ((@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 (FStar.FunctionalExtensionality.efun @x1 @x2)) (HasType @x4 (FStar.FunctionalExtensionality.efun @x1 @x2))) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) Tm_type)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4))))) :pattern ((HasTypeZ @x0 Tm_arrow_1073)))) :named interpretation_Tm_arrow_1073))
(declare-fun FStar.FunctionalExtensionality.feq@tok () Term)
(assert (! (= 1075 (Term_constr_id FStar.FunctionalExtensionality.feq@tok)) :named fresh_token_FStar.FunctionalExtensionality.feq@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.FunctionalExtensionality.feq@tok @x0) @x1) @x2) @x3) (FStar.FunctionalExtensionality.feq @x0 @x1 @x2 @x3)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.FunctionalExtensionality.feq@tok @x0) @x1) @x2) @x3)))) :named token_correspondence_FStar.FunctionalExtensionality.feq))
(assert (! (HasType FStar.FunctionalExtensionality.feq@tok Tm_arrow_1073) :named function_token_typing_FStar.FunctionalExtensionality.feq))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 (FStar.FunctionalExtensionality.efun @x0 @x1)) (HasType @x3 (FStar.FunctionalExtensionality.efun @x0 @x1))) (HasType (FStar.FunctionalExtensionality.feq @x0 @x1 @x2 @x3) Tm_type)) :pattern ((FStar.FunctionalExtensionality.feq @x0 @x1 @x2 @x3)))) :named typing_FStar.FunctionalExtensionality.feq))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (Valid (FStar.FunctionalExtensionality.feq @x0 @x1 @x2 @x3)) (forall ((@x4 Term)) (! (implies (HasType @x4 @x0) (= (ApplyTT @x2 @x4) (ApplyTT @x3 @x4))) :pattern ((ApplyTT @x2 @x4)) :pattern ((ApplyTT @x3 @x4))))) :pattern ((Valid (FStar.FunctionalExtensionality.feq @x0 @x1 @x2 @x3))))) :named equation_FStar.FunctionalExtensionality.feq))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 (FStar.FunctionalExtensionality.efun @x0 @x1)) (HasType @x3 (FStar.FunctionalExtensionality.efun @x0 @x1))) (iff (Valid (FStar.FunctionalExtensionality.feq @x0 @x1 @x2 @x3)) (= @x2 @x3))) :pattern ((FStar.FunctionalExtensionality.feq @x0 @x1 @x2 @x3)))) :named assumption_FStar.FunctionalExtensionality.Extensionality_1076))
(declare-fun FStar.PredicateExtensionality.predicate (Term) Term)
(declare-fun FStar.PredicateExtensionality.predicate@tok () Term)
(assert (! (= 1085 (Term_constr_id FStar.PredicateExtensionality.predicate@tok)) :named fresh_token_FStar.PredicateExtensionality.predicate@tok))
(assert (! (forall ((@x0 Term)) (! (= (ApplyTT FStar.PredicateExtensionality.predicate@tok @x0) (FStar.PredicateExtensionality.predicate @x0)) :pattern ((ApplyTT FStar.PredicateExtensionality.predicate@tok @x0)))) :named token_correspondence_FStar.PredicateExtensionality.predicate))
(assert (! (HasType FStar.PredicateExtensionality.predicate@tok Tm_arrow_105) :named function_token_typing_FStar.PredicateExtensionality.predicate))
(assert (! (forall ((@x0 Term)) (! (implies (HasType @x0 Tm_type) (HasType (FStar.PredicateExtensionality.predicate @x0) Tm_type)) :pattern ((FStar.PredicateExtensionality.predicate @x0)))) :named typing_FStar.PredicateExtensionality.predicate))
(assert (! (forall ((@x0 Term)) (! (= (FStar.PredicateExtensionality.predicate @x0) (Tm_arrow_239 @x0)) :pattern ((FStar.PredicateExtensionality.predicate @x0)))) :named equation_FStar.PredicateExtensionality.predicate))
(declare-fun FStar.PredicateExtensionality.peq (Term Term Term) Term)
(declare-fun Tm_arrow_1088 () Term)
(assert (! (HasType Tm_arrow_1088 Tm_type) :named kinding_Tm_arrow_1088))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_1088) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_1088)))) :named pre_typing_Tm_arrow_1088))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_1088) (forall ((@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 (FStar.PredicateExtensionality.predicate @x1)) (HasType @x3 (FStar.PredicateExtensionality.predicate @x1))) (HasType (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) Tm_type)) :pattern ((ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3))))) :pattern ((HasTypeZ @x0 Tm_arrow_1088)))) :named interpretation_Tm_arrow_1088))
(declare-fun FStar.PredicateExtensionality.peq@tok () Term)
(assert (! (= 1090 (Term_constr_id FStar.PredicateExtensionality.peq@tok)) :named fresh_token_FStar.PredicateExtensionality.peq@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT FStar.PredicateExtensionality.peq@tok @x0) @x1) @x2) (FStar.PredicateExtensionality.peq @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT FStar.PredicateExtensionality.peq@tok @x0) @x1) @x2)))) :named token_correspondence_FStar.PredicateExtensionality.peq))
(assert (! (HasType FStar.PredicateExtensionality.peq@tok Tm_arrow_1088) :named function_token_typing_FStar.PredicateExtensionality.peq))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 (FStar.PredicateExtensionality.predicate @x0)) (HasType @x2 (FStar.PredicateExtensionality.predicate @x0))) (HasType (FStar.PredicateExtensionality.peq @x0 @x1 @x2) Tm_type)) :pattern ((FStar.PredicateExtensionality.peq @x0 @x1 @x2)))) :named typing_FStar.PredicateExtensionality.peq))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (Valid (FStar.PredicateExtensionality.peq @x0 @x1 @x2)) (forall ((@x3 Term)) (implies (HasType @x3 @x0) (iff (Valid (ApplyTT @x1 @x3)) (Valid (ApplyTT @x2 @x3)))))) :pattern ((Valid (FStar.PredicateExtensionality.peq @x0 @x1 @x2))))) :named equation_FStar.PredicateExtensionality.peq))
(declare-fun FStar.PredicateExtensionality.predicateExtensionality (Term Term Term) Term)
(declare-fun FStar.PredicateExtensionality.predicateExtensionality@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 (FStar.PredicateExtensionality.predicate @x0)) (HasType @x2 (FStar.PredicateExtensionality.predicate @x0))) (iff (Valid (FStar.PredicateExtensionality.peq @x0 @x1 @x2)) (= @x1 @x2))) :pattern ((FStar.PredicateExtensionality.peq @x0 @x1 @x2)))) :named lemma_FStar.PredicateExtensionality.predicateExtensionality))
(declare-fun FStar.TSet.set (Term) Term)
(declare-fun FStar.TSet.set@tok () Term)
(assert (! (= 1131 (Term_constr_id FStar.TSet.set@tok)) :named fresh_token_FStar.TSet.set@tok))
(assert (! (forall ((@x0 Term)) (! (= (ApplyTT FStar.TSet.set@tok @x0) (FStar.TSet.set @x0)) :pattern ((ApplyTT FStar.TSet.set@tok @x0)))) :named token_correspondence_FStar.TSet.set))
(assert (! (HasType FStar.TSet.set@tok Tm_arrow_105) :named function_token_typing_FStar.TSet.set))
(assert (! (forall ((@x0 Term)) (! (implies (HasType @x0 Tm_type) (HasType (FStar.TSet.set @x0) Tm_type)) :pattern ((FStar.TSet.set @x0)))) :named typing_FStar.TSet.set))
(declare-fun FStar.TSet.equal (Term Term Term) Term)
(declare-fun Tm_arrow_1133 () Term)
(assert (! (HasType Tm_arrow_1133 Tm_type) :named kinding_Tm_arrow_1133))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_1133) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_1133)))) :named pre_typing_Tm_arrow_1133))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_1133) (forall ((@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 (FStar.TSet.set @x1)) (HasType @x3 (FStar.TSet.set @x1))) (HasType (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) Tm_type)) :pattern ((ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3))))) :pattern ((HasTypeZ @x0 Tm_arrow_1133)))) :named interpretation_Tm_arrow_1133))
(declare-fun FStar.TSet.equal@tok () Term)
(assert (! (= 1135 (Term_constr_id FStar.TSet.equal@tok)) :named fresh_token_FStar.TSet.equal@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT FStar.TSet.equal@tok @x0) @x1) @x2) (FStar.TSet.equal @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT FStar.TSet.equal@tok @x0) @x1) @x2)))) :named token_correspondence_FStar.TSet.equal))
(assert (! (HasType FStar.TSet.equal@tok Tm_arrow_1133) :named function_token_typing_FStar.TSet.equal))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 (FStar.TSet.set @x0)) (HasType @x2 (FStar.TSet.set @x0))) (HasType (FStar.TSet.equal @x0 @x1 @x2) Tm_type)) :pattern ((FStar.TSet.equal @x0 @x1 @x2)))) :named typing_FStar.TSet.equal))
(declare-fun FStar.TSet.mem (Term Term Term) Term)
(declare-fun Tm_arrow_1137 () Term)
(assert (! (HasType Tm_arrow_1137 Tm_type) :named kinding_Tm_arrow_1137))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_1137) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_1137)))) :named pre_typing_Tm_arrow_1137))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_1137) (forall ((@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 @x1) (HasType @x3 (FStar.TSet.set @x1))) (HasType (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) Tm_type)) :pattern ((ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3))))) :pattern ((HasTypeZ @x0 Tm_arrow_1137)))) :named interpretation_Tm_arrow_1137))
(declare-fun FStar.TSet.mem@tok () Term)
(assert (! (= 1139 (Term_constr_id FStar.TSet.mem@tok)) :named fresh_token_FStar.TSet.mem@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT FStar.TSet.mem@tok @x0) @x1) @x2) (FStar.TSet.mem @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT FStar.TSet.mem@tok @x0) @x1) @x2)))) :named token_correspondence_FStar.TSet.mem))
(assert (! (HasType FStar.TSet.mem@tok Tm_arrow_1137) :named function_token_typing_FStar.TSet.mem))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 @x0) (HasType @x2 (FStar.TSet.set @x0))) (HasType (FStar.TSet.mem @x0 @x1 @x2) Tm_type)) :pattern ((FStar.TSet.mem @x0 @x1 @x2)))) :named typing_FStar.TSet.mem))
(declare-fun FStar.TSet.empty (Term) Term)
(declare-fun Tm_arrow_1141 () Term)
(assert (! (HasType Tm_arrow_1141 Tm_type) :named kinding_Tm_arrow_1141))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_1141) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_1141)))) :named pre_typing_Tm_arrow_1141))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_1141) (forall ((@x1 Term)) (! (implies (HasType @x1 Tm_type) (HasType (ApplyTT @x0 @x1) (FStar.TSet.set @x1))) :pattern ((ApplyTT @x0 @x1))))) :pattern ((HasTypeZ @x0 Tm_arrow_1141)))) :named interpretation_Tm_arrow_1141))
(declare-fun FStar.TSet.empty@tok () Term)
(assert (! (= 1143 (Term_constr_id FStar.TSet.empty@tok)) :named fresh_token_FStar.TSet.empty@tok))
(assert (! (forall ((@x0 Term)) (! (= (ApplyTT FStar.TSet.empty@tok @x0) (FStar.TSet.empty @x0)) :pattern ((ApplyTT FStar.TSet.empty@tok @x0)))) :named token_correspondence_FStar.TSet.empty))
(assert (! (HasType FStar.TSet.empty@tok Tm_arrow_1141) :named function_token_typing_FStar.TSet.empty))
(assert (! (forall ((@x0 Term)) (! (implies (HasType @x0 Tm_type) (HasType (FStar.TSet.empty @x0) (FStar.TSet.set @x0))) :pattern ((FStar.TSet.empty @x0)))) :named typing_FStar.TSet.empty))
(declare-fun FStar.TSet.singleton (Term Term) Term)
(declare-fun Tm_arrow_1145 () Term)
(assert (! (HasType Tm_arrow_1145 Tm_type) :named kinding_Tm_arrow_1145))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_1145) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_1145)))) :named pre_typing_Tm_arrow_1145))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_1145) (forall ((@x1 Term) (@x2 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 @x1)) (HasType (ApplyTT (ApplyTT @x0 @x1) @x2) (FStar.TSet.set @x1))) :pattern ((ApplyTT (ApplyTT @x0 @x1) @x2))))) :pattern ((HasTypeZ @x0 Tm_arrow_1145)))) :named interpretation_Tm_arrow_1145))
(declare-fun FStar.TSet.singleton@tok () Term)
(assert (! (= 1147 (Term_constr_id FStar.TSet.singleton@tok)) :named fresh_token_FStar.TSet.singleton@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (ApplyTT (ApplyTT FStar.TSet.singleton@tok @x0) @x1) (FStar.TSet.singleton @x0 @x1)) :pattern ((ApplyTT (ApplyTT FStar.TSet.singleton@tok @x0) @x1)))) :named token_correspondence_FStar.TSet.singleton))
(assert (! (HasType FStar.TSet.singleton@tok Tm_arrow_1145) :named function_token_typing_FStar.TSet.singleton))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 @x0)) (HasType (FStar.TSet.singleton @x0 @x1) (FStar.TSet.set @x0))) :pattern ((FStar.TSet.singleton @x0 @x1)))) :named typing_FStar.TSet.singleton))
(declare-fun FStar.TSet.union (Term Term Term) Term)
(declare-fun Tm_arrow_1149 () Term)
(assert (! (HasType Tm_arrow_1149 Tm_type) :named kinding_Tm_arrow_1149))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_1149) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_1149)))) :named pre_typing_Tm_arrow_1149))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_1149) (forall ((@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 (FStar.TSet.set @x1)) (HasType @x3 (FStar.TSet.set @x1))) (HasType (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) (FStar.TSet.set @x1))) :pattern ((ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3))))) :pattern ((HasTypeZ @x0 Tm_arrow_1149)))) :named interpretation_Tm_arrow_1149))
(declare-fun FStar.TSet.union@tok () Term)
(assert (! (= 1151 (Term_constr_id FStar.TSet.union@tok)) :named fresh_token_FStar.TSet.union@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT FStar.TSet.union@tok @x0) @x1) @x2) (FStar.TSet.union @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT FStar.TSet.union@tok @x0) @x1) @x2)))) :named token_correspondence_FStar.TSet.union))
(assert (! (HasType FStar.TSet.union@tok Tm_arrow_1149) :named function_token_typing_FStar.TSet.union))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 (FStar.TSet.set @x0)) (HasType @x2 (FStar.TSet.set @x0))) (HasType (FStar.TSet.union @x0 @x1 @x2) (FStar.TSet.set @x0))) :pattern ((FStar.TSet.union @x0 @x1 @x2)))) :named typing_FStar.TSet.union))
(declare-fun FStar.TSet.intersect (Term Term Term) Term)
(declare-fun FStar.TSet.intersect@tok () Term)
(assert (! (= 1153 (Term_constr_id FStar.TSet.intersect@tok)) :named fresh_token_FStar.TSet.intersect@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT FStar.TSet.intersect@tok @x0) @x1) @x2) (FStar.TSet.intersect @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT FStar.TSet.intersect@tok @x0) @x1) @x2)))) :named token_correspondence_FStar.TSet.intersect))
(assert (! (HasType FStar.TSet.intersect@tok Tm_arrow_1149) :named function_token_typing_FStar.TSet.intersect))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 (FStar.TSet.set @x0)) (HasType @x2 (FStar.TSet.set @x0))) (HasType (FStar.TSet.intersect @x0 @x1 @x2) (FStar.TSet.set @x0))) :pattern ((FStar.TSet.intersect @x0 @x1 @x2)))) :named typing_FStar.TSet.intersect))
(declare-fun FStar.TSet.complement (Term Term) Term)
(declare-fun Tm_arrow_1155 () Term)
(assert (! (HasType Tm_arrow_1155 Tm_type) :named kinding_Tm_arrow_1155))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_1155) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_1155)))) :named pre_typing_Tm_arrow_1155))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_1155) (forall ((@x1 Term) (@x2 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 (FStar.TSet.set @x1))) (HasType (ApplyTT (ApplyTT @x0 @x1) @x2) (FStar.TSet.set @x1))) :pattern ((ApplyTT (ApplyTT @x0 @x1) @x2))))) :pattern ((HasTypeZ @x0 Tm_arrow_1155)))) :named interpretation_Tm_arrow_1155))
(declare-fun FStar.TSet.complement@tok () Term)
(assert (! (= 1157 (Term_constr_id FStar.TSet.complement@tok)) :named fresh_token_FStar.TSet.complement@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (ApplyTT (ApplyTT FStar.TSet.complement@tok @x0) @x1) (FStar.TSet.complement @x0 @x1)) :pattern ((ApplyTT (ApplyTT FStar.TSet.complement@tok @x0) @x1)))) :named token_correspondence_FStar.TSet.complement))
(assert (! (HasType FStar.TSet.complement@tok Tm_arrow_1155) :named function_token_typing_FStar.TSet.complement))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 (FStar.TSet.set @x0))) (HasType (FStar.TSet.complement @x0 @x1) (FStar.TSet.set @x0))) :pattern ((FStar.TSet.complement @x0 @x1)))) :named typing_FStar.TSet.complement))
(declare-fun FStar.TSet.subset (Term Term Term) Term)
(declare-fun FStar.TSet.subset@tok () Term)
(assert (! (= 1159 (Term_constr_id FStar.TSet.subset@tok)) :named fresh_token_FStar.TSet.subset@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT FStar.TSet.subset@tok @x0) @x1) @x2) (FStar.TSet.subset @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT FStar.TSet.subset@tok @x0) @x1) @x2)))) :named token_correspondence_FStar.TSet.subset))
(assert (! (HasType FStar.TSet.subset@tok Tm_arrow_1133) :named function_token_typing_FStar.TSet.subset))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 (FStar.TSet.set @x0)) (HasType @x2 (FStar.TSet.set @x0))) (HasType (FStar.TSet.subset @x0 @x1 @x2) Tm_type)) :pattern ((FStar.TSet.subset @x0 @x1 @x2)))) :named typing_FStar.TSet.subset))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (Valid (FStar.TSet.subset @x0 @x1 @x2)) (forall ((@x3 Term)) (implies (and (HasType @x3 @x0) (Valid (FStar.TSet.mem @x0 @x3 @x1))) (Valid (FStar.TSet.mem @x0 @x3 @x2))))) :pattern ((Valid (FStar.TSet.subset @x0 @x1 @x2))))) :named equation_FStar.TSet.subset))
(declare-fun FStar.TSet.mem_empty (Term Term) Term)
(declare-fun FStar.TSet.mem_empty@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 @x0)) (not (Valid (FStar.TSet.mem @x0 @x1 (FStar.TSet.empty @x0))))) :pattern ((FStar.TSet.mem @x0 @x1 (FStar.TSet.empty @x0))))) :named lemma_FStar.TSet.mem_empty))
(declare-fun FStar.TSet.mem_singleton (Term Term Term) Term)
(declare-fun FStar.TSet.mem_singleton@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 @x0) (HasType @x2 @x0)) (iff (Valid (FStar.TSet.mem @x0 @x2 (FStar.TSet.singleton @x0 @x1))) (= @x1 @x2))) :pattern ((FStar.TSet.mem @x0 @x2 (FStar.TSet.singleton @x0 @x1))))) :named lemma_FStar.TSet.mem_singleton))
(declare-fun FStar.TSet.mem_union (Term Term Term Term) Term)
(declare-fun FStar.TSet.mem_union@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 @x0) (HasType @x2 (FStar.TSet.set @x0)) (HasType @x3 (FStar.TSet.set @x0))) (= (FStar.TSet.mem @x0 @x1 (FStar.TSet.union @x0 @x2 @x3)) (Prims.l_or (FStar.TSet.mem @x0 @x1 @x2) (FStar.TSet.mem @x0 @x1 @x3)))) :pattern ((FStar.TSet.mem @x0 @x1 (FStar.TSet.union @x0 @x2 @x3))))) :named lemma_FStar.TSet.mem_union))
(declare-fun FStar.TSet.mem_intersect (Term Term Term Term) Term)
(declare-fun FStar.TSet.mem_intersect@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 @x0) (HasType @x2 (FStar.TSet.set @x0)) (HasType @x3 (FStar.TSet.set @x0))) (= (FStar.TSet.mem @x0 @x1 (FStar.TSet.intersect @x0 @x2 @x3)) (Prims.l_and (FStar.TSet.mem @x0 @x1 @x2) (FStar.TSet.mem @x0 @x1 @x3)))) :pattern ((FStar.TSet.mem @x0 @x1 (FStar.TSet.intersect @x0 @x2 @x3))))) :named lemma_FStar.TSet.mem_intersect))
(declare-fun FStar.TSet.mem_complement (Term Term Term) Term)
(declare-fun FStar.TSet.mem_complement@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 @x0) (HasType @x2 (FStar.TSet.set @x0))) (= (FStar.TSet.mem @x0 @x1 (FStar.TSet.complement @x0 @x2)) (Prims.l_not (FStar.TSet.mem @x0 @x1 @x2)))) :pattern ((FStar.TSet.mem @x0 @x1 (FStar.TSet.complement @x0 @x2))))) :named lemma_FStar.TSet.mem_complement))
(declare-fun FStar.TSet.subset_mem (Term Term Term) Term)
(declare-fun FStar.TSet.subset_mem@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (Valid (FStar.TSet.subset @x0 @x1 @x2)) (HasType @x0 Tm_type) (HasType @x1 (FStar.TSet.set @x0)) (HasType @x2 (FStar.TSet.set @x0))) (forall ((@x3 Term)) (implies (and (HasType @x3 @x0) (Valid (FStar.TSet.mem @x0 @x3 @x1))) (Valid (FStar.TSet.mem @x0 @x3 @x2))))) :pattern ((FStar.TSet.subset @x0 @x1 @x2)))) :named lemma_FStar.TSet.subset_mem))
(declare-fun FStar.TSet.mem_subset (Term Term Term) Term)
(declare-fun FStar.TSet.mem_subset@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (forall ((@x3 Term)) (implies (and (HasType @x3 @x0) (Valid (FStar.TSet.mem @x0 @x3 @x1))) (Valid (FStar.TSet.mem @x0 @x3 @x2)))) (HasType @x0 Tm_type) (HasType @x1 (FStar.TSet.set @x0)) (HasType @x2 (FStar.TSet.set @x0))) (Valid (FStar.TSet.subset @x0 @x1 @x2))) :pattern ((FStar.TSet.subset @x0 @x1 @x2)))) :named lemma_FStar.TSet.mem_subset))
(declare-fun FStar.TSet.lemma_equal_intro (Term Term Term) Term)
(declare-fun FStar.TSet.lemma_equal_intro@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (forall ((@x3 Term)) (implies (HasType @x3 @x0) (iff (Valid (FStar.TSet.mem @x0 @x3 @x1)) (Valid (FStar.TSet.mem @x0 @x3 @x2))))) (HasType @x0 Tm_type) (HasType @x1 (FStar.TSet.set @x0)) (HasType @x2 (FStar.TSet.set @x0))) (Valid (FStar.TSet.equal @x0 @x1 @x2))) :pattern ((FStar.TSet.equal @x0 @x1 @x2)))) :named lemma_FStar.TSet.lemma_equal_intro))
(declare-fun FStar.TSet.lemma_equal_elim (Term Term Term) Term)
(declare-fun FStar.TSet.lemma_equal_elim@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (Valid (FStar.TSet.equal @x0 @x1 @x2)) (HasType @x0 Tm_type) (HasType @x1 (FStar.TSet.set @x0)) (HasType @x2 (FStar.TSet.set @x0))) (= @x1 @x2)) :pattern ((FStar.TSet.equal @x0 @x1 @x2)))) :named lemma_FStar.TSet.lemma_equal_elim))
(declare-fun FStar.TSet.lemma_equal_refl (Term Term Term) Term)
(declare-fun FStar.TSet.lemma_equal_refl@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (= @x1 @x2) (HasType @x0 Tm_type) (HasType @x1 (FStar.TSet.set @x0)) (HasType @x2 (FStar.TSet.set @x0))) (Valid (FStar.TSet.equal @x0 @x1 @x2))) :pattern ((FStar.TSet.equal @x0 @x1 @x2)))) :named lemma_FStar.TSet.lemma_equal_refl))
(declare-fun FStar.Set.set (Term) Term)
(declare-fun FStar.Set.set@tok () Term)
(assert (! (= 1206 (Term_constr_id FStar.Set.set@tok)) :named fresh_token_FStar.Set.set@tok))
(assert (! (forall ((@x0 Term)) (! (= (ApplyTT FStar.Set.set@tok @x0) (FStar.Set.set @x0)) :pattern ((ApplyTT FStar.Set.set@tok @x0)))) :named token_correspondence_FStar.Set.set))
(assert (! (HasType FStar.Set.set@tok (Tm_arrow_239 Prims.eqtype)) :named function_token_typing_FStar.Set.set))
(assert (! (forall ((@x0 Term)) (! (implies (HasType @x0 Prims.eqtype) (HasType (FStar.Set.set @x0) Tm_type)) :pattern ((FStar.Set.set @x0)))) :named typing_FStar.Set.set))
(declare-fun FStar.Set.equal (Term Term Term) Term)
(declare-fun Tm_arrow_1208 (Term) Term)
(assert (! (forall ((@x0 Term)) (! (HasType (Tm_arrow_1208 @x0) Tm_type) :pattern ((HasType (Tm_arrow_1208 @x0) Tm_type)))) :named kinding_Tm_arrow_1208))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_1208 @x2)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_1208 @x2))))) :named pre_typing_Tm_arrow_1208))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_1208 @x1)) (forall ((@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x2 @x1) (HasType @x3 (FStar.Set.set @x2)) (HasType @x4 (FStar.Set.set @x2))) (HasType (ApplyTT (ApplyTT (ApplyTT @x0 @x2) @x3) @x4) Tm_type)) :pattern ((ApplyTT (ApplyTT (ApplyTT @x0 @x2) @x3) @x4))))) :pattern ((HasTypeZ @x0 (Tm_arrow_1208 @x1))))) :named interpretation_Tm_arrow_1208))
(declare-fun FStar.Set.equal@tok () Term)
(assert (! (= 1210 (Term_constr_id FStar.Set.equal@tok)) :named fresh_token_FStar.Set.equal@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT FStar.Set.equal@tok @x0) @x1) @x2) (FStar.Set.equal @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT FStar.Set.equal@tok @x0) @x1) @x2)))) :named token_correspondence_FStar.Set.equal))
(assert (! (HasType FStar.Set.equal@tok (Tm_arrow_1208 Prims.eqtype)) :named function_token_typing_FStar.Set.equal))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Prims.eqtype) (HasType @x1 (FStar.Set.set @x0)) (HasType @x2 (FStar.Set.set @x0))) (HasType (FStar.Set.equal @x0 @x1 @x2) Tm_type)) :pattern ((FStar.Set.equal @x0 @x1 @x2)))) :named typing_FStar.Set.equal))
(declare-fun FStar.Set.mem (Term Term Term) Term)
(declare-fun Tm_arrow_1212 (Term Term) Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (HasType (Tm_arrow_1212 @x0 @x1) Tm_type) :pattern ((HasType (Tm_arrow_1212 @x0 @x1) Tm_type)))) :named kinding_Tm_arrow_1212))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_1212 @x2 @x3)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_1212 @x2 @x3))))) :named pre_typing_Tm_arrow_1212))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_1212 @x1 @x2)) (forall ((@x3 Term) (@x4 Term) (@x5 Term)) (! (implies (and (HasType @x3 @x2) (HasType @x4 @x3) (HasType @x5 (FStar.Set.set @x3))) (HasType (ApplyTT (ApplyTT (ApplyTT @x0 @x3) @x4) @x5) @x1)) :pattern ((ApplyTT (ApplyTT (ApplyTT @x0 @x3) @x4) @x5))))) :pattern ((HasTypeZ @x0 (Tm_arrow_1212 @x1 @x2))))) :named interpretation_Tm_arrow_1212))
(declare-fun FStar.Set.mem@tok () Term)
(assert (! (= 1214 (Term_constr_id FStar.Set.mem@tok)) :named fresh_token_FStar.Set.mem@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT FStar.Set.mem@tok @x0) @x1) @x2) (FStar.Set.mem @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT FStar.Set.mem@tok @x0) @x1) @x2)))) :named token_correspondence_FStar.Set.mem))
(assert (! (HasType FStar.Set.mem@tok (Tm_arrow_1212 Prims.bool Prims.eqtype)) :named function_token_typing_FStar.Set.mem))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Prims.eqtype) (HasType @x1 @x0) (HasType @x2 (FStar.Set.set @x0))) (HasType (FStar.Set.mem @x0 @x1 @x2) Prims.bool)) :pattern ((FStar.Set.mem @x0 @x1 @x2)))) :named typing_FStar.Set.mem))
(declare-fun FStar.Set.empty (Term) Term)
(declare-fun Tm_arrow_1216 (Term) Term)
(assert (! (forall ((@x0 Term)) (! (HasType (Tm_arrow_1216 @x0) Tm_type) :pattern ((HasType (Tm_arrow_1216 @x0) Tm_type)))) :named kinding_Tm_arrow_1216))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_1216 @x2)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_1216 @x2))))) :named pre_typing_Tm_arrow_1216))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_1216 @x1)) (forall ((@x2 Term)) (! (implies (HasType @x2 @x1) (HasType (ApplyTT @x0 @x2) (FStar.Set.set @x2))) :pattern ((ApplyTT @x0 @x2))))) :pattern ((HasTypeZ @x0 (Tm_arrow_1216 @x1))))) :named interpretation_Tm_arrow_1216))
(declare-fun FStar.Set.empty@tok () Term)
(assert (! (= 1218 (Term_constr_id FStar.Set.empty@tok)) :named fresh_token_FStar.Set.empty@tok))
(assert (! (forall ((@x0 Term)) (! (= (ApplyTT FStar.Set.empty@tok @x0) (FStar.Set.empty @x0)) :pattern ((ApplyTT FStar.Set.empty@tok @x0)))) :named token_correspondence_FStar.Set.empty))
(assert (! (HasType FStar.Set.empty@tok (Tm_arrow_1216 Prims.eqtype)) :named function_token_typing_FStar.Set.empty))
(assert (! (forall ((@x0 Term)) (! (implies (HasType @x0 Prims.eqtype) (HasType (FStar.Set.empty @x0) (FStar.Set.set @x0))) :pattern ((FStar.Set.empty @x0)))) :named typing_FStar.Set.empty))
(declare-fun FStar.Set.singleton (Term Term) Term)
(declare-fun Tm_arrow_1220 (Term) Term)
(assert (! (forall ((@x0 Term)) (! (HasType (Tm_arrow_1220 @x0) Tm_type) :pattern ((HasType (Tm_arrow_1220 @x0) Tm_type)))) :named kinding_Tm_arrow_1220))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_1220 @x2)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_1220 @x2))))) :named pre_typing_Tm_arrow_1220))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_1220 @x1)) (forall ((@x2 Term) (@x3 Term)) (! (implies (and (HasType @x2 @x1) (HasType @x3 @x2)) (HasType (ApplyTT (ApplyTT @x0 @x2) @x3) (FStar.Set.set @x2))) :pattern ((ApplyTT (ApplyTT @x0 @x2) @x3))))) :pattern ((HasTypeZ @x0 (Tm_arrow_1220 @x1))))) :named interpretation_Tm_arrow_1220))
(declare-fun FStar.Set.singleton@tok () Term)
(assert (! (= 1222 (Term_constr_id FStar.Set.singleton@tok)) :named fresh_token_FStar.Set.singleton@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (ApplyTT (ApplyTT FStar.Set.singleton@tok @x0) @x1) (FStar.Set.singleton @x0 @x1)) :pattern ((ApplyTT (ApplyTT FStar.Set.singleton@tok @x0) @x1)))) :named token_correspondence_FStar.Set.singleton))
(assert (! (HasType FStar.Set.singleton@tok (Tm_arrow_1220 Prims.eqtype)) :named function_token_typing_FStar.Set.singleton))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 Prims.eqtype) (HasType @x1 @x0)) (HasType (FStar.Set.singleton @x0 @x1) (FStar.Set.set @x0))) :pattern ((FStar.Set.singleton @x0 @x1)))) :named typing_FStar.Set.singleton))
(declare-fun FStar.Set.union (Term Term Term) Term)
(declare-fun Tm_arrow_1224 (Term) Term)
(assert (! (forall ((@x0 Term)) (! (HasType (Tm_arrow_1224 @x0) Tm_type) :pattern ((HasType (Tm_arrow_1224 @x0) Tm_type)))) :named kinding_Tm_arrow_1224))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_1224 @x2)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_1224 @x2))))) :named pre_typing_Tm_arrow_1224))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_1224 @x1)) (forall ((@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x2 @x1) (HasType @x3 (FStar.Set.set @x2)) (HasType @x4 (FStar.Set.set @x2))) (HasType (ApplyTT (ApplyTT (ApplyTT @x0 @x2) @x3) @x4) (FStar.Set.set @x2))) :pattern ((ApplyTT (ApplyTT (ApplyTT @x0 @x2) @x3) @x4))))) :pattern ((HasTypeZ @x0 (Tm_arrow_1224 @x1))))) :named interpretation_Tm_arrow_1224))
(declare-fun FStar.Set.union@tok () Term)
(assert (! (= 1226 (Term_constr_id FStar.Set.union@tok)) :named fresh_token_FStar.Set.union@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT FStar.Set.union@tok @x0) @x1) @x2) (FStar.Set.union @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT FStar.Set.union@tok @x0) @x1) @x2)))) :named token_correspondence_FStar.Set.union))
(assert (! (HasType FStar.Set.union@tok (Tm_arrow_1224 Prims.eqtype)) :named function_token_typing_FStar.Set.union))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Prims.eqtype) (HasType @x1 (FStar.Set.set @x0)) (HasType @x2 (FStar.Set.set @x0))) (HasType (FStar.Set.union @x0 @x1 @x2) (FStar.Set.set @x0))) :pattern ((FStar.Set.union @x0 @x1 @x2)))) :named typing_FStar.Set.union))
(declare-fun FStar.Set.intersect (Term Term Term) Term)
(declare-fun FStar.Set.intersect@tok () Term)
(assert (! (= 1228 (Term_constr_id FStar.Set.intersect@tok)) :named fresh_token_FStar.Set.intersect@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT FStar.Set.intersect@tok @x0) @x1) @x2) (FStar.Set.intersect @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT FStar.Set.intersect@tok @x0) @x1) @x2)))) :named token_correspondence_FStar.Set.intersect))
(assert (! (HasType FStar.Set.intersect@tok (Tm_arrow_1224 Prims.eqtype)) :named function_token_typing_FStar.Set.intersect))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Prims.eqtype) (HasType @x1 (FStar.Set.set @x0)) (HasType @x2 (FStar.Set.set @x0))) (HasType (FStar.Set.intersect @x0 @x1 @x2) (FStar.Set.set @x0))) :pattern ((FStar.Set.intersect @x0 @x1 @x2)))) :named typing_FStar.Set.intersect))
(declare-fun FStar.Set.complement (Term Term) Term)
(declare-fun Tm_arrow_1230 (Term) Term)
(assert (! (forall ((@x0 Term)) (! (HasType (Tm_arrow_1230 @x0) Tm_type) :pattern ((HasType (Tm_arrow_1230 @x0) Tm_type)))) :named kinding_Tm_arrow_1230))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_1230 @x2)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_1230 @x2))))) :named pre_typing_Tm_arrow_1230))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_1230 @x1)) (forall ((@x2 Term) (@x3 Term)) (! (implies (and (HasType @x2 @x1) (HasType @x3 (FStar.Set.set @x2))) (HasType (ApplyTT (ApplyTT @x0 @x2) @x3) (FStar.Set.set @x2))) :pattern ((ApplyTT (ApplyTT @x0 @x2) @x3))))) :pattern ((HasTypeZ @x0 (Tm_arrow_1230 @x1))))) :named interpretation_Tm_arrow_1230))
(declare-fun FStar.Set.complement@tok () Term)
(assert (! (= 1232 (Term_constr_id FStar.Set.complement@tok)) :named fresh_token_FStar.Set.complement@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (ApplyTT (ApplyTT FStar.Set.complement@tok @x0) @x1) (FStar.Set.complement @x0 @x1)) :pattern ((ApplyTT (ApplyTT FStar.Set.complement@tok @x0) @x1)))) :named token_correspondence_FStar.Set.complement))
(assert (! (HasType FStar.Set.complement@tok (Tm_arrow_1230 Prims.eqtype)) :named function_token_typing_FStar.Set.complement))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 Prims.eqtype) (HasType @x1 (FStar.Set.set @x0))) (HasType (FStar.Set.complement @x0 @x1) (FStar.Set.set @x0))) :pattern ((FStar.Set.complement @x0 @x1)))) :named typing_FStar.Set.complement))
(declare-fun FStar.Set.subset (Term Term Term) Term)
(declare-fun FStar.Set.subset@tok () Term)
(assert (! (= 1234 (Term_constr_id FStar.Set.subset@tok)) :named fresh_token_FStar.Set.subset@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT FStar.Set.subset@tok @x0) @x1) @x2) (FStar.Set.subset @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT FStar.Set.subset@tok @x0) @x1) @x2)))) :named token_correspondence_FStar.Set.subset))
(assert (! (HasType FStar.Set.subset@tok (Tm_arrow_1208 Prims.eqtype)) :named function_token_typing_FStar.Set.subset))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Prims.eqtype) (HasType @x1 (FStar.Set.set @x0)) (HasType @x2 (FStar.Set.set @x0))) (HasType (FStar.Set.subset @x0 @x1 @x2) Tm_type)) :pattern ((FStar.Set.subset @x0 @x1 @x2)))) :named typing_FStar.Set.subset))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (Valid (FStar.Set.subset @x0 @x1 @x2)) (forall ((@x3 Term)) (implies (and (HasType @x3 @x0) (BoxBool_proj_0 (FStar.Set.mem @x0 @x3 @x1))) (BoxBool_proj_0 (FStar.Set.mem @x0 @x3 @x2))))) :pattern ((Valid (FStar.Set.subset @x0 @x1 @x2))))) :named equation_FStar.Set.subset))
(declare-fun FStar.Set.mem_empty (Term Term) Term)
(declare-fun FStar.Set.mem_empty@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 Prims.eqtype) (HasType @x1 @x0)) (not (BoxBool_proj_0 (FStar.Set.mem @x0 @x1 (FStar.Set.empty @x0))))) :pattern ((FStar.Set.mem @x0 @x1 (FStar.Set.empty @x0))))) :named lemma_FStar.Set.mem_empty))
(declare-fun FStar.Set.mem_singleton (Term Term Term) Term)
(declare-fun FStar.Set.mem_singleton@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Prims.eqtype) (HasType @x1 @x0) (HasType @x2 @x0)) (= (FStar.Set.mem @x0 @x2 (FStar.Set.singleton @x0 @x1)) (Prims.op_Equality @x0 @x1 @x2))) :pattern ((FStar.Set.mem @x0 @x2 (FStar.Set.singleton @x0 @x1))))) :named lemma_FStar.Set.mem_singleton))
(declare-fun FStar.Set.mem_union (Term Term Term Term) Term)
(declare-fun FStar.Set.mem_union@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x0 Prims.eqtype) (HasType @x1 @x0) (HasType @x2 (FStar.Set.set @x0)) (HasType @x3 (FStar.Set.set @x0))) (= (FStar.Set.mem @x0 @x1 (FStar.Set.union @x0 @x2 @x3)) (Prims.op_BarBar (FStar.Set.mem @x0 @x1 @x2) (FStar.Set.mem @x0 @x1 @x3)))) :pattern ((FStar.Set.mem @x0 @x1 (FStar.Set.union @x0 @x2 @x3))))) :named lemma_FStar.Set.mem_union))
(declare-fun FStar.Set.mem_intersect (Term Term Term Term) Term)
(declare-fun FStar.Set.mem_intersect@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x0 Prims.eqtype) (HasType @x1 @x0) (HasType @x2 (FStar.Set.set @x0)) (HasType @x3 (FStar.Set.set @x0))) (= (FStar.Set.mem @x0 @x1 (FStar.Set.intersect @x0 @x2 @x3)) (Prims.op_AmpAmp (FStar.Set.mem @x0 @x1 @x2) (FStar.Set.mem @x0 @x1 @x3)))) :pattern ((FStar.Set.mem @x0 @x1 (FStar.Set.intersect @x0 @x2 @x3))))) :named lemma_FStar.Set.mem_intersect))
(declare-fun FStar.Set.mem_complement (Term Term Term) Term)
(declare-fun FStar.Set.mem_complement@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Prims.eqtype) (HasType @x1 @x0) (HasType @x2 (FStar.Set.set @x0))) (= (FStar.Set.mem @x0 @x1 (FStar.Set.complement @x0 @x2)) (Prims.op_Negation (FStar.Set.mem @x0 @x1 @x2)))) :pattern ((FStar.Set.mem @x0 @x1 (FStar.Set.complement @x0 @x2))))) :named lemma_FStar.Set.mem_complement))
(declare-fun FStar.Set.subset_mem (Term Term Term) Term)
(declare-fun FStar.Set.subset_mem@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (Valid (FStar.Set.subset @x0 @x1 @x2)) (HasType @x0 Prims.eqtype) (HasType @x1 (FStar.Set.set @x0)) (HasType @x2 (FStar.Set.set @x0))) (forall ((@x3 Term)) (implies (and (HasType @x3 @x0) (BoxBool_proj_0 (FStar.Set.mem @x0 @x3 @x1))) (BoxBool_proj_0 (FStar.Set.mem @x0 @x3 @x2))))) :pattern ((FStar.Set.subset @x0 @x1 @x2)))) :named lemma_FStar.Set.subset_mem))
(declare-fun FStar.Set.mem_subset (Term Term Term) Term)
(declare-fun FStar.Set.mem_subset@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (forall ((@x3 Term)) (implies (and (HasType @x3 @x0) (BoxBool_proj_0 (FStar.Set.mem @x0 @x3 @x1))) (BoxBool_proj_0 (FStar.Set.mem @x0 @x3 @x2)))) (HasType @x0 Prims.eqtype) (HasType @x1 (FStar.Set.set @x0)) (HasType @x2 (FStar.Set.set @x0))) (Valid (FStar.Set.subset @x0 @x1 @x2))) :pattern ((FStar.Set.subset @x0 @x1 @x2)))) :named lemma_FStar.Set.mem_subset))
(declare-fun FStar.Set.lemma_equal_intro (Term Term Term) Term)
(declare-fun FStar.Set.lemma_equal_intro@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (forall ((@x3 Term)) (implies (HasType @x3 @x0) (= (FStar.Set.mem @x0 @x3 @x1) (FStar.Set.mem @x0 @x3 @x2)))) (HasType @x0 Prims.eqtype) (HasType @x1 (FStar.Set.set @x0)) (HasType @x2 (FStar.Set.set @x0))) (Valid (FStar.Set.equal @x0 @x1 @x2))) :pattern ((FStar.Set.equal @x0 @x1 @x2)))) :named lemma_FStar.Set.lemma_equal_intro))
(declare-fun FStar.Set.lemma_equal_elim (Term Term Term) Term)
(declare-fun FStar.Set.lemma_equal_elim@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (Valid (FStar.Set.equal @x0 @x1 @x2)) (HasType @x0 Prims.eqtype) (HasType @x1 (FStar.Set.set @x0)) (HasType @x2 (FStar.Set.set @x0))) (= @x1 @x2)) :pattern ((FStar.Set.equal @x0 @x1 @x2)))) :named lemma_FStar.Set.lemma_equal_elim))
(declare-fun FStar.Set.lemma_equal_refl (Term Term Term) Term)
(declare-fun FStar.Set.lemma_equal_refl@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (= @x1 @x2) (HasType @x0 Prims.eqtype) (HasType @x1 (FStar.Set.set @x0)) (HasType @x2 (FStar.Set.set @x0))) (Valid (FStar.Set.equal @x0 @x1 @x2))) :pattern ((FStar.Set.equal @x0 @x1 @x2)))) :named lemma_FStar.Set.lemma_equal_refl))
(declare-fun FStar.Set.set_to_tset (Term Term) Term)
(declare-fun Tm_arrow_1236 (Term) Term)
(assert (! (forall ((@x0 Term)) (! (HasType (Tm_arrow_1236 @x0) Tm_type) :pattern ((HasType (Tm_arrow_1236 @x0) Tm_type)))) :named kinding_Tm_arrow_1236))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_1236 @x2)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_1236 @x2))))) :named pre_typing_Tm_arrow_1236))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_1236 @x1)) (forall ((@x2 Term) (@x3 Term)) (! (implies (and (HasType @x2 @x1) (HasType @x3 (FStar.Set.set @x2))) (HasType (ApplyTT (ApplyTT @x0 @x2) @x3) (FStar.TSet.set @x2))) :pattern ((ApplyTT (ApplyTT @x0 @x2) @x3))))) :pattern ((HasTypeZ @x0 (Tm_arrow_1236 @x1))))) :named interpretation_Tm_arrow_1236))
(declare-fun FStar.Set.set_to_tset@tok () Term)
(assert (! (= 1238 (Term_constr_id FStar.Set.set_to_tset@tok)) :named fresh_token_FStar.Set.set_to_tset@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (ApplyTT (ApplyTT FStar.Set.set_to_tset@tok @x0) @x1) (FStar.Set.set_to_tset @x0 @x1)) :pattern ((ApplyTT (ApplyTT FStar.Set.set_to_tset@tok @x0) @x1)))) :named token_correspondence_FStar.Set.set_to_tset))
(assert (! (HasType FStar.Set.set_to_tset@tok (Tm_arrow_1236 Prims.eqtype)) :named function_token_typing_FStar.Set.set_to_tset))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 Prims.eqtype) (HasType @x1 (FStar.Set.set @x0))) (HasType (FStar.Set.set_to_tset @x0 @x1) (FStar.TSet.set @x0))) :pattern ((FStar.Set.set_to_tset @x0 @x1)))) :named typing_FStar.Set.set_to_tset))
(declare-fun FStar.Set.lemma_set_to_tset (Term Term Term) Term)
(declare-fun FStar.Set.lemma_set_to_tset@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Prims.eqtype) (HasType @x1 (FStar.Set.set @x0)) (HasType @x2 @x0)) (iff (BoxBool_proj_0 (FStar.Set.mem @x0 @x2 @x1)) (Valid (FStar.TSet.mem @x0 @x2 (FStar.Set.set_to_tset @x0 @x1))))) :pattern ((FStar.TSet.mem @x0 @x2 (FStar.Set.set_to_tset @x0 @x1))))) :named lemma_FStar.Set.lemma_set_to_tset))
(declare-fun FStar.Map.t (Term Term) Term)
(declare-fun Tm_arrow_1378 (Term) Term)
(assert (! (forall ((@x0 Term)) (! (HasType (Tm_arrow_1378 @x0) Tm_type) :pattern ((HasType (Tm_arrow_1378 @x0) Tm_type)))) :named kinding_Tm_arrow_1378))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_1378 @x2)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_1378 @x2))))) :named pre_typing_Tm_arrow_1378))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_1378 @x1)) (forall ((@x2 Term) (@x3 Term)) (! (implies (and (HasType @x2 @x1) (HasType @x3 Tm_type)) (HasType (ApplyTT (ApplyTT @x0 @x2) @x3) Tm_type)) :pattern ((ApplyTT (ApplyTT @x0 @x2) @x3))))) :pattern ((HasTypeZ @x0 (Tm_arrow_1378 @x1))))) :named interpretation_Tm_arrow_1378))
(declare-fun FStar.Map.t@tok () Term)
(assert (! (= 1380 (Term_constr_id FStar.Map.t@tok)) :named fresh_token_FStar.Map.t@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (ApplyTT (ApplyTT FStar.Map.t@tok @x0) @x1) (FStar.Map.t @x0 @x1)) :pattern ((ApplyTT (ApplyTT FStar.Map.t@tok @x0) @x1)))) :named token_correspondence_FStar.Map.t))
(assert (! (HasType FStar.Map.t@tok (Tm_arrow_1378 Prims.eqtype)) :named function_token_typing_FStar.Map.t))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= 1381 (Term_constr_id (FStar.Map.t @x0 @x1))) :pattern ((FStar.Map.t @x0 @x1)))) :named constructor_distinct_FStar.Map.t))
(assert (! (forall ((@x0 Term) (@u1 Fuel) (@x2 Term) (@x3 Term)) (! (implies (HasTypeFuel @u1 @x0 (FStar.Map.t @x2 @x3)) (= (FStar.Map.t @x2 @x3) (PreType @x0))) :pattern ((HasTypeFuel @u1 @x0 (FStar.Map.t @x2 @x3))))) :named @pretyping__1384))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 Prims.eqtype) (HasType @x1 Tm_type)) (HasType (FStar.Map.t @x0 @x1) Tm_type)) :pattern ((FStar.Map.t @x0 @x1)))) :named typing_FStar.Map.t))
(declare-fun FStar.Map.Mkt (Term Term Term Term) Term)
(declare-fun Tm_arrow_1388 (Term) Term)
(assert (! (forall ((@x0 Term)) (! (HasType (Tm_arrow_1388 @x0) Tm_type) :pattern ((HasType (Tm_arrow_1388 @x0) Tm_type)))) :named kinding_Tm_arrow_1388))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_1388 @x2)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_1388 @x2))))) :named pre_typing_Tm_arrow_1388))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_1388 @x1)) (forall ((@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (implies (and (HasType @x2 @x1) (HasType @x3 Tm_type) (HasType @x4 (Tm_arrow_228 @x3 @x2)) (HasType @x5 (FStar.Set.set @x2))) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x2) @x3) @x4) @x5) (FStar.Map.t @x2 @x3))) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x2) @x3) @x4) @x5))))) :pattern ((HasTypeZ @x0 (Tm_arrow_1388 @x1))))) :named interpretation_Tm_arrow_1388))
(declare-fun FStar.Map.Mkt@tok () Term)
(assert (! (= 1390 (Term_constr_id FStar.Map.Mkt@tok)) :named fresh_token_FStar.Map.Mkt@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.Map.Mkt@tok @x0) @x1) @x2) @x3) (FStar.Map.Mkt @x0 @x1 @x2 @x3)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.Map.Mkt@tok @x0) @x1) @x2) @x3)))) :named token_correspondence_FStar.Map.Mkt))
(assert (! (HasType FStar.Map.Mkt@tok (Tm_arrow_1388 Prims.eqtype)) :named function_token_typing_FStar.Map.Mkt))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x0 Prims.eqtype) (HasType @x1 Tm_type) (HasType @x2 (Tm_arrow_228 @x1 @x0)) (HasType @x3 (FStar.Set.set @x0))) (HasType (FStar.Map.Mkt @x0 @x1 @x2 @x3) (FStar.Map.t @x0 @x1))) :pattern ((FStar.Map.Mkt @x0 @x1 @x2 @x3)))) :named typing_FStar.Map.Mkt))
(declare-fun FStar.Map.Mkt.mappings (Term Term Term) Term)
(declare-fun Tm_arrow_1393 (Term) Term)
(assert (! (forall ((@x0 Term)) (! (HasType (Tm_arrow_1393 @x0) Tm_type) :pattern ((HasType (Tm_arrow_1393 @x0) Tm_type)))) :named kinding_Tm_arrow_1393))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_1393 @x2)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_1393 @x2))))) :named pre_typing_Tm_arrow_1393))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_1393 @x1)) (forall ((@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x2 @x1) (HasType @x3 Tm_type) (HasType @x4 (FStar.Map.t @x2 @x3))) (HasType (ApplyTT (ApplyTT (ApplyTT @x0 @x2) @x3) @x4) (Tm_arrow_228 @x3 @x2))) :pattern ((ApplyTT (ApplyTT (ApplyTT @x0 @x2) @x3) @x4))))) :pattern ((HasTypeZ @x0 (Tm_arrow_1393 @x1))))) :named interpretation_Tm_arrow_1393))
(declare-fun FStar.Map.Mkt.mappings@tok () Term)
(assert (! (= 1395 (Term_constr_id FStar.Map.Mkt.mappings@tok)) :named fresh_token_FStar.Map.Mkt.mappings@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT FStar.Map.Mkt.mappings@tok @x0) @x1) @x2) (FStar.Map.Mkt.mappings @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT FStar.Map.Mkt.mappings@tok @x0) @x1) @x2)))) :named token_correspondence_FStar.Map.Mkt.mappings))
(assert (! (HasType FStar.Map.Mkt.mappings@tok (Tm_arrow_1393 Prims.eqtype)) :named function_token_typing_FStar.Map.Mkt.mappings))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Prims.eqtype) (HasType @x1 Tm_type) (HasType @x2 (FStar.Map.t @x0 @x1))) (HasType (FStar.Map.Mkt.mappings @x0 @x1 @x2) (Tm_arrow_228 @x1 @x0))) :pattern ((FStar.Map.Mkt.mappings @x0 @x1 @x2)))) :named typing_FStar.Map.Mkt.mappings))
(declare-fun FStar.Map.Mkt.domain (Term Term Term) Term)
(declare-fun Tm_arrow_1398 (Term) Term)
(assert (! (forall ((@x0 Term)) (! (HasType (Tm_arrow_1398 @x0) Tm_type) :pattern ((HasType (Tm_arrow_1398 @x0) Tm_type)))) :named kinding_Tm_arrow_1398))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_1398 @x2)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_1398 @x2))))) :named pre_typing_Tm_arrow_1398))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_1398 @x1)) (forall ((@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x2 @x1) (HasType @x3 Tm_type) (HasType @x4 (FStar.Map.t @x2 @x3))) (HasType (ApplyTT (ApplyTT (ApplyTT @x0 @x2) @x3) @x4) (FStar.Set.set @x2))) :pattern ((ApplyTT (ApplyTT (ApplyTT @x0 @x2) @x3) @x4))))) :pattern ((HasTypeZ @x0 (Tm_arrow_1398 @x1))))) :named interpretation_Tm_arrow_1398))
(declare-fun FStar.Map.Mkt.domain@tok () Term)
(assert (! (= 1400 (Term_constr_id FStar.Map.Mkt.domain@tok)) :named fresh_token_FStar.Map.Mkt.domain@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT FStar.Map.Mkt.domain@tok @x0) @x1) @x2) (FStar.Map.Mkt.domain @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT FStar.Map.Mkt.domain@tok @x0) @x1) @x2)))) :named token_correspondence_FStar.Map.Mkt.domain))
(assert (! (HasType FStar.Map.Mkt.domain@tok (Tm_arrow_1398 Prims.eqtype)) :named function_token_typing_FStar.Map.Mkt.domain))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Prims.eqtype) (HasType @x1 Tm_type) (HasType @x2 (FStar.Map.t @x0 @x1))) (HasType (FStar.Map.Mkt.domain @x0 @x1 @x2) (FStar.Set.set @x0))) :pattern ((FStar.Map.Mkt.domain @x0 @x1 @x2)))) :named typing_FStar.Map.Mkt.domain))
(declare-fun FStar.Map.sel (Term Term Term Term) Term)
(declare-fun Tm_arrow_1402 (Term) Term)
(assert (! (forall ((@x0 Term)) (! (HasType (Tm_arrow_1402 @x0) Tm_type) :pattern ((HasType (Tm_arrow_1402 @x0) Tm_type)))) :named kinding_Tm_arrow_1402))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_1402 @x2)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_1402 @x2))))) :named pre_typing_Tm_arrow_1402))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_1402 @x1)) (forall ((@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (implies (and (HasType @x2 @x1) (HasType @x3 Tm_type) (HasType @x4 (FStar.Map.t @x2 @x3)) (HasType @x5 @x2)) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x2) @x3) @x4) @x5) @x3)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x2) @x3) @x4) @x5))))) :pattern ((HasTypeZ @x0 (Tm_arrow_1402 @x1))))) :named interpretation_Tm_arrow_1402))
(declare-fun FStar.Map.sel@tok () Term)
(assert (! (= 1404 (Term_constr_id FStar.Map.sel@tok)) :named fresh_token_FStar.Map.sel@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.Map.sel@tok @x0) @x1) @x2) @x3) (FStar.Map.sel @x0 @x1 @x2 @x3)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.Map.sel@tok @x0) @x1) @x2) @x3)))) :named token_correspondence_FStar.Map.sel))
(assert (! (HasType FStar.Map.sel@tok (Tm_arrow_1402 Prims.eqtype)) :named function_token_typing_FStar.Map.sel))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x0 Prims.eqtype) (HasType @x1 Tm_type) (HasType @x2 (FStar.Map.t @x0 @x1)) (HasType @x3 @x0)) (HasType (FStar.Map.sel @x0 @x1 @x2 @x3) @x1)) :pattern ((FStar.Map.sel @x0 @x1 @x2 @x3)))) :named typing_FStar.Map.sel))
(declare-fun FStar.Map.upd (Term Term Term Term Term) Term)
(declare-fun Tm_arrow_1406 (Term) Term)
(assert (! (forall ((@x0 Term)) (! (HasType (Tm_arrow_1406 @x0) Tm_type) :pattern ((HasType (Tm_arrow_1406 @x0) Tm_type)))) :named kinding_Tm_arrow_1406))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_1406 @x2)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_1406 @x2))))) :named pre_typing_Tm_arrow_1406))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_1406 @x1)) (forall ((@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term)) (! (implies (and (HasType @x2 @x1) (HasType @x3 Tm_type) (HasType @x4 (FStar.Map.t @x2 @x3)) (HasType @x5 @x2) (HasType @x6 @x3)) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x2) @x3) @x4) @x5) @x6) (FStar.Map.t @x2 @x3))) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x2) @x3) @x4) @x5) @x6))))) :pattern ((HasTypeZ @x0 (Tm_arrow_1406 @x1))))) :named interpretation_Tm_arrow_1406))
(declare-fun FStar.Map.upd@tok () Term)
(assert (! (= 1408 (Term_constr_id FStar.Map.upd@tok)) :named fresh_token_FStar.Map.upd@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.Map.upd@tok @x0) @x1) @x2) @x3) @x4) (FStar.Map.upd @x0 @x1 @x2 @x3 @x4)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.Map.upd@tok @x0) @x1) @x2) @x3) @x4)))) :named token_correspondence_FStar.Map.upd))
(assert (! (HasType FStar.Map.upd@tok (Tm_arrow_1406 Prims.eqtype)) :named function_token_typing_FStar.Map.upd))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x0 Prims.eqtype) (HasType @x1 Tm_type) (HasType @x2 (FStar.Map.t @x0 @x1)) (HasType @x3 @x0) (HasType @x4 @x1)) (HasType (FStar.Map.upd @x0 @x1 @x2 @x3 @x4) (FStar.Map.t @x0 @x1))) :pattern ((FStar.Map.upd @x0 @x1 @x2 @x3 @x4)))) :named typing_FStar.Map.upd))
(declare-fun FStar.Map.const (Term Term Term) Term)
(declare-fun Tm_arrow_1410 (Term) Term)
(assert (! (forall ((@x0 Term)) (! (HasType (Tm_arrow_1410 @x0) Tm_type) :pattern ((HasType (Tm_arrow_1410 @x0) Tm_type)))) :named kinding_Tm_arrow_1410))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_1410 @x2)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_1410 @x2))))) :named pre_typing_Tm_arrow_1410))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_1410 @x1)) (forall ((@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x2 @x1) (HasType @x3 Tm_type) (HasType @x4 @x3)) (HasType (ApplyTT (ApplyTT (ApplyTT @x0 @x2) @x3) @x4) (FStar.Map.t @x2 @x3))) :pattern ((ApplyTT (ApplyTT (ApplyTT @x0 @x2) @x3) @x4))))) :pattern ((HasTypeZ @x0 (Tm_arrow_1410 @x1))))) :named interpretation_Tm_arrow_1410))
(declare-fun FStar.Map.const@tok () Term)
(assert (! (= 1412 (Term_constr_id FStar.Map.const@tok)) :named fresh_token_FStar.Map.const@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT FStar.Map.const@tok @x0) @x1) @x2) (FStar.Map.const @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT FStar.Map.const@tok @x0) @x1) @x2)))) :named token_correspondence_FStar.Map.const))
(assert (! (HasType FStar.Map.const@tok (Tm_arrow_1410 Prims.eqtype)) :named function_token_typing_FStar.Map.const))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Prims.eqtype) (HasType @x1 Tm_type) (HasType @x2 @x1)) (HasType (FStar.Map.const @x0 @x1 @x2) (FStar.Map.t @x0 @x1))) :pattern ((FStar.Map.const @x0 @x1 @x2)))) :named typing_FStar.Map.const))
(declare-fun FStar.Map.concat (Term Term Term Term) Term)
(declare-fun Tm_arrow_1414 (Term) Term)
(assert (! (forall ((@x0 Term)) (! (HasType (Tm_arrow_1414 @x0) Tm_type) :pattern ((HasType (Tm_arrow_1414 @x0) Tm_type)))) :named kinding_Tm_arrow_1414))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_1414 @x2)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_1414 @x2))))) :named pre_typing_Tm_arrow_1414))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_1414 @x1)) (forall ((@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (implies (and (HasType @x2 @x1) (HasType @x3 Tm_type) (HasType @x4 (FStar.Map.t @x2 @x3)) (HasType @x5 (FStar.Map.t @x2 @x3))) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x2) @x3) @x4) @x5) (FStar.Map.t @x2 @x3))) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x2) @x3) @x4) @x5))))) :pattern ((HasTypeZ @x0 (Tm_arrow_1414 @x1))))) :named interpretation_Tm_arrow_1414))
(declare-fun FStar.Map.concat@tok () Term)
(assert (! (= 1416 (Term_constr_id FStar.Map.concat@tok)) :named fresh_token_FStar.Map.concat@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.Map.concat@tok @x0) @x1) @x2) @x3) (FStar.Map.concat @x0 @x1 @x2 @x3)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.Map.concat@tok @x0) @x1) @x2) @x3)))) :named token_correspondence_FStar.Map.concat))
(assert (! (HasType FStar.Map.concat@tok (Tm_arrow_1414 Prims.eqtype)) :named function_token_typing_FStar.Map.concat))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x0 Prims.eqtype) (HasType @x1 Tm_type) (HasType @x2 (FStar.Map.t @x0 @x1)) (HasType @x3 (FStar.Map.t @x0 @x1))) (HasType (FStar.Map.concat @x0 @x1 @x2 @x3) (FStar.Map.t @x0 @x1))) :pattern ((FStar.Map.concat @x0 @x1 @x2 @x3)))) :named typing_FStar.Map.concat))
(declare-fun FStar.Map.contains (Term Term Term Term) Term)
(declare-fun Tm_arrow_1418 (Term Term) Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (HasType (Tm_arrow_1418 @x0 @x1) Tm_type) :pattern ((HasType (Tm_arrow_1418 @x0 @x1) Tm_type)))) :named kinding_Tm_arrow_1418))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_1418 @x2 @x3)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_1418 @x2 @x3))))) :named pre_typing_Tm_arrow_1418))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_1418 @x1 @x2)) (forall ((@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term)) (! (implies (and (HasType @x3 @x2) (HasType @x4 Tm_type) (HasType @x5 (FStar.Map.t @x3 @x4)) (HasType @x6 @x3)) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x3) @x4) @x5) @x6) @x1)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x3) @x4) @x5) @x6))))) :pattern ((HasTypeZ @x0 (Tm_arrow_1418 @x1 @x2))))) :named interpretation_Tm_arrow_1418))
(declare-fun FStar.Map.contains@tok () Term)
(assert (! (= 1420 (Term_constr_id FStar.Map.contains@tok)) :named fresh_token_FStar.Map.contains@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.Map.contains@tok @x0) @x1) @x2) @x3) (FStar.Map.contains @x0 @x1 @x2 @x3)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.Map.contains@tok @x0) @x1) @x2) @x3)))) :named token_correspondence_FStar.Map.contains))
(assert (! (HasType FStar.Map.contains@tok (Tm_arrow_1418 Prims.bool Prims.eqtype)) :named function_token_typing_FStar.Map.contains))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x0 Prims.eqtype) (HasType @x1 Tm_type) (HasType @x2 (FStar.Map.t @x0 @x1)) (HasType @x3 @x0)) (HasType (FStar.Map.contains @x0 @x1 @x2 @x3) Prims.bool)) :pattern ((FStar.Map.contains @x0 @x1 @x2 @x3)))) :named typing_FStar.Map.contains))
(declare-fun FStar.Map.restrict (Term Term Term Term) Term)
(declare-fun Tm_arrow_1422 (Term) Term)
(assert (! (forall ((@x0 Term)) (! (HasType (Tm_arrow_1422 @x0) Tm_type) :pattern ((HasType (Tm_arrow_1422 @x0) Tm_type)))) :named kinding_Tm_arrow_1422))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_1422 @x2)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_1422 @x2))))) :named pre_typing_Tm_arrow_1422))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_1422 @x1)) (forall ((@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (implies (and (HasType @x2 @x1) (HasType @x3 Tm_type) (HasType @x4 (FStar.Set.set @x2)) (HasType @x5 (FStar.Map.t @x2 @x3))) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x2) @x3) @x4) @x5) (FStar.Map.t @x2 @x3))) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x2) @x3) @x4) @x5))))) :pattern ((HasTypeZ @x0 (Tm_arrow_1422 @x1))))) :named interpretation_Tm_arrow_1422))
(declare-fun FStar.Map.restrict@tok () Term)
(assert (! (= 1424 (Term_constr_id FStar.Map.restrict@tok)) :named fresh_token_FStar.Map.restrict@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.Map.restrict@tok @x0) @x1) @x2) @x3) (FStar.Map.restrict @x0 @x1 @x2 @x3)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.Map.restrict@tok @x0) @x1) @x2) @x3)))) :named token_correspondence_FStar.Map.restrict))
(assert (! (HasType FStar.Map.restrict@tok (Tm_arrow_1422 Prims.eqtype)) :named function_token_typing_FStar.Map.restrict))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x0 Prims.eqtype) (HasType @x1 Tm_type) (HasType @x2 (FStar.Set.set @x0)) (HasType @x3 (FStar.Map.t @x0 @x1))) (HasType (FStar.Map.restrict @x0 @x1 @x2 @x3) (FStar.Map.t @x0 @x1))) :pattern ((FStar.Map.restrict @x0 @x1 @x2 @x3)))) :named typing_FStar.Map.restrict))
(declare-fun FStar.Map.domain (Term Term Term) Term)
(declare-fun FStar.Map.domain@tok () Term)
(assert (! (= 1426 (Term_constr_id FStar.Map.domain@tok)) :named fresh_token_FStar.Map.domain@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT FStar.Map.domain@tok @x0) @x1) @x2) (FStar.Map.domain @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT FStar.Map.domain@tok @x0) @x1) @x2)))) :named token_correspondence_FStar.Map.domain))
(assert (! (HasType FStar.Map.domain@tok (Tm_arrow_1398 Prims.eqtype)) :named function_token_typing_FStar.Map.domain))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Prims.eqtype) (HasType @x1 Tm_type) (HasType @x2 (FStar.Map.t @x0 @x1))) (HasType (FStar.Map.domain @x0 @x1 @x2) (FStar.Set.set @x0))) :pattern ((FStar.Map.domain @x0 @x1 @x2)))) :named typing_FStar.Map.domain))
(declare-fun FStar.Map.lemma_SelUpd1 (Term Term Term Term Term) Term)
(declare-fun FStar.Map.lemma_SelUpd1@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x0 Prims.eqtype) (HasType @x1 Tm_type) (HasType @x2 (FStar.Map.t @x0 @x1)) (HasType @x3 @x0) (HasType @x4 @x1)) (= (FStar.Map.sel @x0 @x1 (FStar.Map.upd @x0 @x1 @x2 @x3 @x4) @x3) @x4)) :pattern ((FStar.Map.sel @x0 @x1 (FStar.Map.upd @x0 @x1 @x2 @x3 @x4) @x3)))) :named lemma_FStar.Map.lemma_SelUpd1))
(declare-fun FStar.Map.lemma_SelUpd2 (Term Term Term Term Term Term) Term)
(declare-fun FStar.Map.lemma_SelUpd2@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (implies (and (HasType @x0 Prims.eqtype) (HasType @x1 Tm_type) (HasType @x2 (FStar.Map.t @x0 @x1)) (HasType @x3 @x0) (HasType @x4 @x0) (HasType @x5 @x1) (not (= @x4 @x3))) (= (FStar.Map.sel @x0 @x1 (FStar.Map.upd @x0 @x1 @x2 @x4 @x5) @x3) (FStar.Map.sel @x0 @x1 @x2 @x3))) :pattern ((FStar.Map.sel @x0 @x1 (FStar.Map.upd @x0 @x1 @x2 @x4 @x5) @x3)))) :named lemma_FStar.Map.lemma_SelUpd2))
(declare-fun FStar.Map.lemma_SelConst (Term Term Term Term) Term)
(declare-fun FStar.Map.lemma_SelConst@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x0 Prims.eqtype) (HasType @x1 Tm_type) (HasType @x2 @x1) (HasType @x3 @x0)) (= (FStar.Map.sel @x0 @x1 (FStar.Map.const @x0 @x1 @x2) @x3) @x2)) :pattern ((FStar.Map.sel @x0 @x1 (FStar.Map.const @x0 @x1 @x2) @x3)))) :named lemma_FStar.Map.lemma_SelConst))
(declare-fun FStar.Map.lemma_SelRestrict (Term Term Term Term Term) Term)
(declare-fun FStar.Map.lemma_SelRestrict@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x0 Prims.eqtype) (HasType @x1 Tm_type) (HasType @x2 (FStar.Map.t @x0 @x1)) (HasType @x3 (FStar.Set.set @x0)) (HasType @x4 @x0) (BoxBool_proj_0 (FStar.Set.mem @x0 @x4 @x3))) (= (FStar.Map.sel @x0 @x1 (FStar.Map.restrict @x0 @x1 @x3 @x2) @x4) (FStar.Map.sel @x0 @x1 @x2 @x4))) :pattern ((FStar.Map.sel @x0 @x1 (FStar.Map.restrict @x0 @x1 @x3 @x2) @x4)))) :named lemma_FStar.Map.lemma_SelRestrict))
(declare-fun FStar.Map.lemma_SelConcat1 (Term Term Term Term Term) Term)
(declare-fun FStar.Map.lemma_SelConcat1@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x0 Prims.eqtype) (HasType @x1 Tm_type) (HasType @x2 (FStar.Map.t @x0 @x1)) (HasType @x3 (FStar.Map.t @x0 @x1)) (HasType @x4 @x0) (BoxBool_proj_0 (FStar.Map.contains @x0 @x1 @x3 @x4))) (= (FStar.Map.sel @x0 @x1 (FStar.Map.concat @x0 @x1 @x2 @x3) @x4) (FStar.Map.sel @x0 @x1 @x3 @x4))) :pattern ((FStar.Map.sel @x0 @x1 (FStar.Map.concat @x0 @x1 @x2 @x3) @x4)))) :named lemma_FStar.Map.lemma_SelConcat1))
(declare-fun FStar.Map.lemma_SelConcat2 (Term Term Term Term Term) Term)
(declare-fun FStar.Map.lemma_SelConcat2@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x0 Prims.eqtype) (HasType @x1 Tm_type) (HasType @x2 (FStar.Map.t @x0 @x1)) (HasType @x3 (FStar.Map.t @x0 @x1)) (HasType @x4 @x0) (not (BoxBool_proj_0 (FStar.Map.contains @x0 @x1 @x3 @x4)))) (= (FStar.Map.sel @x0 @x1 (FStar.Map.concat @x0 @x1 @x2 @x3) @x4) (FStar.Map.sel @x0 @x1 @x2 @x4))) :pattern ((FStar.Map.sel @x0 @x1 (FStar.Map.concat @x0 @x1 @x2 @x3) @x4)))) :named lemma_FStar.Map.lemma_SelConcat2))
(declare-fun FStar.Map.lemma_InDomUpd1 (Term Term Term Term Term Term) Term)
(declare-fun FStar.Map.lemma_InDomUpd1@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (implies (and (HasType @x0 Prims.eqtype) (HasType @x1 Tm_type) (HasType @x2 (FStar.Map.t @x0 @x1)) (HasType @x3 @x0) (HasType @x4 @x0) (HasType @x5 @x1)) (= (FStar.Map.contains @x0 @x1 (FStar.Map.upd @x0 @x1 @x2 @x3 @x5) @x4) (Prims.op_BarBar (Prims.op_Equality @x0 @x3 @x4) (FStar.Map.contains @x0 @x1 @x2 @x4)))) :pattern ((FStar.Map.contains @x0 @x1 (FStar.Map.upd @x0 @x1 @x2 @x3 @x5) @x4)))) :named lemma_FStar.Map.lemma_InDomUpd1))
(declare-fun FStar.Map.lemma_InDomUpd2 (Term Term Term Term Term Term) Term)
(declare-fun FStar.Map.lemma_InDomUpd2@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (implies (and (HasType @x0 Prims.eqtype) (HasType @x1 Tm_type) (HasType @x2 (FStar.Map.t @x0 @x1)) (HasType @x3 @x0) (HasType @x4 @x0) (HasType @x5 @x1) (not (= @x4 @x3))) (= (FStar.Map.contains @x0 @x1 (FStar.Map.upd @x0 @x1 @x2 @x4 @x5) @x3) (FStar.Map.contains @x0 @x1 @x2 @x3))) :pattern ((FStar.Map.contains @x0 @x1 (FStar.Map.upd @x0 @x1 @x2 @x4 @x5) @x3)))) :named lemma_FStar.Map.lemma_InDomUpd2))
(declare-fun FStar.Map.lemma_InDomConstMap (Term Term Term Term) Term)
(declare-fun FStar.Map.lemma_InDomConstMap@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x0 Prims.eqtype) (HasType @x1 Tm_type) (HasType @x2 @x1) (HasType @x3 @x0)) (BoxBool_proj_0 (FStar.Map.contains @x0 @x1 (FStar.Map.const @x0 @x1 @x2) @x3))) :pattern ((FStar.Map.contains @x0 @x1 (FStar.Map.const @x0 @x1 @x2) @x3)))) :named lemma_FStar.Map.lemma_InDomConstMap))
(declare-fun FStar.Map.lemma_InDomConcat (Term Term Term Term Term) Term)
(declare-fun FStar.Map.lemma_InDomConcat@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x0 Prims.eqtype) (HasType @x1 Tm_type) (HasType @x2 (FStar.Map.t @x0 @x1)) (HasType @x3 (FStar.Map.t @x0 @x1)) (HasType @x4 @x0)) (= (FStar.Map.contains @x0 @x1 (FStar.Map.concat @x0 @x1 @x2 @x3) @x4) (Prims.op_BarBar (FStar.Map.contains @x0 @x1 @x2 @x4) (FStar.Map.contains @x0 @x1 @x3 @x4)))) :pattern ((FStar.Map.contains @x0 @x1 (FStar.Map.concat @x0 @x1 @x2 @x3) @x4)))) :named lemma_FStar.Map.lemma_InDomConcat))
(declare-fun FStar.Map.lemma_InDomRestrict (Term Term Term Term Term) Term)
(declare-fun FStar.Map.lemma_InDomRestrict@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x0 Prims.eqtype) (HasType @x1 Tm_type) (HasType @x2 (FStar.Map.t @x0 @x1)) (HasType @x3 (FStar.Set.set @x0)) (HasType @x4 @x0)) (= (FStar.Map.contains @x0 @x1 (FStar.Map.restrict @x0 @x1 @x3 @x2) @x4) (Prims.op_AmpAmp (FStar.Set.mem @x0 @x4 @x3) (FStar.Map.contains @x0 @x1 @x2 @x4)))) :pattern ((FStar.Map.contains @x0 @x1 (FStar.Map.restrict @x0 @x1 @x3 @x2) @x4)))) :named lemma_FStar.Map.lemma_InDomRestrict))
(declare-fun FStar.Map.lemma_ContainsDom (Term Term Term Term) Term)
(declare-fun FStar.Map.lemma_ContainsDom@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x0 Prims.eqtype) (HasType @x1 Tm_type) (HasType @x2 (FStar.Map.t @x0 @x1)) (HasType @x3 @x0)) (= (FStar.Map.contains @x0 @x1 @x2 @x3) (FStar.Set.mem @x0 @x3 (FStar.Map.domain @x0 @x1 @x2)))) :pattern ((FStar.Map.contains @x0 @x1 @x2 @x3)))) :named lemma_FStar.Map.lemma_ContainsDom))
(declare-fun FStar.Map.lemma_UpdDomain (Term Term Term Term Term) Term)
(declare-fun FStar.Map.lemma_UpdDomain@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x0 Prims.eqtype) (HasType @x1 Tm_type) (HasType @x2 (FStar.Map.t @x0 @x1)) (HasType @x3 @x0) (HasType @x4 @x1)) (Valid (FStar.Set.equal @x0 (FStar.Map.domain @x0 @x1 (FStar.Map.upd @x0 @x1 @x2 @x3 @x4)) (FStar.Set.union @x0 (FStar.Map.domain @x0 @x1 @x2) (FStar.Set.singleton @x0 @x3))))) :pattern ((FStar.Map.domain @x0 @x1 (FStar.Map.upd @x0 @x1 @x2 @x3 @x4))))) :named lemma_FStar.Map.lemma_UpdDomain))
(declare-fun FStar.Map.equal (Term Term Term Term) Term)
(declare-fun Tm_arrow_1428 (Term) Term)
(assert (! (forall ((@x0 Term)) (! (HasType (Tm_arrow_1428 @x0) Tm_type) :pattern ((HasType (Tm_arrow_1428 @x0) Tm_type)))) :named kinding_Tm_arrow_1428))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_1428 @x2)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_1428 @x2))))) :named pre_typing_Tm_arrow_1428))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_1428 @x1)) (forall ((@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (implies (and (HasType @x2 @x1) (HasType @x3 Tm_type) (HasType @x4 (FStar.Map.t @x2 @x3)) (HasType @x5 (FStar.Map.t @x2 @x3))) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x2) @x3) @x4) @x5) Tm_type)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x2) @x3) @x4) @x5))))) :pattern ((HasTypeZ @x0 (Tm_arrow_1428 @x1))))) :named interpretation_Tm_arrow_1428))
(declare-fun FStar.Map.equal@tok () Term)
(assert (! (= 1430 (Term_constr_id FStar.Map.equal@tok)) :named fresh_token_FStar.Map.equal@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.Map.equal@tok @x0) @x1) @x2) @x3) (FStar.Map.equal @x0 @x1 @x2 @x3)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.Map.equal@tok @x0) @x1) @x2) @x3)))) :named token_correspondence_FStar.Map.equal))
(assert (! (HasType FStar.Map.equal@tok (Tm_arrow_1428 Prims.eqtype)) :named function_token_typing_FStar.Map.equal))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x0 Prims.eqtype) (HasType @x1 Tm_type) (HasType @x2 (FStar.Map.t @x0 @x1)) (HasType @x3 (FStar.Map.t @x0 @x1))) (HasType (FStar.Map.equal @x0 @x1 @x2 @x3) Tm_type)) :pattern ((FStar.Map.equal @x0 @x1 @x2 @x3)))) :named typing_FStar.Map.equal))
(declare-fun FStar.Map.lemma_equal_intro (Term Term Term Term) Term)
(declare-fun FStar.Map.lemma_equal_intro@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (forall ((@x4 Term)) (implies (HasType @x4 @x0) (and (= (FStar.Map.sel @x0 @x1 @x2 @x4) (FStar.Map.sel @x0 @x1 @x3 @x4)) (= (FStar.Map.contains @x0 @x1 @x2 @x4) (FStar.Map.contains @x0 @x1 @x3 @x4))))) (HasType @x0 Prims.eqtype) (HasType @x1 Tm_type) (HasType @x2 (FStar.Map.t @x0 @x1)) (HasType @x3 (FStar.Map.t @x0 @x1))) (Valid (FStar.Map.equal @x0 @x1 @x2 @x3))) :pattern ((FStar.Map.equal @x0 @x1 @x2 @x3)))) :named lemma_FStar.Map.lemma_equal_intro))
(declare-fun FStar.Map.lemma_equal_elim (Term Term Term Term) Term)
(declare-fun FStar.Map.lemma_equal_elim@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (Valid (FStar.Map.equal @x0 @x1 @x2 @x3)) (HasType @x0 Prims.eqtype) (HasType @x1 Tm_type) (HasType @x2 (FStar.Map.t @x0 @x1)) (HasType @x3 (FStar.Map.t @x0 @x1))) (= @x2 @x3)) :pattern ((FStar.Map.equal @x0 @x1 @x2 @x3)))) :named lemma_FStar.Map.lemma_equal_elim))
(declare-fun FStar.Map.lemma_equal_refl (Term Term Term Term) Term)
(declare-fun FStar.Map.lemma_equal_refl@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (= @x2 @x3) (HasType @x0 Prims.eqtype) (HasType @x1 Tm_type) (HasType @x2 (FStar.Map.t @x0 @x1)) (HasType @x3 (FStar.Map.t @x0 @x1))) (Valid (FStar.Map.equal @x0 @x1 @x2 @x3))) :pattern ((FStar.Map.equal @x0 @x1 @x2 @x3)))) :named lemma_FStar.Map.lemma_equal_refl))
(declare-fun FStar.Map.const_on (Term Term Term Term) Term)
(declare-fun Tm_arrow_1432 (Term) Term)
(assert (! (forall ((@x0 Term)) (! (HasType (Tm_arrow_1432 @x0) Tm_type) :pattern ((HasType (Tm_arrow_1432 @x0) Tm_type)))) :named kinding_Tm_arrow_1432))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_1432 @x2)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_1432 @x2))))) :named pre_typing_Tm_arrow_1432))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_1432 @x1)) (forall ((@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (implies (and (HasType @x2 @x1) (HasType @x3 Tm_type) (HasType @x4 (FStar.Set.set @x2)) (HasType @x5 @x3)) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x2) @x3) @x4) @x5) (FStar.Map.t @x2 @x3))) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x2) @x3) @x4) @x5))))) :pattern ((HasTypeZ @x0 (Tm_arrow_1432 @x1))))) :named interpretation_Tm_arrow_1432))
(declare-fun FStar.Map.const_on@tok () Term)
(assert (! (= 1434 (Term_constr_id FStar.Map.const_on@tok)) :named fresh_token_FStar.Map.const_on@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.Map.const_on@tok @x0) @x1) @x2) @x3) (FStar.Map.const_on @x0 @x1 @x2 @x3)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.Map.const_on@tok @x0) @x1) @x2) @x3)))) :named token_correspondence_FStar.Map.const_on))
(assert (! (HasType FStar.Map.const_on@tok (Tm_arrow_1432 Prims.eqtype)) :named function_token_typing_FStar.Map.const_on))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x0 Prims.eqtype) (HasType @x1 Tm_type) (HasType @x2 (FStar.Set.set @x0)) (HasType @x3 @x1)) (HasType (FStar.Map.const_on @x0 @x1 @x2 @x3) (FStar.Map.t @x0 @x1))) :pattern ((FStar.Map.const_on @x0 @x1 @x2 @x3)))) :named typing_FStar.Map.const_on))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (FStar.Map.const_on @x0 @x1 @x2 @x3) (FStar.Map.restrict @x0 @x1 @x2 (FStar.Map.const @x0 @x1 @x3))) :pattern ((FStar.Map.const_on @x0 @x1 @x2 @x3)))) :named equation_FStar.Map.const_on))
(declare-fun FStar.Map.disjoint_dom (Term Term Term Term) Term)
(declare-fun FStar.Map.disjoint_dom@tok () Term)
(assert (! (= 1436 (Term_constr_id FStar.Map.disjoint_dom@tok)) :named fresh_token_FStar.Map.disjoint_dom@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.Map.disjoint_dom@tok @x0) @x1) @x2) @x3) (FStar.Map.disjoint_dom @x0 @x1 @x2 @x3)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.Map.disjoint_dom@tok @x0) @x1) @x2) @x3)))) :named token_correspondence_FStar.Map.disjoint_dom))
(assert (! (HasType FStar.Map.disjoint_dom@tok (Tm_arrow_1428 Prims.eqtype)) :named function_token_typing_FStar.Map.disjoint_dom))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x0 Prims.eqtype) (HasType @x1 Tm_type) (HasType @x2 (FStar.Map.t @x0 @x1)) (HasType @x3 (FStar.Map.t @x0 @x1))) (HasType (FStar.Map.disjoint_dom @x0 @x1 @x2 @x3) Tm_type)) :pattern ((FStar.Map.disjoint_dom @x0 @x1 @x2 @x3)))) :named typing_FStar.Map.disjoint_dom))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (Valid (FStar.Map.disjoint_dom @x0 @x1 @x2 @x3)) (forall ((@x4 Term)) (! (implies (and (HasType @x4 @x0) (BoxBool_proj_0 (FStar.Map.contains @x0 @x1 @x2 @x4))) (not (BoxBool_proj_0 (FStar.Map.contains @x0 @x1 @x3 @x4)))) :pattern ((FStar.Map.contains @x0 @x1 @x2 @x4))))) :pattern ((Valid (FStar.Map.disjoint_dom @x0 @x1 @x2 @x3))))) :named equation_FStar.Map.disjoint_dom))
(declare-fun FStar.Map.has_dom (Term Term Term Term) Term)
(declare-fun Tm_arrow_1438 (Term) Term)
(assert (! (forall ((@x0 Term)) (! (HasType (Tm_arrow_1438 @x0) Tm_type) :pattern ((HasType (Tm_arrow_1438 @x0) Tm_type)))) :named kinding_Tm_arrow_1438))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_1438 @x2)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_1438 @x2))))) :named pre_typing_Tm_arrow_1438))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_1438 @x1)) (forall ((@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (implies (and (HasType @x2 @x1) (HasType @x3 Tm_type) (HasType @x4 (FStar.Map.t @x2 @x3)) (HasType @x5 (FStar.Set.set @x2))) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x2) @x3) @x4) @x5) Tm_type)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x2) @x3) @x4) @x5))))) :pattern ((HasTypeZ @x0 (Tm_arrow_1438 @x1))))) :named interpretation_Tm_arrow_1438))
(declare-fun FStar.Map.has_dom@tok () Term)
(assert (! (= 1440 (Term_constr_id FStar.Map.has_dom@tok)) :named fresh_token_FStar.Map.has_dom@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.Map.has_dom@tok @x0) @x1) @x2) @x3) (FStar.Map.has_dom @x0 @x1 @x2 @x3)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.Map.has_dom@tok @x0) @x1) @x2) @x3)))) :named token_correspondence_FStar.Map.has_dom))
(assert (! (HasType FStar.Map.has_dom@tok (Tm_arrow_1438 Prims.eqtype)) :named function_token_typing_FStar.Map.has_dom))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x0 Prims.eqtype) (HasType @x1 Tm_type) (HasType @x2 (FStar.Map.t @x0 @x1)) (HasType @x3 (FStar.Set.set @x0))) (HasType (FStar.Map.has_dom @x0 @x1 @x2 @x3) Tm_type)) :pattern ((FStar.Map.has_dom @x0 @x1 @x2 @x3)))) :named typing_FStar.Map.has_dom))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (Valid (FStar.Map.has_dom @x0 @x1 @x2 @x3)) (forall ((@x4 Term)) (implies (HasType @x4 @x0) (iff (BoxBool_proj_0 (FStar.Map.contains @x0 @x1 @x2 @x4)) (BoxBool_proj_0 (FStar.Set.mem @x0 @x4 @x3)))))) :pattern ((Valid (FStar.Map.has_dom @x0 @x1 @x2 @x3))))) :named equation_FStar.Map.has_dom))
(declare-fun FStar.List.Tot.isEmpty (Term Term) Term)
(declare-fun FStar.List.Tot.isEmpty@tok () Term)
(assert (! (= 1754 (Term_constr_id FStar.List.Tot.isEmpty@tok)) :named fresh_token_FStar.List.Tot.isEmpty@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (ApplyTT (ApplyTT FStar.List.Tot.isEmpty@tok @x0) @x1) (FStar.List.Tot.isEmpty @x0 @x1)) :pattern ((ApplyTT (ApplyTT FStar.List.Tot.isEmpty@tok @x0) @x1)))) :named token_correspondence_FStar.List.Tot.isEmpty))
(assert (! (HasType FStar.List.Tot.isEmpty@tok (Tm_arrow_357 Prims.bool)) :named function_token_typing_FStar.List.Tot.isEmpty))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 (Prims.list @x0))) (HasType (FStar.List.Tot.isEmpty @x0 @x1) Prims.bool)) :pattern ((FStar.List.Tot.isEmpty @x0 @x1)))) :named typing_FStar.List.Tot.isEmpty))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (FStar.List.Tot.isEmpty @x0 @x1) (ite (is-Prims.Nil @x1) (BoxBool true) (ite true (BoxBool false) Tm_unit))) :pattern ((FStar.List.Tot.isEmpty @x0 @x1)))) :named equation_FStar.List.Tot.isEmpty))
(declare-fun FStar.List.Tot.hd (Term Term) Term)
(declare-fun FStar.List.Tot.hd@tok () Term)
(assert (! (= 1758 (Term_constr_id FStar.List.Tot.hd@tok)) :named fresh_token_FStar.List.Tot.hd@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (ApplyTT (ApplyTT FStar.List.Tot.hd@tok @x0) @x1) (FStar.List.Tot.hd @x0 @x1)) :pattern ((ApplyTT (ApplyTT FStar.List.Tot.hd@tok @x0) @x1)))) :named token_correspondence_FStar.List.Tot.hd))
(assert (! (HasType FStar.List.Tot.hd@tok Tm_arrow_366) :named function_token_typing_FStar.List.Tot.hd))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 (Tm_refine_363 @x0))) (HasType (FStar.List.Tot.hd @x0 @x1) @x0)) :pattern ((FStar.List.Tot.hd @x0 @x1)))) :named typing_FStar.List.Tot.hd))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (FStar.List.Tot.hd @x0 @x1) (ite (is-Prims.Cons @x1) (Prims.Cons_hd @x1) Tm_unit)) :pattern ((FStar.List.Tot.hd @x0 @x1)))) :named equation_FStar.List.Tot.hd))
(declare-fun FStar.List.Tot.tl (Term Term) Term)
(declare-fun FStar.List.Tot.tl@tok () Term)
(assert (! (= 1763 (Term_constr_id FStar.List.Tot.tl@tok)) :named fresh_token_FStar.List.Tot.tl@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (ApplyTT (ApplyTT FStar.List.Tot.tl@tok @x0) @x1) (FStar.List.Tot.tl @x0 @x1)) :pattern ((ApplyTT (ApplyTT FStar.List.Tot.tl@tok @x0) @x1)))) :named token_correspondence_FStar.List.Tot.tl))
(assert (! (HasType FStar.List.Tot.tl@tok Tm_arrow_372) :named function_token_typing_FStar.List.Tot.tl))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 (Tm_refine_363 @x0))) (HasType (FStar.List.Tot.tl @x0 @x1) (Prims.list @x0))) :pattern ((FStar.List.Tot.tl @x0 @x1)))) :named typing_FStar.List.Tot.tl))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (FStar.List.Tot.tl @x0 @x1) (ite (is-Prims.Cons @x1) (Prims.Cons_tl @x1) Tm_unit)) :pattern ((FStar.List.Tot.tl @x0 @x1)))) :named equation_FStar.List.Tot.tl))
(declare-fun FStar.List.Tot.length__1768 (Fuel Term Term) Term)
(declare-fun FStar.List.Tot.length__1769 () Term)
(declare-fun FStar.List.Tot.length (Term Term) Term)
(declare-fun FStar.List.Tot.length@tok () Term)
(assert (! (= 1766 (Term_constr_id FStar.List.Tot.length@tok)) :named fresh_token_FStar.List.Tot.length@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (ApplyTT (ApplyTT FStar.List.Tot.length@tok @x0) @x1) (FStar.List.Tot.length @x0 @x1)) :pattern ((ApplyTT (ApplyTT FStar.List.Tot.length@tok @x0) @x1)))) :named token_correspondence_FStar.List.Tot.length))
(assert (! (HasType FStar.List.Tot.length@tok (Tm_arrow_357 Prims.nat)) :named function_token_typing_FStar.List.Tot.length))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 (Prims.list @x0))) (HasType (FStar.List.Tot.length @x0 @x1) Prims.nat)) :pattern ((FStar.List.Tot.length @x0 @x1)))) :named typing_FStar.List.Tot.length))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTF FStar.List.Tot.length__1769 @u0) @x1) @x2) (FStar.List.Tot.length__1768 @u0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTF FStar.List.Tot.length__1769 @u0) @x1) @x2)))) :named fuel_tokem_correspondence_FStar.List.Tot.length__1769))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 (Prims.list @x1))) (HasType (FStar.List.Tot.length__1768 @u0 @x1 @x2) Prims.nat)) :pattern ((FStar.List.Tot.length__1768 @u0 @x1 @x2)))) :named token_correspondence_FStar.List.Tot.length__1768))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (FStar.List.Tot.length @x0 @x1) (FStar.List.Tot.length__1768 MaxFuel @x0 @x1)) :pattern ((FStar.List.Tot.length @x0 @x1)))) :named fuel_correspondence_FStar.List.Tot.length__1768))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (= (FStar.List.Tot.length__1768 (SFuel @u0) @x1 @x2) (FStar.List.Tot.length__1768 ZFuel @x1 @x2)) :pattern ((FStar.List.Tot.length__1768 (SFuel @u0) @x1 @x2)))) :named fuel_irrelevance_FStar.List.Tot.length__1768))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (= (FStar.List.Tot.length__1768 (SFuel @u0) @x1 @x2) (ite (is-Prims.Nil @x2) (BoxInt 0) (ite (is-Prims.Cons @x2) (Prims.op_Addition (BoxInt 1) (FStar.List.Tot.length__1768 @u0 @x1 (Prims.Cons_tl @x2))) Tm_unit))) :pattern ((FStar.List.Tot.length__1768 (SFuel @u0) @x1 @x2)))) :named equation_with_fuel_FStar.List.Tot.length__1768))
(declare-fun FStar.List.Tot.nth__1775 (Fuel Term Term Term) Term)
(declare-fun FStar.List.Tot.nth__1776 () Term)
(declare-fun FStar.List.Tot.nth (Term Term Term) Term)
(declare-fun Tm_arrow_1771 (Term) Term)
(declare-fun FStar.List.Tot.nth@tok () Term)
(assert (! (forall ((@x0 Term)) (! (HasType (Tm_arrow_1771 @x0) Tm_type) :pattern ((HasType (Tm_arrow_1771 @x0) Tm_type)))) :named kinding_Tm_arrow_1771))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_1771 @x2)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_1771 @x2))))) :named pre_typing_Tm_arrow_1771))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_1771 @x1)) (forall ((@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x2 Tm_type) (HasType @x3 (Prims.list @x2)) (HasType @x4 @x1)) (HasType (ApplyTT (ApplyTT (ApplyTT @x0 @x2) @x3) @x4) (Prims.option @x2))) :pattern ((ApplyTT (ApplyTT (ApplyTT @x0 @x2) @x3) @x4))))) :pattern ((HasTypeZ @x0 (Tm_arrow_1771 @x1))))) :named interpretation_Tm_arrow_1771))
(assert (! (= 1773 (Term_constr_id FStar.List.Tot.nth@tok)) :named fresh_token_FStar.List.Tot.nth@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT FStar.List.Tot.nth@tok @x0) @x1) @x2) (FStar.List.Tot.nth @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT FStar.List.Tot.nth@tok @x0) @x1) @x2)))) :named token_correspondence_FStar.List.Tot.nth))
(assert (! (HasType FStar.List.Tot.nth@tok (Tm_arrow_1771 Prims.nat)) :named function_token_typing_FStar.List.Tot.nth))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 (Prims.list @x0)) (HasType @x2 Prims.nat)) (HasType (FStar.List.Tot.nth @x0 @x1 @x2) (Prims.option @x0))) :pattern ((FStar.List.Tot.nth @x0 @x1 @x2)))) :named typing_FStar.List.Tot.nth))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTF FStar.List.Tot.nth__1776 @u0) @x1) @x2) @x3) (FStar.List.Tot.nth__1775 @u0 @x1 @x2 @x3)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTF FStar.List.Tot.nth__1776 @u0) @x1) @x2) @x3)))) :named fuel_tokem_correspondence_FStar.List.Tot.nth__1776))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 (Prims.list @x1)) (HasType @x3 Prims.nat)) (HasType (FStar.List.Tot.nth__1775 @u0 @x1 @x2 @x3) (Prims.option @x1))) :pattern ((FStar.List.Tot.nth__1775 @u0 @x1 @x2 @x3)))) :named token_correspondence_FStar.List.Tot.nth__1775))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (FStar.List.Tot.nth @x0 @x1 @x2) (FStar.List.Tot.nth__1775 MaxFuel @x0 @x1 @x2)) :pattern ((FStar.List.Tot.nth @x0 @x1 @x2)))) :named fuel_correspondence_FStar.List.Tot.nth__1775))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (FStar.List.Tot.nth__1775 (SFuel @u0) @x1 @x2 @x3) (FStar.List.Tot.nth__1775 ZFuel @x1 @x2 @x3)) :pattern ((FStar.List.Tot.nth__1775 (SFuel @u0) @x1 @x2 @x3)))) :named fuel_irrelevance_FStar.List.Tot.nth__1775))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (FStar.List.Tot.nth__1775 (SFuel @u0) @x1 @x2 @x3) (ite (is-Prims.Nil @x2) (Prims.None @x1) (ite (is-Prims.Cons @x2) (ite (= (Prims.op_Equality Prims.int @x3 (BoxInt 0)) (BoxBool true)) (Prims.Some @x1 (Prims.Cons_hd @x2)) (ite true (FStar.List.Tot.nth__1775 @u0 @x1 (Prims.Cons_tl @x2) (Prims.op_Subtraction @x3 (BoxInt 1))) Tm_unit)) Tm_unit))) :pattern ((FStar.List.Tot.nth__1775 (SFuel @u0) @x1 @x2 @x3)))) :named equation_with_fuel_FStar.List.Tot.nth__1775))
(declare-fun FStar.List.Tot.count__1782 (Fuel Term Term Term) Term)
(declare-fun FStar.List.Tot.count__1783 () Term)
(declare-fun FStar.List.Tot.count (Term Term Term) Term)
(declare-fun Tm_arrow_1778 (Term Term) Term)
(declare-fun FStar.List.Tot.count@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (HasType (Tm_arrow_1778 @x0 @x1) Tm_type) :pattern ((HasType (Tm_arrow_1778 @x0 @x1) Tm_type)))) :named kinding_Tm_arrow_1778))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_1778 @x2 @x3)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_1778 @x2 @x3))))) :named pre_typing_Tm_arrow_1778))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_1778 @x1 @x2)) (forall ((@x3 Term) (@x4 Term) (@x5 Term)) (! (implies (and (HasType @x3 @x2) (HasType @x4 @x3) (HasType @x5 (Prims.list @x3))) (HasType (ApplyTT (ApplyTT (ApplyTT @x0 @x3) @x4) @x5) @x1)) :pattern ((ApplyTT (ApplyTT (ApplyTT @x0 @x3) @x4) @x5))))) :pattern ((HasTypeZ @x0 (Tm_arrow_1778 @x1 @x2))))) :named interpretation_Tm_arrow_1778))
(assert (! (= 1780 (Term_constr_id FStar.List.Tot.count@tok)) :named fresh_token_FStar.List.Tot.count@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT FStar.List.Tot.count@tok @x0) @x1) @x2) (FStar.List.Tot.count @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT FStar.List.Tot.count@tok @x0) @x1) @x2)))) :named token_correspondence_FStar.List.Tot.count))
(assert (! (HasType FStar.List.Tot.count@tok (Tm_arrow_1778 Prims.nat Prims.eqtype)) :named function_token_typing_FStar.List.Tot.count))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Prims.eqtype) (HasType @x1 @x0) (HasType @x2 (Prims.list @x0))) (HasType (FStar.List.Tot.count @x0 @x1 @x2) Prims.nat)) :pattern ((FStar.List.Tot.count @x0 @x1 @x2)))) :named typing_FStar.List.Tot.count))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTF FStar.List.Tot.count__1783 @u0) @x1) @x2) @x3) (FStar.List.Tot.count__1782 @u0 @x1 @x2 @x3)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTF FStar.List.Tot.count__1783 @u0) @x1) @x2) @x3)))) :named fuel_tokem_correspondence_FStar.List.Tot.count__1783))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x1 Prims.eqtype) (HasType @x2 @x1) (HasType @x3 (Prims.list @x1))) (HasType (FStar.List.Tot.count__1782 @u0 @x1 @x2 @x3) Prims.nat)) :pattern ((FStar.List.Tot.count__1782 @u0 @x1 @x2 @x3)))) :named token_correspondence_FStar.List.Tot.count__1782))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (FStar.List.Tot.count @x0 @x1 @x2) (FStar.List.Tot.count__1782 MaxFuel @x0 @x1 @x2)) :pattern ((FStar.List.Tot.count @x0 @x1 @x2)))) :named fuel_correspondence_FStar.List.Tot.count__1782))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (FStar.List.Tot.count__1782 (SFuel @u0) @x1 @x2 @x3) (FStar.List.Tot.count__1782 ZFuel @x1 @x2 @x3)) :pattern ((FStar.List.Tot.count__1782 (SFuel @u0) @x1 @x2 @x3)))) :named fuel_irrelevance_FStar.List.Tot.count__1782))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (FStar.List.Tot.count__1782 (SFuel @u0) @x1 @x2 @x3) (ite (is-Prims.Nil @x3) (BoxInt 0) (ite (is-Prims.Cons @x3) (ite (= (Prims.op_Equality @x1 @x2 (Prims.Cons_hd @x3)) (BoxBool true)) (Prims.op_Addition (BoxInt 1) (FStar.List.Tot.count__1782 @u0 @x1 @x2 (Prims.Cons_tl @x3))) (ite true (FStar.List.Tot.count__1782 @u0 @x1 @x2 (Prims.Cons_tl @x3)) Tm_unit)) Tm_unit))) :pattern ((FStar.List.Tot.count__1782 (SFuel @u0) @x1 @x2 @x3)))) :named equation_with_fuel_FStar.List.Tot.count__1782))
(declare-fun FStar.List.Tot.rev_acc__1789 (Fuel Term Term Term) Term)
(declare-fun FStar.List.Tot.rev_acc__1790 () Term)
(declare-fun FStar.List.Tot.rev_acc (Term Term Term) Term)
(declare-fun Tm_arrow_1785 () Term)
(declare-fun FStar.List.Tot.rev_acc@tok () Term)
(assert (! (HasType Tm_arrow_1785 Tm_type) :named kinding_Tm_arrow_1785))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_1785) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_1785)))) :named pre_typing_Tm_arrow_1785))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_1785) (forall ((@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 (Prims.list @x1)) (HasType @x3 (Prims.list @x1))) (HasType (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) (Prims.list @x1))) :pattern ((ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3))))) :pattern ((HasTypeZ @x0 Tm_arrow_1785)))) :named interpretation_Tm_arrow_1785))
(assert (! (= 1787 (Term_constr_id FStar.List.Tot.rev_acc@tok)) :named fresh_token_FStar.List.Tot.rev_acc@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT FStar.List.Tot.rev_acc@tok @x0) @x1) @x2) (FStar.List.Tot.rev_acc @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT FStar.List.Tot.rev_acc@tok @x0) @x1) @x2)))) :named token_correspondence_FStar.List.Tot.rev_acc))
(assert (! (HasType FStar.List.Tot.rev_acc@tok Tm_arrow_1785) :named function_token_typing_FStar.List.Tot.rev_acc))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 (Prims.list @x0)) (HasType @x2 (Prims.list @x0))) (HasType (FStar.List.Tot.rev_acc @x0 @x1 @x2) (Prims.list @x0))) :pattern ((FStar.List.Tot.rev_acc @x0 @x1 @x2)))) :named typing_FStar.List.Tot.rev_acc))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTF FStar.List.Tot.rev_acc__1790 @u0) @x1) @x2) @x3) (FStar.List.Tot.rev_acc__1789 @u0 @x1 @x2 @x3)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTF FStar.List.Tot.rev_acc__1790 @u0) @x1) @x2) @x3)))) :named fuel_tokem_correspondence_FStar.List.Tot.rev_acc__1790))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 (Prims.list @x1)) (HasType @x3 (Prims.list @x1))) (HasType (FStar.List.Tot.rev_acc__1789 @u0 @x1 @x2 @x3) (Prims.list @x1))) :pattern ((FStar.List.Tot.rev_acc__1789 @u0 @x1 @x2 @x3)))) :named token_correspondence_FStar.List.Tot.rev_acc__1789))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (FStar.List.Tot.rev_acc @x0 @x1 @x2) (FStar.List.Tot.rev_acc__1789 MaxFuel @x0 @x1 @x2)) :pattern ((FStar.List.Tot.rev_acc @x0 @x1 @x2)))) :named fuel_correspondence_FStar.List.Tot.rev_acc__1789))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (FStar.List.Tot.rev_acc__1789 (SFuel @u0) @x1 @x2 @x3) (FStar.List.Tot.rev_acc__1789 ZFuel @x1 @x2 @x3)) :pattern ((FStar.List.Tot.rev_acc__1789 (SFuel @u0) @x1 @x2 @x3)))) :named fuel_irrelevance_FStar.List.Tot.rev_acc__1789))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (FStar.List.Tot.rev_acc__1789 (SFuel @u0) @x1 @x2 @x3) (ite (is-Prims.Nil @x2) @x3 (ite (is-Prims.Cons @x2) (FStar.List.Tot.rev_acc__1789 @u0 @x1 (Prims.Cons_tl @x2) (Prims.Cons @x1 (Prims.Cons_hd @x2) @x3)) Tm_unit))) :pattern ((FStar.List.Tot.rev_acc__1789 (SFuel @u0) @x1 @x2 @x3)))) :named equation_with_fuel_FStar.List.Tot.rev_acc__1789))
(declare-fun FStar.List.Tot.rev (Term Term) Term)
(declare-fun Tm_arrow_1792 () Term)
(assert (! (HasType Tm_arrow_1792 Tm_type) :named kinding_Tm_arrow_1792))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_1792) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_1792)))) :named pre_typing_Tm_arrow_1792))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_1792) (forall ((@x1 Term) (@x2 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 (Prims.list @x1))) (HasType (ApplyTT (ApplyTT @x0 @x1) @x2) (Prims.list @x1))) :pattern ((ApplyTT (ApplyTT @x0 @x1) @x2))))) :pattern ((HasTypeZ @x0 Tm_arrow_1792)))) :named interpretation_Tm_arrow_1792))
(declare-fun FStar.List.Tot.rev@tok () Term)
(assert (! (= 1794 (Term_constr_id FStar.List.Tot.rev@tok)) :named fresh_token_FStar.List.Tot.rev@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (ApplyTT (ApplyTT FStar.List.Tot.rev@tok @x0) @x1) (FStar.List.Tot.rev @x0 @x1)) :pattern ((ApplyTT (ApplyTT FStar.List.Tot.rev@tok @x0) @x1)))) :named token_correspondence_FStar.List.Tot.rev))
(assert (! (HasType FStar.List.Tot.rev@tok Tm_arrow_1792) :named function_token_typing_FStar.List.Tot.rev))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 (Prims.list @x0))) (HasType (FStar.List.Tot.rev @x0 @x1) (Prims.list @x0))) :pattern ((FStar.List.Tot.rev @x0 @x1)))) :named typing_FStar.List.Tot.rev))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (FStar.List.Tot.rev @x0 @x1) (FStar.List.Tot.rev_acc @x0 @x1 (Prims.Nil @x0))) :pattern ((FStar.List.Tot.rev @x0 @x1)))) :named equation_FStar.List.Tot.rev))
(declare-fun FStar.List.Tot.append__1798 (Fuel Term Term Term) Term)
(declare-fun FStar.List.Tot.append__1799 () Term)
(declare-fun FStar.List.Tot.append (Term Term Term) Term)
(declare-fun FStar.List.Tot.append@tok () Term)
(assert (! (= 1796 (Term_constr_id FStar.List.Tot.append@tok)) :named fresh_token_FStar.List.Tot.append@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT FStar.List.Tot.append@tok @x0) @x1) @x2) (FStar.List.Tot.append @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT FStar.List.Tot.append@tok @x0) @x1) @x2)))) :named token_correspondence_FStar.List.Tot.append))
(assert (! (HasType FStar.List.Tot.append@tok Tm_arrow_1785) :named function_token_typing_FStar.List.Tot.append))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 (Prims.list @x0)) (HasType @x2 (Prims.list @x0))) (HasType (FStar.List.Tot.append @x0 @x1 @x2) (Prims.list @x0))) :pattern ((FStar.List.Tot.append @x0 @x1 @x2)))) :named typing_FStar.List.Tot.append))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTF FStar.List.Tot.append__1799 @u0) @x1) @x2) @x3) (FStar.List.Tot.append__1798 @u0 @x1 @x2 @x3)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTF FStar.List.Tot.append__1799 @u0) @x1) @x2) @x3)))) :named fuel_tokem_correspondence_FStar.List.Tot.append__1799))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 (Prims.list @x1)) (HasType @x3 (Prims.list @x1))) (HasType (FStar.List.Tot.append__1798 @u0 @x1 @x2 @x3) (Prims.list @x1))) :pattern ((FStar.List.Tot.append__1798 @u0 @x1 @x2 @x3)))) :named token_correspondence_FStar.List.Tot.append__1798))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (FStar.List.Tot.append @x0 @x1 @x2) (FStar.List.Tot.append__1798 MaxFuel @x0 @x1 @x2)) :pattern ((FStar.List.Tot.append @x0 @x1 @x2)))) :named fuel_correspondence_FStar.List.Tot.append__1798))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (FStar.List.Tot.append__1798 (SFuel @u0) @x1 @x2 @x3) (FStar.List.Tot.append__1798 ZFuel @x1 @x2 @x3)) :pattern ((FStar.List.Tot.append__1798 (SFuel @u0) @x1 @x2 @x3)))) :named fuel_irrelevance_FStar.List.Tot.append__1798))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (FStar.List.Tot.append__1798 (SFuel @u0) @x1 @x2 @x3) (ite (is-Prims.Nil @x2) @x3 (ite (is-Prims.Cons @x2) (Prims.Cons @x1 (Prims.Cons_hd @x2) (FStar.List.Tot.append__1798 @u0 @x1 (Prims.Cons_tl @x2) @x3)) Tm_unit))) :pattern ((FStar.List.Tot.append__1798 (SFuel @u0) @x1 @x2 @x3)))) :named equation_with_fuel_FStar.List.Tot.append__1798))
(declare-fun FStar.List.Tot.op_At (Term Term Term) Term)
(declare-fun FStar.List.Tot.op_At@tok () Term)
(assert (! (= 1801 (Term_constr_id FStar.List.Tot.op_At@tok)) :named fresh_token_FStar.List.Tot.op_At@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT FStar.List.Tot.op_At@tok @x0) @x1) @x2) (FStar.List.Tot.op_At @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT FStar.List.Tot.op_At@tok @x0) @x1) @x2)))) :named token_correspondence_FStar.List.Tot.op_At))
(assert (! (HasType FStar.List.Tot.op_At@tok Tm_arrow_1785) :named function_token_typing_FStar.List.Tot.op_At))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 (Prims.list @x0)) (HasType @x2 (Prims.list @x0))) (HasType (FStar.List.Tot.op_At @x0 @x1 @x2) (Prims.list @x0))) :pattern ((FStar.List.Tot.op_At @x0 @x1 @x2)))) :named typing_FStar.List.Tot.op_At))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (FStar.List.Tot.op_At @x0 @x1 @x2) (FStar.List.Tot.append @x0 @x1 @x2)) :pattern ((FStar.List.Tot.op_At @x0 @x1 @x2)))) :named equation_FStar.List.Tot.op_At))
(declare-fun FStar.List.Tot.flatten__1807 (Fuel Term Term) Term)
(declare-fun FStar.List.Tot.flatten__1808 () Term)
(declare-fun FStar.List.Tot.flatten (Term Term) Term)
(declare-fun Tm_arrow_1803 () Term)
(declare-fun FStar.List.Tot.flatten@tok () Term)
(assert (! (HasType Tm_arrow_1803 Tm_type) :named kinding_Tm_arrow_1803))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_1803) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_1803)))) :named pre_typing_Tm_arrow_1803))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_1803) (forall ((@x1 Term) (@x2 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 (Prims.list (Prims.list @x1)))) (HasType (ApplyTT (ApplyTT @x0 @x1) @x2) (Prims.list @x1))) :pattern ((ApplyTT (ApplyTT @x0 @x1) @x2))))) :pattern ((HasTypeZ @x0 Tm_arrow_1803)))) :named interpretation_Tm_arrow_1803))
(assert (! (= 1805 (Term_constr_id FStar.List.Tot.flatten@tok)) :named fresh_token_FStar.List.Tot.flatten@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (ApplyTT (ApplyTT FStar.List.Tot.flatten@tok @x0) @x1) (FStar.List.Tot.flatten @x0 @x1)) :pattern ((ApplyTT (ApplyTT FStar.List.Tot.flatten@tok @x0) @x1)))) :named token_correspondence_FStar.List.Tot.flatten))
(assert (! (HasType FStar.List.Tot.flatten@tok Tm_arrow_1803) :named function_token_typing_FStar.List.Tot.flatten))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 (Prims.list (Prims.list @x0)))) (HasType (FStar.List.Tot.flatten @x0 @x1) (Prims.list @x0))) :pattern ((FStar.List.Tot.flatten @x0 @x1)))) :named typing_FStar.List.Tot.flatten))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTF FStar.List.Tot.flatten__1808 @u0) @x1) @x2) (FStar.List.Tot.flatten__1807 @u0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTF FStar.List.Tot.flatten__1808 @u0) @x1) @x2)))) :named fuel_tokem_correspondence_FStar.List.Tot.flatten__1808))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 (Prims.list (Prims.list @x1)))) (HasType (FStar.List.Tot.flatten__1807 @u0 @x1 @x2) (Prims.list @x1))) :pattern ((FStar.List.Tot.flatten__1807 @u0 @x1 @x2)))) :named token_correspondence_FStar.List.Tot.flatten__1807))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (FStar.List.Tot.flatten @x0 @x1) (FStar.List.Tot.flatten__1807 MaxFuel @x0 @x1)) :pattern ((FStar.List.Tot.flatten @x0 @x1)))) :named fuel_correspondence_FStar.List.Tot.flatten__1807))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (= (FStar.List.Tot.flatten__1807 (SFuel @u0) @x1 @x2) (FStar.List.Tot.flatten__1807 ZFuel @x1 @x2)) :pattern ((FStar.List.Tot.flatten__1807 (SFuel @u0) @x1 @x2)))) :named fuel_irrelevance_FStar.List.Tot.flatten__1807))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (= (FStar.List.Tot.flatten__1807 (SFuel @u0) @x1 @x2) (ite (is-Prims.Nil @x2) (Prims.Nil @x1) (ite (is-Prims.Cons @x2) (FStar.List.Tot.append @x1 (Prims.Cons_hd @x2) (FStar.List.Tot.flatten__1807 @u0 @x1 (Prims.Cons_tl @x2))) Tm_unit))) :pattern ((FStar.List.Tot.flatten__1807 (SFuel @u0) @x1 @x2)))) :named equation_with_fuel_FStar.List.Tot.flatten__1807))
(declare-fun FStar.List.Tot.iter__1816 (Fuel Term Term Term) Term)
(declare-fun FStar.List.Tot.iter__1817 () Term)
(declare-fun FStar.List.Tot.iter (Term Term Term) Term)
(declare-fun Tm_arrow_1812 (Term) Term)
(declare-fun FStar.List.Tot.iter@tok () Term)
(assert (! (forall ((@x0 Term)) (! (HasType (Tm_arrow_1812 @x0) Tm_type) :pattern ((HasType (Tm_arrow_1812 @x0) Tm_type)))) :named kinding_Tm_arrow_1812))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_1812 @x2)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_1812 @x2))))) :named pre_typing_Tm_arrow_1812))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_1812 @x1)) (forall ((@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x2 Tm_type) (HasType @x3 (Tm_arrow_228 @x1 @x2)) (HasType @x4 (Prims.list @x2))) (HasType (ApplyTT (ApplyTT (ApplyTT @x0 @x2) @x3) @x4) @x1)) :pattern ((ApplyTT (ApplyTT (ApplyTT @x0 @x2) @x3) @x4))))) :pattern ((HasTypeZ @x0 (Tm_arrow_1812 @x1))))) :named interpretation_Tm_arrow_1812))
(assert (! (= 1814 (Term_constr_id FStar.List.Tot.iter@tok)) :named fresh_token_FStar.List.Tot.iter@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT FStar.List.Tot.iter@tok @x0) @x1) @x2) (FStar.List.Tot.iter @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT FStar.List.Tot.iter@tok @x0) @x1) @x2)))) :named token_correspondence_FStar.List.Tot.iter))
(assert (! (HasType FStar.List.Tot.iter@tok (Tm_arrow_1812 Prims.unit)) :named function_token_typing_FStar.List.Tot.iter))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 (Tm_arrow_228 Prims.unit @x0)) (HasType @x2 (Prims.list @x0))) (HasType (FStar.List.Tot.iter @x0 @x1 @x2) Prims.unit)) :pattern ((FStar.List.Tot.iter @x0 @x1 @x2)))) :named typing_FStar.List.Tot.iter))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTF FStar.List.Tot.iter__1817 @u0) @x1) @x2) @x3) (FStar.List.Tot.iter__1816 @u0 @x1 @x2 @x3)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTF FStar.List.Tot.iter__1817 @u0) @x1) @x2) @x3)))) :named fuel_tokem_correspondence_FStar.List.Tot.iter__1817))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 (Tm_arrow_228 Prims.unit @x1)) (HasType @x3 (Prims.list @x1))) (HasType (FStar.List.Tot.iter__1816 @u0 @x1 @x2 @x3) Prims.unit)) :pattern ((FStar.List.Tot.iter__1816 @u0 @x1 @x2 @x3)))) :named token_correspondence_FStar.List.Tot.iter__1816))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (FStar.List.Tot.iter @x0 @x1 @x2) (FStar.List.Tot.iter__1816 MaxFuel @x0 @x1 @x2)) :pattern ((FStar.List.Tot.iter @x0 @x1 @x2)))) :named fuel_correspondence_FStar.List.Tot.iter__1816))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (FStar.List.Tot.iter__1816 (SFuel @u0) @x1 @x2 @x3) (FStar.List.Tot.iter__1816 ZFuel @x1 @x2 @x3)) :pattern ((FStar.List.Tot.iter__1816 (SFuel @u0) @x1 @x2 @x3)))) :named fuel_irrelevance_FStar.List.Tot.iter__1816))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (FStar.List.Tot.iter__1816 (SFuel @u0) @x1 @x2 @x3) (ite (is-Prims.Nil @x3) Tm_unit (ite (is-Prims.Cons @x3) (FStar.List.Tot.iter__1816 @u0 @x1 @x2 (Prims.Cons_tl @x3)) Tm_unit))) :pattern ((FStar.List.Tot.iter__1816 (SFuel @u0) @x1 @x2 @x3)))) :named equation_with_fuel_FStar.List.Tot.iter__1816))
(declare-fun FStar.List.Tot.map__1827 (Fuel Term Term Term Term) Term)
(declare-fun FStar.List.Tot.map__1828 () Term)
(declare-fun FStar.List.Tot.map (Term Term Term Term) Term)
(declare-fun Tm_arrow_1823 () Term)
(declare-fun FStar.List.Tot.map@tok () Term)
(assert (! (HasType Tm_arrow_1823 Tm_type) :named kinding_Tm_arrow_1823))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_1823) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_1823)))) :named pre_typing_Tm_arrow_1823))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_1823) (forall ((@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 (Tm_arrow_228 @x2 @x1)) (HasType @x4 (Prims.list @x1))) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) (Prims.list @x2))) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4))))) :pattern ((HasTypeZ @x0 Tm_arrow_1823)))) :named interpretation_Tm_arrow_1823))
(assert (! (= 1825 (Term_constr_id FStar.List.Tot.map@tok)) :named fresh_token_FStar.List.Tot.map@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.List.Tot.map@tok @x0) @x1) @x2) @x3) (FStar.List.Tot.map @x0 @x1 @x2 @x3)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.List.Tot.map@tok @x0) @x1) @x2) @x3)))) :named token_correspondence_FStar.List.Tot.map))
(assert (! (HasType FStar.List.Tot.map@tok Tm_arrow_1823) :named function_token_typing_FStar.List.Tot.map))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 (Tm_arrow_228 @x1 @x0)) (HasType @x3 (Prims.list @x0))) (HasType (FStar.List.Tot.map @x0 @x1 @x2 @x3) (Prims.list @x1))) :pattern ((FStar.List.Tot.map @x0 @x1 @x2 @x3)))) :named typing_FStar.List.Tot.map))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTF FStar.List.Tot.map__1828 @u0) @x1) @x2) @x3) @x4) (FStar.List.Tot.map__1827 @u0 @x1 @x2 @x3 @x4)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTF FStar.List.Tot.map__1828 @u0) @x1) @x2) @x3) @x4)))) :named fuel_tokem_correspondence_FStar.List.Tot.map__1828))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 (Tm_arrow_228 @x2 @x1)) (HasType @x4 (Prims.list @x1))) (HasType (FStar.List.Tot.map__1827 @u0 @x1 @x2 @x3 @x4) (Prims.list @x2))) :pattern ((FStar.List.Tot.map__1827 @u0 @x1 @x2 @x3 @x4)))) :named token_correspondence_FStar.List.Tot.map__1827))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (FStar.List.Tot.map @x0 @x1 @x2 @x3) (FStar.List.Tot.map__1827 MaxFuel @x0 @x1 @x2 @x3)) :pattern ((FStar.List.Tot.map @x0 @x1 @x2 @x3)))) :named fuel_correspondence_FStar.List.Tot.map__1827))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (= (FStar.List.Tot.map__1827 (SFuel @u0) @x1 @x2 @x3 @x4) (FStar.List.Tot.map__1827 ZFuel @x1 @x2 @x3 @x4)) :pattern ((FStar.List.Tot.map__1827 (SFuel @u0) @x1 @x2 @x3 @x4)))) :named fuel_irrelevance_FStar.List.Tot.map__1827))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (= (FStar.List.Tot.map__1827 (SFuel @u0) @x1 @x2 @x3 @x4) (ite (is-Prims.Nil @x4) (Prims.Nil @x2) (ite (is-Prims.Cons @x4) (Prims.Cons @x2 (ApplyTT @x3 (Prims.Cons_hd @x4)) (FStar.List.Tot.map__1827 @u0 @x1 @x2 @x3 (Prims.Cons_tl @x4))) Tm_unit))) :pattern ((FStar.List.Tot.map__1827 (SFuel @u0) @x1 @x2 @x3 @x4)))) :named equation_with_fuel_FStar.List.Tot.map__1827))
(declare-fun FStar.List.Tot.mapi_init__1840 (Fuel Term Term Term Term Term) Term)
(declare-fun FStar.List.Tot.mapi_init__1841 () Term)
(declare-fun Tm_arrow_1832 (Term Term Term) Term)
(declare-fun FStar.List.Tot.mapi_init (Term Term Term Term Term) Term)
(declare-fun Tm_arrow_1836 (Term) Term)
(declare-fun FStar.List.Tot.mapi_init@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (HasType (Tm_arrow_1832 @x0 @x1 @x2) Tm_type) :pattern ((HasType (Tm_arrow_1832 @x0 @x1 @x2) Tm_type)))) :named kinding_Tm_arrow_1832))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_1832 @x2 @x3 @x4)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_1832 @x2 @x3 @x4))))) :named pre_typing_Tm_arrow_1832))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_1832 @x1 @x2 @x3)) (forall ((@x4 Term) (@x5 Term)) (! (implies (and (HasType @x4 @x3) (HasType @x5 @x2)) (HasType (ApplyTT (ApplyTT @x0 @x4) @x5) @x1)) :pattern ((ApplyTT (ApplyTT @x0 @x4) @x5))))) :pattern ((HasTypeZ @x0 (Tm_arrow_1832 @x1 @x2 @x3))))) :named interpretation_Tm_arrow_1832))
(assert (! (forall ((@x0 Term)) (! (HasType (Tm_arrow_1836 @x0) Tm_type) :pattern ((HasType (Tm_arrow_1836 @x0) Tm_type)))) :named kinding_Tm_arrow_1836))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_1836 @x2)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_1836 @x2))))) :named pre_typing_Tm_arrow_1836))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_1836 @x1)) (forall ((@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term)) (! (implies (and (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 (Tm_arrow_1832 @x3 @x2 @x1)) (HasType @x5 (Prims.list @x2)) (HasType @x6 @x1)) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x2) @x3) @x4) @x5) @x6) (Prims.list @x3))) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x2) @x3) @x4) @x5) @x6))))) :pattern ((HasTypeZ @x0 (Tm_arrow_1836 @x1))))) :named interpretation_Tm_arrow_1836))
(assert (! (= 1838 (Term_constr_id FStar.List.Tot.mapi_init@tok)) :named fresh_token_FStar.List.Tot.mapi_init@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.List.Tot.mapi_init@tok @x0) @x1) @x2) @x3) @x4) (FStar.List.Tot.mapi_init @x0 @x1 @x2 @x3 @x4)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.List.Tot.mapi_init@tok @x0) @x1) @x2) @x3) @x4)))) :named token_correspondence_FStar.List.Tot.mapi_init))
(assert (! (HasType FStar.List.Tot.mapi_init@tok (Tm_arrow_1836 Prims.int)) :named function_token_typing_FStar.List.Tot.mapi_init))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 (Tm_arrow_1832 @x1 @x0 Prims.int)) (HasType @x3 (Prims.list @x0)) (HasType @x4 Prims.int)) (HasType (FStar.List.Tot.mapi_init @x0 @x1 @x2 @x3 @x4) (Prims.list @x1))) :pattern ((FStar.List.Tot.mapi_init @x0 @x1 @x2 @x3 @x4)))) :named typing_FStar.List.Tot.mapi_init))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTF FStar.List.Tot.mapi_init__1841 @u0) @x1) @x2) @x3) @x4) @x5) (FStar.List.Tot.mapi_init__1840 @u0 @x1 @x2 @x3 @x4 @x5)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTF FStar.List.Tot.mapi_init__1841 @u0) @x1) @x2) @x3) @x4) @x5)))) :named fuel_tokem_correspondence_FStar.List.Tot.mapi_init__1841))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 (Tm_arrow_1832 @x2 @x1 Prims.int)) (HasType @x4 (Prims.list @x1)) (HasType @x5 Prims.int)) (HasType (FStar.List.Tot.mapi_init__1840 @u0 @x1 @x2 @x3 @x4 @x5) (Prims.list @x2))) :pattern ((FStar.List.Tot.mapi_init__1840 @u0 @x1 @x2 @x3 @x4 @x5)))) :named token_correspondence_FStar.List.Tot.mapi_init__1840))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (= (FStar.List.Tot.mapi_init @x0 @x1 @x2 @x3 @x4) (FStar.List.Tot.mapi_init__1840 MaxFuel @x0 @x1 @x2 @x3 @x4)) :pattern ((FStar.List.Tot.mapi_init @x0 @x1 @x2 @x3 @x4)))) :named fuel_correspondence_FStar.List.Tot.mapi_init__1840))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (= (FStar.List.Tot.mapi_init__1840 (SFuel @u0) @x1 @x2 @x3 @x4 @x5) (FStar.List.Tot.mapi_init__1840 ZFuel @x1 @x2 @x3 @x4 @x5)) :pattern ((FStar.List.Tot.mapi_init__1840 (SFuel @u0) @x1 @x2 @x3 @x4 @x5)))) :named fuel_irrelevance_FStar.List.Tot.mapi_init__1840))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (= (FStar.List.Tot.mapi_init__1840 (SFuel @u0) @x1 @x2 @x3 @x4 @x5) (ite (is-Prims.Nil @x4) (Prims.Nil @x2) (ite (is-Prims.Cons @x4) (Prims.Cons @x2 (ApplyTT (ApplyTT @x3 @x5) (Prims.Cons_hd @x4)) (FStar.List.Tot.mapi_init__1840 @u0 @x1 @x2 @x3 (Prims.Cons_tl @x4) (Prims.op_Addition @x5 (BoxInt 1)))) Tm_unit))) :pattern ((FStar.List.Tot.mapi_init__1840 (SFuel @u0) @x1 @x2 @x3 @x4 @x5)))) :named equation_with_fuel_FStar.List.Tot.mapi_init__1840))
(declare-fun FStar.List.Tot.mapi (Term Term Term Term) Term)
(declare-fun Tm_arrow_1847 (Term) Term)
(assert (! (forall ((@x0 Term)) (! (HasType (Tm_arrow_1847 @x0) Tm_type) :pattern ((HasType (Tm_arrow_1847 @x0) Tm_type)))) :named kinding_Tm_arrow_1847))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_1847 @x2)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_1847 @x2))))) :named pre_typing_Tm_arrow_1847))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_1847 @x1)) (forall ((@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (implies (and (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 (Tm_arrow_1832 @x3 @x2 @x1)) (HasType @x5 (Prims.list @x2))) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x2) @x3) @x4) @x5) (Prims.list @x3))) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x2) @x3) @x4) @x5))))) :pattern ((HasTypeZ @x0 (Tm_arrow_1847 @x1))))) :named interpretation_Tm_arrow_1847))
(declare-fun FStar.List.Tot.mapi@tok () Term)
(assert (! (= 1849 (Term_constr_id FStar.List.Tot.mapi@tok)) :named fresh_token_FStar.List.Tot.mapi@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.List.Tot.mapi@tok @x0) @x1) @x2) @x3) (FStar.List.Tot.mapi @x0 @x1 @x2 @x3)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.List.Tot.mapi@tok @x0) @x1) @x2) @x3)))) :named token_correspondence_FStar.List.Tot.mapi))
(assert (! (HasType FStar.List.Tot.mapi@tok (Tm_arrow_1847 Prims.int)) :named function_token_typing_FStar.List.Tot.mapi))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 (Tm_arrow_1832 @x1 @x0 Prims.int)) (HasType @x3 (Prims.list @x0))) (HasType (FStar.List.Tot.mapi @x0 @x1 @x2 @x3) (Prims.list @x1))) :pattern ((FStar.List.Tot.mapi @x0 @x1 @x2 @x3)))) :named typing_FStar.List.Tot.mapi))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (FStar.List.Tot.mapi @x0 @x1 @x2 @x3) (FStar.List.Tot.mapi_init @x0 @x1 @x2 @x3 (BoxInt 0))) :pattern ((FStar.List.Tot.mapi @x0 @x1 @x2 @x3)))) :named equation_FStar.List.Tot.mapi))
(declare-fun FStar.List.Tot.concatMap__1860 (Fuel Term Term Term Term) Term)
(declare-fun FStar.List.Tot.concatMap__1861 () Term)
(declare-fun Tm_arrow_1852 (Term Term) Term)
(declare-fun FStar.List.Tot.concatMap (Term Term Term Term) Term)
(declare-fun Tm_arrow_1856 () Term)
(declare-fun FStar.List.Tot.concatMap@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (HasType (Tm_arrow_1852 @x0 @x1) Tm_type) :pattern ((HasType (Tm_arrow_1852 @x0 @x1) Tm_type)))) :named kinding_Tm_arrow_1852))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_1852 @x2 @x3)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_1852 @x2 @x3))))) :named pre_typing_Tm_arrow_1852))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_1852 @x1 @x2)) (forall ((@x3 Term)) (! (implies (HasType @x3 @x2) (HasType (ApplyTT @x0 @x3) (Prims.list @x1))) :pattern ((ApplyTT @x0 @x3))))) :pattern ((HasTypeZ @x0 (Tm_arrow_1852 @x1 @x2))))) :named interpretation_Tm_arrow_1852))
(assert (! (HasType Tm_arrow_1856 Tm_type) :named kinding_Tm_arrow_1856))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_1856) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_1856)))) :named pre_typing_Tm_arrow_1856))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_1856) (forall ((@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 (Tm_arrow_1852 @x2 @x1)) (HasType @x4 (Prims.list @x1))) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) (Prims.list @x2))) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4))))) :pattern ((HasTypeZ @x0 Tm_arrow_1856)))) :named interpretation_Tm_arrow_1856))
(assert (! (= 1858 (Term_constr_id FStar.List.Tot.concatMap@tok)) :named fresh_token_FStar.List.Tot.concatMap@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.List.Tot.concatMap@tok @x0) @x1) @x2) @x3) (FStar.List.Tot.concatMap @x0 @x1 @x2 @x3)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.List.Tot.concatMap@tok @x0) @x1) @x2) @x3)))) :named token_correspondence_FStar.List.Tot.concatMap))
(assert (! (HasType FStar.List.Tot.concatMap@tok Tm_arrow_1856) :named function_token_typing_FStar.List.Tot.concatMap))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 (Tm_arrow_1852 @x1 @x0)) (HasType @x3 (Prims.list @x0))) (HasType (FStar.List.Tot.concatMap @x0 @x1 @x2 @x3) (Prims.list @x1))) :pattern ((FStar.List.Tot.concatMap @x0 @x1 @x2 @x3)))) :named typing_FStar.List.Tot.concatMap))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTF FStar.List.Tot.concatMap__1861 @u0) @x1) @x2) @x3) @x4) (FStar.List.Tot.concatMap__1860 @u0 @x1 @x2 @x3 @x4)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTF FStar.List.Tot.concatMap__1861 @u0) @x1) @x2) @x3) @x4)))) :named fuel_tokem_correspondence_FStar.List.Tot.concatMap__1861))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 (Tm_arrow_1852 @x2 @x1)) (HasType @x4 (Prims.list @x1))) (HasType (FStar.List.Tot.concatMap__1860 @u0 @x1 @x2 @x3 @x4) (Prims.list @x2))) :pattern ((FStar.List.Tot.concatMap__1860 @u0 @x1 @x2 @x3 @x4)))) :named token_correspondence_FStar.List.Tot.concatMap__1860))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (FStar.List.Tot.concatMap @x0 @x1 @x2 @x3) (FStar.List.Tot.concatMap__1860 MaxFuel @x0 @x1 @x2 @x3)) :pattern ((FStar.List.Tot.concatMap @x0 @x1 @x2 @x3)))) :named fuel_correspondence_FStar.List.Tot.concatMap__1860))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (= (FStar.List.Tot.concatMap__1860 (SFuel @u0) @x1 @x2 @x3 @x4) (FStar.List.Tot.concatMap__1860 ZFuel @x1 @x2 @x3 @x4)) :pattern ((FStar.List.Tot.concatMap__1860 (SFuel @u0) @x1 @x2 @x3 @x4)))) :named fuel_irrelevance_FStar.List.Tot.concatMap__1860))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (= (FStar.List.Tot.concatMap__1860 (SFuel @u0) @x1 @x2 @x3 @x4) (ite (is-Prims.Nil @x4) (Prims.Nil @x2) (ite (is-Prims.Cons @x4) (FStar.List.Tot.append @x2 (ApplyTT @x3 (Prims.Cons_hd @x4)) (FStar.List.Tot.concatMap__1860 @u0 @x1 @x2 @x3 (Prims.Cons_tl @x4))) Tm_unit))) :pattern ((FStar.List.Tot.concatMap__1860 (SFuel @u0) @x1 @x2 @x3 @x4)))) :named equation_with_fuel_FStar.List.Tot.concatMap__1860))
(declare-fun FStar.List.Tot.fold_left__1873 (Fuel Term Term Term Term Term) Term)
(declare-fun FStar.List.Tot.fold_left__1874 () Term)
(declare-fun Tm_arrow_1865 (Term Term) Term)
(declare-fun FStar.List.Tot.fold_left (Term Term Term Term Term) Term)
(declare-fun Tm_arrow_1869 () Term)
(declare-fun FStar.List.Tot.fold_left@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (HasType (Tm_arrow_1865 @x0 @x1) Tm_type) :pattern ((HasType (Tm_arrow_1865 @x0 @x1) Tm_type)))) :named kinding_Tm_arrow_1865))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_1865 @x2 @x3)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_1865 @x2 @x3))))) :named pre_typing_Tm_arrow_1865))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_1865 @x1 @x2)) (forall ((@x3 Term) (@x4 Term)) (! (implies (and (HasType @x3 @x2) (HasType @x4 @x1)) (HasType (ApplyTT (ApplyTT @x0 @x3) @x4) @x2)) :pattern ((ApplyTT (ApplyTT @x0 @x3) @x4))))) :pattern ((HasTypeZ @x0 (Tm_arrow_1865 @x1 @x2))))) :named interpretation_Tm_arrow_1865))
(assert (! (HasType Tm_arrow_1869 Tm_type) :named kinding_Tm_arrow_1869))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_1869) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_1869)))) :named pre_typing_Tm_arrow_1869))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_1869) (forall ((@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 (Tm_arrow_1865 @x2 @x1)) (HasType @x4 @x1) (HasType @x5 (Prims.list @x2))) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x1)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5))))) :pattern ((HasTypeZ @x0 Tm_arrow_1869)))) :named interpretation_Tm_arrow_1869))
(assert (! (= 1871 (Term_constr_id FStar.List.Tot.fold_left@tok)) :named fresh_token_FStar.List.Tot.fold_left@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.List.Tot.fold_left@tok @x0) @x1) @x2) @x3) @x4) (FStar.List.Tot.fold_left @x0 @x1 @x2 @x3 @x4)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.List.Tot.fold_left@tok @x0) @x1) @x2) @x3) @x4)))) :named token_correspondence_FStar.List.Tot.fold_left))
(assert (! (HasType FStar.List.Tot.fold_left@tok Tm_arrow_1869) :named function_token_typing_FStar.List.Tot.fold_left))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 (Tm_arrow_1865 @x1 @x0)) (HasType @x3 @x0) (HasType @x4 (Prims.list @x1))) (HasType (FStar.List.Tot.fold_left @x0 @x1 @x2 @x3 @x4) @x0)) :pattern ((FStar.List.Tot.fold_left @x0 @x1 @x2 @x3 @x4)))) :named typing_FStar.List.Tot.fold_left))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTF FStar.List.Tot.fold_left__1874 @u0) @x1) @x2) @x3) @x4) @x5) (FStar.List.Tot.fold_left__1873 @u0 @x1 @x2 @x3 @x4 @x5)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTF FStar.List.Tot.fold_left__1874 @u0) @x1) @x2) @x3) @x4) @x5)))) :named fuel_tokem_correspondence_FStar.List.Tot.fold_left__1874))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 (Tm_arrow_1865 @x2 @x1)) (HasType @x4 @x1) (HasType @x5 (Prims.list @x2))) (HasType (FStar.List.Tot.fold_left__1873 @u0 @x1 @x2 @x3 @x4 @x5) @x1)) :pattern ((FStar.List.Tot.fold_left__1873 @u0 @x1 @x2 @x3 @x4 @x5)))) :named token_correspondence_FStar.List.Tot.fold_left__1873))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (= (FStar.List.Tot.fold_left @x0 @x1 @x2 @x3 @x4) (FStar.List.Tot.fold_left__1873 MaxFuel @x0 @x1 @x2 @x3 @x4)) :pattern ((FStar.List.Tot.fold_left @x0 @x1 @x2 @x3 @x4)))) :named fuel_correspondence_FStar.List.Tot.fold_left__1873))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (= (FStar.List.Tot.fold_left__1873 (SFuel @u0) @x1 @x2 @x3 @x4 @x5) (FStar.List.Tot.fold_left__1873 ZFuel @x1 @x2 @x3 @x4 @x5)) :pattern ((FStar.List.Tot.fold_left__1873 (SFuel @u0) @x1 @x2 @x3 @x4 @x5)))) :named fuel_irrelevance_FStar.List.Tot.fold_left__1873))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (= (FStar.List.Tot.fold_left__1873 (SFuel @u0) @x1 @x2 @x3 @x4 @x5) (ite (is-Prims.Nil @x5) @x4 (ite (is-Prims.Cons @x5) (FStar.List.Tot.fold_left__1873 @u0 @x1 @x2 @x3 (ApplyTT (ApplyTT @x3 @x4) (Prims.Cons_hd @x5)) (Prims.Cons_tl @x5)) Tm_unit))) :pattern ((FStar.List.Tot.fold_left__1873 (SFuel @u0) @x1 @x2 @x3 @x4 @x5)))) :named equation_with_fuel_FStar.List.Tot.fold_left__1873))
(declare-fun FStar.List.Tot.fold_right__1886 (Fuel Term Term Term Term Term) Term)
(declare-fun FStar.List.Tot.fold_right__1887 () Term)
(declare-fun Tm_arrow_1878 (Term Term) Term)
(declare-fun FStar.List.Tot.fold_right (Term Term Term Term Term) Term)
(declare-fun Tm_arrow_1882 () Term)
(declare-fun FStar.List.Tot.fold_right@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (HasType (Tm_arrow_1878 @x0 @x1) Tm_type) :pattern ((HasType (Tm_arrow_1878 @x0 @x1) Tm_type)))) :named kinding_Tm_arrow_1878))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_1878 @x2 @x3)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_1878 @x2 @x3))))) :named pre_typing_Tm_arrow_1878))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_1878 @x1 @x2)) (forall ((@x3 Term) (@x4 Term)) (! (implies (and (HasType @x3 @x2) (HasType @x4 @x1)) (HasType (ApplyTT (ApplyTT @x0 @x3) @x4) @x1)) :pattern ((ApplyTT (ApplyTT @x0 @x3) @x4))))) :pattern ((HasTypeZ @x0 (Tm_arrow_1878 @x1 @x2))))) :named interpretation_Tm_arrow_1878))
(assert (! (HasType Tm_arrow_1882 Tm_type) :named kinding_Tm_arrow_1882))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_1882) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_1882)))) :named pre_typing_Tm_arrow_1882))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_1882) (forall ((@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 (Tm_arrow_1878 @x2 @x1)) (HasType @x4 (Prims.list @x1)) (HasType @x5 @x2)) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5))))) :pattern ((HasTypeZ @x0 Tm_arrow_1882)))) :named interpretation_Tm_arrow_1882))
(assert (! (= 1884 (Term_constr_id FStar.List.Tot.fold_right@tok)) :named fresh_token_FStar.List.Tot.fold_right@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.List.Tot.fold_right@tok @x0) @x1) @x2) @x3) @x4) (FStar.List.Tot.fold_right @x0 @x1 @x2 @x3 @x4)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.List.Tot.fold_right@tok @x0) @x1) @x2) @x3) @x4)))) :named token_correspondence_FStar.List.Tot.fold_right))
(assert (! (HasType FStar.List.Tot.fold_right@tok Tm_arrow_1882) :named function_token_typing_FStar.List.Tot.fold_right))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 (Tm_arrow_1878 @x1 @x0)) (HasType @x3 (Prims.list @x0)) (HasType @x4 @x1)) (HasType (FStar.List.Tot.fold_right @x0 @x1 @x2 @x3 @x4) @x1)) :pattern ((FStar.List.Tot.fold_right @x0 @x1 @x2 @x3 @x4)))) :named typing_FStar.List.Tot.fold_right))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTF FStar.List.Tot.fold_right__1887 @u0) @x1) @x2) @x3) @x4) @x5) (FStar.List.Tot.fold_right__1886 @u0 @x1 @x2 @x3 @x4 @x5)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTF FStar.List.Tot.fold_right__1887 @u0) @x1) @x2) @x3) @x4) @x5)))) :named fuel_tokem_correspondence_FStar.List.Tot.fold_right__1887))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 (Tm_arrow_1878 @x2 @x1)) (HasType @x4 (Prims.list @x1)) (HasType @x5 @x2)) (HasType (FStar.List.Tot.fold_right__1886 @u0 @x1 @x2 @x3 @x4 @x5) @x2)) :pattern ((FStar.List.Tot.fold_right__1886 @u0 @x1 @x2 @x3 @x4 @x5)))) :named token_correspondence_FStar.List.Tot.fold_right__1886))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (= (FStar.List.Tot.fold_right @x0 @x1 @x2 @x3 @x4) (FStar.List.Tot.fold_right__1886 MaxFuel @x0 @x1 @x2 @x3 @x4)) :pattern ((FStar.List.Tot.fold_right @x0 @x1 @x2 @x3 @x4)))) :named fuel_correspondence_FStar.List.Tot.fold_right__1886))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (= (FStar.List.Tot.fold_right__1886 (SFuel @u0) @x1 @x2 @x3 @x4 @x5) (FStar.List.Tot.fold_right__1886 ZFuel @x1 @x2 @x3 @x4 @x5)) :pattern ((FStar.List.Tot.fold_right__1886 (SFuel @u0) @x1 @x2 @x3 @x4 @x5)))) :named fuel_irrelevance_FStar.List.Tot.fold_right__1886))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (= (FStar.List.Tot.fold_right__1886 (SFuel @u0) @x1 @x2 @x3 @x4 @x5) (ite (is-Prims.Nil @x4) @x5 (ite (is-Prims.Cons @x4) (ApplyTT (ApplyTT @x3 (Prims.Cons_hd @x4)) (FStar.List.Tot.fold_right__1886 @u0 @x1 @x2 @x3 (Prims.Cons_tl @x4) @x5)) Tm_unit))) :pattern ((FStar.List.Tot.fold_right__1886 (SFuel @u0) @x1 @x2 @x3 @x4 @x5)))) :named equation_with_fuel_FStar.List.Tot.fold_right__1886))
(declare-fun FStar.List.Tot.mem__1893 (Fuel Term Term Term) Term)
(declare-fun FStar.List.Tot.mem__1894 () Term)
(declare-fun FStar.List.Tot.mem (Term Term Term) Term)
(declare-fun FStar.List.Tot.mem@tok () Term)
(assert (! (= 1891 (Term_constr_id FStar.List.Tot.mem@tok)) :named fresh_token_FStar.List.Tot.mem@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT FStar.List.Tot.mem@tok @x0) @x1) @x2) (FStar.List.Tot.mem @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT FStar.List.Tot.mem@tok @x0) @x1) @x2)))) :named token_correspondence_FStar.List.Tot.mem))
(assert (! (HasType FStar.List.Tot.mem@tok (Tm_arrow_1778 Prims.bool Prims.eqtype)) :named function_token_typing_FStar.List.Tot.mem))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Prims.eqtype) (HasType @x1 @x0) (HasType @x2 (Prims.list @x0))) (HasType (FStar.List.Tot.mem @x0 @x1 @x2) Prims.bool)) :pattern ((FStar.List.Tot.mem @x0 @x1 @x2)))) :named typing_FStar.List.Tot.mem))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTF FStar.List.Tot.mem__1894 @u0) @x1) @x2) @x3) (FStar.List.Tot.mem__1893 @u0 @x1 @x2 @x3)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTF FStar.List.Tot.mem__1894 @u0) @x1) @x2) @x3)))) :named fuel_tokem_correspondence_FStar.List.Tot.mem__1894))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x1 Prims.eqtype) (HasType @x2 @x1) (HasType @x3 (Prims.list @x1))) (HasType (FStar.List.Tot.mem__1893 @u0 @x1 @x2 @x3) Prims.bool)) :pattern ((FStar.List.Tot.mem__1893 @u0 @x1 @x2 @x3)))) :named token_correspondence_FStar.List.Tot.mem__1893))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (FStar.List.Tot.mem @x0 @x1 @x2) (FStar.List.Tot.mem__1893 MaxFuel @x0 @x1 @x2)) :pattern ((FStar.List.Tot.mem @x0 @x1 @x2)))) :named fuel_correspondence_FStar.List.Tot.mem__1893))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (FStar.List.Tot.mem__1893 (SFuel @u0) @x1 @x2 @x3) (FStar.List.Tot.mem__1893 ZFuel @x1 @x2 @x3)) :pattern ((FStar.List.Tot.mem__1893 (SFuel @u0) @x1 @x2 @x3)))) :named fuel_irrelevance_FStar.List.Tot.mem__1893))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (FStar.List.Tot.mem__1893 (SFuel @u0) @x1 @x2 @x3) (ite (is-Prims.Nil @x3) (BoxBool false) (ite (is-Prims.Cons @x3) (ite (= (Prims.op_Equality @x1 (Prims.Cons_hd @x3) @x2) (BoxBool true)) (BoxBool true) (ite true (FStar.List.Tot.mem__1893 @u0 @x1 @x2 (Prims.Cons_tl @x3)) Tm_unit)) Tm_unit))) :pattern ((FStar.List.Tot.mem__1893 (SFuel @u0) @x1 @x2 @x3)))) :named equation_with_fuel_FStar.List.Tot.mem__1893))
(declare-fun FStar.List.Tot.contains (Term Term Term) Term)
(declare-fun FStar.List.Tot.contains@tok () Term)
(assert (! (= 1896 (Term_constr_id FStar.List.Tot.contains@tok)) :named fresh_token_FStar.List.Tot.contains@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT FStar.List.Tot.contains@tok @x0) @x1) @x2) (FStar.List.Tot.contains @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT FStar.List.Tot.contains@tok @x0) @x1) @x2)))) :named token_correspondence_FStar.List.Tot.contains))
(assert (! (HasType FStar.List.Tot.contains@tok (Tm_arrow_1778 Prims.bool Prims.eqtype)) :named function_token_typing_FStar.List.Tot.contains))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Prims.eqtype) (HasType @x1 @x0) (HasType @x2 (Prims.list @x0))) (HasType (FStar.List.Tot.contains @x0 @x1 @x2) Prims.bool)) :pattern ((FStar.List.Tot.contains @x0 @x1 @x2)))) :named typing_FStar.List.Tot.contains))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (FStar.List.Tot.contains @x0 @x1 @x2) (FStar.List.Tot.mem @x0 @x1 @x2)) :pattern ((FStar.List.Tot.contains @x0 @x1 @x2)))) :named equation_FStar.List.Tot.contains))
(declare-fun FStar.List.Tot.existsb__1902 (Fuel Term Term Term) Term)
(declare-fun FStar.List.Tot.existsb__1903 () Term)
(declare-fun FStar.List.Tot.existsb (Term Term Term) Term)
(declare-fun FStar.List.Tot.existsb@tok () Term)
(assert (! (= 1900 (Term_constr_id FStar.List.Tot.existsb@tok)) :named fresh_token_FStar.List.Tot.existsb@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT FStar.List.Tot.existsb@tok @x0) @x1) @x2) (FStar.List.Tot.existsb @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT FStar.List.Tot.existsb@tok @x0) @x1) @x2)))) :named token_correspondence_FStar.List.Tot.existsb))
(assert (! (HasType FStar.List.Tot.existsb@tok (Tm_arrow_1812 Prims.bool)) :named function_token_typing_FStar.List.Tot.existsb))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 (Tm_arrow_228 Prims.bool @x0)) (HasType @x2 (Prims.list @x0))) (HasType (FStar.List.Tot.existsb @x0 @x1 @x2) Prims.bool)) :pattern ((FStar.List.Tot.existsb @x0 @x1 @x2)))) :named typing_FStar.List.Tot.existsb))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTF FStar.List.Tot.existsb__1903 @u0) @x1) @x2) @x3) (FStar.List.Tot.existsb__1902 @u0 @x1 @x2 @x3)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTF FStar.List.Tot.existsb__1903 @u0) @x1) @x2) @x3)))) :named fuel_tokem_correspondence_FStar.List.Tot.existsb__1903))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 (Tm_arrow_228 Prims.bool @x1)) (HasType @x3 (Prims.list @x1))) (HasType (FStar.List.Tot.existsb__1902 @u0 @x1 @x2 @x3) Prims.bool)) :pattern ((FStar.List.Tot.existsb__1902 @u0 @x1 @x2 @x3)))) :named token_correspondence_FStar.List.Tot.existsb__1902))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (FStar.List.Tot.existsb @x0 @x1 @x2) (FStar.List.Tot.existsb__1902 MaxFuel @x0 @x1 @x2)) :pattern ((FStar.List.Tot.existsb @x0 @x1 @x2)))) :named fuel_correspondence_FStar.List.Tot.existsb__1902))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (FStar.List.Tot.existsb__1902 (SFuel @u0) @x1 @x2 @x3) (FStar.List.Tot.existsb__1902 ZFuel @x1 @x2 @x3)) :pattern ((FStar.List.Tot.existsb__1902 (SFuel @u0) @x1 @x2 @x3)))) :named fuel_irrelevance_FStar.List.Tot.existsb__1902))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (FStar.List.Tot.existsb__1902 (SFuel @u0) @x1 @x2 @x3) (ite (is-Prims.Nil @x3) (BoxBool false) (ite (is-Prims.Cons @x3) (ite (= (ApplyTT @x2 (Prims.Cons_hd @x3)) (BoxBool true)) (BoxBool true) (ite true (FStar.List.Tot.existsb__1902 @u0 @x1 @x2 (Prims.Cons_tl @x3)) Tm_unit)) Tm_unit))) :pattern ((FStar.List.Tot.existsb__1902 (SFuel @u0) @x1 @x2 @x3)))) :named equation_with_fuel_FStar.List.Tot.existsb__1902))
(declare-fun FStar.List.Tot.find__1916 (Fuel Term Term Term) Term)
(declare-fun FStar.List.Tot.find__1917 () Term)
(declare-fun FStar.List.Tot.find (Term Term Term) Term)
(declare-fun Tm_arrow_1911 (Term) Term)
(declare-fun Tm_refine_1910 (Term Term) Term)
(declare-fun FStar.List.Tot.find@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (HasType (Tm_refine_1910 @x0 @x1) Tm_type) :pattern ((HasType (Tm_refine_1910 @x0 @x1) Tm_type)))) :named refinement_kinding_Tm_refine_1910))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (iff (HasTypeFuel @u0 @x1 (Tm_refine_1910 @x2 @x3)) (and (HasTypeFuel @u0 @x1 @x3) (BoxBool_proj_0 (ApplyTT @x2 @x1)))) :pattern ((HasTypeFuel @u0 @x1 (Tm_refine_1910 @x2 @x3))))) :named refinement_interpretation_Tm_refine_1910))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (Valid (Prims.hasEq (Tm_refine_1910 @x0 @x1))) (Valid (Prims.hasEq @x1))) :pattern ((Valid (Prims.hasEq (Tm_refine_1910 @x0 @x1)))))) :named haseqTm_refine_1910))
(assert (! (forall ((@x0 Term)) (! (HasType (Tm_arrow_1911 @x0) Tm_type) :pattern ((HasType (Tm_arrow_1911 @x0) Tm_type)))) :named kinding_Tm_arrow_1911))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_1911 @x2)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_1911 @x2))))) :named pre_typing_Tm_arrow_1911))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_1911 @x1)) (forall ((@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x2 Tm_type) (HasType @x3 (Tm_arrow_228 @x1 @x2)) (HasType @x4 (Prims.list @x2))) (HasType (ApplyTT (ApplyTT (ApplyTT @x0 @x2) @x3) @x4) (Prims.option (Tm_refine_1910 @x3 @x2)))) :pattern ((ApplyTT (ApplyTT (ApplyTT @x0 @x2) @x3) @x4))))) :pattern ((HasTypeZ @x0 (Tm_arrow_1911 @x1))))) :named interpretation_Tm_arrow_1911))
(assert (! (= 1913 (Term_constr_id FStar.List.Tot.find@tok)) :named fresh_token_FStar.List.Tot.find@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT FStar.List.Tot.find@tok @x0) @x1) @x2) (FStar.List.Tot.find @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT FStar.List.Tot.find@tok @x0) @x1) @x2)))) :named token_correspondence_FStar.List.Tot.find))
(assert (! (HasType FStar.List.Tot.find@tok (Tm_arrow_1911 Prims.bool)) :named function_token_typing_FStar.List.Tot.find))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 (Tm_arrow_228 Prims.bool @x0)) (HasType @x2 (Prims.list @x0))) (HasType (FStar.List.Tot.find @x0 @x1 @x2) (Prims.option (Tm_refine_1910 @x1 @x0)))) :pattern ((FStar.List.Tot.find @x0 @x1 @x2)))) :named typing_FStar.List.Tot.find))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTF FStar.List.Tot.find__1917 @u0) @x1) @x2) @x3) (FStar.List.Tot.find__1916 @u0 @x1 @x2 @x3)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTF FStar.List.Tot.find__1917 @u0) @x1) @x2) @x3)))) :named fuel_tokem_correspondence_FStar.List.Tot.find__1917))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 (Tm_arrow_228 Prims.bool @x1)) (HasType @x3 (Prims.list @x1))) (HasType (FStar.List.Tot.find__1916 @u0 @x1 @x2 @x3) (Prims.option (Tm_refine_1910 @x2 @x1)))) :pattern ((FStar.List.Tot.find__1916 @u0 @x1 @x2 @x3)))) :named token_correspondence_FStar.List.Tot.find__1916))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (FStar.List.Tot.find @x0 @x1 @x2) (FStar.List.Tot.find__1916 MaxFuel @x0 @x1 @x2)) :pattern ((FStar.List.Tot.find @x0 @x1 @x2)))) :named fuel_correspondence_FStar.List.Tot.find__1916))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (FStar.List.Tot.find__1916 (SFuel @u0) @x1 @x2 @x3) (FStar.List.Tot.find__1916 ZFuel @x1 @x2 @x3)) :pattern ((FStar.List.Tot.find__1916 (SFuel @u0) @x1 @x2 @x3)))) :named fuel_irrelevance_FStar.List.Tot.find__1916))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (FStar.List.Tot.find__1916 (SFuel @u0) @x1 @x2 @x3) (ite (is-Prims.Nil @x3) (Prims.None (Tm_refine_1910 @x2 @x1)) (ite (is-Prims.Cons @x3) (ite (= (ApplyTT @x2 (Prims.Cons_hd @x3)) (BoxBool true)) (Prims.Some (Tm_refine_1910 @x2 @x1) (Prims.Cons_hd @x3)) (ite true (FStar.List.Tot.find__1916 @u0 @x1 @x2 (Prims.Cons_tl @x3)) Tm_unit)) Tm_unit))) :pattern ((FStar.List.Tot.find__1916 (SFuel @u0) @x1 @x2 @x3)))) :named equation_with_fuel_FStar.List.Tot.find__1916))
(declare-fun FStar.List.Tot.filter__1933 (Fuel Term Term Term) Term)
(declare-fun FStar.List.Tot.filter__1934 () Term)
(declare-fun FStar.List.Tot.filter (Term Term Term) Term)
(declare-fun Tm_arrow_1928 (Term Term) Term)
(declare-fun Tm_refine_1927 (Term Term) Term)
(declare-fun FStar.List.Tot.filter@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (HasType (Tm_refine_1927 @x0 @x1) Tm_type) :pattern ((HasType (Tm_refine_1927 @x0 @x1) Tm_type)))) :named refinement_kinding_Tm_refine_1927))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (iff (HasTypeFuel @u0 @x1 (Tm_refine_1927 @x2 @x3)) (and (HasTypeFuel @u0 @x1 (Prims.list @x3)) (forall ((@x4 Term)) (implies (and (HasType @x4 @x3) (BoxBool_proj_0 (FStar.List.Tot.mem @x3 @x4 @x1))) (BoxBool_proj_0 (ApplyTT @x2 @x4)))))) :pattern ((HasTypeFuel @u0 @x1 (Tm_refine_1927 @x2 @x3))))) :named refinement_interpretation_Tm_refine_1927))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (Valid (Prims.hasEq (Tm_refine_1927 @x0 @x1))) (Valid (Prims.hasEq (Prims.list @x1)))) :pattern ((Valid (Prims.hasEq (Tm_refine_1927 @x0 @x1)))))) :named haseqTm_refine_1927))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (HasType (Tm_arrow_1928 @x0 @x1) Tm_type) :pattern ((HasType (Tm_arrow_1928 @x0 @x1) Tm_type)))) :named kinding_Tm_arrow_1928))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_1928 @x2 @x3)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_1928 @x2 @x3))))) :named pre_typing_Tm_arrow_1928))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_1928 @x1 @x2)) (forall ((@x3 Term) (@x4 Term) (@x5 Term)) (! (implies (and (HasType @x3 @x2) (HasType @x4 (Tm_arrow_228 @x1 @x3)) (HasType @x5 (Prims.list @x3))) (HasType (ApplyTT (ApplyTT (ApplyTT @x0 @x3) @x4) @x5) (Tm_refine_1927 @x4 @x3))) :pattern ((ApplyTT (ApplyTT (ApplyTT @x0 @x3) @x4) @x5))))) :pattern ((HasTypeZ @x0 (Tm_arrow_1928 @x1 @x2))))) :named interpretation_Tm_arrow_1928))
(assert (! (= 1930 (Term_constr_id FStar.List.Tot.filter@tok)) :named fresh_token_FStar.List.Tot.filter@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT FStar.List.Tot.filter@tok @x0) @x1) @x2) (FStar.List.Tot.filter @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT FStar.List.Tot.filter@tok @x0) @x1) @x2)))) :named token_correspondence_FStar.List.Tot.filter))
(assert (! (HasType FStar.List.Tot.filter@tok (Tm_arrow_1928 Prims.bool Prims.eqtype)) :named function_token_typing_FStar.List.Tot.filter))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Prims.eqtype) (HasType @x1 (Tm_arrow_228 Prims.bool @x0)) (HasType @x2 (Prims.list @x0))) (HasType (FStar.List.Tot.filter @x0 @x1 @x2) (Tm_refine_1927 @x1 @x0))) :pattern ((FStar.List.Tot.filter @x0 @x1 @x2)))) :named typing_FStar.List.Tot.filter))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTF FStar.List.Tot.filter__1934 @u0) @x1) @x2) @x3) (FStar.List.Tot.filter__1933 @u0 @x1 @x2 @x3)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTF FStar.List.Tot.filter__1934 @u0) @x1) @x2) @x3)))) :named fuel_tokem_correspondence_FStar.List.Tot.filter__1934))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x1 Prims.eqtype) (HasType @x2 (Tm_arrow_228 Prims.bool @x1)) (HasType @x3 (Prims.list @x1))) (HasType (FStar.List.Tot.filter__1933 @u0 @x1 @x2 @x3) (Tm_refine_1927 @x2 @x1))) :pattern ((FStar.List.Tot.filter__1933 @u0 @x1 @x2 @x3)))) :named token_correspondence_FStar.List.Tot.filter__1933))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (FStar.List.Tot.filter @x0 @x1 @x2) (FStar.List.Tot.filter__1933 MaxFuel @x0 @x1 @x2)) :pattern ((FStar.List.Tot.filter @x0 @x1 @x2)))) :named fuel_correspondence_FStar.List.Tot.filter__1933))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (FStar.List.Tot.filter__1933 (SFuel @u0) @x1 @x2 @x3) (FStar.List.Tot.filter__1933 ZFuel @x1 @x2 @x3)) :pattern ((FStar.List.Tot.filter__1933 (SFuel @u0) @x1 @x2 @x3)))) :named fuel_irrelevance_FStar.List.Tot.filter__1933))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (FStar.List.Tot.filter__1933 (SFuel @u0) @x1 @x2 @x3) (ite (is-Prims.Nil @x3) (Prims.Nil @x1) (ite (is-Prims.Cons @x3) (ite (= (ApplyTT @x2 (Prims.Cons_hd @x3)) (BoxBool true)) (Prims.Cons @x1 (Prims.Cons_hd @x3) (FStar.List.Tot.filter__1933 @u0 @x1 @x2 (Prims.Cons_tl @x3))) (ite true (FStar.List.Tot.filter__1933 @u0 @x1 @x2 (Prims.Cons_tl @x3)) Tm_unit)) Tm_unit))) :pattern ((FStar.List.Tot.filter__1933 (SFuel @u0) @x1 @x2 @x3)))) :named equation_with_fuel_FStar.List.Tot.filter__1933))
(declare-fun FStar.List.Tot.for_all__1943 (Fuel Term Term Term) Term)
(declare-fun FStar.List.Tot.for_all__1944 () Term)
(declare-fun FStar.List.Tot.for_all (Term Term Term) Term)
(declare-fun FStar.List.Tot.for_all@tok () Term)
(assert (! (= 1941 (Term_constr_id FStar.List.Tot.for_all@tok)) :named fresh_token_FStar.List.Tot.for_all@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT FStar.List.Tot.for_all@tok @x0) @x1) @x2) (FStar.List.Tot.for_all @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT FStar.List.Tot.for_all@tok @x0) @x1) @x2)))) :named token_correspondence_FStar.List.Tot.for_all))
(assert (! (HasType FStar.List.Tot.for_all@tok (Tm_arrow_1812 Prims.bool)) :named function_token_typing_FStar.List.Tot.for_all))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 (Tm_arrow_228 Prims.bool @x0)) (HasType @x2 (Prims.list @x0))) (HasType (FStar.List.Tot.for_all @x0 @x1 @x2) Prims.bool)) :pattern ((FStar.List.Tot.for_all @x0 @x1 @x2)))) :named typing_FStar.List.Tot.for_all))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTF FStar.List.Tot.for_all__1944 @u0) @x1) @x2) @x3) (FStar.List.Tot.for_all__1943 @u0 @x1 @x2 @x3)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTF FStar.List.Tot.for_all__1944 @u0) @x1) @x2) @x3)))) :named fuel_tokem_correspondence_FStar.List.Tot.for_all__1944))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 (Tm_arrow_228 Prims.bool @x1)) (HasType @x3 (Prims.list @x1))) (HasType (FStar.List.Tot.for_all__1943 @u0 @x1 @x2 @x3) Prims.bool)) :pattern ((FStar.List.Tot.for_all__1943 @u0 @x1 @x2 @x3)))) :named token_correspondence_FStar.List.Tot.for_all__1943))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (FStar.List.Tot.for_all @x0 @x1 @x2) (FStar.List.Tot.for_all__1943 MaxFuel @x0 @x1 @x2)) :pattern ((FStar.List.Tot.for_all @x0 @x1 @x2)))) :named fuel_correspondence_FStar.List.Tot.for_all__1943))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (FStar.List.Tot.for_all__1943 (SFuel @u0) @x1 @x2 @x3) (FStar.List.Tot.for_all__1943 ZFuel @x1 @x2 @x3)) :pattern ((FStar.List.Tot.for_all__1943 (SFuel @u0) @x1 @x2 @x3)))) :named fuel_irrelevance_FStar.List.Tot.for_all__1943))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (FStar.List.Tot.for_all__1943 (SFuel @u0) @x1 @x2 @x3) (ite (is-Prims.Nil @x3) (BoxBool true) (ite (is-Prims.Cons @x3) (ite (= (ApplyTT @x2 (Prims.Cons_hd @x3)) (BoxBool true)) (FStar.List.Tot.for_all__1943 @u0 @x1 @x2 (Prims.Cons_tl @x3)) (ite true (BoxBool false) Tm_unit)) Tm_unit))) :pattern ((FStar.List.Tot.for_all__1943 (SFuel @u0) @x1 @x2 @x3)))) :named equation_with_fuel_FStar.List.Tot.for_all__1943))
(declare-fun FStar.List.Tot.collect__1952 (Fuel Term Term Term Term) Term)
(declare-fun FStar.List.Tot.collect__1953 () Term)
(declare-fun FStar.List.Tot.collect (Term Term Term Term) Term)
(declare-fun FStar.List.Tot.collect@tok () Term)
(assert (! (= 1950 (Term_constr_id FStar.List.Tot.collect@tok)) :named fresh_token_FStar.List.Tot.collect@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.List.Tot.collect@tok @x0) @x1) @x2) @x3) (FStar.List.Tot.collect @x0 @x1 @x2 @x3)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.List.Tot.collect@tok @x0) @x1) @x2) @x3)))) :named token_correspondence_FStar.List.Tot.collect))
(assert (! (HasType FStar.List.Tot.collect@tok Tm_arrow_1856) :named function_token_typing_FStar.List.Tot.collect))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 (Tm_arrow_1852 @x1 @x0)) (HasType @x3 (Prims.list @x0))) (HasType (FStar.List.Tot.collect @x0 @x1 @x2 @x3) (Prims.list @x1))) :pattern ((FStar.List.Tot.collect @x0 @x1 @x2 @x3)))) :named typing_FStar.List.Tot.collect))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTF FStar.List.Tot.collect__1953 @u0) @x1) @x2) @x3) @x4) (FStar.List.Tot.collect__1952 @u0 @x1 @x2 @x3 @x4)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTF FStar.List.Tot.collect__1953 @u0) @x1) @x2) @x3) @x4)))) :named fuel_tokem_correspondence_FStar.List.Tot.collect__1953))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 (Tm_arrow_1852 @x2 @x1)) (HasType @x4 (Prims.list @x1))) (HasType (FStar.List.Tot.collect__1952 @u0 @x1 @x2 @x3 @x4) (Prims.list @x2))) :pattern ((FStar.List.Tot.collect__1952 @u0 @x1 @x2 @x3 @x4)))) :named token_correspondence_FStar.List.Tot.collect__1952))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (FStar.List.Tot.collect @x0 @x1 @x2 @x3) (FStar.List.Tot.collect__1952 MaxFuel @x0 @x1 @x2 @x3)) :pattern ((FStar.List.Tot.collect @x0 @x1 @x2 @x3)))) :named fuel_correspondence_FStar.List.Tot.collect__1952))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (= (FStar.List.Tot.collect__1952 (SFuel @u0) @x1 @x2 @x3 @x4) (FStar.List.Tot.collect__1952 ZFuel @x1 @x2 @x3 @x4)) :pattern ((FStar.List.Tot.collect__1952 (SFuel @u0) @x1 @x2 @x3 @x4)))) :named fuel_irrelevance_FStar.List.Tot.collect__1952))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (= (FStar.List.Tot.collect__1952 (SFuel @u0) @x1 @x2 @x3 @x4) (ite (is-Prims.Nil @x4) (Prims.Nil @x2) (ite (is-Prims.Cons @x4) (FStar.List.Tot.append @x2 (ApplyTT @x3 (Prims.Cons_hd @x4)) (FStar.List.Tot.collect__1952 @u0 @x1 @x2 @x3 (Prims.Cons_tl @x4))) Tm_unit))) :pattern ((FStar.List.Tot.collect__1952 (SFuel @u0) @x1 @x2 @x3 @x4)))) :named equation_with_fuel_FStar.List.Tot.collect__1952))
(declare-fun FStar.List.Tot.tryFind__1963 (Fuel Term Term Term) Term)
(declare-fun FStar.List.Tot.tryFind__1964 () Term)
(declare-fun FStar.List.Tot.tryFind (Term Term Term) Term)
(declare-fun Tm_arrow_1959 (Term) Term)
(declare-fun FStar.List.Tot.tryFind@tok () Term)
(assert (! (forall ((@x0 Term)) (! (HasType (Tm_arrow_1959 @x0) Tm_type) :pattern ((HasType (Tm_arrow_1959 @x0) Tm_type)))) :named kinding_Tm_arrow_1959))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_1959 @x2)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_1959 @x2))))) :named pre_typing_Tm_arrow_1959))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_1959 @x1)) (forall ((@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x2 Tm_type) (HasType @x3 (Tm_arrow_228 @x1 @x2)) (HasType @x4 (Prims.list @x2))) (HasType (ApplyTT (ApplyTT (ApplyTT @x0 @x2) @x3) @x4) (Prims.option @x2))) :pattern ((ApplyTT (ApplyTT (ApplyTT @x0 @x2) @x3) @x4))))) :pattern ((HasTypeZ @x0 (Tm_arrow_1959 @x1))))) :named interpretation_Tm_arrow_1959))
(assert (! (= 1961 (Term_constr_id FStar.List.Tot.tryFind@tok)) :named fresh_token_FStar.List.Tot.tryFind@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT FStar.List.Tot.tryFind@tok @x0) @x1) @x2) (FStar.List.Tot.tryFind @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT FStar.List.Tot.tryFind@tok @x0) @x1) @x2)))) :named token_correspondence_FStar.List.Tot.tryFind))
(assert (! (HasType FStar.List.Tot.tryFind@tok (Tm_arrow_1959 Prims.bool)) :named function_token_typing_FStar.List.Tot.tryFind))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 (Tm_arrow_228 Prims.bool @x0)) (HasType @x2 (Prims.list @x0))) (HasType (FStar.List.Tot.tryFind @x0 @x1 @x2) (Prims.option @x0))) :pattern ((FStar.List.Tot.tryFind @x0 @x1 @x2)))) :named typing_FStar.List.Tot.tryFind))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTF FStar.List.Tot.tryFind__1964 @u0) @x1) @x2) @x3) (FStar.List.Tot.tryFind__1963 @u0 @x1 @x2 @x3)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTF FStar.List.Tot.tryFind__1964 @u0) @x1) @x2) @x3)))) :named fuel_tokem_correspondence_FStar.List.Tot.tryFind__1964))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 (Tm_arrow_228 Prims.bool @x1)) (HasType @x3 (Prims.list @x1))) (HasType (FStar.List.Tot.tryFind__1963 @u0 @x1 @x2 @x3) (Prims.option @x1))) :pattern ((FStar.List.Tot.tryFind__1963 @u0 @x1 @x2 @x3)))) :named token_correspondence_FStar.List.Tot.tryFind__1963))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (FStar.List.Tot.tryFind @x0 @x1 @x2) (FStar.List.Tot.tryFind__1963 MaxFuel @x0 @x1 @x2)) :pattern ((FStar.List.Tot.tryFind @x0 @x1 @x2)))) :named fuel_correspondence_FStar.List.Tot.tryFind__1963))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (FStar.List.Tot.tryFind__1963 (SFuel @u0) @x1 @x2 @x3) (FStar.List.Tot.tryFind__1963 ZFuel @x1 @x2 @x3)) :pattern ((FStar.List.Tot.tryFind__1963 (SFuel @u0) @x1 @x2 @x3)))) :named fuel_irrelevance_FStar.List.Tot.tryFind__1963))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (FStar.List.Tot.tryFind__1963 (SFuel @u0) @x1 @x2 @x3) (ite (is-Prims.Nil @x3) (Prims.None @x1) (ite (is-Prims.Cons @x3) (ite (= (ApplyTT @x2 (Prims.Cons_hd @x3)) (BoxBool true)) (Prims.Some @x1 (Prims.Cons_hd @x3)) (ite true (FStar.List.Tot.tryFind__1963 @u0 @x1 @x2 (Prims.Cons_tl @x3)) Tm_unit)) Tm_unit))) :pattern ((FStar.List.Tot.tryFind__1963 (SFuel @u0) @x1 @x2 @x3)))) :named equation_with_fuel_FStar.List.Tot.tryFind__1963))
(declare-fun FStar.List.Tot.tryPick__1976 (Fuel Term Term Term Term) Term)
(declare-fun FStar.List.Tot.tryPick__1977 () Term)
(declare-fun Tm_arrow_1968 (Term Term) Term)
(declare-fun FStar.List.Tot.tryPick (Term Term Term Term) Term)
(declare-fun Tm_arrow_1972 () Term)
(declare-fun FStar.List.Tot.tryPick@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (HasType (Tm_arrow_1968 @x0 @x1) Tm_type) :pattern ((HasType (Tm_arrow_1968 @x0 @x1) Tm_type)))) :named kinding_Tm_arrow_1968))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_1968 @x2 @x3)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_1968 @x2 @x3))))) :named pre_typing_Tm_arrow_1968))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_1968 @x1 @x2)) (forall ((@x3 Term)) (! (implies (HasType @x3 @x2) (HasType (ApplyTT @x0 @x3) (Prims.option @x1))) :pattern ((ApplyTT @x0 @x3))))) :pattern ((HasTypeZ @x0 (Tm_arrow_1968 @x1 @x2))))) :named interpretation_Tm_arrow_1968))
(assert (! (HasType Tm_arrow_1972 Tm_type) :named kinding_Tm_arrow_1972))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_1972) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_1972)))) :named pre_typing_Tm_arrow_1972))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_1972) (forall ((@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 (Tm_arrow_1968 @x2 @x1)) (HasType @x4 (Prims.list @x1))) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) (Prims.option @x2))) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4))))) :pattern ((HasTypeZ @x0 Tm_arrow_1972)))) :named interpretation_Tm_arrow_1972))
(assert (! (= 1974 (Term_constr_id FStar.List.Tot.tryPick@tok)) :named fresh_token_FStar.List.Tot.tryPick@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.List.Tot.tryPick@tok @x0) @x1) @x2) @x3) (FStar.List.Tot.tryPick @x0 @x1 @x2 @x3)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.List.Tot.tryPick@tok @x0) @x1) @x2) @x3)))) :named token_correspondence_FStar.List.Tot.tryPick))
(assert (! (HasType FStar.List.Tot.tryPick@tok Tm_arrow_1972) :named function_token_typing_FStar.List.Tot.tryPick))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 (Tm_arrow_1968 @x1 @x0)) (HasType @x3 (Prims.list @x0))) (HasType (FStar.List.Tot.tryPick @x0 @x1 @x2 @x3) (Prims.option @x1))) :pattern ((FStar.List.Tot.tryPick @x0 @x1 @x2 @x3)))) :named typing_FStar.List.Tot.tryPick))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTF FStar.List.Tot.tryPick__1977 @u0) @x1) @x2) @x3) @x4) (FStar.List.Tot.tryPick__1976 @u0 @x1 @x2 @x3 @x4)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTF FStar.List.Tot.tryPick__1977 @u0) @x1) @x2) @x3) @x4)))) :named fuel_tokem_correspondence_FStar.List.Tot.tryPick__1977))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 (Tm_arrow_1968 @x2 @x1)) (HasType @x4 (Prims.list @x1))) (HasType (FStar.List.Tot.tryPick__1976 @u0 @x1 @x2 @x3 @x4) (Prims.option @x2))) :pattern ((FStar.List.Tot.tryPick__1976 @u0 @x1 @x2 @x3 @x4)))) :named token_correspondence_FStar.List.Tot.tryPick__1976))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (FStar.List.Tot.tryPick @x0 @x1 @x2 @x3) (FStar.List.Tot.tryPick__1976 MaxFuel @x0 @x1 @x2 @x3)) :pattern ((FStar.List.Tot.tryPick @x0 @x1 @x2 @x3)))) :named fuel_correspondence_FStar.List.Tot.tryPick__1976))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (= (FStar.List.Tot.tryPick__1976 (SFuel @u0) @x1 @x2 @x3 @x4) (FStar.List.Tot.tryPick__1976 ZFuel @x1 @x2 @x3 @x4)) :pattern ((FStar.List.Tot.tryPick__1976 (SFuel @u0) @x1 @x2 @x3 @x4)))) :named fuel_irrelevance_FStar.List.Tot.tryPick__1976))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (= (FStar.List.Tot.tryPick__1976 (SFuel @u0) @x1 @x2 @x3 @x4) (ite (is-Prims.Nil @x4) (Prims.None @x2) (ite (is-Prims.Cons @x4) (ite (is-Prims.Some (ApplyTT @x3 (Prims.Cons_hd @x4))) (Prims.Some @x2 (Prims.Some_v (ApplyTT @x3 (Prims.Cons_hd @x4)))) (ite (is-Prims.None (ApplyTT @x3 (Prims.Cons_hd @x4))) (FStar.List.Tot.tryPick__1976 @u0 @x1 @x2 @x3 (Prims.Cons_tl @x4)) Tm_unit)) Tm_unit))) :pattern ((FStar.List.Tot.tryPick__1976 (SFuel @u0) @x1 @x2 @x3 @x4)))) :named equation_with_fuel_FStar.List.Tot.tryPick__1976))
(declare-fun FStar.List.Tot.choose__1987 (Fuel Term Term Term Term) Term)
(declare-fun FStar.List.Tot.choose__1988 () Term)
(declare-fun FStar.List.Tot.choose (Term Term Term Term) Term)
(declare-fun Tm_arrow_1983 () Term)
(declare-fun FStar.List.Tot.choose@tok () Term)
(assert (! (HasType Tm_arrow_1983 Tm_type) :named kinding_Tm_arrow_1983))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_1983) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_1983)))) :named pre_typing_Tm_arrow_1983))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_1983) (forall ((@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 (Tm_arrow_1968 @x2 @x1)) (HasType @x4 (Prims.list @x1))) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) (Prims.list @x2))) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4))))) :pattern ((HasTypeZ @x0 Tm_arrow_1983)))) :named interpretation_Tm_arrow_1983))
(assert (! (= 1985 (Term_constr_id FStar.List.Tot.choose@tok)) :named fresh_token_FStar.List.Tot.choose@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.List.Tot.choose@tok @x0) @x1) @x2) @x3) (FStar.List.Tot.choose @x0 @x1 @x2 @x3)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.List.Tot.choose@tok @x0) @x1) @x2) @x3)))) :named token_correspondence_FStar.List.Tot.choose))
(assert (! (HasType FStar.List.Tot.choose@tok Tm_arrow_1983) :named function_token_typing_FStar.List.Tot.choose))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 (Tm_arrow_1968 @x1 @x0)) (HasType @x3 (Prims.list @x0))) (HasType (FStar.List.Tot.choose @x0 @x1 @x2 @x3) (Prims.list @x1))) :pattern ((FStar.List.Tot.choose @x0 @x1 @x2 @x3)))) :named typing_FStar.List.Tot.choose))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTF FStar.List.Tot.choose__1988 @u0) @x1) @x2) @x3) @x4) (FStar.List.Tot.choose__1987 @u0 @x1 @x2 @x3 @x4)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTF FStar.List.Tot.choose__1988 @u0) @x1) @x2) @x3) @x4)))) :named fuel_tokem_correspondence_FStar.List.Tot.choose__1988))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 (Tm_arrow_1968 @x2 @x1)) (HasType @x4 (Prims.list @x1))) (HasType (FStar.List.Tot.choose__1987 @u0 @x1 @x2 @x3 @x4) (Prims.list @x2))) :pattern ((FStar.List.Tot.choose__1987 @u0 @x1 @x2 @x3 @x4)))) :named token_correspondence_FStar.List.Tot.choose__1987))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (FStar.List.Tot.choose @x0 @x1 @x2 @x3) (FStar.List.Tot.choose__1987 MaxFuel @x0 @x1 @x2 @x3)) :pattern ((FStar.List.Tot.choose @x0 @x1 @x2 @x3)))) :named fuel_correspondence_FStar.List.Tot.choose__1987))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (= (FStar.List.Tot.choose__1987 (SFuel @u0) @x1 @x2 @x3 @x4) (FStar.List.Tot.choose__1987 ZFuel @x1 @x2 @x3 @x4)) :pattern ((FStar.List.Tot.choose__1987 (SFuel @u0) @x1 @x2 @x3 @x4)))) :named fuel_irrelevance_FStar.List.Tot.choose__1987))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (= (FStar.List.Tot.choose__1987 (SFuel @u0) @x1 @x2 @x3 @x4) (ite (is-Prims.Nil @x4) (Prims.Nil @x2) (ite (is-Prims.Cons @x4) (ite (is-Prims.Some (ApplyTT @x3 (Prims.Cons_hd @x4))) (Prims.Cons @x2 (Prims.Some_v (ApplyTT @x3 (Prims.Cons_hd @x4))) (FStar.List.Tot.choose__1987 @u0 @x1 @x2 @x3 (Prims.Cons_tl @x4))) (ite (is-Prims.None (ApplyTT @x3 (Prims.Cons_hd @x4))) (FStar.List.Tot.choose__1987 @u0 @x1 @x2 @x3 (Prims.Cons_tl @x4)) Tm_unit)) Tm_unit))) :pattern ((FStar.List.Tot.choose__1987 (SFuel @u0) @x1 @x2 @x3 @x4)))) :named equation_with_fuel_FStar.List.Tot.choose__1987))
(declare-fun FStar.List.Tot.partition__1998 (Fuel Term Term Term) Term)
(declare-fun FStar.List.Tot.partition__1999 () Term)
(declare-fun FStar.List.Tot.partition (Term Term Term) Term)
(declare-fun Tm_arrow_1994 (Term) Term)
(declare-fun FStar.List.Tot.partition@tok () Term)
(assert (! (forall ((@x0 Term)) (! (HasType (Tm_arrow_1994 @x0) Tm_type) :pattern ((HasType (Tm_arrow_1994 @x0) Tm_type)))) :named kinding_Tm_arrow_1994))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_1994 @x2)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_1994 @x2))))) :named pre_typing_Tm_arrow_1994))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_1994 @x1)) (forall ((@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x2 Tm_type) (HasType @x3 (Tm_arrow_228 @x1 @x2)) (HasType @x4 (Prims.list @x2))) (HasType (ApplyTT (ApplyTT (ApplyTT @x0 @x2) @x3) @x4) (Prims.tuple2 (Prims.list @x2) (Prims.list @x2)))) :pattern ((ApplyTT (ApplyTT (ApplyTT @x0 @x2) @x3) @x4))))) :pattern ((HasTypeZ @x0 (Tm_arrow_1994 @x1))))) :named interpretation_Tm_arrow_1994))
(assert (! (= 1996 (Term_constr_id FStar.List.Tot.partition@tok)) :named fresh_token_FStar.List.Tot.partition@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT FStar.List.Tot.partition@tok @x0) @x1) @x2) (FStar.List.Tot.partition @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT FStar.List.Tot.partition@tok @x0) @x1) @x2)))) :named token_correspondence_FStar.List.Tot.partition))
(assert (! (HasType FStar.List.Tot.partition@tok (Tm_arrow_1994 Prims.bool)) :named function_token_typing_FStar.List.Tot.partition))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 (Tm_arrow_228 Prims.bool @x0)) (HasType @x2 (Prims.list @x0))) (HasType (FStar.List.Tot.partition @x0 @x1 @x2) (Prims.tuple2 (Prims.list @x0) (Prims.list @x0)))) :pattern ((FStar.List.Tot.partition @x0 @x1 @x2)))) :named typing_FStar.List.Tot.partition))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTF FStar.List.Tot.partition__1999 @u0) @x1) @x2) @x3) (FStar.List.Tot.partition__1998 @u0 @x1 @x2 @x3)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTF FStar.List.Tot.partition__1999 @u0) @x1) @x2) @x3)))) :named fuel_tokem_correspondence_FStar.List.Tot.partition__1999))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 (Tm_arrow_228 Prims.bool @x1)) (HasType @x3 (Prims.list @x1))) (HasType (FStar.List.Tot.partition__1998 @u0 @x1 @x2 @x3) (Prims.tuple2 (Prims.list @x1) (Prims.list @x1)))) :pattern ((FStar.List.Tot.partition__1998 @u0 @x1 @x2 @x3)))) :named token_correspondence_FStar.List.Tot.partition__1998))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (FStar.List.Tot.partition @x0 @x1 @x2) (FStar.List.Tot.partition__1998 MaxFuel @x0 @x1 @x2)) :pattern ((FStar.List.Tot.partition @x0 @x1 @x2)))) :named fuel_correspondence_FStar.List.Tot.partition__1998))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (FStar.List.Tot.partition__1998 (SFuel @u0) @x1 @x2 @x3) (FStar.List.Tot.partition__1998 ZFuel @x1 @x2 @x3)) :pattern ((FStar.List.Tot.partition__1998 (SFuel @u0) @x1 @x2 @x3)))) :named fuel_irrelevance_FStar.List.Tot.partition__1998))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (FStar.List.Tot.partition__1998 (SFuel @u0) @x1 @x2 @x3) (ite (is-Prims.Nil @x3) (Prims.Mktuple2 (Prims.list @x1) (Prims.list @x1) (Prims.Nil @x1) (Prims.Nil @x1)) (ite (is-Prims.Cons @x3) (ite (is-Prims.Mktuple2 (FStar.List.Tot.partition__1998 @u0 @x1 @x2 (Prims.Cons_tl @x3))) (ite (= (ApplyTT @x2 (Prims.Cons_hd @x3)) (BoxBool true)) (Prims.Mktuple2 (Prims.list @x1) (Prims.list @x1) (Prims.Cons @x1 (Prims.Cons_hd @x3) (Prims.Mktuple2__1 (FStar.List.Tot.partition__1998 @u0 @x1 @x2 (Prims.Cons_tl @x3)))) (Prims.Mktuple2__2 (FStar.List.Tot.partition__1998 @u0 @x1 @x2 (Prims.Cons_tl @x3)))) (ite true (Prims.Mktuple2 (Prims.list @x1) (Prims.list @x1) (Prims.Mktuple2__1 (FStar.List.Tot.partition__1998 @u0 @x1 @x2 (Prims.Cons_tl @x3))) (Prims.Cons @x1 (Prims.Cons_hd @x3) (Prims.Mktuple2__2 (FStar.List.Tot.partition__1998 @u0 @x1 @x2 (Prims.Cons_tl @x3))))) Tm_unit)) Tm_unit) Tm_unit))) :pattern ((FStar.List.Tot.partition__1998 (SFuel @u0) @x1 @x2 @x3)))) :named equation_with_fuel_FStar.List.Tot.partition__1998))
(declare-fun FStar.List.Tot.subset__2007 (Fuel Term Term Term) Term)
(declare-fun FStar.List.Tot.subset__2008 () Term)
(declare-fun FStar.List.Tot.subset (Term Term Term) Term)
(declare-fun Tm_arrow_2003 (Term Term) Term)
(declare-fun FStar.List.Tot.subset@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (HasType (Tm_arrow_2003 @x0 @x1) Tm_type) :pattern ((HasType (Tm_arrow_2003 @x0 @x1) Tm_type)))) :named kinding_Tm_arrow_2003))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_2003 @x2 @x3)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_2003 @x2 @x3))))) :named pre_typing_Tm_arrow_2003))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_2003 @x1 @x2)) (forall ((@x3 Term) (@x4 Term) (@x5 Term)) (! (implies (and (HasType @x3 @x2) (HasType @x4 (Prims.list @x3)) (HasType @x5 (Prims.list @x3))) (HasType (ApplyTT (ApplyTT (ApplyTT @x0 @x3) @x4) @x5) @x1)) :pattern ((ApplyTT (ApplyTT (ApplyTT @x0 @x3) @x4) @x5))))) :pattern ((HasTypeZ @x0 (Tm_arrow_2003 @x1 @x2))))) :named interpretation_Tm_arrow_2003))
(assert (! (= 2005 (Term_constr_id FStar.List.Tot.subset@tok)) :named fresh_token_FStar.List.Tot.subset@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT FStar.List.Tot.subset@tok @x0) @x1) @x2) (FStar.List.Tot.subset @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT FStar.List.Tot.subset@tok @x0) @x1) @x2)))) :named token_correspondence_FStar.List.Tot.subset))
(assert (! (HasType FStar.List.Tot.subset@tok (Tm_arrow_2003 Prims.bool Prims.eqtype)) :named function_token_typing_FStar.List.Tot.subset))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Prims.eqtype) (HasType @x1 (Prims.list @x0)) (HasType @x2 (Prims.list @x0))) (HasType (FStar.List.Tot.subset @x0 @x1 @x2) Prims.bool)) :pattern ((FStar.List.Tot.subset @x0 @x1 @x2)))) :named typing_FStar.List.Tot.subset))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTF FStar.List.Tot.subset__2008 @u0) @x1) @x2) @x3) (FStar.List.Tot.subset__2007 @u0 @x1 @x2 @x3)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTF FStar.List.Tot.subset__2008 @u0) @x1) @x2) @x3)))) :named fuel_tokem_correspondence_FStar.List.Tot.subset__2008))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x1 Prims.eqtype) (HasType @x2 (Prims.list @x1)) (HasType @x3 (Prims.list @x1))) (HasType (FStar.List.Tot.subset__2007 @u0 @x1 @x2 @x3) Prims.bool)) :pattern ((FStar.List.Tot.subset__2007 @u0 @x1 @x2 @x3)))) :named token_correspondence_FStar.List.Tot.subset__2007))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (FStar.List.Tot.subset @x0 @x1 @x2) (FStar.List.Tot.subset__2007 MaxFuel @x0 @x1 @x2)) :pattern ((FStar.List.Tot.subset @x0 @x1 @x2)))) :named fuel_correspondence_FStar.List.Tot.subset__2007))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (FStar.List.Tot.subset__2007 (SFuel @u0) @x1 @x2 @x3) (FStar.List.Tot.subset__2007 ZFuel @x1 @x2 @x3)) :pattern ((FStar.List.Tot.subset__2007 (SFuel @u0) @x1 @x2 @x3)))) :named fuel_irrelevance_FStar.List.Tot.subset__2007))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (FStar.List.Tot.subset__2007 (SFuel @u0) @x1 @x2 @x3) (ite (is-Prims.Nil @x2) (BoxBool true) (ite (is-Prims.Cons @x2) (Prims.op_AmpAmp (FStar.List.Tot.mem @x1 (Prims.Cons_hd @x2) @x3) (FStar.List.Tot.subset__2007 @u0 @x1 (Prims.Cons_tl @x2) @x3)) Tm_unit))) :pattern ((FStar.List.Tot.subset__2007 (SFuel @u0) @x1 @x2 @x3)))) :named equation_with_fuel_FStar.List.Tot.subset__2007))
(declare-fun FStar.List.Tot.noRepeats__2014 (Fuel Term Term) Term)
(declare-fun FStar.List.Tot.noRepeats__2015 () Term)
(declare-fun FStar.List.Tot.noRepeats (Term Term) Term)
(declare-fun Tm_arrow_2010 (Term Term) Term)
(declare-fun FStar.List.Tot.noRepeats@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (HasType (Tm_arrow_2010 @x0 @x1) Tm_type) :pattern ((HasType (Tm_arrow_2010 @x0 @x1) Tm_type)))) :named kinding_Tm_arrow_2010))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_2010 @x2 @x3)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_2010 @x2 @x3))))) :named pre_typing_Tm_arrow_2010))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_2010 @x1 @x2)) (forall ((@x3 Term) (@x4 Term)) (! (implies (and (HasType @x3 @x2) (HasType @x4 (Prims.list @x3))) (HasType (ApplyTT (ApplyTT @x0 @x3) @x4) @x1)) :pattern ((ApplyTT (ApplyTT @x0 @x3) @x4))))) :pattern ((HasTypeZ @x0 (Tm_arrow_2010 @x1 @x2))))) :named interpretation_Tm_arrow_2010))
(assert (! (= 2012 (Term_constr_id FStar.List.Tot.noRepeats@tok)) :named fresh_token_FStar.List.Tot.noRepeats@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (ApplyTT (ApplyTT FStar.List.Tot.noRepeats@tok @x0) @x1) (FStar.List.Tot.noRepeats @x0 @x1)) :pattern ((ApplyTT (ApplyTT FStar.List.Tot.noRepeats@tok @x0) @x1)))) :named token_correspondence_FStar.List.Tot.noRepeats))
(assert (! (HasType FStar.List.Tot.noRepeats@tok (Tm_arrow_2010 Prims.bool Prims.eqtype)) :named function_token_typing_FStar.List.Tot.noRepeats))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 Prims.eqtype) (HasType @x1 (Prims.list @x0))) (HasType (FStar.List.Tot.noRepeats @x0 @x1) Prims.bool)) :pattern ((FStar.List.Tot.noRepeats @x0 @x1)))) :named typing_FStar.List.Tot.noRepeats))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTF FStar.List.Tot.noRepeats__2015 @u0) @x1) @x2) (FStar.List.Tot.noRepeats__2014 @u0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTF FStar.List.Tot.noRepeats__2015 @u0) @x1) @x2)))) :named fuel_tokem_correspondence_FStar.List.Tot.noRepeats__2015))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x1 Prims.eqtype) (HasType @x2 (Prims.list @x1))) (HasType (FStar.List.Tot.noRepeats__2014 @u0 @x1 @x2) Prims.bool)) :pattern ((FStar.List.Tot.noRepeats__2014 @u0 @x1 @x2)))) :named token_correspondence_FStar.List.Tot.noRepeats__2014))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (FStar.List.Tot.noRepeats @x0 @x1) (FStar.List.Tot.noRepeats__2014 MaxFuel @x0 @x1)) :pattern ((FStar.List.Tot.noRepeats @x0 @x1)))) :named fuel_correspondence_FStar.List.Tot.noRepeats__2014))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (= (FStar.List.Tot.noRepeats__2014 (SFuel @u0) @x1 @x2) (FStar.List.Tot.noRepeats__2014 ZFuel @x1 @x2)) :pattern ((FStar.List.Tot.noRepeats__2014 (SFuel @u0) @x1 @x2)))) :named fuel_irrelevance_FStar.List.Tot.noRepeats__2014))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (= (FStar.List.Tot.noRepeats__2014 (SFuel @u0) @x1 @x2) (ite (is-Prims.Nil @x2) (BoxBool true) (ite (is-Prims.Cons @x2) (Prims.op_AmpAmp (Prims.op_Negation (FStar.List.Tot.mem @x1 (Prims.Cons_hd @x2) (Prims.Cons_tl @x2))) (FStar.List.Tot.noRepeats__2014 @u0 @x1 (Prims.Cons_tl @x2))) Tm_unit))) :pattern ((FStar.List.Tot.noRepeats__2014 (SFuel @u0) @x1 @x2)))) :named equation_with_fuel_FStar.List.Tot.noRepeats__2014))
(declare-fun FStar.List.Tot.assoc__2021 (Fuel Term Term Term Term) Term)
(declare-fun FStar.List.Tot.assoc__2022 () Term)
(declare-fun FStar.List.Tot.assoc (Term Term Term Term) Term)
(declare-fun Tm_arrow_2017 (Term) Term)
(declare-fun FStar.List.Tot.assoc@tok () Term)
(assert (! (forall ((@x0 Term)) (! (HasType (Tm_arrow_2017 @x0) Tm_type) :pattern ((HasType (Tm_arrow_2017 @x0) Tm_type)))) :named kinding_Tm_arrow_2017))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_2017 @x2)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_2017 @x2))))) :named pre_typing_Tm_arrow_2017))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_2017 @x1)) (forall ((@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (implies (and (HasType @x2 @x1) (HasType @x3 Tm_type) (HasType @x4 @x2) (HasType @x5 (Prims.list (Prims.tuple2 @x2 @x3)))) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x2) @x3) @x4) @x5) (Prims.option @x3))) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x2) @x3) @x4) @x5))))) :pattern ((HasTypeZ @x0 (Tm_arrow_2017 @x1))))) :named interpretation_Tm_arrow_2017))
(assert (! (= 2019 (Term_constr_id FStar.List.Tot.assoc@tok)) :named fresh_token_FStar.List.Tot.assoc@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.List.Tot.assoc@tok @x0) @x1) @x2) @x3) (FStar.List.Tot.assoc @x0 @x1 @x2 @x3)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.List.Tot.assoc@tok @x0) @x1) @x2) @x3)))) :named token_correspondence_FStar.List.Tot.assoc))
(assert (! (HasType FStar.List.Tot.assoc@tok (Tm_arrow_2017 Prims.eqtype)) :named function_token_typing_FStar.List.Tot.assoc))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x0 Prims.eqtype) (HasType @x1 Tm_type) (HasType @x2 @x0) (HasType @x3 (Prims.list (Prims.tuple2 @x0 @x1)))) (HasType (FStar.List.Tot.assoc @x0 @x1 @x2 @x3) (Prims.option @x1))) :pattern ((FStar.List.Tot.assoc @x0 @x1 @x2 @x3)))) :named typing_FStar.List.Tot.assoc))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTF FStar.List.Tot.assoc__2022 @u0) @x1) @x2) @x3) @x4) (FStar.List.Tot.assoc__2021 @u0 @x1 @x2 @x3 @x4)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTF FStar.List.Tot.assoc__2022 @u0) @x1) @x2) @x3) @x4)))) :named fuel_tokem_correspondence_FStar.List.Tot.assoc__2022))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x1 Prims.eqtype) (HasType @x2 Tm_type) (HasType @x3 @x1) (HasType @x4 (Prims.list (Prims.tuple2 @x1 @x2)))) (HasType (FStar.List.Tot.assoc__2021 @u0 @x1 @x2 @x3 @x4) (Prims.option @x2))) :pattern ((FStar.List.Tot.assoc__2021 @u0 @x1 @x2 @x3 @x4)))) :named token_correspondence_FStar.List.Tot.assoc__2021))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (FStar.List.Tot.assoc @x0 @x1 @x2 @x3) (FStar.List.Tot.assoc__2021 MaxFuel @x0 @x1 @x2 @x3)) :pattern ((FStar.List.Tot.assoc @x0 @x1 @x2 @x3)))) :named fuel_correspondence_FStar.List.Tot.assoc__2021))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (= (FStar.List.Tot.assoc__2021 (SFuel @u0) @x1 @x2 @x3 @x4) (FStar.List.Tot.assoc__2021 ZFuel @x1 @x2 @x3 @x4)) :pattern ((FStar.List.Tot.assoc__2021 (SFuel @u0) @x1 @x2 @x3 @x4)))) :named fuel_irrelevance_FStar.List.Tot.assoc__2021))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (= (FStar.List.Tot.assoc__2021 (SFuel @u0) @x1 @x2 @x3 @x4) (ite (is-Prims.Nil @x4) (Prims.None @x2) (ite (and (is-Prims.Cons @x4) (is-Prims.Mktuple2 (Prims.Cons_hd @x4))) (ite (= (Prims.op_Equality @x1 @x3 (Prims.Mktuple2__1 (Prims.Cons_hd @x4))) (BoxBool true)) (Prims.Some @x2 (Prims.Mktuple2__2 (Prims.Cons_hd @x4))) (ite true (FStar.List.Tot.assoc__2021 @u0 @x1 @x2 @x3 (Prims.Cons_tl @x4)) Tm_unit)) Tm_unit))) :pattern ((FStar.List.Tot.assoc__2021 (SFuel @u0) @x1 @x2 @x3 @x4)))) :named equation_with_fuel_FStar.List.Tot.assoc__2021))
(declare-fun FStar.List.Tot.split__2028 (Fuel Term Term Term) Term)
(declare-fun FStar.List.Tot.split__2029 () Term)
(declare-fun FStar.List.Tot.split (Term Term Term) Term)
(declare-fun Tm_arrow_2024 () Term)
(declare-fun FStar.List.Tot.split@tok () Term)
(assert (! (HasType Tm_arrow_2024 Tm_type) :named kinding_Tm_arrow_2024))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_2024) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_2024)))) :named pre_typing_Tm_arrow_2024))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_2024) (forall ((@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 (Prims.list (Prims.tuple2 @x1 @x2)))) (HasType (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) (Prims.tuple2 (Prims.list @x1) (Prims.list @x2)))) :pattern ((ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3))))) :pattern ((HasTypeZ @x0 Tm_arrow_2024)))) :named interpretation_Tm_arrow_2024))
(assert (! (= 2026 (Term_constr_id FStar.List.Tot.split@tok)) :named fresh_token_FStar.List.Tot.split@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT FStar.List.Tot.split@tok @x0) @x1) @x2) (FStar.List.Tot.split @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT FStar.List.Tot.split@tok @x0) @x1) @x2)))) :named token_correspondence_FStar.List.Tot.split))
(assert (! (HasType FStar.List.Tot.split@tok Tm_arrow_2024) :named function_token_typing_FStar.List.Tot.split))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 (Prims.list (Prims.tuple2 @x0 @x1)))) (HasType (FStar.List.Tot.split @x0 @x1 @x2) (Prims.tuple2 (Prims.list @x0) (Prims.list @x1)))) :pattern ((FStar.List.Tot.split @x0 @x1 @x2)))) :named typing_FStar.List.Tot.split))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTF FStar.List.Tot.split__2029 @u0) @x1) @x2) @x3) (FStar.List.Tot.split__2028 @u0 @x1 @x2 @x3)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTF FStar.List.Tot.split__2029 @u0) @x1) @x2) @x3)))) :named fuel_tokem_correspondence_FStar.List.Tot.split__2029))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 (Prims.list (Prims.tuple2 @x1 @x2)))) (HasType (FStar.List.Tot.split__2028 @u0 @x1 @x2 @x3) (Prims.tuple2 (Prims.list @x1) (Prims.list @x2)))) :pattern ((FStar.List.Tot.split__2028 @u0 @x1 @x2 @x3)))) :named token_correspondence_FStar.List.Tot.split__2028))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (FStar.List.Tot.split @x0 @x1 @x2) (FStar.List.Tot.split__2028 MaxFuel @x0 @x1 @x2)) :pattern ((FStar.List.Tot.split @x0 @x1 @x2)))) :named fuel_correspondence_FStar.List.Tot.split__2028))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (FStar.List.Tot.split__2028 (SFuel @u0) @x1 @x2 @x3) (FStar.List.Tot.split__2028 ZFuel @x1 @x2 @x3)) :pattern ((FStar.List.Tot.split__2028 (SFuel @u0) @x1 @x2 @x3)))) :named fuel_irrelevance_FStar.List.Tot.split__2028))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (FStar.List.Tot.split__2028 (SFuel @u0) @x1 @x2 @x3) (ite (is-Prims.Nil @x3) (Prims.Mktuple2 (Prims.list @x1) (Prims.list @x2) (Prims.Nil @x1) (Prims.Nil @x2)) (ite (and (is-Prims.Cons @x3) (is-Prims.Mktuple2 (Prims.Cons_hd @x3))) (ite (is-Prims.Mktuple2 (FStar.List.Tot.split__2028 @u0 @x1 @x2 (Prims.Cons_tl @x3))) (Prims.Mktuple2 (Prims.list @x1) (Prims.list @x2) (Prims.Cons @x1 (Prims.Mktuple2__1 (Prims.Cons_hd @x3)) (Prims.Mktuple2__1 (FStar.List.Tot.split__2028 @u0 @x1 @x2 (Prims.Cons_tl @x3)))) (Prims.Cons @x2 (Prims.Mktuple2__2 (Prims.Cons_hd @x3)) (Prims.Mktuple2__2 (FStar.List.Tot.split__2028 @u0 @x1 @x2 (Prims.Cons_tl @x3))))) Tm_unit) Tm_unit))) :pattern ((FStar.List.Tot.split__2028 (SFuel @u0) @x1 @x2 @x3)))) :named equation_with_fuel_FStar.List.Tot.split__2028))
(declare-fun FStar.List.Tot.unzip (Term Term Term) Term)
(declare-fun Tm_arrow_2031 () Term)
(assert (! (HasType Tm_arrow_2031 Tm_type) :named kinding_Tm_arrow_2031))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_2031) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_2031)))) :named pre_typing_Tm_arrow_2031))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_2031) (forall ((@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 (Prims.list (Prims.tuple2 @x2 @x1)))) (HasType (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) (Prims.tuple2 (Prims.list @x2) (Prims.list @x1)))) :pattern ((ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3))))) :pattern ((HasTypeZ @x0 Tm_arrow_2031)))) :named interpretation_Tm_arrow_2031))
(declare-fun FStar.List.Tot.unzip@tok () Term)
(assert (! (= 2033 (Term_constr_id FStar.List.Tot.unzip@tok)) :named fresh_token_FStar.List.Tot.unzip@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT FStar.List.Tot.unzip@tok @x0) @x1) @x2) (FStar.List.Tot.unzip @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT FStar.List.Tot.unzip@tok @x0) @x1) @x2)))) :named token_correspondence_FStar.List.Tot.unzip))
(assert (! (HasType FStar.List.Tot.unzip@tok Tm_arrow_2031) :named function_token_typing_FStar.List.Tot.unzip))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 (Prims.list (Prims.tuple2 @x1 @x0)))) (HasType (FStar.List.Tot.unzip @x0 @x1 @x2) (Prims.tuple2 (Prims.list @x1) (Prims.list @x0)))) :pattern ((FStar.List.Tot.unzip @x0 @x1 @x2)))) :named typing_FStar.List.Tot.unzip))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (FStar.List.Tot.unzip @x0 @x1 @x2) (FStar.List.Tot.split @x1 @x0 @x2)) :pattern ((FStar.List.Tot.unzip @x0 @x1 @x2)))) :named equation_FStar.List.Tot.unzip))
(declare-fun FStar.List.Tot.unzip3__2039 (Fuel Term Term Term Term) Term)
(declare-fun FStar.List.Tot.unzip3__2040 () Term)
(declare-fun FStar.List.Tot.unzip3 (Term Term Term Term) Term)
(declare-fun Tm_arrow_2035 () Term)
(declare-fun FStar.List.Tot.unzip3@tok () Term)
(assert (! (HasType Tm_arrow_2035 Tm_type) :named kinding_Tm_arrow_2035))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_2035) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_2035)))) :named pre_typing_Tm_arrow_2035))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_2035) (forall ((@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 (Prims.list (Prims.tuple3 @x1 @x2 @x3)))) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) (Prims.tuple3 (Prims.list @x1) (Prims.list @x2) (Prims.list @x3)))) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4))))) :pattern ((HasTypeZ @x0 Tm_arrow_2035)))) :named interpretation_Tm_arrow_2035))
(assert (! (= 2037 (Term_constr_id FStar.List.Tot.unzip3@tok)) :named fresh_token_FStar.List.Tot.unzip3@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.List.Tot.unzip3@tok @x0) @x1) @x2) @x3) (FStar.List.Tot.unzip3 @x0 @x1 @x2 @x3)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.List.Tot.unzip3@tok @x0) @x1) @x2) @x3)))) :named token_correspondence_FStar.List.Tot.unzip3))
(assert (! (HasType FStar.List.Tot.unzip3@tok Tm_arrow_2035) :named function_token_typing_FStar.List.Tot.unzip3))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 (Prims.list (Prims.tuple3 @x0 @x1 @x2)))) (HasType (FStar.List.Tot.unzip3 @x0 @x1 @x2 @x3) (Prims.tuple3 (Prims.list @x0) (Prims.list @x1) (Prims.list @x2)))) :pattern ((FStar.List.Tot.unzip3 @x0 @x1 @x2 @x3)))) :named typing_FStar.List.Tot.unzip3))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTF FStar.List.Tot.unzip3__2040 @u0) @x1) @x2) @x3) @x4) (FStar.List.Tot.unzip3__2039 @u0 @x1 @x2 @x3 @x4)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTF FStar.List.Tot.unzip3__2040 @u0) @x1) @x2) @x3) @x4)))) :named fuel_tokem_correspondence_FStar.List.Tot.unzip3__2040))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 (Prims.list (Prims.tuple3 @x1 @x2 @x3)))) (HasType (FStar.List.Tot.unzip3__2039 @u0 @x1 @x2 @x3 @x4) (Prims.tuple3 (Prims.list @x1) (Prims.list @x2) (Prims.list @x3)))) :pattern ((FStar.List.Tot.unzip3__2039 @u0 @x1 @x2 @x3 @x4)))) :named token_correspondence_FStar.List.Tot.unzip3__2039))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (FStar.List.Tot.unzip3 @x0 @x1 @x2 @x3) (FStar.List.Tot.unzip3__2039 MaxFuel @x0 @x1 @x2 @x3)) :pattern ((FStar.List.Tot.unzip3 @x0 @x1 @x2 @x3)))) :named fuel_correspondence_FStar.List.Tot.unzip3__2039))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (= (FStar.List.Tot.unzip3__2039 (SFuel @u0) @x1 @x2 @x3 @x4) (FStar.List.Tot.unzip3__2039 ZFuel @x1 @x2 @x3 @x4)) :pattern ((FStar.List.Tot.unzip3__2039 (SFuel @u0) @x1 @x2 @x3 @x4)))) :named fuel_irrelevance_FStar.List.Tot.unzip3__2039))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (= (FStar.List.Tot.unzip3__2039 (SFuel @u0) @x1 @x2 @x3 @x4) (ite (is-Prims.Nil @x4) (Prims.Mktuple3 (Prims.list @x1) (Prims.list @x2) (Prims.list @x3) (Prims.Nil @x1) (Prims.Nil @x2) (Prims.Nil @x3)) (ite (and (is-Prims.Cons @x4) (is-Prims.Mktuple3 (Prims.Cons_hd @x4))) (ite (is-Prims.Mktuple3 (FStar.List.Tot.unzip3__2039 @u0 @x1 @x2 @x3 (Prims.Cons_tl @x4))) (Prims.Mktuple3 (Prims.list @x1) (Prims.list @x2) (Prims.list @x3) (Prims.Cons @x1 (Prims.Mktuple3__1 (Prims.Cons_hd @x4)) (Prims.Mktuple3__1 (FStar.List.Tot.unzip3__2039 @u0 @x1 @x2 @x3 (Prims.Cons_tl @x4)))) (Prims.Cons @x2 (Prims.Mktuple3__2 (Prims.Cons_hd @x4)) (Prims.Mktuple3__2 (FStar.List.Tot.unzip3__2039 @u0 @x1 @x2 @x3 (Prims.Cons_tl @x4)))) (Prims.Cons @x3 (Prims.Mktuple3__3 (Prims.Cons_hd @x4)) (Prims.Mktuple3__3 (FStar.List.Tot.unzip3__2039 @u0 @x1 @x2 @x3 (Prims.Cons_tl @x4))))) Tm_unit) Tm_unit))) :pattern ((FStar.List.Tot.unzip3__2039 (SFuel @u0) @x1 @x2 @x3 @x4)))) :named equation_with_fuel_FStar.List.Tot.unzip3__2039))
(declare-fun FStar.List.Tot.partition_length (Term Term Term) Term)
(declare-fun FStar.List.Tot.partition_length@tok () Term)
(declare-fun Tm_arrow_2042 (Term Term) Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (HasType (Tm_arrow_2042 @x0 @x1) Tm_type) :pattern ((HasType (Tm_arrow_2042 @x0 @x1) Tm_type)))) :named kinding_Tm_arrow_2042))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_2042 @x2 @x3)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_2042 @x2 @x3))))) :named pre_typing_Tm_arrow_2042))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_2042 @x1 @x2)) (forall ((@x3 Term) (@x4 Term)) (! (implies (and (HasType @x3 @x2) (HasType @x4 @x2)) (HasType (ApplyTT (ApplyTT @x0 @x3) @x4) @x1)) :pattern ((ApplyTT (ApplyTT @x0 @x3) @x4))))) :pattern ((HasTypeZ @x0 (Tm_arrow_2042 @x1 @x2))))) :named interpretation_Tm_arrow_2042))
(declare-fun FStar.List.Tot.bool_of_compare (Term Term Term Term) Term)
(declare-fun Tm_arrow_2046 (Term Term) Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (HasType (Tm_arrow_2046 @x0 @x1) Tm_type) :pattern ((HasType (Tm_arrow_2046 @x0 @x1) Tm_type)))) :named kinding_Tm_arrow_2046))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_2046 @x2 @x3)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_2046 @x2 @x3))))) :named pre_typing_Tm_arrow_2046))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_2046 @x1 @x2)) (forall ((@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term)) (! (implies (and (HasType @x3 Tm_type) (HasType @x4 (Tm_arrow_2042 @x2 @x3)) (HasType @x5 @x3) (HasType @x6 @x3)) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x3) @x4) @x5) @x6) @x1)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x3) @x4) @x5) @x6))))) :pattern ((HasTypeZ @x0 (Tm_arrow_2046 @x1 @x2))))) :named interpretation_Tm_arrow_2046))
(declare-fun FStar.List.Tot.bool_of_compare@tok () Term)
(assert (! (= 2048 (Term_constr_id FStar.List.Tot.bool_of_compare@tok)) :named fresh_token_FStar.List.Tot.bool_of_compare@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.List.Tot.bool_of_compare@tok @x0) @x1) @x2) @x3) (FStar.List.Tot.bool_of_compare @x0 @x1 @x2 @x3)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.List.Tot.bool_of_compare@tok @x0) @x1) @x2) @x3)))) :named token_correspondence_FStar.List.Tot.bool_of_compare))
(assert (! (HasType FStar.List.Tot.bool_of_compare@tok (Tm_arrow_2046 Prims.bool Prims.int)) :named function_token_typing_FStar.List.Tot.bool_of_compare))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 (Tm_arrow_2042 Prims.int @x0)) (HasType @x2 @x0) (HasType @x3 @x0)) (HasType (FStar.List.Tot.bool_of_compare @x0 @x1 @x2 @x3) Prims.bool)) :pattern ((FStar.List.Tot.bool_of_compare @x0 @x1 @x2 @x3)))) :named typing_FStar.List.Tot.bool_of_compare))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (FStar.List.Tot.bool_of_compare @x0 @x1 @x2 @x3) (Prims.op_GreaterThanOrEqual (ApplyTT (ApplyTT @x1 @x2) @x3) (BoxInt 0))) :pattern ((FStar.List.Tot.bool_of_compare @x0 @x1 @x2 @x3)))) :named equation_FStar.List.Tot.bool_of_compare))
(declare-fun FStar.List.Tot.sortWith__2057 (Fuel Term Term Term) Term)
(declare-fun FStar.List.Tot.sortWith__2058 () Term)
(declare-fun FStar.List.Tot.sortWith (Term Term Term) Term)
(declare-fun Tm_arrow_2053 (Term) Term)
(declare-fun FStar.List.Tot.sortWith@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (HasType (ApplyTT (ApplyTT (ApplyTT FStar.List.Tot.bool_of_compare@tok @x3) @x2) (Prims.Cons_hd @x1)) (Tm_arrow_228 @x0 @x3)) :pattern ((HasType (ApplyTT (ApplyTT (ApplyTT FStar.List.Tot.bool_of_compare@tok @x3) @x2) (Prims.Cons_hd @x1)) (Tm_arrow_228 @x0 @x3))))) :named @partial_app_typing__2061))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (HasType (ApplyTT (ApplyTT (ApplyTT FStar.List.Tot.bool_of_compare@tok @x3) @x2) (Prims.Cons_hd @x1)) (Tm_arrow_228 @x0 @x3)) :pattern ((HasType (ApplyTT (ApplyTT (ApplyTT FStar.List.Tot.bool_of_compare@tok @x3) @x2) (Prims.Cons_hd @x1)) (Tm_arrow_228 @x0 @x3))))) :named @partial_app_typing__2063))
(assert (! (forall ((@x0 Term)) (! (HasType (Tm_arrow_2053 @x0) Tm_type) :pattern ((HasType (Tm_arrow_2053 @x0) Tm_type)))) :named kinding_Tm_arrow_2053))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_2053 @x2)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_2053 @x2))))) :named pre_typing_Tm_arrow_2053))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_2053 @x1)) (forall ((@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x2 Tm_type) (HasType @x3 (Tm_arrow_2042 @x1 @x2)) (HasType @x4 (Prims.list @x2))) (HasType (ApplyTT (ApplyTT (ApplyTT @x0 @x2) @x3) @x4) (Prims.list @x2))) :pattern ((ApplyTT (ApplyTT (ApplyTT @x0 @x2) @x3) @x4))))) :pattern ((HasTypeZ @x0 (Tm_arrow_2053 @x1))))) :named interpretation_Tm_arrow_2053))
(assert (! (= 2055 (Term_constr_id FStar.List.Tot.sortWith@tok)) :named fresh_token_FStar.List.Tot.sortWith@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT FStar.List.Tot.sortWith@tok @x0) @x1) @x2) (FStar.List.Tot.sortWith @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT FStar.List.Tot.sortWith@tok @x0) @x1) @x2)))) :named token_correspondence_FStar.List.Tot.sortWith))
(assert (! (HasType FStar.List.Tot.sortWith@tok (Tm_arrow_2053 Prims.int)) :named function_token_typing_FStar.List.Tot.sortWith))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 (Tm_arrow_2042 Prims.int @x0)) (HasType @x2 (Prims.list @x0))) (HasType (FStar.List.Tot.sortWith @x0 @x1 @x2) (Prims.list @x0))) :pattern ((FStar.List.Tot.sortWith @x0 @x1 @x2)))) :named typing_FStar.List.Tot.sortWith))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTF FStar.List.Tot.sortWith__2058 @u0) @x1) @x2) @x3) (FStar.List.Tot.sortWith__2057 @u0 @x1 @x2 @x3)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTF FStar.List.Tot.sortWith__2058 @u0) @x1) @x2) @x3)))) :named fuel_tokem_correspondence_FStar.List.Tot.sortWith__2058))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 (Tm_arrow_2042 Prims.int @x1)) (HasType @x3 (Prims.list @x1))) (HasType (FStar.List.Tot.sortWith__2057 @u0 @x1 @x2 @x3) (Prims.list @x1))) :pattern ((FStar.List.Tot.sortWith__2057 @u0 @x1 @x2 @x3)))) :named token_correspondence_FStar.List.Tot.sortWith__2057))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (FStar.List.Tot.sortWith @x0 @x1 @x2) (FStar.List.Tot.sortWith__2057 MaxFuel @x0 @x1 @x2)) :pattern ((FStar.List.Tot.sortWith @x0 @x1 @x2)))) :named fuel_correspondence_FStar.List.Tot.sortWith__2057))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (FStar.List.Tot.sortWith__2057 (SFuel @u0) @x1 @x2 @x3) (FStar.List.Tot.sortWith__2057 ZFuel @x1 @x2 @x3)) :pattern ((FStar.List.Tot.sortWith__2057 (SFuel @u0) @x1 @x2 @x3)))) :named fuel_irrelevance_FStar.List.Tot.sortWith__2057))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (FStar.List.Tot.sortWith__2057 (SFuel @u0) @x1 @x2 @x3) (ite (is-Prims.Nil @x3) (Prims.Nil @x1) (ite (is-Prims.Cons @x3) (ite (is-Prims.Mktuple2 (FStar.List.Tot.partition @x1 (ApplyTT (ApplyTT (ApplyTT FStar.List.Tot.bool_of_compare@tok @x1) @x2) (Prims.Cons_hd @x3)) (Prims.Cons_tl @x3))) (FStar.List.Tot.append @x1 (FStar.List.Tot.sortWith__2057 @u0 @x1 @x2 (Prims.Mktuple2__2 (FStar.List.Tot.partition @x1 (ApplyTT (ApplyTT (ApplyTT FStar.List.Tot.bool_of_compare@tok @x1) @x2) (Prims.Cons_hd @x3)) (Prims.Cons_tl @x3)))) (Prims.Cons @x1 (Prims.Cons_hd @x3) (FStar.List.Tot.sortWith__2057 @u0 @x1 @x2 (Prims.Mktuple2__1 (FStar.List.Tot.partition @x1 (ApplyTT (ApplyTT (ApplyTT FStar.List.Tot.bool_of_compare@tok @x1) @x2) (Prims.Cons_hd @x3)) (Prims.Cons_tl @x3)))))) Tm_unit) Tm_unit))) :pattern ((FStar.List.Tot.sortWith__2057 (SFuel @u0) @x1 @x2 @x3)))) :named equation_with_fuel_FStar.List.Tot.sortWith__2057))
(declare-fun FStar.Heap.heap () Term)
(assert (! (HasType FStar.Heap.heap Tm_type) :named function_token_typing_FStar.Heap.heap))
(assert (! (= 2189 (Term_constr_id FStar.Heap.heap)) :named constructor_distinct_FStar.Heap.heap))
(assert (! (forall ((@x0 Term) (@u1 Fuel)) (! (implies (HasTypeFuel @u1 @x0 FStar.Heap.heap) (= FStar.Heap.heap (PreType @x0))) :pattern ((HasTypeFuel @u1 @x0 FStar.Heap.heap)))) :named @pretyping__2192))
(assert (! (HasType FStar.Heap.heap Tm_type) :named typing_FStar.Heap.heap))
(declare-fun FStar.Heap.ref (Term) Term)
(declare-fun FStar.Heap.ref@tok () Term)
(assert (! (= 2194 (Term_constr_id FStar.Heap.ref@tok)) :named fresh_token_FStar.Heap.ref@tok))
(assert (! (forall ((@x0 Term)) (! (= (ApplyTT FStar.Heap.ref@tok @x0) (FStar.Heap.ref @x0)) :pattern ((ApplyTT FStar.Heap.ref@tok @x0)))) :named token_correspondence_FStar.Heap.ref))
(assert (! (HasType FStar.Heap.ref@tok Tm_arrow_105) :named function_token_typing_FStar.Heap.ref))
(assert (! (forall ((@x0 Term)) (! (= 2195 (Term_constr_id (FStar.Heap.ref @x0))) :pattern ((FStar.Heap.ref @x0)))) :named constructor_distinct_FStar.Heap.ref))
(assert (! (forall ((@x0 Term) (@u1 Fuel) (@x2 Term)) (! (implies (HasTypeFuel @u1 @x0 (FStar.Heap.ref @x2)) (= (FStar.Heap.ref @x2) (PreType @x0))) :pattern ((HasTypeFuel @u1 @x0 (FStar.Heap.ref @x2))))) :named @pretyping__2198))
(assert (! (forall ((@x0 Term)) (! (implies (HasType @x0 Tm_type) (HasType (FStar.Heap.ref @x0) Tm_type)) :pattern ((FStar.Heap.ref @x0)))) :named typing_FStar.Heap.ref))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel @u0 @x1 (FStar.Heap.ref @x2)) (is-BoxRef @x1)) :pattern ((HasTypeFuel @u0 @x1 (FStar.Heap.ref @x2))))) :named ref_inversion))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasTypeFuel @u0 @x1 (FStar.Heap.ref @x2)) (HasTypeFuel @u0 @x1 (FStar.Heap.ref @x3))) (= @x2 @x3)) :pattern ((HasTypeFuel @u0 @x1 (FStar.Heap.ref @x2)) (HasTypeFuel @u0 @x1 (FStar.Heap.ref @x3))))) :named ref_injectivity))
(declare-fun FStar.Heap.MkRef (Term Term) Term)
(declare-fun Tm_arrow_2202 () Term)
(assert (! (HasType Tm_arrow_2202 Tm_type) :named kinding_Tm_arrow_2202))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_2202) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_2202)))) :named pre_typing_Tm_arrow_2202))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_2202) (forall ((@x1 Term) (@x2 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 @x1)) (HasType (ApplyTT (ApplyTT @x0 @x1) @x2) (FStar.Heap.ref @x1))) :pattern ((ApplyTT (ApplyTT @x0 @x1) @x2))))) :pattern ((HasTypeZ @x0 Tm_arrow_2202)))) :named interpretation_Tm_arrow_2202))
(declare-fun FStar.Heap.MkRef@tok () Term)
(assert (! (= 2204 (Term_constr_id FStar.Heap.MkRef@tok)) :named fresh_token_FStar.Heap.MkRef@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (ApplyTT (ApplyTT FStar.Heap.MkRef@tok @x0) @x1) (FStar.Heap.MkRef @x0 @x1)) :pattern ((ApplyTT (ApplyTT FStar.Heap.MkRef@tok @x0) @x1)))) :named token_correspondence_FStar.Heap.MkRef))
(assert (! (HasType FStar.Heap.MkRef@tok Tm_arrow_2202) :named function_token_typing_FStar.Heap.MkRef))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 @x0)) (HasType (FStar.Heap.MkRef @x0 @x1) (FStar.Heap.ref @x0))) :pattern ((FStar.Heap.MkRef @x0 @x1)))) :named typing_FStar.Heap.MkRef))
(assert (! (forall ((@x0 Term)) (! (implies (and (HasType @x0 Tm_type) (Valid (Prims.hasEq @x0))) (Valid (Prims.hasEq (FStar.Heap.ref @x0)))) :pattern ((Prims.hasEq (FStar.Heap.ref @x0))))) :named assumption_FStar.Heap.ref_haseq_2205))
(declare-fun FStar.Heap.MkRef._0 (Term Term) Term)
(declare-fun Tm_arrow_2207 () Term)
(assert (! (HasType Tm_arrow_2207 Tm_type) :named kinding_Tm_arrow_2207))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_2207) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_2207)))) :named pre_typing_Tm_arrow_2207))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_2207) (forall ((@x1 Term) (@x2 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 (FStar.Heap.ref @x1))) (HasType (ApplyTT (ApplyTT @x0 @x1) @x2) @x1)) :pattern ((ApplyTT (ApplyTT @x0 @x1) @x2))))) :pattern ((HasTypeZ @x0 Tm_arrow_2207)))) :named interpretation_Tm_arrow_2207))
(declare-fun FStar.Heap.MkRef._0@tok () Term)
(assert (! (= 2209 (Term_constr_id FStar.Heap.MkRef._0@tok)) :named fresh_token_FStar.Heap.MkRef._0@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (ApplyTT (ApplyTT FStar.Heap.MkRef._0@tok @x0) @x1) (FStar.Heap.MkRef._0 @x0 @x1)) :pattern ((ApplyTT (ApplyTT FStar.Heap.MkRef._0@tok @x0) @x1)))) :named token_correspondence_FStar.Heap.MkRef._0))
(assert (! (HasType FStar.Heap.MkRef._0@tok Tm_arrow_2207) :named function_token_typing_FStar.Heap.MkRef._0))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 (FStar.Heap.ref @x0))) (HasType (FStar.Heap.MkRef._0 @x0 @x1) @x0)) :pattern ((FStar.Heap.MkRef._0 @x0 @x1)))) :named typing_FStar.Heap.MkRef._0))
(assert (! (forall ((@x0 Term)) (! (implies (HasType @x0 Tm_type) (Valid (Prims.hasEq (FStar.Heap.ref @x0)))) :pattern ((Prims.hasEq (FStar.Heap.ref @x0))))) :named assumption_FStar.Heap.HasEq_ref_2210))
(declare-fun FStar.Heap.aref () Term)
(declare-fun FStar.Heap.Ref (Term Term) Term)
(declare-fun FStar.Heap.Ref_a (Term) Term)
(declare-fun FStar.Heap.Ref_r (Term) Term)
(declare-fun Tm_arrow_2221 () Term)
(declare-fun FStar.Heap.Ref@tok () Term)
(assert (! (= 2211 (Term_constr_id FStar.Heap.aref)) :named constructor_distinct_FStar.Heap.aref))
(define-fun is-FStar.Heap.aref ((@x0 Term)) Bool (and (= (Term_constr_id @x0) 2211) (= @x0 FStar.Heap.aref)))
(assert (! (HasType FStar.Heap.aref Tm_type) :named kinding_FStar.Heap.aref@tok))
(assert (! (forall ((@x0 Term) (@u1 Fuel)) (! (implies (HasTypeFuel @u1 @x0 FStar.Heap.aref) (= FStar.Heap.aref (PreType @x0))) :pattern ((HasTypeFuel @u1 @x0 FStar.Heap.aref)))) :named @pretyping__2217))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= 2219 (Term_constr_id (FStar.Heap.Ref @x0 @x1))) :pattern ((FStar.Heap.Ref @x0 @x1)))) :named constructor_distinct_FStar.Heap.Ref))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (FStar.Heap.Ref_a (FStar.Heap.Ref @x0 @x1)) @x0) :pattern ((FStar.Heap.Ref @x0 @x1)))) :named projection_inverse_FStar.Heap.Ref_a))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (FStar.Heap.Ref_r (FStar.Heap.Ref @x0 @x1)) @x1) :pattern ((FStar.Heap.Ref @x0 @x1)))) :named projection_inverse_FStar.Heap.Ref_r))
(define-fun is-FStar.Heap.Ref ((@x0 Term)) Bool (and (= (Term_constr_id @x0) 2219) (= @x0 (FStar.Heap.Ref (FStar.Heap.Ref_a @x0) (FStar.Heap.Ref_r @x0)))))
(assert (! (HasType Tm_arrow_2221 Tm_type) :named kinding_Tm_arrow_2221))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_2221) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_2221)))) :named pre_typing_Tm_arrow_2221))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_2221) (forall ((@x1 Term) (@x2 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 (FStar.Heap.ref @x1))) (HasType (ApplyTT (ApplyTT @x0 @x1) @x2) FStar.Heap.aref)) :pattern ((ApplyTT (ApplyTT @x0 @x1) @x2))))) :pattern ((HasTypeZ @x0 Tm_arrow_2221)))) :named interpretation_Tm_arrow_2221))
(assert (! (= 2223 (Term_constr_id FStar.Heap.Ref@tok)) :named fresh_token_FStar.Heap.Ref@tok))
(assert (! (HasType FStar.Heap.Ref@tok Tm_arrow_2221) :named typing_tok_FStar.Heap.Ref@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (ApplyTT (ApplyTT FStar.Heap.Ref@tok @x0) @x1) (FStar.Heap.Ref @x0 @x1)) :pattern ((ApplyTT (ApplyTT FStar.Heap.Ref@tok @x0) @x1)))) :named equality_tok_FStar.Heap.Ref@tok))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (and (HasTypeFuel @u0 @x1 Tm_type) (HasTypeFuel @u0 @x2 (FStar.Heap.ref @x1))) (HasTypeFuel @u0 (FStar.Heap.Ref @x1 @x2) FStar.Heap.aref)) :pattern ((HasTypeFuel @u0 (FStar.Heap.Ref @x1 @x2) FStar.Heap.aref)))) :named data_typing_intro_FStar.Heap.Ref@tok))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel (SFuel @u0) (FStar.Heap.Ref @x1 @x2) FStar.Heap.aref) (and (HasTypeFuel @u0 @x1 Tm_type) (HasTypeFuel @u0 @x2 (FStar.Heap.ref @x1)))) :pattern ((HasTypeFuel (SFuel @u0) (FStar.Heap.Ref @x1 @x2) FStar.Heap.aref)))) :named data_elim_FStar.Heap.Ref))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel (SFuel @u0) (FStar.Heap.Ref @x1 @x2) FStar.Heap.aref) (and (Valid (Precedes @x1 (FStar.Heap.Ref @x1 @x2))) (Valid (Precedes @x2 (FStar.Heap.Ref @x1 @x2))))) :pattern ((HasTypeFuel (SFuel @u0) (FStar.Heap.Ref @x1 @x2) FStar.Heap.aref)))) :named subterm_ordering_FStar.Heap.Ref))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 FStar.Heap.aref) (is-FStar.Heap.Ref @x1)) :pattern ((HasTypeFuel @u0 @x1 FStar.Heap.aref)))) :named fuel_guarded_inversion_FStar.Heap.aref_2214))
(declare-fun FStar.Heap.Ref.a (Term) Term)
(declare-fun Tm_arrow_2225 () Term)
(assert (! (HasType Tm_arrow_2225 Tm_type) :named kinding_Tm_arrow_2225))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_2225) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_2225)))) :named pre_typing_Tm_arrow_2225))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_2225) (forall ((@x1 Term)) (! (implies (HasType @x1 FStar.Heap.aref) (HasType (ApplyTT @x0 @x1) Tm_type)) :pattern ((ApplyTT @x0 @x1))))) :pattern ((HasTypeZ @x0 Tm_arrow_2225)))) :named interpretation_Tm_arrow_2225))
(declare-fun FStar.Heap.Ref.a@tok () Term)
(assert (! (= 2227 (Term_constr_id FStar.Heap.Ref.a@tok)) :named fresh_token_FStar.Heap.Ref.a@tok))
(assert (! (forall ((@x0 Term)) (! (= (ApplyTT FStar.Heap.Ref.a@tok @x0) (FStar.Heap.Ref.a @x0)) :pattern ((ApplyTT FStar.Heap.Ref.a@tok @x0)))) :named token_correspondence_FStar.Heap.Ref.a))
(assert (! (HasType FStar.Heap.Ref.a@tok Tm_arrow_2225) :named function_token_typing_FStar.Heap.Ref.a))
(assert (! (forall ((@x0 Term)) (! (implies (HasType @x0 FStar.Heap.aref) (HasType (FStar.Heap.Ref.a @x0) Tm_type)) :pattern ((FStar.Heap.Ref.a @x0)))) :named typing_FStar.Heap.Ref.a))
(assert (! (forall ((@x0 Term)) (! (= (FStar.Heap.Ref.a @x0) (FStar.Heap.Ref_a @x0)) :pattern ((FStar.Heap.Ref.a @x0)))) :named proj_equation_FStar.Heap.Ref_a))
(declare-fun FStar.Heap.Ref.r (Term) Term)
(declare-fun Tm_arrow_2229 () Term)
(assert (! (HasType Tm_arrow_2229 Tm_type) :named kinding_Tm_arrow_2229))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_2229) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_2229)))) :named pre_typing_Tm_arrow_2229))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_2229) (forall ((@x1 Term)) (! (implies (HasType @x1 FStar.Heap.aref) (HasType (ApplyTT @x0 @x1) (FStar.Heap.ref (FStar.Heap.Ref.a @x1)))) :pattern ((ApplyTT @x0 @x1))))) :pattern ((HasTypeZ @x0 Tm_arrow_2229)))) :named interpretation_Tm_arrow_2229))
(declare-fun FStar.Heap.Ref.r@tok () Term)
(assert (! (= 2231 (Term_constr_id FStar.Heap.Ref.r@tok)) :named fresh_token_FStar.Heap.Ref.r@tok))
(assert (! (forall ((@x0 Term)) (! (= (ApplyTT FStar.Heap.Ref.r@tok @x0) (FStar.Heap.Ref.r @x0)) :pattern ((ApplyTT FStar.Heap.Ref.r@tok @x0)))) :named token_correspondence_FStar.Heap.Ref.r))
(assert (! (HasType FStar.Heap.Ref.r@tok Tm_arrow_2229) :named function_token_typing_FStar.Heap.Ref.r))
(assert (! (forall ((@x0 Term)) (! (implies (HasType @x0 FStar.Heap.aref) (HasType (FStar.Heap.Ref.r @x0) (FStar.Heap.ref (FStar.Heap.Ref.a @x0)))) :pattern ((FStar.Heap.Ref.r @x0)))) :named typing_FStar.Heap.Ref.r))
(assert (! (forall ((@x0 Term)) (! (= (FStar.Heap.Ref.r @x0) (FStar.Heap.Ref_r @x0)) :pattern ((FStar.Heap.Ref.r @x0)))) :named proj_equation_FStar.Heap.Ref_r))
(declare-fun FStar.Heap.sel (Term Term Term) Term)
(declare-fun Tm_arrow_2233 (Term) Term)
(assert (! (forall ((@x0 Term)) (! (HasType (Tm_arrow_2233 @x0) Tm_type) :pattern ((HasType (Tm_arrow_2233 @x0) Tm_type)))) :named kinding_Tm_arrow_2233))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_2233 @x2)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_2233 @x2))))) :named pre_typing_Tm_arrow_2233))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_2233 @x1)) (forall ((@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x2 Tm_type) (HasType @x3 @x1) (HasType @x4 (FStar.Heap.ref @x2))) (HasType (ApplyTT (ApplyTT (ApplyTT @x0 @x2) @x3) @x4) @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT @x0 @x2) @x3) @x4))))) :pattern ((HasTypeZ @x0 (Tm_arrow_2233 @x1))))) :named interpretation_Tm_arrow_2233))
(declare-fun FStar.Heap.sel@tok () Term)
(assert (! (= 2235 (Term_constr_id FStar.Heap.sel@tok)) :named fresh_token_FStar.Heap.sel@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT FStar.Heap.sel@tok @x0) @x1) @x2) (FStar.Heap.sel @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT FStar.Heap.sel@tok @x0) @x1) @x2)))) :named token_correspondence_FStar.Heap.sel))
(assert (! (HasType FStar.Heap.sel@tok (Tm_arrow_2233 FStar.Heap.heap)) :named function_token_typing_FStar.Heap.sel))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 FStar.Heap.heap) (HasType @x2 (FStar.Heap.ref @x0))) (HasType (FStar.Heap.sel @x0 @x1 @x2) @x0)) :pattern ((FStar.Heap.sel @x0 @x1 @x2)))) :named typing_FStar.Heap.sel))
(declare-fun FStar.Heap.upd (Term Term Term Term) Term)
(declare-fun Tm_arrow_2237 (Term) Term)
(assert (! (forall ((@x0 Term)) (! (HasType (Tm_arrow_2237 @x0) Tm_type) :pattern ((HasType (Tm_arrow_2237 @x0) Tm_type)))) :named kinding_Tm_arrow_2237))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_2237 @x2)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_2237 @x2))))) :named pre_typing_Tm_arrow_2237))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_2237 @x1)) (forall ((@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (implies (and (HasType @x2 Tm_type) (HasType @x3 @x1) (HasType @x4 (FStar.Heap.ref @x2)) (HasType @x5 @x2)) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x2) @x3) @x4) @x5) @x1)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x2) @x3) @x4) @x5))))) :pattern ((HasTypeZ @x0 (Tm_arrow_2237 @x1))))) :named interpretation_Tm_arrow_2237))
(declare-fun FStar.Heap.upd@tok () Term)
(assert (! (= 2239 (Term_constr_id FStar.Heap.upd@tok)) :named fresh_token_FStar.Heap.upd@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.Heap.upd@tok @x0) @x1) @x2) @x3) (FStar.Heap.upd @x0 @x1 @x2 @x3)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.Heap.upd@tok @x0) @x1) @x2) @x3)))) :named token_correspondence_FStar.Heap.upd))
(assert (! (HasType FStar.Heap.upd@tok (Tm_arrow_2237 FStar.Heap.heap)) :named function_token_typing_FStar.Heap.upd))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 FStar.Heap.heap) (HasType @x2 (FStar.Heap.ref @x0)) (HasType @x3 @x0)) (HasType (FStar.Heap.upd @x0 @x1 @x2 @x3) FStar.Heap.heap)) :pattern ((FStar.Heap.upd @x0 @x1 @x2 @x3)))) :named typing_FStar.Heap.upd))
(declare-fun FStar.Heap.emp () Term)
(assert (! (HasType FStar.Heap.emp FStar.Heap.heap) :named function_token_typing_FStar.Heap.emp))
(assert (! (HasType FStar.Heap.emp FStar.Heap.heap) :named typing_FStar.Heap.emp))
(declare-fun FStar.Heap.contains (Term Term Term) Term)
(declare-fun Tm_arrow_2241 (Term Term) Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (HasType (Tm_arrow_2241 @x0 @x1) Tm_type) :pattern ((HasType (Tm_arrow_2241 @x0 @x1) Tm_type)))) :named kinding_Tm_arrow_2241))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_2241 @x2 @x3)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_2241 @x2 @x3))))) :named pre_typing_Tm_arrow_2241))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_2241 @x1 @x2)) (forall ((@x3 Term) (@x4 Term) (@x5 Term)) (! (implies (and (HasType @x3 Tm_type) (HasType @x4 @x2) (HasType @x5 (FStar.Heap.ref @x3))) (HasType (ApplyTT (ApplyTT (ApplyTT @x0 @x3) @x4) @x5) @x1)) :pattern ((ApplyTT (ApplyTT (ApplyTT @x0 @x3) @x4) @x5))))) :pattern ((HasTypeZ @x0 (Tm_arrow_2241 @x1 @x2))))) :named interpretation_Tm_arrow_2241))
(declare-fun FStar.Heap.contains@tok () Term)
(assert (! (= 2243 (Term_constr_id FStar.Heap.contains@tok)) :named fresh_token_FStar.Heap.contains@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT FStar.Heap.contains@tok @x0) @x1) @x2) (FStar.Heap.contains @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT FStar.Heap.contains@tok @x0) @x1) @x2)))) :named token_correspondence_FStar.Heap.contains))
(assert (! (HasType FStar.Heap.contains@tok (Tm_arrow_2241 Prims.bool FStar.Heap.heap)) :named function_token_typing_FStar.Heap.contains))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 FStar.Heap.heap) (HasType @x2 (FStar.Heap.ref @x0))) (HasType (FStar.Heap.contains @x0 @x1 @x2) Prims.bool)) :pattern ((FStar.Heap.contains @x0 @x1 @x2)))) :named typing_FStar.Heap.contains))
(declare-fun FStar.Heap.equal (Term Term) Term)
(declare-fun FStar.Heap.equal@tok () Term)
(assert (! (= 2245 (Term_constr_id FStar.Heap.equal@tok)) :named fresh_token_FStar.Heap.equal@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (ApplyTT (ApplyTT FStar.Heap.equal@tok @x0) @x1) (FStar.Heap.equal @x0 @x1)) :pattern ((ApplyTT (ApplyTT FStar.Heap.equal@tok @x0) @x1)))) :named token_correspondence_FStar.Heap.equal))
(assert (! (HasType FStar.Heap.equal@tok (Tm_arrow_2042 Prims.bool FStar.Heap.heap)) :named function_token_typing_FStar.Heap.equal))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 FStar.Heap.heap) (HasType @x1 FStar.Heap.heap)) (HasType (FStar.Heap.equal @x0 @x1) Prims.bool)) :pattern ((FStar.Heap.equal @x0 @x1)))) :named typing_FStar.Heap.equal))
(declare-fun FStar.Heap.restrict (Term Term) Term)
(declare-fun Tm_arrow_2247 (Term) Term)
(assert (! (forall ((@x0 Term)) (! (HasType (Tm_arrow_2247 @x0) Tm_type) :pattern ((HasType (Tm_arrow_2247 @x0) Tm_type)))) :named kinding_Tm_arrow_2247))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_2247 @x2)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_2247 @x2))))) :named pre_typing_Tm_arrow_2247))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_2247 @x1)) (forall ((@x2 Term) (@x3 Term)) (! (implies (and (HasType @x2 @x1) (HasType @x3 (FStar.TSet.set FStar.Heap.aref))) (HasType (ApplyTT (ApplyTT @x0 @x2) @x3) @x1)) :pattern ((ApplyTT (ApplyTT @x0 @x2) @x3))))) :pattern ((HasTypeZ @x0 (Tm_arrow_2247 @x1))))) :named interpretation_Tm_arrow_2247))
(declare-fun FStar.Heap.restrict@tok () Term)
(assert (! (= 2249 (Term_constr_id FStar.Heap.restrict@tok)) :named fresh_token_FStar.Heap.restrict@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (ApplyTT (ApplyTT FStar.Heap.restrict@tok @x0) @x1) (FStar.Heap.restrict @x0 @x1)) :pattern ((ApplyTT (ApplyTT FStar.Heap.restrict@tok @x0) @x1)))) :named token_correspondence_FStar.Heap.restrict))
(assert (! (HasType FStar.Heap.restrict@tok (Tm_arrow_2247 FStar.Heap.heap)) :named function_token_typing_FStar.Heap.restrict))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 FStar.Heap.heap) (HasType @x1 (FStar.TSet.set FStar.Heap.aref))) (HasType (FStar.Heap.restrict @x0 @x1) FStar.Heap.heap)) :pattern ((FStar.Heap.restrict @x0 @x1)))) :named typing_FStar.Heap.restrict))
(declare-fun FStar.Heap.concat (Term Term) Term)
(declare-fun FStar.Heap.concat@tok () Term)
(assert (! (= 2251 (Term_constr_id FStar.Heap.concat@tok)) :named fresh_token_FStar.Heap.concat@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (ApplyTT (ApplyTT FStar.Heap.concat@tok @x0) @x1) (FStar.Heap.concat @x0 @x1)) :pattern ((ApplyTT (ApplyTT FStar.Heap.concat@tok @x0) @x1)))) :named token_correspondence_FStar.Heap.concat))
(assert (! (HasType FStar.Heap.concat@tok (Tm_arrow_331 FStar.Heap.heap)) :named function_token_typing_FStar.Heap.concat))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 FStar.Heap.heap) (HasType @x1 FStar.Heap.heap)) (HasType (FStar.Heap.concat @x0 @x1) FStar.Heap.heap)) :pattern ((FStar.Heap.concat @x0 @x1)))) :named typing_FStar.Heap.concat))
(declare-fun FStar.Heap.domain (Term) Term)
(declare-fun Tm_arrow_2253 (Term) Term)
(assert (! (forall ((@x0 Term)) (! (HasType (Tm_arrow_2253 @x0) Tm_type) :pattern ((HasType (Tm_arrow_2253 @x0) Tm_type)))) :named kinding_Tm_arrow_2253))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_2253 @x2)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_2253 @x2))))) :named pre_typing_Tm_arrow_2253))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_2253 @x1)) (forall ((@x2 Term)) (! (implies (HasType @x2 @x1) (HasType (ApplyTT @x0 @x2) (FStar.TSet.set FStar.Heap.aref))) :pattern ((ApplyTT @x0 @x2))))) :pattern ((HasTypeZ @x0 (Tm_arrow_2253 @x1))))) :named interpretation_Tm_arrow_2253))
(declare-fun FStar.Heap.domain@tok () Term)
(assert (! (= 2255 (Term_constr_id FStar.Heap.domain@tok)) :named fresh_token_FStar.Heap.domain@tok))
(assert (! (forall ((@x0 Term)) (! (= (ApplyTT FStar.Heap.domain@tok @x0) (FStar.Heap.domain @x0)) :pattern ((ApplyTT FStar.Heap.domain@tok @x0)))) :named token_correspondence_FStar.Heap.domain))
(assert (! (HasType FStar.Heap.domain@tok (Tm_arrow_2253 FStar.Heap.heap)) :named function_token_typing_FStar.Heap.domain))
(assert (! (forall ((@x0 Term)) (! (implies (HasType @x0 FStar.Heap.heap) (HasType (FStar.Heap.domain @x0) (FStar.TSet.set FStar.Heap.aref))) :pattern ((FStar.Heap.domain @x0)))) :named typing_FStar.Heap.domain))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 FStar.Heap.heap) (HasType @x2 (FStar.Heap.ref @x0)) (HasType @x3 @x0)) (= (FStar.Heap.sel @x0 (FStar.Heap.upd @x0 @x1 @x2 @x3) @x2) @x3)) :pattern ((FStar.Heap.sel @x0 (FStar.Heap.upd @x0 @x1 @x2 @x3) @x2)))) :named assumption_FStar.Heap.SelUpd1_2256))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 FStar.Heap.heap) (HasType @x3 (FStar.Heap.ref @x0)) (HasType @x4 (FStar.Heap.ref @x1)) (HasType @x5 @x1) (not (= @x4 @x3))) (= (FStar.Heap.sel @x0 (FStar.Heap.upd @x1 @x2 @x4 @x5) @x3) (FStar.Heap.sel @x0 @x2 @x3))) :pattern ((FStar.Heap.sel @x0 (FStar.Heap.upd @x1 @x2 @x4 @x5) @x3)))) :named assumption_FStar.Heap.SelUpd2_2257))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 (FStar.Heap.ref @x0))) (not (BoxBool_proj_0 (FStar.Heap.contains @x0 FStar.Heap.emp @x1)))) :pattern ((FStar.Heap.contains @x0 FStar.Heap.emp @x1)))) :named assumption_FStar.Heap.InDomEmp_2258))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 FStar.Heap.heap) (HasType @x1 FStar.Heap.heap)) (iff (BoxBool_proj_0 (FStar.Heap.equal @x0 @x1)) (= @x0 @x1))) :pattern ((FStar.Heap.equal @x0 @x1)))) :named assumption_FStar.Heap.Extensional_2259))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 FStar.Heap.heap) (HasType @x1 FStar.Heap.heap)) (iff (BoxBool_proj_0 (FStar.Heap.equal @x0 @x1)) (forall ((@x2 Term) (@x3 Term)) (! (implies (and (HasType @x2 Tm_type) (HasType @x3 (FStar.Heap.ref @x2))) (= (FStar.Heap.sel @x2 @x0 @x3) (FStar.Heap.sel @x2 @x1 @x3))) :pattern ((FStar.Heap.sel @x2 @x0 @x3) (FStar.Heap.sel @x2 @x1 @x3)))))) :pattern ((FStar.Heap.equal @x0 @x1)))) :named assumption_FStar.Heap.Equals_2260))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 FStar.Heap.heap) (HasType @x2 (FStar.TSet.set FStar.Heap.aref)) (HasType @x3 (FStar.Heap.ref @x0)) (Valid (FStar.TSet.mem FStar.Heap.aref (FStar.Heap.Ref @x0 @x3) @x2))) (= (FStar.Heap.sel @x0 (FStar.Heap.restrict @x1 @x2) @x3) (FStar.Heap.sel @x0 @x1 @x3))) :pattern ((FStar.Heap.sel @x0 (FStar.Heap.restrict @x1 @x2) @x3)))) :named assumption_FStar.Heap.RestrictSel_2261))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 FStar.Heap.heap) (HasType @x2 FStar.Heap.heap) (HasType @x3 (FStar.Heap.ref @x0))) (ite (= (FStar.Heap.contains @x0 @x2 @x3) (BoxBool true)) (= (FStar.Heap.sel @x0 (FStar.Heap.concat @x1 @x2) @x3) (FStar.Heap.sel @x0 @x2 @x3)) (ite true (= (FStar.Heap.sel @x0 (FStar.Heap.concat @x1 @x2) @x3) (FStar.Heap.sel @x0 @x1 @x3)) false))) :pattern ((FStar.Heap.sel @x0 (FStar.Heap.concat @x1 @x2) @x3)))) :named assumption_FStar.Heap.SelConcat_2262))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 FStar.Heap.heap) (HasType @x2 (FStar.Heap.ref @x0)) (HasType @x3 @x0)) (= (FStar.Heap.domain (FStar.Heap.upd @x0 @x1 @x2 @x3)) (FStar.TSet.union FStar.Heap.aref (FStar.Heap.domain @x1) (FStar.TSet.singleton FStar.Heap.aref (FStar.Heap.Ref @x0 @x2))))) :pattern ((FStar.Heap.domain (FStar.Heap.upd @x0 @x1 @x2 @x3))))) :named assumption_FStar.Heap.DomUpd_2263))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 FStar.Heap.heap) (HasType @x1 (FStar.TSet.set FStar.Heap.aref))) (= (FStar.Heap.domain (FStar.Heap.restrict @x0 @x1)) (FStar.TSet.intersect FStar.Heap.aref (FStar.Heap.domain @x0) @x1))) :pattern ((FStar.Heap.domain (FStar.Heap.restrict @x0 @x1))))) :named assumption_FStar.Heap.DomRestrict_2264))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 FStar.Heap.heap) (HasType @x1 FStar.Heap.heap)) (= (FStar.Heap.domain (FStar.Heap.concat @x0 @x1)) (FStar.TSet.union FStar.Heap.aref (FStar.Heap.domain @x0) (FStar.Heap.domain @x1)))) :pattern ((FStar.Heap.domain (FStar.Heap.concat @x0 @x1))))) :named assumption_FStar.Heap.DomConcat_2265))
(assert (! (= (FStar.Heap.domain FStar.Heap.emp) (FStar.TSet.empty FStar.Heap.aref)) :named assumption_FStar.Heap.DomEmp_2266))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 FStar.Heap.heap) (HasType @x2 (FStar.Heap.ref @x0))) (iff (BoxBool_proj_0 (FStar.Heap.contains @x0 @x1 @x2)) (Valid (FStar.TSet.mem FStar.Heap.aref (FStar.Heap.Ref @x0 @x2) (FStar.Heap.domain @x1))))) :pattern ((FStar.Heap.contains @x0 @x1 @x2)))) :named assumption_FStar.Heap.DomContains_2267))
(declare-fun FStar.Heap.on (Term Term Term) Term)
(declare-fun Tm_arrow_2271 (Term) Term)
(assert (! (forall ((@x0 Term)) (! (HasType (Tm_arrow_2271 @x0) Tm_type) :pattern ((HasType (Tm_arrow_2271 @x0) Tm_type)))) :named kinding_Tm_arrow_2271))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_2271 @x2)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_2271 @x2))))) :named pre_typing_Tm_arrow_2271))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_2271 @x1)) (forall ((@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x2 (FStar.TSet.set FStar.Heap.aref)) (HasType @x3 (Tm_arrow_239 @x1)) (HasType @x4 @x1)) (HasType (ApplyTT (ApplyTT (ApplyTT @x0 @x2) @x3) @x4) Tm_type)) :pattern ((ApplyTT (ApplyTT (ApplyTT @x0 @x2) @x3) @x4))))) :pattern ((HasTypeZ @x0 (Tm_arrow_2271 @x1))))) :named interpretation_Tm_arrow_2271))
(declare-fun FStar.Heap.on@tok () Term)
(assert (! (= 2273 (Term_constr_id FStar.Heap.on@tok)) :named fresh_token_FStar.Heap.on@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT FStar.Heap.on@tok @x0) @x1) @x2) (FStar.Heap.on @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT FStar.Heap.on@tok @x0) @x1) @x2)))) :named token_correspondence_FStar.Heap.on))
(assert (! (HasType FStar.Heap.on@tok (Tm_arrow_2271 FStar.Heap.heap)) :named function_token_typing_FStar.Heap.on))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 (FStar.TSet.set FStar.Heap.aref)) (HasType @x1 (Tm_arrow_239 FStar.Heap.heap)) (HasType @x2 FStar.Heap.heap)) (HasType (FStar.Heap.on @x0 @x1 @x2) Tm_type)) :pattern ((FStar.Heap.on @x0 @x1 @x2)))) :named typing_FStar.Heap.on))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (FStar.Heap.on @x0 @x1 @x2) (ApplyTT @x1 (FStar.Heap.restrict @x2 @x0))) :pattern ((FStar.Heap.on @x0 @x1 @x2)))) :named equation_FStar.Heap.on))
(declare-fun FStar.Heap.fresh (Term Term Term) Term)
(declare-fun Tm_arrow_2276 (Term) Term)
(assert (! (forall ((@x0 Term)) (! (HasType (Tm_arrow_2276 @x0) Tm_type) :pattern ((HasType (Tm_arrow_2276 @x0) Tm_type)))) :named kinding_Tm_arrow_2276))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_2276 @x2)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_2276 @x2))))) :named pre_typing_Tm_arrow_2276))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_2276 @x1)) (forall ((@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x2 (FStar.TSet.set FStar.Heap.aref)) (HasType @x3 @x1) (HasType @x4 @x1)) (HasType (ApplyTT (ApplyTT (ApplyTT @x0 @x2) @x3) @x4) Tm_type)) :pattern ((ApplyTT (ApplyTT (ApplyTT @x0 @x2) @x3) @x4))))) :pattern ((HasTypeZ @x0 (Tm_arrow_2276 @x1))))) :named interpretation_Tm_arrow_2276))
(declare-fun FStar.Heap.fresh@tok () Term)
(assert (! (= 2278 (Term_constr_id FStar.Heap.fresh@tok)) :named fresh_token_FStar.Heap.fresh@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT FStar.Heap.fresh@tok @x0) @x1) @x2) (FStar.Heap.fresh @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT FStar.Heap.fresh@tok @x0) @x1) @x2)))) :named token_correspondence_FStar.Heap.fresh))
(assert (! (HasType FStar.Heap.fresh@tok (Tm_arrow_2276 FStar.Heap.heap)) :named function_token_typing_FStar.Heap.fresh))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 (FStar.TSet.set FStar.Heap.aref)) (HasType @x1 FStar.Heap.heap) (HasType @x2 FStar.Heap.heap)) (HasType (FStar.Heap.fresh @x0 @x1 @x2) Tm_type)) :pattern ((FStar.Heap.fresh @x0 @x1 @x2)))) :named typing_FStar.Heap.fresh))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (Valid (FStar.Heap.fresh @x0 @x1 @x2)) (forall ((@x3 Term) (@x4 Term)) (! (implies (and (HasType @x3 Tm_type) (HasType @x4 (FStar.Heap.ref @x3)) (Valid (FStar.TSet.mem FStar.Heap.aref (FStar.Heap.Ref @x3 @x4) @x0))) (and (not (BoxBool_proj_0 (FStar.Heap.contains @x3 @x1 @x4))) (BoxBool_proj_0 (FStar.Heap.contains @x3 @x2 @x4)))) :pattern ((FStar.Heap.contains @x3 @x1 @x4))))) :pattern ((Valid (FStar.Heap.fresh @x0 @x1 @x2))))) :named equation_FStar.Heap.fresh))
(declare-fun FStar.Heap.modifies (Term Term Term) Term)
(declare-fun FStar.Heap.modifies@tok () Term)
(assert (! (= 2280 (Term_constr_id FStar.Heap.modifies@tok)) :named fresh_token_FStar.Heap.modifies@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT FStar.Heap.modifies@tok @x0) @x1) @x2) (FStar.Heap.modifies @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT FStar.Heap.modifies@tok @x0) @x1) @x2)))) :named token_correspondence_FStar.Heap.modifies))
(assert (! (HasType FStar.Heap.modifies@tok (Tm_arrow_2276 FStar.Heap.heap)) :named function_token_typing_FStar.Heap.modifies))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 (FStar.TSet.set FStar.Heap.aref)) (HasType @x1 FStar.Heap.heap) (HasType @x2 FStar.Heap.heap)) (HasType (FStar.Heap.modifies @x0 @x1 @x2) Tm_type)) :pattern ((FStar.Heap.modifies @x0 @x1 @x2)))) :named typing_FStar.Heap.modifies))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (Valid (FStar.Heap.modifies @x0 @x1 @x2)) (and (BoxBool_proj_0 (FStar.Heap.equal @x2 (FStar.Heap.concat @x2 (FStar.Heap.restrict @x1 (FStar.TSet.complement FStar.Heap.aref @x0))))) (Valid (FStar.TSet.subset FStar.Heap.aref (FStar.Heap.domain @x1) (FStar.Heap.domain @x2))))) :pattern ((Valid (FStar.Heap.modifies @x0 @x1 @x2))))) :named equation_FStar.Heap.modifies))
(declare-fun FStar.Heap.lemma_modifies_trans (Term Term Term Term Term) Term)
(declare-fun FStar.Heap.lemma_modifies_trans@tok () Term)
(declare-fun FStar.Heap.only (Term Term) Term)
(declare-fun Tm_arrow_2282 () Term)
(assert (! (HasType Tm_arrow_2282 Tm_type) :named kinding_Tm_arrow_2282))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_2282) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_2282)))) :named pre_typing_Tm_arrow_2282))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_2282) (forall ((@x1 Term) (@x2 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 (FStar.Heap.ref @x1))) (HasType (ApplyTT (ApplyTT @x0 @x1) @x2) (FStar.TSet.set FStar.Heap.aref))) :pattern ((ApplyTT (ApplyTT @x0 @x1) @x2))))) :pattern ((HasTypeZ @x0 Tm_arrow_2282)))) :named interpretation_Tm_arrow_2282))
(declare-fun FStar.Heap.only@tok () Term)
(assert (! (= 2284 (Term_constr_id FStar.Heap.only@tok)) :named fresh_token_FStar.Heap.only@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (ApplyTT (ApplyTT FStar.Heap.only@tok @x0) @x1) (FStar.Heap.only @x0 @x1)) :pattern ((ApplyTT (ApplyTT FStar.Heap.only@tok @x0) @x1)))) :named token_correspondence_FStar.Heap.only))
(assert (! (HasType FStar.Heap.only@tok Tm_arrow_2282) :named function_token_typing_FStar.Heap.only))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 (FStar.Heap.ref @x0))) (HasType (FStar.Heap.only @x0 @x1) (FStar.TSet.set FStar.Heap.aref))) :pattern ((FStar.Heap.only @x0 @x1)))) :named typing_FStar.Heap.only))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (FStar.Heap.only @x0 @x1) (FStar.TSet.singleton FStar.Heap.aref (FStar.Heap.Ref @x0 @x1))) :pattern ((FStar.Heap.only @x0 @x1)))) :named equation_FStar.Heap.only))
(declare-fun FStar.Heap.op_Hat_Plus_Plus (Term Term Term Term) Term)
(declare-fun Tm_arrow_2286 () Term)
(assert (! (HasType Tm_arrow_2286 Tm_type) :named kinding_Tm_arrow_2286))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_2286) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_2286)))) :named pre_typing_Tm_arrow_2286))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_2286) (forall ((@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 (FStar.Heap.ref @x1)) (HasType @x4 (FStar.TSet.set FStar.Heap.aref))) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) (FStar.TSet.set FStar.Heap.aref))) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4))))) :pattern ((HasTypeZ @x0 Tm_arrow_2286)))) :named interpretation_Tm_arrow_2286))
(declare-fun FStar.Heap.op_Hat_Plus_Plus@tok () Term)
(assert (! (= 2288 (Term_constr_id FStar.Heap.op_Hat_Plus_Plus@tok)) :named fresh_token_FStar.Heap.op_Hat_Plus_Plus@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.Heap.op_Hat_Plus_Plus@tok @x0) @x1) @x2) @x3) (FStar.Heap.op_Hat_Plus_Plus @x0 @x1 @x2 @x3)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.Heap.op_Hat_Plus_Plus@tok @x0) @x1) @x2) @x3)))) :named token_correspondence_FStar.Heap.op_Hat_Plus_Plus))
(assert (! (HasType FStar.Heap.op_Hat_Plus_Plus@tok Tm_arrow_2286) :named function_token_typing_FStar.Heap.op_Hat_Plus_Plus))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 (FStar.Heap.ref @x0)) (HasType @x3 (FStar.TSet.set FStar.Heap.aref))) (HasType (FStar.Heap.op_Hat_Plus_Plus @x0 @x1 @x2 @x3) (FStar.TSet.set FStar.Heap.aref))) :pattern ((FStar.Heap.op_Hat_Plus_Plus @x0 @x1 @x2 @x3)))) :named typing_FStar.Heap.op_Hat_Plus_Plus))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (FStar.Heap.op_Hat_Plus_Plus @x0 @x1 @x2 @x3) (FStar.TSet.union FStar.Heap.aref (FStar.TSet.singleton FStar.Heap.aref (FStar.Heap.Ref @x0 @x2)) @x3)) :pattern ((FStar.Heap.op_Hat_Plus_Plus @x0 @x1 @x2 @x3)))) :named equation_FStar.Heap.op_Hat_Plus_Plus))
(declare-fun FStar.Heap.op_Plus_Plus_Hat (Term Term Term Term) Term)
(declare-fun Tm_arrow_2290 () Term)
(assert (! (HasType Tm_arrow_2290 Tm_type) :named kinding_Tm_arrow_2290))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_2290) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_2290)))) :named pre_typing_Tm_arrow_2290))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_2290) (forall ((@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 (FStar.TSet.set FStar.Heap.aref)) (HasType @x4 (FStar.Heap.ref @x1))) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) (FStar.TSet.set FStar.Heap.aref))) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4))))) :pattern ((HasTypeZ @x0 Tm_arrow_2290)))) :named interpretation_Tm_arrow_2290))
(declare-fun FStar.Heap.op_Plus_Plus_Hat@tok () Term)
(assert (! (= 2292 (Term_constr_id FStar.Heap.op_Plus_Plus_Hat@tok)) :named fresh_token_FStar.Heap.op_Plus_Plus_Hat@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.Heap.op_Plus_Plus_Hat@tok @x0) @x1) @x2) @x3) (FStar.Heap.op_Plus_Plus_Hat @x0 @x1 @x2 @x3)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.Heap.op_Plus_Plus_Hat@tok @x0) @x1) @x2) @x3)))) :named token_correspondence_FStar.Heap.op_Plus_Plus_Hat))
(assert (! (HasType FStar.Heap.op_Plus_Plus_Hat@tok Tm_arrow_2290) :named function_token_typing_FStar.Heap.op_Plus_Plus_Hat))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 (FStar.TSet.set FStar.Heap.aref)) (HasType @x3 (FStar.Heap.ref @x0))) (HasType (FStar.Heap.op_Plus_Plus_Hat @x0 @x1 @x2 @x3) (FStar.TSet.set FStar.Heap.aref))) :pattern ((FStar.Heap.op_Plus_Plus_Hat @x0 @x1 @x2 @x3)))) :named typing_FStar.Heap.op_Plus_Plus_Hat))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (FStar.Heap.op_Plus_Plus_Hat @x0 @x1 @x2 @x3) (FStar.TSet.union FStar.Heap.aref @x2 (FStar.TSet.singleton FStar.Heap.aref (FStar.Heap.Ref @x0 @x3)))) :pattern ((FStar.Heap.op_Plus_Plus_Hat @x0 @x1 @x2 @x3)))) :named equation_FStar.Heap.op_Plus_Plus_Hat))
(declare-fun FStar.Heap.op_Hat_Plus_Hat (Term Term Term Term Term Term) Term)
(declare-fun Tm_arrow_2294 () Term)
(assert (! (HasType Tm_arrow_2294 Tm_type) :named kinding_Tm_arrow_2294))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_2294) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_2294)))) :named pre_typing_Tm_arrow_2294))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_2294) (forall ((@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 Tm_type) (HasType @x5 (FStar.Heap.ref @x2)) (HasType @x6 (FStar.Heap.ref @x1))) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x6) (FStar.TSet.set FStar.Heap.aref))) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x1) @x2) @x3) @x4) @x5) @x6))))) :pattern ((HasTypeZ @x0 Tm_arrow_2294)))) :named interpretation_Tm_arrow_2294))
(declare-fun FStar.Heap.op_Hat_Plus_Hat@tok () Term)
(assert (! (= 2296 (Term_constr_id FStar.Heap.op_Hat_Plus_Hat@tok)) :named fresh_token_FStar.Heap.op_Hat_Plus_Hat@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.Heap.op_Hat_Plus_Hat@tok @x0) @x1) @x2) @x3) @x4) @x5) (FStar.Heap.op_Hat_Plus_Hat @x0 @x1 @x2 @x3 @x4 @x5)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.Heap.op_Hat_Plus_Hat@tok @x0) @x1) @x2) @x3) @x4) @x5)))) :named token_correspondence_FStar.Heap.op_Hat_Plus_Hat))
(assert (! (HasType FStar.Heap.op_Hat_Plus_Hat@tok Tm_arrow_2294) :named function_token_typing_FStar.Heap.op_Hat_Plus_Hat))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 Tm_type) (HasType @x2 Tm_type) (HasType @x3 Tm_type) (HasType @x4 (FStar.Heap.ref @x1)) (HasType @x5 (FStar.Heap.ref @x0))) (HasType (FStar.Heap.op_Hat_Plus_Hat @x0 @x1 @x2 @x3 @x4 @x5) (FStar.TSet.set FStar.Heap.aref))) :pattern ((FStar.Heap.op_Hat_Plus_Hat @x0 @x1 @x2 @x3 @x4 @x5)))) :named typing_FStar.Heap.op_Hat_Plus_Hat))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (= (FStar.Heap.op_Hat_Plus_Hat @x0 @x1 @x2 @x3 @x4 @x5) (FStar.TSet.union FStar.Heap.aref (FStar.TSet.singleton FStar.Heap.aref (FStar.Heap.Ref @x1 @x4)) (FStar.TSet.singleton FStar.Heap.aref (FStar.Heap.Ref @x0 @x5)))) :pattern ((FStar.Heap.op_Hat_Plus_Hat @x0 @x1 @x2 @x3 @x4 @x5)))) :named equation_FStar.Heap.op_Hat_Plus_Hat))
(declare-fun FStar.HyperHeap.rid () Term)
(assert (! (HasType FStar.HyperHeap.rid Tm_type) :named function_token_typing_FStar.HyperHeap.rid))
(assert (! (HasType FStar.HyperHeap.rid Tm_type) :named typing_FStar.HyperHeap.rid))
(declare-fun FStar.HyperHeap.color (Term) Term)
(declare-fun FStar.HyperHeap.color@tok () Term)
(assert (! (= 2644 (Term_constr_id FStar.HyperHeap.color@tok)) :named fresh_token_FStar.HyperHeap.color@tok))
(assert (! (forall ((@x0 Term)) (! (= (ApplyTT FStar.HyperHeap.color@tok @x0) (FStar.HyperHeap.color @x0)) :pattern ((ApplyTT FStar.HyperHeap.color@tok @x0)))) :named token_correspondence_FStar.HyperHeap.color))
(assert (! (HasType FStar.HyperHeap.color@tok (Tm_arrow_228 Prims.int FStar.HyperHeap.rid)) :named function_token_typing_FStar.HyperHeap.color))
(assert (! (forall ((@x0 Term)) (! (implies (HasType @x0 FStar.HyperHeap.rid) (HasType (FStar.HyperHeap.color @x0) Prims.int)) :pattern ((FStar.HyperHeap.color @x0)))) :named typing_FStar.HyperHeap.color))
(declare-fun FStar.HyperHeap.t () Term)
(assert (! (HasType FStar.HyperHeap.t Tm_type) :named function_token_typing_FStar.HyperHeap.t))
(assert (! (HasType FStar.HyperHeap.t Tm_type) :named typing_FStar.HyperHeap.t))
(assert (! (= FStar.HyperHeap.t (FStar.Map.t FStar.HyperHeap.rid FStar.Heap.heap)) :named equation_FStar.HyperHeap.t))
(declare-fun FStar.HyperHeap.has_eq_rid (Term) Term)
(declare-fun FStar.HyperHeap.has_eq_rid@tok () Term)
(assert (! (Valid (Prims.hasEq FStar.HyperHeap.rid)) :named assumption_FStar.HyperHeap.HasEq_rid_2645))
(declare-fun FStar.HyperHeap.root () Term)
(assert (! (HasType FStar.HyperHeap.root FStar.HyperHeap.rid) :named function_token_typing_FStar.HyperHeap.root))
(assert (! (HasType FStar.HyperHeap.root FStar.HyperHeap.rid) :named typing_FStar.HyperHeap.root))
(declare-fun FStar.HyperHeap.root_has_color_zero (Term) Term)
(declare-fun FStar.HyperHeap.root_has_color_zero@tok () Term)
(declare-fun FStar.HyperHeap.rref (Term Term) Term)
(declare-fun FStar.HyperHeap.rref@tok () Term)
(assert (! (= 2647 (Term_constr_id FStar.HyperHeap.rref@tok)) :named fresh_token_FStar.HyperHeap.rref@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (ApplyTT (ApplyTT FStar.HyperHeap.rref@tok @x0) @x1) (FStar.HyperHeap.rref @x0 @x1)) :pattern ((ApplyTT (ApplyTT FStar.HyperHeap.rref@tok @x0) @x1)))) :named token_correspondence_FStar.HyperHeap.rref))
(assert (! (HasType FStar.HyperHeap.rref@tok (Tm_arrow_1378 FStar.HyperHeap.rid)) :named function_token_typing_FStar.HyperHeap.rref))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 FStar.HyperHeap.rid) (HasType @x1 Tm_type)) (HasType (FStar.HyperHeap.rref @x0 @x1) Tm_type)) :pattern ((FStar.HyperHeap.rref @x0 @x1)))) :named typing_FStar.HyperHeap.rref))
(declare-fun FStar.HyperHeap.has_eq_rref (Term Term) Term)
(declare-fun FStar.HyperHeap.has_eq_rref@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 FStar.HyperHeap.rid) (HasType @x1 Tm_type)) (Valid (Prims.hasEq (FStar.HyperHeap.rref @x0 @x1)))) :pattern ((Prims.hasEq (FStar.HyperHeap.rref @x0 @x1))))) :named lemma_FStar.HyperHeap.has_eq_rref))
(declare-fun FStar.HyperHeap.as_ref (Term Term Term) Term)
(declare-fun Tm_arrow_2649 (Term) Term)
(assert (! (forall ((@x0 Term)) (! (HasType (Tm_arrow_2649 @x0) Tm_type) :pattern ((HasType (Tm_arrow_2649 @x0) Tm_type)))) :named kinding_Tm_arrow_2649))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_2649 @x2)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_2649 @x2))))) :named pre_typing_Tm_arrow_2649))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_2649 @x1)) (forall ((@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x2 Tm_type) (HasType @x3 @x1) (HasType @x4 (FStar.HyperHeap.rref @x3 @x2))) (HasType (ApplyTT (ApplyTT (ApplyTT @x0 @x2) @x3) @x4) (FStar.Heap.ref @x2))) :pattern ((ApplyTT (ApplyTT (ApplyTT @x0 @x2) @x3) @x4))))) :pattern ((HasTypeZ @x0 (Tm_arrow_2649 @x1))))) :named interpretation_Tm_arrow_2649))
(declare-fun FStar.HyperHeap.as_ref@tok () Term)
(assert (! (= 2651 (Term_constr_id FStar.HyperHeap.as_ref@tok)) :named fresh_token_FStar.HyperHeap.as_ref@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT FStar.HyperHeap.as_ref@tok @x0) @x1) @x2) (FStar.HyperHeap.as_ref @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT FStar.HyperHeap.as_ref@tok @x0) @x1) @x2)))) :named token_correspondence_FStar.HyperHeap.as_ref))
(assert (! (HasType FStar.HyperHeap.as_ref@tok (Tm_arrow_2649 FStar.HyperHeap.rid)) :named function_token_typing_FStar.HyperHeap.as_ref))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 FStar.HyperHeap.rid) (HasType @x2 (FStar.HyperHeap.rref @x1 @x0))) (HasType (FStar.HyperHeap.as_ref @x0 @x1 @x2) (FStar.Heap.ref @x0))) :pattern ((FStar.HyperHeap.as_ref @x0 @x1 @x2)))) :named typing_FStar.HyperHeap.as_ref))
(declare-fun FStar.HyperHeap.ref_as_rref (Term Term Term) Term)
(declare-fun Tm_arrow_2653 (Term) Term)
(assert (! (forall ((@x0 Term)) (! (HasType (Tm_arrow_2653 @x0) Tm_type) :pattern ((HasType (Tm_arrow_2653 @x0) Tm_type)))) :named kinding_Tm_arrow_2653))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_2653 @x2)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_2653 @x2))))) :named pre_typing_Tm_arrow_2653))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_2653 @x1)) (forall ((@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x2 Tm_type) (HasType @x3 @x1) (HasType @x4 (FStar.Heap.ref @x2))) (HasType (ApplyTT (ApplyTT (ApplyTT @x0 @x2) @x3) @x4) (FStar.HyperHeap.rref @x3 @x2))) :pattern ((ApplyTT (ApplyTT (ApplyTT @x0 @x2) @x3) @x4))))) :pattern ((HasTypeZ @x0 (Tm_arrow_2653 @x1))))) :named interpretation_Tm_arrow_2653))
(declare-fun FStar.HyperHeap.ref_as_rref@tok () Term)
(assert (! (= 2655 (Term_constr_id FStar.HyperHeap.ref_as_rref@tok)) :named fresh_token_FStar.HyperHeap.ref_as_rref@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT FStar.HyperHeap.ref_as_rref@tok @x0) @x1) @x2) (FStar.HyperHeap.ref_as_rref @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT FStar.HyperHeap.ref_as_rref@tok @x0) @x1) @x2)))) :named token_correspondence_FStar.HyperHeap.ref_as_rref))
(assert (! (HasType FStar.HyperHeap.ref_as_rref@tok (Tm_arrow_2653 FStar.HyperHeap.rid)) :named function_token_typing_FStar.HyperHeap.ref_as_rref))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 FStar.HyperHeap.rid) (HasType @x2 (FStar.Heap.ref @x0))) (HasType (FStar.HyperHeap.ref_as_rref @x0 @x1 @x2) (FStar.HyperHeap.rref @x1 @x0))) :pattern ((FStar.HyperHeap.ref_as_rref @x0 @x1 @x2)))) :named typing_FStar.HyperHeap.ref_as_rref))
(declare-fun FStar.HyperHeap.lemma_as_ref_inj (Term Term Term) Term)
(declare-fun FStar.HyperHeap.lemma_as_ref_inj@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 FStar.HyperHeap.rid) (HasType @x2 (FStar.HyperHeap.rref @x1 @x0))) (= (FStar.HyperHeap.ref_as_rref @x0 @x1 (FStar.HyperHeap.as_ref @x0 @x1 @x2)) @x2)) :pattern ((FStar.HyperHeap.as_ref @x0 @x1 @x2)))) :named lemma_FStar.HyperHeap.lemma_as_ref_inj))
(declare-fun FStar.HyperHeap.includes (Term Term) Term)
(declare-fun FStar.HyperHeap.includes@tok () Term)
(assert (! (= 2657 (Term_constr_id FStar.HyperHeap.includes@tok)) :named fresh_token_FStar.HyperHeap.includes@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (ApplyTT (ApplyTT FStar.HyperHeap.includes@tok @x0) @x1) (FStar.HyperHeap.includes @x0 @x1)) :pattern ((ApplyTT (ApplyTT FStar.HyperHeap.includes@tok @x0) @x1)))) :named token_correspondence_FStar.HyperHeap.includes))
(assert (! (HasType FStar.HyperHeap.includes@tok (Tm_arrow_2042 Prims.bool FStar.HyperHeap.rid)) :named function_token_typing_FStar.HyperHeap.includes))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 FStar.HyperHeap.rid) (HasType @x1 FStar.HyperHeap.rid)) (HasType (FStar.HyperHeap.includes @x0 @x1) Prims.bool)) :pattern ((FStar.HyperHeap.includes @x0 @x1)))) :named typing_FStar.HyperHeap.includes))
(declare-fun FStar.HyperHeap.disjoint (Term Term) Term)
(declare-fun FStar.HyperHeap.disjoint@tok () Term)
(assert (! (= 2659 (Term_constr_id FStar.HyperHeap.disjoint@tok)) :named fresh_token_FStar.HyperHeap.disjoint@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (ApplyTT (ApplyTT FStar.HyperHeap.disjoint@tok @x0) @x1) (FStar.HyperHeap.disjoint @x0 @x1)) :pattern ((ApplyTT (ApplyTT FStar.HyperHeap.disjoint@tok @x0) @x1)))) :named token_correspondence_FStar.HyperHeap.disjoint))
(assert (! (HasType FStar.HyperHeap.disjoint@tok (Tm_arrow_2042 Prims.bool FStar.HyperHeap.rid)) :named function_token_typing_FStar.HyperHeap.disjoint))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 FStar.HyperHeap.rid) (HasType @x1 FStar.HyperHeap.rid)) (HasType (FStar.HyperHeap.disjoint @x0 @x1) Prims.bool)) :pattern ((FStar.HyperHeap.disjoint @x0 @x1)))) :named typing_FStar.HyperHeap.disjoint))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (FStar.HyperHeap.disjoint @x0 @x1) (Prims.op_AmpAmp (Prims.op_Negation (FStar.HyperHeap.includes @x0 @x1)) (Prims.op_Negation (FStar.HyperHeap.includes @x1 @x0)))) :pattern ((FStar.HyperHeap.disjoint @x0 @x1)))) :named equation_FStar.HyperHeap.disjoint))
(declare-fun FStar.HyperHeap.lemma_aux (Term Term) Term)
(declare-fun FStar.HyperHeap.lemma_aux@tok () Term)
(declare-fun FStar.HyperHeap.lemma_disjoint_includes (Term Term Term) Term)
(declare-fun FStar.HyperHeap.lemma_disjoint_includes@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (BoxBool_proj_0 (FStar.HyperHeap.disjoint @x0 @x1)) (BoxBool_proj_0 (FStar.HyperHeap.includes @x1 @x2)) (HasType @x0 FStar.HyperHeap.rid) (HasType @x1 FStar.HyperHeap.rid) (HasType @x2 FStar.HyperHeap.rid)) (BoxBool_proj_0 (FStar.HyperHeap.disjoint @x0 @x2))) :pattern ((FStar.HyperHeap.disjoint @x0 @x1) (FStar.HyperHeap.includes @x1 @x2)))) :named lemma_FStar.HyperHeap.lemma_disjoint_includes))
(declare-fun FStar.HyperHeap.extends (Term Term) Term)
(declare-fun FStar.HyperHeap.extends@tok () Term)
(assert (! (= 2661 (Term_constr_id FStar.HyperHeap.extends@tok)) :named fresh_token_FStar.HyperHeap.extends@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (ApplyTT (ApplyTT FStar.HyperHeap.extends@tok @x0) @x1) (FStar.HyperHeap.extends @x0 @x1)) :pattern ((ApplyTT (ApplyTT FStar.HyperHeap.extends@tok @x0) @x1)))) :named token_correspondence_FStar.HyperHeap.extends))
(assert (! (HasType FStar.HyperHeap.extends@tok (Tm_arrow_2042 Prims.bool FStar.HyperHeap.rid)) :named function_token_typing_FStar.HyperHeap.extends))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 FStar.HyperHeap.rid) (HasType @x1 FStar.HyperHeap.rid)) (HasType (FStar.HyperHeap.extends @x0 @x1) Prims.bool)) :pattern ((FStar.HyperHeap.extends @x0 @x1)))) :named typing_FStar.HyperHeap.extends))
(declare-fun Tm_refine_2663 (Term Term) Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (HasType (Tm_refine_2663 @x0 @x1) Tm_type) :pattern ((HasType (Tm_refine_2663 @x0 @x1) Tm_type)))) :named refinement_kinding_Tm_refine_2663))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (iff (HasTypeFuel @u0 @x1 (Tm_refine_2663 @x2 @x3)) (and (HasTypeFuel @u0 @x1 @x3) (not (= @x1 @x2)))) :pattern ((HasTypeFuel @u0 @x1 (Tm_refine_2663 @x2 @x3))))) :named refinement_interpretation_Tm_refine_2663))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (Valid (Prims.hasEq (Tm_refine_2663 @x0 @x1))) (Valid (Prims.hasEq @x1))) :pattern ((Valid (Prims.hasEq (Tm_refine_2663 @x0 @x1)))))) :named haseqTm_refine_2663))
(declare-fun FStar.HyperHeap.parent (Term) Term)
(declare-fun Tm_arrow_2666 (Term Term) Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (HasType (Tm_arrow_2666 @x0 @x1) Tm_type) :pattern ((HasType (Tm_arrow_2666 @x0 @x1) Tm_type)))) :named kinding_Tm_arrow_2666))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_2666 @x2 @x3)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_2666 @x2 @x3))))) :named pre_typing_Tm_arrow_2666))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_2666 @x1 @x2)) (forall ((@x3 Term)) (! (implies (HasType @x3 (Tm_refine_2663 @x2 @x1)) (HasType (ApplyTT @x0 @x3) @x1)) :pattern ((ApplyTT @x0 @x3))))) :pattern ((HasTypeZ @x0 (Tm_arrow_2666 @x1 @x2))))) :named interpretation_Tm_arrow_2666))
(declare-fun FStar.HyperHeap.parent@tok () Term)
(assert (! (= 2668 (Term_constr_id FStar.HyperHeap.parent@tok)) :named fresh_token_FStar.HyperHeap.parent@tok))
(assert (! (forall ((@x0 Term)) (! (= (ApplyTT FStar.HyperHeap.parent@tok @x0) (FStar.HyperHeap.parent @x0)) :pattern ((ApplyTT FStar.HyperHeap.parent@tok @x0)))) :named token_correspondence_FStar.HyperHeap.parent))
(assert (! (HasType FStar.HyperHeap.parent@tok (Tm_arrow_2666 FStar.HyperHeap.rid FStar.HyperHeap.root)) :named function_token_typing_FStar.HyperHeap.parent))
(assert (! (forall ((@x0 Term)) (! (implies (HasType @x0 (Tm_refine_2663 FStar.HyperHeap.root FStar.HyperHeap.rid)) (HasType (FStar.HyperHeap.parent @x0) FStar.HyperHeap.rid)) :pattern ((FStar.HyperHeap.parent @x0)))) :named typing_FStar.HyperHeap.parent))
(declare-fun FStar.HyperHeap.lemma_includes_refl (Term) Term)
(declare-fun FStar.HyperHeap.lemma_includes_refl@tok () Term)
(assert (! (forall ((@x0 Term)) (! (implies (HasType @x0 FStar.HyperHeap.rid) (BoxBool_proj_0 (FStar.HyperHeap.includes @x0 @x0))) :pattern ((FStar.HyperHeap.includes @x0 @x0)))) :named lemma_FStar.HyperHeap.lemma_includes_refl))
(declare-fun FStar.HyperHeap.lemma_extends_includes (Term Term) Term)
(declare-fun FStar.HyperHeap.lemma_extends_includes@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (BoxBool_proj_0 (FStar.HyperHeap.extends @x1 @x0)) (HasType @x0 FStar.HyperHeap.rid) (HasType @x1 FStar.HyperHeap.rid)) (and (BoxBool_proj_0 (FStar.HyperHeap.includes @x0 @x1)) (not (BoxBool_proj_0 (FStar.HyperHeap.includes @x1 @x0))))) :pattern ((FStar.HyperHeap.extends @x1 @x0)))) :named lemma_FStar.HyperHeap.lemma_extends_includes))
(declare-fun FStar.HyperHeap.lemma_includes_anti_symmetric (Term Term) Term)
(declare-fun FStar.HyperHeap.lemma_includes_anti_symmetric@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (BoxBool_proj_0 (FStar.HyperHeap.includes @x0 @x1)) (not (= @x0 @x1)) (HasType @x0 FStar.HyperHeap.rid) (HasType @x1 FStar.HyperHeap.rid)) (not (BoxBool_proj_0 (FStar.HyperHeap.includes @x1 @x0)))) :pattern ((FStar.HyperHeap.includes @x0 @x1)))) :named lemma_FStar.HyperHeap.lemma_includes_anti_symmetric))
(declare-fun FStar.HyperHeap.lemma_extends_disjoint (Term Term Term) Term)
(declare-fun FStar.HyperHeap.lemma_extends_disjoint@tok () Term)
(declare-fun FStar.HyperHeap.lemma_extends_parent (Term) Term)
(declare-fun FStar.HyperHeap.lemma_extends_parent@tok () Term)
(assert (! (forall ((@x0 Term)) (! (implies (HasType @x0 (Tm_refine_2663 FStar.HyperHeap.root FStar.HyperHeap.rid)) (BoxBool_proj_0 (FStar.HyperHeap.extends @x0 (FStar.HyperHeap.parent @x0)))) :pattern ((FStar.HyperHeap.parent @x0)))) :named lemma_FStar.HyperHeap.lemma_extends_parent))
(declare-fun FStar.HyperHeap.lemma_extends_not_root (Term Term) Term)
(declare-fun FStar.HyperHeap.lemma_extends_not_root@tok () Term)
(declare-fun Tm_refine_2671 (Term Term) Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (HasType (Tm_refine_2671 @x0 @x1) Tm_type) :pattern ((HasType (Tm_refine_2671 @x0 @x1) Tm_type)))) :named refinement_kinding_Tm_refine_2671))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (iff (HasTypeFuel @u0 @x1 (Tm_refine_2671 @x2 @x3)) (and (HasTypeFuel @u0 @x1 @x3) (BoxBool_proj_0 (FStar.HyperHeap.extends @x1 @x2)))) :pattern ((HasTypeFuel @u0 @x1 (Tm_refine_2671 @x2 @x3))))) :named refinement_interpretation_Tm_refine_2671))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (Valid (Prims.hasEq (Tm_refine_2671 @x0 @x1))) (Valid (Prims.hasEq @x1))) :pattern ((Valid (Prims.hasEq (Tm_refine_2671 @x0 @x1)))))) :named haseqTm_refine_2671))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 FStar.HyperHeap.rid) (HasType @x1 (Tm_refine_2671 @x0 FStar.HyperHeap.rid))) (not (= @x1 FStar.HyperHeap.root))) :pattern ((FStar.HyperHeap.extends @x1 @x0)))) :named lemma_FStar.HyperHeap.lemma_extends_not_root))
(declare-fun FStar.HyperHeap.lemma_extends_only_parent (Term Term) Term)
(declare-fun FStar.HyperHeap.lemma_extends_only_parent@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 FStar.HyperHeap.rid) (HasType @x1 (Tm_refine_2671 @x0 FStar.HyperHeap.rid))) (= @x0 (FStar.HyperHeap.parent @x1))) :pattern ((FStar.HyperHeap.extends @x1 @x0)))) :named lemma_FStar.HyperHeap.lemma_extends_only_parent))
(declare-fun FStar.HyperHeap.test0 () Term)
(assert (! (HasType FStar.HyperHeap.test0 Prims.unit) :named function_token_typing_FStar.HyperHeap.test0))
(assert (! (HasType FStar.HyperHeap.test0 Prims.unit) :named typing_FStar.HyperHeap.test0))
(assert (! (= FStar.HyperHeap.test0 (Prims._assert (Prims.b2t (FStar.HyperHeap.includes (Prims.Cons (Prims.tuple2 Prims.int Prims.int) (Prims.Mktuple2 Prims.int Prims.int (BoxInt 0) (BoxInt 1)) (Prims.Cons (Prims.tuple2 Prims.int Prims.int) (Prims.Mktuple2 Prims.int Prims.int (BoxInt 1) (BoxInt 0)) (Prims.Nil (Prims.tuple2 Prims.int Prims.int)))) (Prims.Cons (Prims.tuple2 Prims.int Prims.int) (Prims.Mktuple2 Prims.int Prims.int (BoxInt 2) (BoxInt 2)) (Prims.Cons (Prims.tuple2 Prims.int Prims.int) (Prims.Mktuple2 Prims.int Prims.int (BoxInt 0) (BoxInt 1)) (Prims.Cons (Prims.tuple2 Prims.int Prims.int) (Prims.Mktuple2 Prims.int Prims.int (BoxInt 1) (BoxInt 0)) (Prims.Nil (Prims.tuple2 Prims.int Prims.int))))))) Tm_unit)) :named equation_FStar.HyperHeap.test0))
(declare-fun Tm_refine_2674 (Term Term) Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (HasType (Tm_refine_2674 @x0 @x1) Tm_type) :pattern ((HasType (Tm_refine_2674 @x0 @x1) Tm_type)))) :named refinement_kinding_Tm_refine_2674))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (iff (HasTypeFuel @u0 @x1 (Tm_refine_2674 @x2 @x3)) (and (HasTypeFuel @u0 @x1 @x3) (BoxBool_proj_0 (FStar.HyperHeap.includes @x2 @x1)))) :pattern ((HasTypeFuel @u0 @x1 (Tm_refine_2674 @x2 @x3))))) :named refinement_interpretation_Tm_refine_2674))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (Valid (Prims.hasEq (Tm_refine_2674 @x0 @x1))) (Valid (Prims.hasEq @x1))) :pattern ((Valid (Prims.hasEq (Tm_refine_2674 @x0 @x1)))))) :named haseqTm_refine_2674))
(declare-fun FStar.HyperHeap.test1 (Term Term) Term)
(declare-fun Tm_arrow_2677 (Term Term) Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (HasType (Tm_arrow_2677 @x0 @x1) Tm_type) :pattern ((HasType (Tm_arrow_2677 @x0 @x1) Tm_type)))) :named kinding_Tm_arrow_2677))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_2677 @x2 @x3)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_2677 @x2 @x3))))) :named pre_typing_Tm_arrow_2677))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_2677 @x1 @x2)) (forall ((@x3 Term) (@x4 Term)) (! (implies (and (HasType @x3 @x2) (HasType @x4 (Tm_refine_2674 @x3 @x2))) (HasType (ApplyTT (ApplyTT @x0 @x3) @x4) @x1)) :pattern ((ApplyTT (ApplyTT @x0 @x3) @x4))))) :pattern ((HasTypeZ @x0 (Tm_arrow_2677 @x1 @x2))))) :named interpretation_Tm_arrow_2677))
(declare-fun FStar.HyperHeap.test1@tok () Term)
(assert (! (= 2679 (Term_constr_id FStar.HyperHeap.test1@tok)) :named fresh_token_FStar.HyperHeap.test1@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (ApplyTT (ApplyTT FStar.HyperHeap.test1@tok @x0) @x1) (FStar.HyperHeap.test1 @x0 @x1)) :pattern ((ApplyTT (ApplyTT FStar.HyperHeap.test1@tok @x0) @x1)))) :named token_correspondence_FStar.HyperHeap.test1))
(assert (! (HasType FStar.HyperHeap.test1@tok (Tm_arrow_2677 Prims.unit FStar.HyperHeap.rid)) :named function_token_typing_FStar.HyperHeap.test1))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 FStar.HyperHeap.rid) (HasType @x1 (Tm_refine_2674 @x0 FStar.HyperHeap.rid))) (HasType (FStar.HyperHeap.test1 @x0 @x1) Prims.unit)) :pattern ((FStar.HyperHeap.test1 @x0 @x1)))) :named typing_FStar.HyperHeap.test1))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (FStar.HyperHeap.test1 @x0 @x1) (Prims._assert (Prims.b2t (FStar.HyperHeap.includes @x0 (Prims.Cons (Prims.tuple2 Prims.int Prims.int) (Prims.Mktuple2 Prims.int Prims.int (BoxInt 0) (BoxInt 0)) @x1))) Tm_unit)) :pattern ((FStar.HyperHeap.test1 @x0 @x1)))) :named equation_FStar.HyperHeap.test1))
(declare-fun FStar.HyperHeap.fresh_region (Term Term Term) Term)
(declare-fun Tm_arrow_2682 (Term Term) Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (HasType (Tm_arrow_2682 @x0 @x1) Tm_type) :pattern ((HasType (Tm_arrow_2682 @x0 @x1) Tm_type)))) :named kinding_Tm_arrow_2682))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_2682 @x2 @x3)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_2682 @x2 @x3))))) :named pre_typing_Tm_arrow_2682))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_2682 @x1 @x2)) (forall ((@x3 Term) (@x4 Term) (@x5 Term)) (! (implies (and (HasType @x3 @x2) (HasType @x4 @x1) (HasType @x5 @x1)) (HasType (ApplyTT (ApplyTT (ApplyTT @x0 @x3) @x4) @x5) Tm_type)) :pattern ((ApplyTT (ApplyTT (ApplyTT @x0 @x3) @x4) @x5))))) :pattern ((HasTypeZ @x0 (Tm_arrow_2682 @x1 @x2))))) :named interpretation_Tm_arrow_2682))
(declare-fun FStar.HyperHeap.fresh_region@tok () Term)
(assert (! (= 2684 (Term_constr_id FStar.HyperHeap.fresh_region@tok)) :named fresh_token_FStar.HyperHeap.fresh_region@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT FStar.HyperHeap.fresh_region@tok @x0) @x1) @x2) (FStar.HyperHeap.fresh_region @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT FStar.HyperHeap.fresh_region@tok @x0) @x1) @x2)))) :named token_correspondence_FStar.HyperHeap.fresh_region))
(assert (! (HasType FStar.HyperHeap.fresh_region@tok (Tm_arrow_2682 FStar.HyperHeap.t FStar.HyperHeap.rid)) :named function_token_typing_FStar.HyperHeap.fresh_region))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 FStar.HyperHeap.rid) (HasType @x1 FStar.HyperHeap.t) (HasType @x2 FStar.HyperHeap.t)) (HasType (FStar.HyperHeap.fresh_region @x0 @x1 @x2) Tm_type)) :pattern ((FStar.HyperHeap.fresh_region @x0 @x1 @x2)))) :named typing_FStar.HyperHeap.fresh_region))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (Valid (FStar.HyperHeap.fresh_region @x0 @x1 @x2)) (and (forall ((@x3 Term)) (implies (and (HasType @x3 FStar.HyperHeap.rid) (BoxBool_proj_0 (FStar.HyperHeap.includes @x0 @x3))) (not (BoxBool_proj_0 (FStar.Map.contains FStar.HyperHeap.rid FStar.Heap.heap @x1 @x3))))) (BoxBool_proj_0 (FStar.Map.contains FStar.HyperHeap.rid FStar.Heap.heap @x2 @x0)))) :pattern ((Valid (FStar.HyperHeap.fresh_region @x0 @x1 @x2))))) :named equation_FStar.HyperHeap.fresh_region))
(declare-fun FStar.HyperHeap.sel (Term Term Term Term) Term)
(declare-fun Tm_arrow_2686 (Term Term) Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (HasType (Tm_arrow_2686 @x0 @x1) Tm_type) :pattern ((HasType (Tm_arrow_2686 @x0 @x1) Tm_type)))) :named kinding_Tm_arrow_2686))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_2686 @x2 @x3)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_2686 @x2 @x3))))) :named pre_typing_Tm_arrow_2686))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_2686 @x1 @x2)) (forall ((@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term)) (! (implies (and (HasType @x3 Tm_type) (HasType @x4 @x2) (HasType @x5 @x1) (HasType @x6 (FStar.HyperHeap.rref @x4 @x3))) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x3) @x4) @x5) @x6) @x3)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x3) @x4) @x5) @x6))))) :pattern ((HasTypeZ @x0 (Tm_arrow_2686 @x1 @x2))))) :named interpretation_Tm_arrow_2686))
(declare-fun FStar.HyperHeap.sel@tok () Term)
(assert (! (= 2688 (Term_constr_id FStar.HyperHeap.sel@tok)) :named fresh_token_FStar.HyperHeap.sel@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.HyperHeap.sel@tok @x0) @x1) @x2) @x3) (FStar.HyperHeap.sel @x0 @x1 @x2 @x3)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.HyperHeap.sel@tok @x0) @x1) @x2) @x3)))) :named token_correspondence_FStar.HyperHeap.sel))
(assert (! (HasType FStar.HyperHeap.sel@tok (Tm_arrow_2686 FStar.HyperHeap.t FStar.HyperHeap.rid)) :named function_token_typing_FStar.HyperHeap.sel))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 FStar.HyperHeap.rid) (HasType @x2 FStar.HyperHeap.t) (HasType @x3 (FStar.HyperHeap.rref @x1 @x0))) (HasType (FStar.HyperHeap.sel @x0 @x1 @x2 @x3) @x0)) :pattern ((FStar.HyperHeap.sel @x0 @x1 @x2 @x3)))) :named typing_FStar.HyperHeap.sel))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (FStar.HyperHeap.sel @x0 @x1 @x2 @x3) (FStar.Heap.sel @x0 (FStar.Map.sel FStar.HyperHeap.rid FStar.Heap.heap @x2 @x1) (FStar.HyperHeap.as_ref @x0 @x1 @x3))) :pattern ((FStar.HyperHeap.sel @x0 @x1 @x2 @x3)))) :named equation_FStar.HyperHeap.sel))
(declare-fun FStar.HyperHeap.op_String_Access (Term Term Term Term) Term)
(declare-fun FStar.HyperHeap.op_String_Access@tok () Term)
(assert (! (= 2690 (Term_constr_id FStar.HyperHeap.op_String_Access@tok)) :named fresh_token_FStar.HyperHeap.op_String_Access@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.HyperHeap.op_String_Access@tok @x0) @x1) @x2) @x3) (FStar.HyperHeap.op_String_Access @x0 @x1 @x2 @x3)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.HyperHeap.op_String_Access@tok @x0) @x1) @x2) @x3)))) :named token_correspondence_FStar.HyperHeap.op_String_Access))
(assert (! (HasType FStar.HyperHeap.op_String_Access@tok (Tm_arrow_2686 FStar.HyperHeap.t FStar.HyperHeap.rid)) :named function_token_typing_FStar.HyperHeap.op_String_Access))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 FStar.HyperHeap.rid) (HasType @x2 FStar.HyperHeap.t) (HasType @x3 (FStar.HyperHeap.rref @x1 @x0))) (HasType (FStar.HyperHeap.op_String_Access @x0 @x1 @x2 @x3) @x0)) :pattern ((FStar.HyperHeap.op_String_Access @x0 @x1 @x2 @x3)))) :named typing_FStar.HyperHeap.op_String_Access))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (FStar.HyperHeap.op_String_Access @x0 @x1 @x2 @x3) (FStar.HyperHeap.sel @x0 @x1 @x2 @x3)) :pattern ((FStar.HyperHeap.op_String_Access @x0 @x1 @x2 @x3)))) :named equation_FStar.HyperHeap.op_String_Access))
(declare-fun FStar.HyperHeap.upd (Term Term Term Term Term) Term)
(declare-fun Tm_arrow_2692 (Term Term) Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (HasType (Tm_arrow_2692 @x0 @x1) Tm_type) :pattern ((HasType (Tm_arrow_2692 @x0 @x1) Tm_type)))) :named kinding_Tm_arrow_2692))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_2692 @x2 @x3)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_2692 @x2 @x3))))) :named pre_typing_Tm_arrow_2692))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_2692 @x1 @x2)) (forall ((@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term)) (! (implies (and (HasType @x3 Tm_type) (HasType @x4 @x2) (HasType @x5 @x1) (HasType @x6 (FStar.HyperHeap.rref @x4 @x3)) (HasType @x7 @x3)) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x3) @x4) @x5) @x6) @x7) @x1)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x3) @x4) @x5) @x6) @x7))))) :pattern ((HasTypeZ @x0 (Tm_arrow_2692 @x1 @x2))))) :named interpretation_Tm_arrow_2692))
(declare-fun FStar.HyperHeap.upd@tok () Term)
(assert (! (= 2694 (Term_constr_id FStar.HyperHeap.upd@tok)) :named fresh_token_FStar.HyperHeap.upd@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.HyperHeap.upd@tok @x0) @x1) @x2) @x3) @x4) (FStar.HyperHeap.upd @x0 @x1 @x2 @x3 @x4)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.HyperHeap.upd@tok @x0) @x1) @x2) @x3) @x4)))) :named token_correspondence_FStar.HyperHeap.upd))
(assert (! (HasType FStar.HyperHeap.upd@tok (Tm_arrow_2692 FStar.HyperHeap.t FStar.HyperHeap.rid)) :named function_token_typing_FStar.HyperHeap.upd))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 FStar.HyperHeap.rid) (HasType @x2 FStar.HyperHeap.t) (HasType @x3 (FStar.HyperHeap.rref @x1 @x0)) (HasType @x4 @x0)) (HasType (FStar.HyperHeap.upd @x0 @x1 @x2 @x3 @x4) FStar.HyperHeap.t)) :pattern ((FStar.HyperHeap.upd @x0 @x1 @x2 @x3 @x4)))) :named typing_FStar.HyperHeap.upd))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (= (FStar.HyperHeap.upd @x0 @x1 @x2 @x3 @x4) (FStar.Map.upd FStar.HyperHeap.rid FStar.Heap.heap @x2 @x1 (FStar.Heap.upd @x0 (FStar.Map.sel FStar.HyperHeap.rid FStar.Heap.heap @x2 @x1) (FStar.HyperHeap.as_ref @x0 @x1 @x3) @x4))) :pattern ((FStar.HyperHeap.upd @x0 @x1 @x2 @x3 @x4)))) :named equation_FStar.HyperHeap.upd))
(declare-fun FStar.HyperHeap.op_String_Assignment (Term Term Term Term Term) Term)
(declare-fun FStar.HyperHeap.op_String_Assignment@tok () Term)
(assert (! (= 2696 (Term_constr_id FStar.HyperHeap.op_String_Assignment@tok)) :named fresh_token_FStar.HyperHeap.op_String_Assignment@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.HyperHeap.op_String_Assignment@tok @x0) @x1) @x2) @x3) @x4) (FStar.HyperHeap.op_String_Assignment @x0 @x1 @x2 @x3 @x4)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.HyperHeap.op_String_Assignment@tok @x0) @x1) @x2) @x3) @x4)))) :named token_correspondence_FStar.HyperHeap.op_String_Assignment))
(assert (! (HasType FStar.HyperHeap.op_String_Assignment@tok (Tm_arrow_2692 FStar.HyperHeap.t FStar.HyperHeap.rid)) :named function_token_typing_FStar.HyperHeap.op_String_Assignment))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 FStar.HyperHeap.rid) (HasType @x2 FStar.HyperHeap.t) (HasType @x3 (FStar.HyperHeap.rref @x1 @x0)) (HasType @x4 @x0)) (HasType (FStar.HyperHeap.op_String_Assignment @x0 @x1 @x2 @x3 @x4) FStar.HyperHeap.t)) :pattern ((FStar.HyperHeap.op_String_Assignment @x0 @x1 @x2 @x3 @x4)))) :named typing_FStar.HyperHeap.op_String_Assignment))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (= (FStar.HyperHeap.op_String_Assignment @x0 @x1 @x2 @x3 @x4) (FStar.HyperHeap.upd @x0 @x1 @x2 @x3 @x4)) :pattern ((FStar.HyperHeap.op_String_Assignment @x0 @x1 @x2 @x3 @x4)))) :named equation_FStar.HyperHeap.op_String_Assignment))
(declare-fun FStar.HyperHeap.mod_set (Term) Term)
(declare-fun Tm_arrow_2698 (Term) Term)
(assert (! (forall ((@x0 Term)) (! (HasType (Tm_arrow_2698 @x0) Tm_type) :pattern ((HasType (Tm_arrow_2698 @x0) Tm_type)))) :named kinding_Tm_arrow_2698))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_2698 @x2)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_2698 @x2))))) :named pre_typing_Tm_arrow_2698))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_2698 @x1)) (forall ((@x2 Term)) (! (implies (HasType @x2 (FStar.Set.set @x1)) (HasType (ApplyTT @x0 @x2) (FStar.Set.set @x1))) :pattern ((ApplyTT @x0 @x2))))) :pattern ((HasTypeZ @x0 (Tm_arrow_2698 @x1))))) :named interpretation_Tm_arrow_2698))
(declare-fun FStar.HyperHeap.mod_set@tok () Term)
(assert (! (= 2700 (Term_constr_id FStar.HyperHeap.mod_set@tok)) :named fresh_token_FStar.HyperHeap.mod_set@tok))
(assert (! (forall ((@x0 Term)) (! (= (ApplyTT FStar.HyperHeap.mod_set@tok @x0) (FStar.HyperHeap.mod_set @x0)) :pattern ((ApplyTT FStar.HyperHeap.mod_set@tok @x0)))) :named token_correspondence_FStar.HyperHeap.mod_set))
(assert (! (HasType FStar.HyperHeap.mod_set@tok (Tm_arrow_2698 FStar.HyperHeap.rid)) :named function_token_typing_FStar.HyperHeap.mod_set))
(assert (! (forall ((@x0 Term)) (! (implies (HasType @x0 (FStar.Set.set FStar.HyperHeap.rid)) (HasType (FStar.HyperHeap.mod_set @x0) (FStar.Set.set FStar.HyperHeap.rid))) :pattern ((FStar.HyperHeap.mod_set @x0)))) :named typing_FStar.HyperHeap.mod_set))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 FStar.HyperHeap.rid) (HasType @x1 (FStar.Set.set FStar.HyperHeap.rid))) (iff (BoxBool_proj_0 (FStar.Set.mem FStar.HyperHeap.rid @x0 (FStar.HyperHeap.mod_set @x1))) (exists ((@x2 Term)) (and (HasType @x2 FStar.HyperHeap.rid) (BoxBool_proj_0 (FStar.Set.mem FStar.HyperHeap.rid @x2 @x1)) (BoxBool_proj_0 (FStar.HyperHeap.includes @x2 @x0)))))) :pattern ((FStar.Set.mem FStar.HyperHeap.rid @x0 (FStar.HyperHeap.mod_set @x1))))) :named assumption_FStar.HyperHeap.Mod_set_def_2701))
(declare-fun FStar.HyperHeap.modifies (Term Term Term) Term)
(declare-fun Tm_arrow_2703 (Term Term) Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (HasType (Tm_arrow_2703 @x0 @x1) Tm_type) :pattern ((HasType (Tm_arrow_2703 @x0 @x1) Tm_type)))) :named kinding_Tm_arrow_2703))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_2703 @x2 @x3)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_2703 @x2 @x3))))) :named pre_typing_Tm_arrow_2703))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_2703 @x1 @x2)) (forall ((@x3 Term) (@x4 Term) (@x5 Term)) (! (implies (and (HasType @x3 (FStar.Set.set @x2)) (HasType @x4 @x1) (HasType @x5 @x1)) (HasType (ApplyTT (ApplyTT (ApplyTT @x0 @x3) @x4) @x5) Tm_type)) :pattern ((ApplyTT (ApplyTT (ApplyTT @x0 @x3) @x4) @x5))))) :pattern ((HasTypeZ @x0 (Tm_arrow_2703 @x1 @x2))))) :named interpretation_Tm_arrow_2703))
(declare-fun FStar.HyperHeap.modifies@tok () Term)
(assert (! (= 2705 (Term_constr_id FStar.HyperHeap.modifies@tok)) :named fresh_token_FStar.HyperHeap.modifies@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT FStar.HyperHeap.modifies@tok @x0) @x1) @x2) (FStar.HyperHeap.modifies @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT FStar.HyperHeap.modifies@tok @x0) @x1) @x2)))) :named token_correspondence_FStar.HyperHeap.modifies))
(assert (! (HasType FStar.HyperHeap.modifies@tok (Tm_arrow_2703 FStar.HyperHeap.t FStar.HyperHeap.rid)) :named function_token_typing_FStar.HyperHeap.modifies))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 (FStar.Set.set FStar.HyperHeap.rid)) (HasType @x1 FStar.HyperHeap.t) (HasType @x2 FStar.HyperHeap.t)) (HasType (FStar.HyperHeap.modifies @x0 @x1 @x2) Tm_type)) :pattern ((FStar.HyperHeap.modifies @x0 @x1 @x2)))) :named typing_FStar.HyperHeap.modifies))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (Valid (FStar.HyperHeap.modifies @x0 @x1 @x2)) (and (Valid (FStar.Map.equal FStar.HyperHeap.rid FStar.Heap.heap @x2 (FStar.Map.concat FStar.HyperHeap.rid FStar.Heap.heap @x2 (FStar.Map.restrict FStar.HyperHeap.rid FStar.Heap.heap (FStar.Set.complement FStar.HyperHeap.rid (FStar.HyperHeap.mod_set @x0)) @x1)))) (Valid (FStar.Set.subset FStar.HyperHeap.rid (FStar.Map.domain FStar.HyperHeap.rid FStar.Heap.heap @x1) (FStar.Map.domain FStar.HyperHeap.rid FStar.Heap.heap @x2))))) :pattern ((Valid (FStar.HyperHeap.modifies @x0 @x1 @x2))))) :named equation_FStar.HyperHeap.modifies))
(declare-fun FStar.HyperHeap.modifies_just (Term Term Term) Term)
(declare-fun FStar.HyperHeap.modifies_just@tok () Term)
(assert (! (= 2707 (Term_constr_id FStar.HyperHeap.modifies_just@tok)) :named fresh_token_FStar.HyperHeap.modifies_just@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT FStar.HyperHeap.modifies_just@tok @x0) @x1) @x2) (FStar.HyperHeap.modifies_just @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT FStar.HyperHeap.modifies_just@tok @x0) @x1) @x2)))) :named token_correspondence_FStar.HyperHeap.modifies_just))
(assert (! (HasType FStar.HyperHeap.modifies_just@tok (Tm_arrow_2703 FStar.HyperHeap.t FStar.HyperHeap.rid)) :named function_token_typing_FStar.HyperHeap.modifies_just))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 (FStar.Set.set FStar.HyperHeap.rid)) (HasType @x1 FStar.HyperHeap.t) (HasType @x2 FStar.HyperHeap.t)) (HasType (FStar.HyperHeap.modifies_just @x0 @x1 @x2) Tm_type)) :pattern ((FStar.HyperHeap.modifies_just @x0 @x1 @x2)))) :named typing_FStar.HyperHeap.modifies_just))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (Valid (FStar.HyperHeap.modifies_just @x0 @x1 @x2)) (and (Valid (FStar.Map.equal FStar.HyperHeap.rid FStar.Heap.heap @x2 (FStar.Map.concat FStar.HyperHeap.rid FStar.Heap.heap @x2 (FStar.Map.restrict FStar.HyperHeap.rid FStar.Heap.heap (FStar.Set.complement FStar.HyperHeap.rid @x0) @x1)))) (Valid (FStar.Set.subset FStar.HyperHeap.rid (FStar.Map.domain FStar.HyperHeap.rid FStar.Heap.heap @x1) (FStar.Map.domain FStar.HyperHeap.rid FStar.Heap.heap @x2))))) :pattern ((Valid (FStar.HyperHeap.modifies_just @x0 @x1 @x2))))) :named equation_FStar.HyperHeap.modifies_just))
(declare-fun FStar.HyperHeap.modifies_one (Term Term Term) Term)
(declare-fun FStar.HyperHeap.modifies_one@tok () Term)
(assert (! (= 2709 (Term_constr_id FStar.HyperHeap.modifies_one@tok)) :named fresh_token_FStar.HyperHeap.modifies_one@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT FStar.HyperHeap.modifies_one@tok @x0) @x1) @x2) (FStar.HyperHeap.modifies_one @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT FStar.HyperHeap.modifies_one@tok @x0) @x1) @x2)))) :named token_correspondence_FStar.HyperHeap.modifies_one))
(assert (! (HasType FStar.HyperHeap.modifies_one@tok (Tm_arrow_2682 FStar.HyperHeap.t FStar.HyperHeap.rid)) :named function_token_typing_FStar.HyperHeap.modifies_one))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 FStar.HyperHeap.rid) (HasType @x1 FStar.HyperHeap.t) (HasType @x2 FStar.HyperHeap.t)) (HasType (FStar.HyperHeap.modifies_one @x0 @x1 @x2) Tm_type)) :pattern ((FStar.HyperHeap.modifies_one @x0 @x1 @x2)))) :named typing_FStar.HyperHeap.modifies_one))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (FStar.HyperHeap.modifies_one @x0 @x1 @x2) (FStar.HyperHeap.modifies_just (FStar.Set.singleton FStar.HyperHeap.rid @x0) @x1 @x2)) :pattern ((FStar.HyperHeap.modifies_one @x0 @x1 @x2)))) :named equation_FStar.HyperHeap.modifies_one))
(declare-fun FStar.HyperHeap.equal_on (Term Term Term) Term)
(declare-fun FStar.HyperHeap.equal_on@tok () Term)
(assert (! (= 2711 (Term_constr_id FStar.HyperHeap.equal_on@tok)) :named fresh_token_FStar.HyperHeap.equal_on@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT FStar.HyperHeap.equal_on@tok @x0) @x1) @x2) (FStar.HyperHeap.equal_on @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT FStar.HyperHeap.equal_on@tok @x0) @x1) @x2)))) :named token_correspondence_FStar.HyperHeap.equal_on))
(assert (! (HasType FStar.HyperHeap.equal_on@tok (Tm_arrow_2703 FStar.HyperHeap.t FStar.HyperHeap.rid)) :named function_token_typing_FStar.HyperHeap.equal_on))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 (FStar.Set.set FStar.HyperHeap.rid)) (HasType @x1 FStar.HyperHeap.t) (HasType @x2 FStar.HyperHeap.t)) (HasType (FStar.HyperHeap.equal_on @x0 @x1 @x2) Tm_type)) :pattern ((FStar.HyperHeap.equal_on @x0 @x1 @x2)))) :named typing_FStar.HyperHeap.equal_on))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (Valid (FStar.HyperHeap.equal_on @x0 @x1 @x2)) (and (forall ((@x3 Term)) (! (implies (and (HasType @x3 FStar.HyperHeap.rid) (BoxBool_proj_0 (FStar.Set.mem FStar.HyperHeap.rid @x3 (FStar.HyperHeap.mod_set @x0))) (BoxBool_proj_0 (FStar.Map.contains FStar.HyperHeap.rid FStar.Heap.heap @x1 @x3))) (BoxBool_proj_0 (FStar.Map.contains FStar.HyperHeap.rid FStar.Heap.heap @x2 @x3))) :pattern ((FStar.Map.contains FStar.HyperHeap.rid FStar.Heap.heap @x1 @x3)))) (Valid (FStar.Map.equal FStar.HyperHeap.rid FStar.Heap.heap @x2 (FStar.Map.concat FStar.HyperHeap.rid FStar.Heap.heap @x2 (FStar.Map.restrict FStar.HyperHeap.rid FStar.Heap.heap (FStar.HyperHeap.mod_set @x0) @x1)))))) :pattern ((Valid (FStar.HyperHeap.equal_on @x0 @x1 @x2))))) :named equation_FStar.HyperHeap.equal_on))
(declare-fun FStar.HyperHeap.lemma_modifies_just_trans (Term Term Term Term Term) Term)
(declare-fun FStar.HyperHeap.lemma_modifies_just_trans@tok () Term)
(declare-fun FStar.HyperHeap.lemma_modifies_trans (Term Term Term Term Term) Term)
(declare-fun FStar.HyperHeap.lemma_modifies_trans@tok () Term)
(declare-fun FStar.HyperHeap.lemma_includes_trans (Term Term Term) Term)
(declare-fun FStar.HyperHeap.lemma_includes_trans@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (BoxBool_proj_0 (FStar.HyperHeap.includes @x0 @x1)) (BoxBool_proj_0 (FStar.HyperHeap.includes @x1 @x2)) (HasType @x0 FStar.HyperHeap.rid) (HasType @x1 FStar.HyperHeap.rid) (HasType @x2 FStar.HyperHeap.rid)) (BoxBool_proj_0 (FStar.HyperHeap.includes @x0 @x2))) :pattern ((FStar.HyperHeap.includes @x0 @x1) (FStar.HyperHeap.includes @x1 @x2)))) :named lemma_FStar.HyperHeap.lemma_includes_trans))
(declare-fun FStar.HyperHeap.lemma_modset (Term Term) Term)
(declare-fun FStar.HyperHeap.lemma_modset@tok () Term)
(declare-fun FStar.HyperHeap.lemma_modifies_includes (Term Term Term Term) Term)
(declare-fun FStar.HyperHeap.lemma_modifies_includes@tok () Term)
(declare-fun FStar.HyperHeap.lemma_modifies_includes2 (Term Term Term Term) Term)
(declare-fun FStar.HyperHeap.lemma_modifies_includes2@tok () Term)
(declare-fun FStar.HyperHeap.lemma_disjoint_parents (Term Term Term Term) Term)
(declare-fun FStar.HyperHeap.lemma_disjoint_parents@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (BoxBool_proj_0 (FStar.HyperHeap.extends @x1 @x0)) (BoxBool_proj_0 (FStar.HyperHeap.extends @x3 @x2)) (BoxBool_proj_0 (FStar.HyperHeap.disjoint @x0 @x2)) (HasType @x0 FStar.HyperHeap.rid) (HasType @x1 FStar.HyperHeap.rid) (HasType @x2 FStar.HyperHeap.rid) (HasType @x3 FStar.HyperHeap.rid)) (BoxBool_proj_0 (FStar.HyperHeap.disjoint @x1 @x3))) :pattern ((FStar.HyperHeap.extends @x1 @x0) (FStar.HyperHeap.extends @x3 @x2) (FStar.HyperHeap.disjoint @x0 @x2)))) :named lemma_FStar.HyperHeap.lemma_disjoint_parents))
(declare-fun FStar.HyperHeap.contains_ref (Term Term Term Term) Term)
(declare-fun Tm_arrow_2713 (Term Term Term) Term)
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (HasType (Tm_arrow_2713 @x0 @x1 @x2) Tm_type) :pattern ((HasType (Tm_arrow_2713 @x0 @x1 @x2) Tm_type)))) :named kinding_Tm_arrow_2713))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_2713 @x2 @x3 @x4)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_2713 @x2 @x3 @x4))))) :named pre_typing_Tm_arrow_2713))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_2713 @x1 @x2 @x3)) (forall ((@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term)) (! (implies (and (HasType @x4 Tm_type) (HasType @x5 @x3) (HasType @x6 (FStar.HyperHeap.rref @x5 @x4)) (HasType @x7 @x2)) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x4) @x5) @x6) @x7) @x1)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x4) @x5) @x6) @x7))))) :pattern ((HasTypeZ @x0 (Tm_arrow_2713 @x1 @x2 @x3))))) :named interpretation_Tm_arrow_2713))
(declare-fun FStar.HyperHeap.contains_ref@tok () Term)
(assert (! (= 2715 (Term_constr_id FStar.HyperHeap.contains_ref@tok)) :named fresh_token_FStar.HyperHeap.contains_ref@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.HyperHeap.contains_ref@tok @x0) @x1) @x2) @x3) (FStar.HyperHeap.contains_ref @x0 @x1 @x2 @x3)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.HyperHeap.contains_ref@tok @x0) @x1) @x2) @x3)))) :named token_correspondence_FStar.HyperHeap.contains_ref))
(assert (! (HasType FStar.HyperHeap.contains_ref@tok (Tm_arrow_2713 Prims.bool FStar.HyperHeap.t FStar.HyperHeap.rid)) :named function_token_typing_FStar.HyperHeap.contains_ref))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 FStar.HyperHeap.rid) (HasType @x2 (FStar.HyperHeap.rref @x1 @x0)) (HasType @x3 FStar.HyperHeap.t)) (HasType (FStar.HyperHeap.contains_ref @x0 @x1 @x2 @x3) Prims.bool)) :pattern ((FStar.HyperHeap.contains_ref @x0 @x1 @x2 @x3)))) :named typing_FStar.HyperHeap.contains_ref))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (FStar.HyperHeap.contains_ref @x0 @x1 @x2 @x3) (Prims.op_AmpAmp (FStar.Map.contains FStar.HyperHeap.rid FStar.Heap.heap @x3 @x1) (FStar.Heap.contains @x0 (FStar.Map.sel FStar.HyperHeap.rid FStar.Heap.heap @x3 @x1) (FStar.HyperHeap.as_ref @x0 @x1 @x2)))) :pattern ((FStar.HyperHeap.contains_ref @x0 @x1 @x2 @x3)))) :named equation_FStar.HyperHeap.contains_ref))
(declare-fun FStar.HyperHeap.fresh_rref (Term Term Term Term Term) Term)
(declare-fun Tm_arrow_2717 (Term Term) Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (HasType (Tm_arrow_2717 @x0 @x1) Tm_type) :pattern ((HasType (Tm_arrow_2717 @x0 @x1) Tm_type)))) :named kinding_Tm_arrow_2717))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_2717 @x2 @x3)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_2717 @x2 @x3))))) :named pre_typing_Tm_arrow_2717))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_2717 @x1 @x2)) (forall ((@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term)) (! (implies (and (HasType @x3 Tm_type) (HasType @x4 @x2) (HasType @x5 (FStar.HyperHeap.rref @x4 @x3)) (HasType @x6 @x1) (HasType @x7 @x1)) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x3) @x4) @x5) @x6) @x7) Tm_type)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x3) @x4) @x5) @x6) @x7))))) :pattern ((HasTypeZ @x0 (Tm_arrow_2717 @x1 @x2))))) :named interpretation_Tm_arrow_2717))
(declare-fun FStar.HyperHeap.fresh_rref@tok () Term)
(assert (! (= 2719 (Term_constr_id FStar.HyperHeap.fresh_rref@tok)) :named fresh_token_FStar.HyperHeap.fresh_rref@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.HyperHeap.fresh_rref@tok @x0) @x1) @x2) @x3) @x4) (FStar.HyperHeap.fresh_rref @x0 @x1 @x2 @x3 @x4)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.HyperHeap.fresh_rref@tok @x0) @x1) @x2) @x3) @x4)))) :named token_correspondence_FStar.HyperHeap.fresh_rref))
(assert (! (HasType FStar.HyperHeap.fresh_rref@tok (Tm_arrow_2717 FStar.HyperHeap.t FStar.HyperHeap.rid)) :named function_token_typing_FStar.HyperHeap.fresh_rref))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 FStar.HyperHeap.rid) (HasType @x2 (FStar.HyperHeap.rref @x1 @x0)) (HasType @x3 FStar.HyperHeap.t) (HasType @x4 FStar.HyperHeap.t)) (HasType (FStar.HyperHeap.fresh_rref @x0 @x1 @x2 @x3 @x4) Tm_type)) :pattern ((FStar.HyperHeap.fresh_rref @x0 @x1 @x2 @x3 @x4)))) :named typing_FStar.HyperHeap.fresh_rref))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (= (Valid (FStar.HyperHeap.fresh_rref @x0 @x1 @x2 @x3 @x4)) (and (not (BoxBool_proj_0 (FStar.Heap.contains @x0 (FStar.Map.sel FStar.HyperHeap.rid FStar.Heap.heap @x3 @x1) (FStar.HyperHeap.as_ref @x0 @x1 @x2)))) (BoxBool_proj_0 (FStar.Heap.contains @x0 (FStar.Map.sel FStar.HyperHeap.rid FStar.Heap.heap @x4 @x1) (FStar.HyperHeap.as_ref @x0 @x1 @x2))))) :pattern ((Valid (FStar.HyperHeap.fresh_rref @x0 @x1 @x2 @x3 @x4))))) :named equation_FStar.HyperHeap.fresh_rref))
(declare-fun FStar.HyperHeap.modifies_rref (Term Term Term Term) Term)
(declare-fun Tm_arrow_2721 (Term Term) Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (HasType (Tm_arrow_2721 @x0 @x1) Tm_type) :pattern ((HasType (Tm_arrow_2721 @x0 @x1) Tm_type)))) :named kinding_Tm_arrow_2721))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_2721 @x2 @x3)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_2721 @x2 @x3))))) :named pre_typing_Tm_arrow_2721))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_2721 @x1 @x2)) (forall ((@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term)) (! (implies (and (HasType @x3 @x2) (HasType @x4 (FStar.TSet.set FStar.Heap.aref)) (HasType @x5 (FStar.Map.t @x2 @x1)) (HasType @x6 (FStar.Map.t @x2 @x1))) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x3) @x4) @x5) @x6) Tm_type)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x3) @x4) @x5) @x6))))) :pattern ((HasTypeZ @x0 (Tm_arrow_2721 @x1 @x2))))) :named interpretation_Tm_arrow_2721))
(declare-fun FStar.HyperHeap.modifies_rref@tok () Term)
(assert (! (= 2723 (Term_constr_id FStar.HyperHeap.modifies_rref@tok)) :named fresh_token_FStar.HyperHeap.modifies_rref@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.HyperHeap.modifies_rref@tok @x0) @x1) @x2) @x3) (FStar.HyperHeap.modifies_rref @x0 @x1 @x2 @x3)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.HyperHeap.modifies_rref@tok @x0) @x1) @x2) @x3)))) :named token_correspondence_FStar.HyperHeap.modifies_rref))
(assert (! (HasType FStar.HyperHeap.modifies_rref@tok (Tm_arrow_2721 FStar.Heap.heap FStar.HyperHeap.rid)) :named function_token_typing_FStar.HyperHeap.modifies_rref))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x0 FStar.HyperHeap.rid) (HasType @x1 (FStar.TSet.set FStar.Heap.aref)) (HasType @x2 (FStar.Map.t FStar.HyperHeap.rid FStar.Heap.heap)) (HasType @x3 (FStar.Map.t FStar.HyperHeap.rid FStar.Heap.heap))) (HasType (FStar.HyperHeap.modifies_rref @x0 @x1 @x2 @x3) Tm_type)) :pattern ((FStar.HyperHeap.modifies_rref @x0 @x1 @x2 @x3)))) :named typing_FStar.HyperHeap.modifies_rref))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (FStar.HyperHeap.modifies_rref @x0 @x1 @x2 @x3) (FStar.Heap.modifies @x1 (FStar.Map.sel FStar.HyperHeap.rid FStar.Heap.heap @x2 @x0) (FStar.Map.sel FStar.HyperHeap.rid FStar.Heap.heap @x3 @x0))) :pattern ((FStar.HyperHeap.modifies_rref @x0 @x1 @x2 @x3)))) :named equation_FStar.HyperHeap.modifies_rref))
(declare-fun FStar.HyperHeap.lemma_include_cons (Term Term) Term)
(declare-fun FStar.HyperHeap.lemma_include_cons@tok () Term)
(declare-fun FStar.HyperHeap.map_invariant (Term) Term)
(declare-fun FStar.HyperHeap.map_invariant@tok () Term)
(assert (! (= 2725 (Term_constr_id FStar.HyperHeap.map_invariant@tok)) :named fresh_token_FStar.HyperHeap.map_invariant@tok))
(assert (! (forall ((@x0 Term)) (! (= (ApplyTT FStar.HyperHeap.map_invariant@tok @x0) (FStar.HyperHeap.map_invariant @x0)) :pattern ((ApplyTT FStar.HyperHeap.map_invariant@tok @x0)))) :named token_correspondence_FStar.HyperHeap.map_invariant))
(assert (! (HasType FStar.HyperHeap.map_invariant@tok (Tm_arrow_239 FStar.HyperHeap.t)) :named function_token_typing_FStar.HyperHeap.map_invariant))
(assert (! (forall ((@x0 Term)) (! (implies (HasType @x0 FStar.HyperHeap.t) (HasType (FStar.HyperHeap.map_invariant @x0) Tm_type)) :pattern ((FStar.HyperHeap.map_invariant @x0)))) :named typing_FStar.HyperHeap.map_invariant))
(assert (! (forall ((@x0 Term)) (! (= (Valid (FStar.HyperHeap.map_invariant @x0)) (forall ((@x1 Term)) (implies (and (HasType @x1 FStar.HyperHeap.rid) (BoxBool_proj_0 (FStar.Map.contains FStar.HyperHeap.rid FStar.Heap.heap @x0 @x1))) (forall ((@x2 Term)) (implies (and (HasType @x2 FStar.HyperHeap.rid) (BoxBool_proj_0 (FStar.HyperHeap.includes @x2 @x1))) (BoxBool_proj_0 (FStar.Map.contains FStar.HyperHeap.rid FStar.Heap.heap @x0 @x2))))))) :pattern ((Valid (FStar.HyperHeap.map_invariant @x0))))) :named equation_FStar.HyperHeap.map_invariant))
(declare-fun FStar.HyperHeap.lemma_extends_fresh_disjoint (Term Term Term Term Term Term) Term)
(declare-fun FStar.HyperHeap.lemma_extends_fresh_disjoint@tok () Term)
(declare-fun Tm_refine_2727 (Term) Term)
(assert (! (forall ((@x0 Term)) (! (HasType (Tm_refine_2727 @x0) Tm_type) :pattern ((HasType (Tm_refine_2727 @x0) Tm_type)))) :named refinement_kinding_Tm_refine_2727))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (iff (HasTypeFuel @u0 @x1 (Tm_refine_2727 @x2)) (and (HasTypeFuel @u0 @x1 @x2) (Valid (FStar.HyperHeap.map_invariant @x1)))) :pattern ((HasTypeFuel @u0 @x1 (Tm_refine_2727 @x2))))) :named refinement_interpretation_Tm_refine_2727))
(assert (! (forall ((@x0 Term)) (! (iff (Valid (Prims.hasEq (Tm_refine_2727 @x0))) (Valid (Prims.hasEq @x0))) :pattern ((Valid (Prims.hasEq (Tm_refine_2727 @x0)))))) :named haseqTm_refine_2727))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (implies (and (Valid (FStar.HyperHeap.fresh_region @x0 @x4 @x5)) (Valid (FStar.HyperHeap.fresh_region @x1 @x4 @x5)) (BoxBool_proj_0 (FStar.Map.contains FStar.HyperHeap.rid FStar.Heap.heap @x4 @x2)) (BoxBool_proj_0 (FStar.Map.contains FStar.HyperHeap.rid FStar.Heap.heap @x4 @x3)) (BoxBool_proj_0 (FStar.HyperHeap.extends @x0 @x2)) (BoxBool_proj_0 (FStar.HyperHeap.extends @x1 @x3)) (not (= @x0 @x1)) (HasType @x0 FStar.HyperHeap.rid) (HasType @x1 FStar.HyperHeap.rid) (HasType @x2 FStar.HyperHeap.rid) (HasType @x3 FStar.HyperHeap.rid) (HasType @x4 (Tm_refine_2727 FStar.HyperHeap.t)) (HasType @x5 (Tm_refine_2727 FStar.HyperHeap.t))) (BoxBool_proj_0 (FStar.HyperHeap.disjoint @x0 @x1))) :pattern ((FStar.HyperHeap.fresh_region @x0 @x4 @x5) (FStar.HyperHeap.fresh_region @x1 @x4 @x5) (FStar.HyperHeap.extends @x0 @x2) (FStar.HyperHeap.extends @x1 @x3)))) :named lemma_FStar.HyperHeap.lemma_extends_fresh_disjoint))
(declare-fun FStar.HyperHeap.disjoint_regions (Term Term) Term)
(declare-fun Tm_arrow_2730 (Term) Term)
(assert (! (forall ((@x0 Term)) (! (HasType (Tm_arrow_2730 @x0) Tm_type) :pattern ((HasType (Tm_arrow_2730 @x0) Tm_type)))) :named kinding_Tm_arrow_2730))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_2730 @x2)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_2730 @x2))))) :named pre_typing_Tm_arrow_2730))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_2730 @x1)) (forall ((@x2 Term) (@x3 Term)) (! (implies (and (HasType @x2 (FStar.Set.set @x1)) (HasType @x3 (FStar.Set.set @x1))) (HasType (ApplyTT (ApplyTT @x0 @x2) @x3) Tm_type)) :pattern ((ApplyTT (ApplyTT @x0 @x2) @x3))))) :pattern ((HasTypeZ @x0 (Tm_arrow_2730 @x1))))) :named interpretation_Tm_arrow_2730))
(declare-fun FStar.HyperHeap.disjoint_regions@tok () Term)
(assert (! (= 2732 (Term_constr_id FStar.HyperHeap.disjoint_regions@tok)) :named fresh_token_FStar.HyperHeap.disjoint_regions@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (ApplyTT (ApplyTT FStar.HyperHeap.disjoint_regions@tok @x0) @x1) (FStar.HyperHeap.disjoint_regions @x0 @x1)) :pattern ((ApplyTT (ApplyTT FStar.HyperHeap.disjoint_regions@tok @x0) @x1)))) :named token_correspondence_FStar.HyperHeap.disjoint_regions))
(assert (! (HasType FStar.HyperHeap.disjoint_regions@tok (Tm_arrow_2730 FStar.HyperHeap.rid)) :named function_token_typing_FStar.HyperHeap.disjoint_regions))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 (FStar.Set.set FStar.HyperHeap.rid)) (HasType @x1 (FStar.Set.set FStar.HyperHeap.rid))) (HasType (FStar.HyperHeap.disjoint_regions @x0 @x1) Tm_type)) :pattern ((FStar.HyperHeap.disjoint_regions @x0 @x1)))) :named typing_FStar.HyperHeap.disjoint_regions))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (Valid (FStar.HyperHeap.disjoint_regions @x0 @x1)) (forall ((@x2 Term) (@x3 Term)) (! (implies (and (HasType @x2 FStar.HyperHeap.rid) (HasType @x3 FStar.HyperHeap.rid) (BoxBool_proj_0 (FStar.Set.mem FStar.HyperHeap.rid @x2 @x0)) (BoxBool_proj_0 (FStar.Set.mem FStar.HyperHeap.rid @x3 @x1))) (BoxBool_proj_0 (FStar.HyperHeap.disjoint @x2 @x3))) :pattern ((FStar.Set.mem FStar.HyperHeap.rid @x2 @x0) (FStar.Set.mem FStar.HyperHeap.rid @x3 @x1))))) :pattern ((Valid (FStar.HyperHeap.disjoint_regions @x0 @x1))))) :named equation_FStar.HyperHeap.disjoint_regions))
(declare-fun FStar.HyperHeap.extends_parent (Term Term) Term)
(declare-fun FStar.HyperHeap.extends_parent@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 (Tm_refine_2663 FStar.HyperHeap.root FStar.HyperHeap.rid)) (HasType @x1 FStar.HyperHeap.rid) (BoxBool_proj_0 (FStar.HyperHeap.extends @x1 (FStar.HyperHeap.parent @x0))) (not (= @x1 @x0))) (or (BoxBool_proj_0 (FStar.HyperHeap.disjoint @x1 @x0)) (BoxBool_proj_0 (FStar.HyperHeap.extends @x1 @x0)))) :pattern ((FStar.HyperHeap.extends @x1 (FStar.HyperHeap.parent @x0))))) :named lemma_FStar.HyperHeap.extends_parent))
(declare-fun FStar.HyperHeap.includes_child (Term Term) Term)
(declare-fun FStar.HyperHeap.includes_child@tok () Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 (Tm_refine_2663 FStar.HyperHeap.root FStar.HyperHeap.rid)) (HasType @x1 FStar.HyperHeap.rid) (BoxBool_proj_0 (FStar.HyperHeap.includes @x1 @x0))) (or (= @x1 @x0) (BoxBool_proj_0 (FStar.HyperHeap.includes @x1 (FStar.HyperHeap.parent @x0))))) :pattern ((FStar.HyperHeap.includes @x1 (FStar.HyperHeap.parent @x0))))) :named lemma_FStar.HyperHeap.includes_child))
(declare-fun FStar.HyperHeap.root_is_root (Term) Term)
(declare-fun FStar.HyperHeap.root_is_root@tok () Term)
(assert (! (forall ((@x0 Term)) (! (implies (and (BoxBool_proj_0 (FStar.HyperHeap.includes @x0 FStar.HyperHeap.root)) (HasType @x0 FStar.HyperHeap.rid)) (= @x0 FStar.HyperHeap.root)) :pattern ((FStar.HyperHeap.includes @x0 FStar.HyperHeap.root)))) :named lemma_FStar.HyperHeap.root_is_root))
(declare-fun FStar.ST.modifies (Term Term Term) Term)
(declare-fun FStar.ST.modifies@tok () Term)
(assert (! (= 2833 (Term_constr_id FStar.ST.modifies@tok)) :named fresh_token_FStar.ST.modifies@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT FStar.ST.modifies@tok @x0) @x1) @x2) (FStar.ST.modifies @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT FStar.ST.modifies@tok @x0) @x1) @x2)))) :named token_correspondence_FStar.ST.modifies))
(assert (! (HasType FStar.ST.modifies@tok (Tm_arrow_2703 FStar.HyperHeap.t FStar.HyperHeap.rid)) :named function_token_typing_FStar.ST.modifies))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 (FStar.Set.set FStar.HyperHeap.rid)) (HasType @x1 FStar.HyperHeap.t) (HasType @x2 FStar.HyperHeap.t)) (HasType (FStar.ST.modifies @x0 @x1 @x2) Tm_type)) :pattern ((FStar.ST.modifies @x0 @x1 @x2)))) :named typing_FStar.ST.modifies))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (FStar.ST.modifies @x0 @x1 @x2) (FStar.HyperHeap.modifies @x0 @x1 @x2)) :pattern ((FStar.ST.modifies @x0 @x1 @x2)))) :named equation_FStar.ST.modifies))
(declare-fun FStar.ST.ref (Term) Term)
(declare-fun FStar.ST.ref@tok () Term)
(assert (! (= 2835 (Term_constr_id FStar.ST.ref@tok)) :named fresh_token_FStar.ST.ref@tok))
(assert (! (forall ((@x0 Term)) (! (= (ApplyTT FStar.ST.ref@tok @x0) (FStar.ST.ref @x0)) :pattern ((ApplyTT FStar.ST.ref@tok @x0)))) :named token_correspondence_FStar.ST.ref))
(assert (! (HasType FStar.ST.ref@tok Tm_arrow_105) :named function_token_typing_FStar.ST.ref))
(assert (! (forall ((@x0 Term)) (! (implies (HasType @x0 Tm_type) (HasType (FStar.ST.ref @x0) Tm_type)) :pattern ((FStar.ST.ref @x0)))) :named typing_FStar.ST.ref))
(assert (! (forall ((@x0 Term)) (! (= (FStar.ST.ref @x0) (FStar.HyperHeap.rref FStar.HyperHeap.root @x0)) :pattern ((FStar.ST.ref @x0)))) :named equation_FStar.ST.ref))
(declare-fun FStar.ST.st_pre () Term)
(assert (! (HasType FStar.ST.st_pre Tm_type) :named function_token_typing_FStar.ST.st_pre))
(assert (! (HasType FStar.ST.st_pre Tm_type) :named typing_FStar.ST.st_pre))
(assert (! (= FStar.ST.st_pre (Prims.st_pre_h FStar.HyperHeap.t)) :named equation_FStar.ST.st_pre))
(declare-fun FStar.ST.st_post (Term) Term)
(declare-fun FStar.ST.st_post@tok () Term)
(assert (! (= 2837 (Term_constr_id FStar.ST.st_post@tok)) :named fresh_token_FStar.ST.st_post@tok))
(assert (! (forall ((@x0 Term)) (! (= (ApplyTT FStar.ST.st_post@tok @x0) (FStar.ST.st_post @x0)) :pattern ((ApplyTT FStar.ST.st_post@tok @x0)))) :named token_correspondence_FStar.ST.st_post))
(assert (! (HasType FStar.ST.st_post@tok Tm_arrow_105) :named function_token_typing_FStar.ST.st_post))
(assert (! (forall ((@x0 Term)) (! (implies (HasType @x0 Tm_type) (HasType (FStar.ST.st_post @x0) Tm_type)) :pattern ((FStar.ST.st_post @x0)))) :named typing_FStar.ST.st_post))
(assert (! (forall ((@x0 Term)) (! (= (FStar.ST.st_post @x0) (Prims.st_post_h FStar.HyperHeap.t @x0)) :pattern ((FStar.ST.st_post @x0)))) :named equation_FStar.ST.st_post))
(declare-fun FStar.ST.st_wp (Term) Term)
(declare-fun FStar.ST.st_wp@tok () Term)
(assert (! (= 2839 (Term_constr_id FStar.ST.st_wp@tok)) :named fresh_token_FStar.ST.st_wp@tok))
(assert (! (forall ((@x0 Term)) (! (= (ApplyTT FStar.ST.st_wp@tok @x0) (FStar.ST.st_wp @x0)) :pattern ((ApplyTT FStar.ST.st_wp@tok @x0)))) :named token_correspondence_FStar.ST.st_wp))
(assert (! (HasType FStar.ST.st_wp@tok Tm_arrow_105) :named function_token_typing_FStar.ST.st_wp))
(assert (! (forall ((@x0 Term)) (! (implies (HasType @x0 Tm_type) (HasType (FStar.ST.st_wp @x0) Tm_type)) :pattern ((FStar.ST.st_wp @x0)))) :named typing_FStar.ST.st_wp))
(assert (! (forall ((@x0 Term)) (! (= (FStar.ST.st_wp @x0) (Prims.st_wp_h FStar.HyperHeap.t @x0)) :pattern ((FStar.ST.st_wp @x0)))) :named equation_FStar.ST.st_wp))
(declare-fun FStar.ST.new_region (Term) Term)
(declare-fun FStar.ST.new_region@tok () Term)
(declare-fun FStar.ST.new_colored_region (Term Term) Term)
(declare-fun FStar.ST.new_colored_region@tok () Term)
(declare-fun FStar.ST.ralloc_post (Term Term Term Term Term Term) Term)
(declare-fun Tm_arrow_2841 (Term Term) Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (HasType (Tm_arrow_2841 @x0 @x1) Tm_type) :pattern ((HasType (Tm_arrow_2841 @x0 @x1) Tm_type)))) :named kinding_Tm_arrow_2841))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_2841 @x2 @x3)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_2841 @x2 @x3))))) :named pre_typing_Tm_arrow_2841))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_2841 @x1 @x2)) (forall ((@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term)) (! (implies (and (HasType @x3 Tm_type) (HasType @x4 @x2) (HasType @x5 @x3) (HasType @x6 @x1) (HasType @x7 (FStar.HyperHeap.rref @x4 @x3)) (HasType @x8 @x1)) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x3) @x4) @x5) @x6) @x7) @x8) Tm_type)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x3) @x4) @x5) @x6) @x7) @x8))))) :pattern ((HasTypeZ @x0 (Tm_arrow_2841 @x1 @x2))))) :named interpretation_Tm_arrow_2841))
(declare-fun FStar.ST.ralloc_post@tok () Term)
(assert (! (= 2843 (Term_constr_id FStar.ST.ralloc_post@tok)) :named fresh_token_FStar.ST.ralloc_post@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.ST.ralloc_post@tok @x0) @x1) @x2) @x3) @x4) @x5) (FStar.ST.ralloc_post @x0 @x1 @x2 @x3 @x4 @x5)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.ST.ralloc_post@tok @x0) @x1) @x2) @x3) @x4) @x5)))) :named token_correspondence_FStar.ST.ralloc_post))
(assert (! (HasType FStar.ST.ralloc_post@tok (Tm_arrow_2841 FStar.HyperHeap.t FStar.HyperHeap.rid)) :named function_token_typing_FStar.ST.ralloc_post))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 FStar.HyperHeap.rid) (HasType @x2 @x0) (HasType @x3 FStar.HyperHeap.t) (HasType @x4 (FStar.HyperHeap.rref @x1 @x0)) (HasType @x5 FStar.HyperHeap.t)) (HasType (FStar.ST.ralloc_post @x0 @x1 @x2 @x3 @x4 @x5) Tm_type)) :pattern ((FStar.ST.ralloc_post @x0 @x1 @x2 @x3 @x4 @x5)))) :named typing_FStar.ST.ralloc_post))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (= (FStar.ST.ralloc_post @x0 @x1 @x2 @x3 @x4 @x5) (Prims.l_and (Prims.b2t (Prims.op_Negation (FStar.Heap.contains @x0 (FStar.Map.sel FStar.HyperHeap.rid FStar.Heap.heap @x3 @x1) (FStar.HyperHeap.as_ref @x0 @x1 @x4)))) (Prims.eq2 FStar.HyperHeap.t @x5 (FStar.HyperHeap.upd @x0 @x1 @x3 @x4 @x2)))) :pattern ((FStar.ST.ralloc_post @x0 @x1 @x2 @x3 @x4 @x5)))) :named equation_FStar.ST.ralloc_post))
(declare-fun FStar.ST.ralloc (Term Term Term) Term)
(declare-fun FStar.ST.ralloc@tok () Term)
(declare-fun FStar.ST.alloc_post (Term Term Term Term Term) Term)
(declare-fun Tm_arrow_2845 (Term) Term)
(assert (! (forall ((@x0 Term)) (! (HasType (Tm_arrow_2845 @x0) Tm_type) :pattern ((HasType (Tm_arrow_2845 @x0) Tm_type)))) :named kinding_Tm_arrow_2845))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_2845 @x2)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_2845 @x2))))) :named pre_typing_Tm_arrow_2845))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_2845 @x1)) (forall ((@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term)) (! (implies (and (HasType @x2 Tm_type) (HasType @x3 @x2) (HasType @x4 @x1) (HasType @x5 (FStar.ST.ref @x2)) (HasType @x6 @x1)) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x2) @x3) @x4) @x5) @x6) Tm_type)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x2) @x3) @x4) @x5) @x6))))) :pattern ((HasTypeZ @x0 (Tm_arrow_2845 @x1))))) :named interpretation_Tm_arrow_2845))
(declare-fun FStar.ST.alloc_post@tok () Term)
(assert (! (= 2847 (Term_constr_id FStar.ST.alloc_post@tok)) :named fresh_token_FStar.ST.alloc_post@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.ST.alloc_post@tok @x0) @x1) @x2) @x3) @x4) (FStar.ST.alloc_post @x0 @x1 @x2 @x3 @x4)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.ST.alloc_post@tok @x0) @x1) @x2) @x3) @x4)))) :named token_correspondence_FStar.ST.alloc_post))
(assert (! (HasType FStar.ST.alloc_post@tok (Tm_arrow_2845 FStar.HyperHeap.t)) :named function_token_typing_FStar.ST.alloc_post))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 @x0) (HasType @x2 FStar.HyperHeap.t) (HasType @x3 (FStar.ST.ref @x0)) (HasType @x4 FStar.HyperHeap.t)) (HasType (FStar.ST.alloc_post @x0 @x1 @x2 @x3 @x4) Tm_type)) :pattern ((FStar.ST.alloc_post @x0 @x1 @x2 @x3 @x4)))) :named typing_FStar.ST.alloc_post))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (= (FStar.ST.alloc_post @x0 @x1 @x2 @x3 @x4) (Prims.l_and (Prims.b2t (Prims.op_Negation (FStar.Heap.contains @x0 (FStar.Map.sel FStar.HyperHeap.rid FStar.Heap.heap @x2 FStar.HyperHeap.root) (FStar.HyperHeap.as_ref @x0 FStar.HyperHeap.root @x3)))) (Prims.eq2 FStar.HyperHeap.t @x4 (FStar.HyperHeap.upd @x0 FStar.HyperHeap.root @x2 @x3 @x1)))) :pattern ((FStar.ST.alloc_post @x0 @x1 @x2 @x3 @x4)))) :named equation_FStar.ST.alloc_post))
(declare-fun FStar.ST.alloc (Term Term) Term)
(declare-fun FStar.ST.alloc@tok () Term)
(declare-fun FStar.ST.assign_post (Term Term Term Term Term Term Term) Term)
(declare-fun Tm_arrow_2849 (Term Term Term) Term)
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (HasType (Tm_arrow_2849 @x0 @x1 @x2) Tm_type) :pattern ((HasType (Tm_arrow_2849 @x0 @x1 @x2) Tm_type)))) :named kinding_Tm_arrow_2849))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_2849 @x2 @x3 @x4)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_2849 @x2 @x3 @x4))))) :named pre_typing_Tm_arrow_2849))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_2849 @x1 @x2 @x3)) (forall ((@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term) (@x9 Term) (@x10 Term)) (! (implies (and (HasType @x4 Tm_type) (HasType @x5 @x3) (HasType @x6 (FStar.HyperHeap.rref @x5 @x4)) (HasType @x7 @x4) (HasType @x8 @x2) (HasType @x9 @x1) (HasType @x10 @x2)) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x4) @x5) @x6) @x7) @x8) @x9) @x10) Tm_type)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x4) @x5) @x6) @x7) @x8) @x9) @x10))))) :pattern ((HasTypeZ @x0 (Tm_arrow_2849 @x1 @x2 @x3))))) :named interpretation_Tm_arrow_2849))
(declare-fun FStar.ST.assign_post@tok () Term)
(assert (! (= 2851 (Term_constr_id FStar.ST.assign_post@tok)) :named fresh_token_FStar.ST.assign_post@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.ST.assign_post@tok @x0) @x1) @x2) @x3) @x4) @x5) @x6) (FStar.ST.assign_post @x0 @x1 @x2 @x3 @x4 @x5 @x6)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.ST.assign_post@tok @x0) @x1) @x2) @x3) @x4) @x5) @x6)))) :named token_correspondence_FStar.ST.assign_post))
(assert (! (HasType FStar.ST.assign_post@tok (Tm_arrow_2849 Prims.unit FStar.HyperHeap.t FStar.HyperHeap.rid)) :named function_token_typing_FStar.ST.assign_post))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 FStar.HyperHeap.rid) (HasType @x2 (FStar.HyperHeap.rref @x1 @x0)) (HasType @x3 @x0) (HasType @x4 FStar.HyperHeap.t) (HasType @x5 Prims.unit) (HasType @x6 FStar.HyperHeap.t)) (HasType (FStar.ST.assign_post @x0 @x1 @x2 @x3 @x4 @x5 @x6) Tm_type)) :pattern ((FStar.ST.assign_post @x0 @x1 @x2 @x3 @x4 @x5 @x6)))) :named typing_FStar.ST.assign_post))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term)) (! (= (FStar.ST.assign_post @x0 @x1 @x2 @x3 @x4 @x5 @x6) (Prims.eq2 FStar.HyperHeap.t @x6 (FStar.HyperHeap.upd @x0 @x1 @x4 @x2 @x3))) :pattern ((FStar.ST.assign_post @x0 @x1 @x2 @x3 @x4 @x5 @x6)))) :named equation_FStar.ST.assign_post))
(declare-fun FStar.ST.op_Colon_Equals (Term Term Term Term) Term)
(declare-fun FStar.ST.op_Colon_Equals@tok () Term)
(declare-fun FStar.ST.deref_post (Term Term Term Term Term Term) Term)
(declare-fun Tm_arrow_2853 (Term Term) Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (HasType (Tm_arrow_2853 @x0 @x1) Tm_type) :pattern ((HasType (Tm_arrow_2853 @x0 @x1) Tm_type)))) :named kinding_Tm_arrow_2853))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_2853 @x2 @x3)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_2853 @x2 @x3))))) :named pre_typing_Tm_arrow_2853))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_2853 @x1 @x2)) (forall ((@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term)) (! (implies (and (HasType @x3 Tm_type) (HasType @x4 @x2) (HasType @x5 (FStar.HyperHeap.rref @x4 @x3)) (HasType @x6 @x1) (HasType @x7 @x3) (HasType @x8 @x1)) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x3) @x4) @x5) @x6) @x7) @x8) Tm_type)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x3) @x4) @x5) @x6) @x7) @x8))))) :pattern ((HasTypeZ @x0 (Tm_arrow_2853 @x1 @x2))))) :named interpretation_Tm_arrow_2853))
(declare-fun FStar.ST.deref_post@tok () Term)
(assert (! (= 2855 (Term_constr_id FStar.ST.deref_post@tok)) :named fresh_token_FStar.ST.deref_post@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.ST.deref_post@tok @x0) @x1) @x2) @x3) @x4) @x5) (FStar.ST.deref_post @x0 @x1 @x2 @x3 @x4 @x5)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.ST.deref_post@tok @x0) @x1) @x2) @x3) @x4) @x5)))) :named token_correspondence_FStar.ST.deref_post))
(assert (! (HasType FStar.ST.deref_post@tok (Tm_arrow_2853 FStar.HyperHeap.t FStar.HyperHeap.rid)) :named function_token_typing_FStar.ST.deref_post))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 FStar.HyperHeap.rid) (HasType @x2 (FStar.HyperHeap.rref @x1 @x0)) (HasType @x3 FStar.HyperHeap.t) (HasType @x4 @x0) (HasType @x5 FStar.HyperHeap.t)) (HasType (FStar.ST.deref_post @x0 @x1 @x2 @x3 @x4 @x5) Tm_type)) :pattern ((FStar.ST.deref_post @x0 @x1 @x2 @x3 @x4 @x5)))) :named typing_FStar.ST.deref_post))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (= (Valid (FStar.ST.deref_post @x0 @x1 @x2 @x3 @x4 @x5)) (and (= @x5 @x3) (= @x4 (FStar.HyperHeap.sel @x0 @x1 @x3 @x2)))) :pattern ((Valid (FStar.ST.deref_post @x0 @x1 @x2 @x3 @x4 @x5))))) :named equation_FStar.ST.deref_post))
(declare-fun FStar.ST.op_Bang (Term Term Term) Term)
(declare-fun FStar.ST.op_Bang@tok () Term)
(declare-fun FStar.ST.get (Term) Term)
(declare-fun FStar.ST.get@tok () Term)
(declare-fun FStar.ST.recall (Term Term Term) Term)
(declare-fun FStar.ST.recall@tok () Term)
(declare-fun FStar.ST.recall_region (Term) Term)
(declare-fun FStar.ST.recall_region@tok () Term)
(declare-fun FStar.Monotonic.RRef.reln (Term) Term)
(declare-fun FStar.Monotonic.RRef.reln@tok () Term)
(assert (! (= 3032 (Term_constr_id FStar.Monotonic.RRef.reln@tok)) :named fresh_token_FStar.Monotonic.RRef.reln@tok))
(assert (! (forall ((@x0 Term)) (! (= (ApplyTT FStar.Monotonic.RRef.reln@tok @x0) (FStar.Monotonic.RRef.reln @x0)) :pattern ((ApplyTT FStar.Monotonic.RRef.reln@tok @x0)))) :named token_correspondence_FStar.Monotonic.RRef.reln))
(assert (! (HasType FStar.Monotonic.RRef.reln@tok Tm_arrow_105) :named function_token_typing_FStar.Monotonic.RRef.reln))
(assert (! (forall ((@x0 Term)) (! (implies (HasType @x0 Tm_type) (HasType (FStar.Monotonic.RRef.reln @x0) Tm_type)) :pattern ((FStar.Monotonic.RRef.reln @x0)))) :named typing_FStar.Monotonic.RRef.reln))
(declare-fun Tm_arrow_3034 (Term) Term)
(assert (! (forall ((@x0 Term)) (! (HasType (Tm_arrow_3034 @x0) Tm_type) :pattern ((HasType (Tm_arrow_3034 @x0) Tm_type)))) :named kinding_Tm_arrow_3034))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_3034 @x2)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_3034 @x2))))) :named pre_typing_Tm_arrow_3034))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_3034 @x1)) (forall ((@x2 Term) (@x3 Term)) (! (implies (and (HasType @x2 @x1) (HasType @x3 @x1)) (HasType (ApplyTT (ApplyTT @x0 @x2) @x3) Tm_type)) :pattern ((ApplyTT (ApplyTT @x0 @x2) @x3))))) :pattern ((HasTypeZ @x0 (Tm_arrow_3034 @x1))))) :named interpretation_Tm_arrow_3034))
(assert (! (forall ((@x0 Term)) (! (= (FStar.Monotonic.RRef.reln @x0) (Tm_arrow_3034 @x0)) :pattern ((FStar.Monotonic.RRef.reln @x0)))) :named equation_FStar.Monotonic.RRef.reln))
(declare-fun FStar.Monotonic.RRef.monotonic (Term Term) Term)
(declare-fun Tm_arrow_3037 () Term)
(assert (! (HasType Tm_arrow_3037 Tm_type) :named kinding_Tm_arrow_3037))
(assert (! (forall ((@u0 Fuel) (@x1 Term)) (! (implies (HasTypeFuel @u0 @x1 Tm_arrow_3037) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 Tm_arrow_3037)))) :named pre_typing_Tm_arrow_3037))
(assert (! (forall ((@x0 Term)) (! (iff (HasTypeZ @x0 Tm_arrow_3037) (forall ((@x1 Term) (@x2 Term)) (! (implies (and (HasType @x1 Tm_type) (HasType @x2 (FStar.Monotonic.RRef.reln @x1))) (HasType (ApplyTT (ApplyTT @x0 @x1) @x2) Tm_type)) :pattern ((ApplyTT (ApplyTT @x0 @x1) @x2))))) :pattern ((HasTypeZ @x0 Tm_arrow_3037)))) :named interpretation_Tm_arrow_3037))
(declare-fun FStar.Monotonic.RRef.monotonic@tok () Term)
(assert (! (= 3039 (Term_constr_id FStar.Monotonic.RRef.monotonic@tok)) :named fresh_token_FStar.Monotonic.RRef.monotonic@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (ApplyTT (ApplyTT FStar.Monotonic.RRef.monotonic@tok @x0) @x1) (FStar.Monotonic.RRef.monotonic @x0 @x1)) :pattern ((ApplyTT (ApplyTT FStar.Monotonic.RRef.monotonic@tok @x0) @x1)))) :named token_correspondence_FStar.Monotonic.RRef.monotonic))
(assert (! (HasType FStar.Monotonic.RRef.monotonic@tok Tm_arrow_3037) :named function_token_typing_FStar.Monotonic.RRef.monotonic))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 (FStar.Monotonic.RRef.reln @x0))) (HasType (FStar.Monotonic.RRef.monotonic @x0 @x1) Tm_type)) :pattern ((FStar.Monotonic.RRef.monotonic @x0 @x1)))) :named typing_FStar.Monotonic.RRef.monotonic))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (Valid (FStar.Monotonic.RRef.monotonic @x0 @x1)) (and (forall ((@x2 Term)) (implies (HasType @x2 @x0) (Valid (ApplyTT (ApplyTT @x1 @x2) @x2)))) (forall ((@x2 Term) (@x3 Term) (@x4 Term)) (implies (and (HasType @x2 @x0) (HasType @x3 @x0) (HasType @x4 @x0) (Valid (ApplyTT (ApplyTT @x1 @x2) @x3)) (Valid (ApplyTT (ApplyTT @x1 @x3) @x4))) (Valid (ApplyTT (ApplyTT @x1 @x2) @x4)))))) :pattern ((Valid (FStar.Monotonic.RRef.monotonic @x0 @x1))))) :named equation_FStar.Monotonic.RRef.monotonic))
(declare-fun FStar.Monotonic.RRef.m_rref (Term Term Term) Term)
(declare-fun Tm_arrow_3041 (Term) Term)
(assert (! (forall ((@x0 Term)) (! (HasType (Tm_arrow_3041 @x0) Tm_type) :pattern ((HasType (Tm_arrow_3041 @x0) Tm_type)))) :named kinding_Tm_arrow_3041))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_3041 @x2)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_3041 @x2))))) :named pre_typing_Tm_arrow_3041))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_3041 @x1)) (forall ((@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x2 @x1) (HasType @x3 Tm_type) (HasType @x4 (FStar.Monotonic.RRef.reln @x3))) (HasType (ApplyTT (ApplyTT (ApplyTT @x0 @x2) @x3) @x4) Tm_type)) :pattern ((ApplyTT (ApplyTT (ApplyTT @x0 @x2) @x3) @x4))))) :pattern ((HasTypeZ @x0 (Tm_arrow_3041 @x1))))) :named interpretation_Tm_arrow_3041))
(declare-fun FStar.Monotonic.RRef.m_rref@tok () Term)
(assert (! (= 3043 (Term_constr_id FStar.Monotonic.RRef.m_rref@tok)) :named fresh_token_FStar.Monotonic.RRef.m_rref@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT FStar.Monotonic.RRef.m_rref@tok @x0) @x1) @x2) (FStar.Monotonic.RRef.m_rref @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT FStar.Monotonic.RRef.m_rref@tok @x0) @x1) @x2)))) :named token_correspondence_FStar.Monotonic.RRef.m_rref))
(assert (! (HasType FStar.Monotonic.RRef.m_rref@tok (Tm_arrow_3041 FStar.HyperHeap.rid)) :named function_token_typing_FStar.Monotonic.RRef.m_rref))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 FStar.HyperHeap.rid) (HasType @x1 Tm_type) (HasType @x2 (FStar.Monotonic.RRef.reln @x1))) (HasType (FStar.Monotonic.RRef.m_rref @x0 @x1 @x2) Tm_type)) :pattern ((FStar.Monotonic.RRef.m_rref @x0 @x1 @x2)))) :named typing_FStar.Monotonic.RRef.m_rref))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 FStar.HyperHeap.rid) (HasType @x1 Tm_type) (HasType @x2 (FStar.Monotonic.RRef.reln @x1))) (Valid (Prims.hasEq (FStar.Monotonic.RRef.m_rref @x0 @x1 @x2)))) :pattern ((Prims.hasEq (FStar.Monotonic.RRef.m_rref @x0 @x1 @x2))))) :named assumption_FStar.Monotonic.RRef.HasEq_m_rref_3044))
(declare-fun FStar.Monotonic.RRef.as_rref (Term Term Term Term) Term)
(declare-fun Tm_arrow_3046 (Term) Term)
(assert (! (forall ((@x0 Term)) (! (HasType (Tm_arrow_3046 @x0) Tm_type) :pattern ((HasType (Tm_arrow_3046 @x0) Tm_type)))) :named kinding_Tm_arrow_3046))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_3046 @x2)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_3046 @x2))))) :named pre_typing_Tm_arrow_3046))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_3046 @x1)) (forall ((@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (implies (and (HasType @x2 @x1) (HasType @x3 Tm_type) (HasType @x4 (FStar.Monotonic.RRef.reln @x3)) (HasType @x5 (FStar.Monotonic.RRef.m_rref @x2 @x3 @x4))) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x2) @x3) @x4) @x5) (FStar.HyperHeap.rref @x2 @x3))) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x2) @x3) @x4) @x5))))) :pattern ((HasTypeZ @x0 (Tm_arrow_3046 @x1))))) :named interpretation_Tm_arrow_3046))
(declare-fun FStar.Monotonic.RRef.as_rref@tok () Term)
(assert (! (= 3048 (Term_constr_id FStar.Monotonic.RRef.as_rref@tok)) :named fresh_token_FStar.Monotonic.RRef.as_rref@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.Monotonic.RRef.as_rref@tok @x0) @x1) @x2) @x3) (FStar.Monotonic.RRef.as_rref @x0 @x1 @x2 @x3)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.Monotonic.RRef.as_rref@tok @x0) @x1) @x2) @x3)))) :named token_correspondence_FStar.Monotonic.RRef.as_rref))
(assert (! (HasType FStar.Monotonic.RRef.as_rref@tok (Tm_arrow_3046 FStar.HyperHeap.rid)) :named function_token_typing_FStar.Monotonic.RRef.as_rref))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x0 FStar.HyperHeap.rid) (HasType @x1 Tm_type) (HasType @x2 (FStar.Monotonic.RRef.reln @x1)) (HasType @x3 (FStar.Monotonic.RRef.m_rref @x0 @x1 @x2))) (HasType (FStar.Monotonic.RRef.as_rref @x0 @x1 @x2 @x3) (FStar.HyperHeap.rref @x0 @x1))) :pattern ((FStar.Monotonic.RRef.as_rref @x0 @x1 @x2 @x3)))) :named typing_FStar.Monotonic.RRef.as_rref))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (FStar.Monotonic.RRef.as_rref @x0 @x1 @x2 @x3) @x3) :pattern ((FStar.Monotonic.RRef.as_rref @x0 @x1 @x2 @x3)))) :named equation_FStar.Monotonic.RRef.as_rref))
(declare-fun FStar.Monotonic.RRef.m_contains (Term Term Term Term Term) Term)
(declare-fun Tm_arrow_3050 (Term Term Term) Term)
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (HasType (Tm_arrow_3050 @x0 @x1 @x2) Tm_type) :pattern ((HasType (Tm_arrow_3050 @x0 @x1 @x2) Tm_type)))) :named kinding_Tm_arrow_3050))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_3050 @x2 @x3 @x4)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_3050 @x2 @x3 @x4))))) :named pre_typing_Tm_arrow_3050))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_3050 @x1 @x2 @x3)) (forall ((@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term)) (! (implies (and (HasType @x4 @x3) (HasType @x5 Tm_type) (HasType @x6 (FStar.Monotonic.RRef.reln @x5)) (HasType @x7 (FStar.Monotonic.RRef.m_rref @x4 @x5 @x6)) (HasType @x8 @x2)) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x4) @x5) @x6) @x7) @x8) @x1)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x4) @x5) @x6) @x7) @x8))))) :pattern ((HasTypeZ @x0 (Tm_arrow_3050 @x1 @x2 @x3))))) :named interpretation_Tm_arrow_3050))
(declare-fun FStar.Monotonic.RRef.m_contains@tok () Term)
(assert (! (= 3052 (Term_constr_id FStar.Monotonic.RRef.m_contains@tok)) :named fresh_token_FStar.Monotonic.RRef.m_contains@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.Monotonic.RRef.m_contains@tok @x0) @x1) @x2) @x3) @x4) (FStar.Monotonic.RRef.m_contains @x0 @x1 @x2 @x3 @x4)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.Monotonic.RRef.m_contains@tok @x0) @x1) @x2) @x3) @x4)))) :named token_correspondence_FStar.Monotonic.RRef.m_contains))
(assert (! (HasType FStar.Monotonic.RRef.m_contains@tok (Tm_arrow_3050 Prims.bool FStar.HyperHeap.t FStar.HyperHeap.rid)) :named function_token_typing_FStar.Monotonic.RRef.m_contains))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x0 FStar.HyperHeap.rid) (HasType @x1 Tm_type) (HasType @x2 (FStar.Monotonic.RRef.reln @x1)) (HasType @x3 (FStar.Monotonic.RRef.m_rref @x0 @x1 @x2)) (HasType @x4 FStar.HyperHeap.t)) (HasType (FStar.Monotonic.RRef.m_contains @x0 @x1 @x2 @x3 @x4) Prims.bool)) :pattern ((FStar.Monotonic.RRef.m_contains @x0 @x1 @x2 @x3 @x4)))) :named typing_FStar.Monotonic.RRef.m_contains))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (= (FStar.Monotonic.RRef.m_contains @x0 @x1 @x2 @x3 @x4) (FStar.HyperHeap.contains_ref @x1 @x0 (FStar.Monotonic.RRef.as_rref @x0 @x1 @x2 @x3) @x4)) :pattern ((FStar.Monotonic.RRef.m_contains @x0 @x1 @x2 @x3 @x4)))) :named equation_FStar.Monotonic.RRef.m_contains))
(declare-fun FStar.Monotonic.RRef.m_fresh (Term Term Term Term Term Term) Term)
(declare-fun Tm_arrow_3054 (Term Term) Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (HasType (Tm_arrow_3054 @x0 @x1) Tm_type) :pattern ((HasType (Tm_arrow_3054 @x0 @x1) Tm_type)))) :named kinding_Tm_arrow_3054))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_3054 @x2 @x3)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_3054 @x2 @x3))))) :named pre_typing_Tm_arrow_3054))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_3054 @x1 @x2)) (forall ((@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term)) (! (implies (and (HasType @x3 @x2) (HasType @x4 Tm_type) (HasType @x5 (FStar.Monotonic.RRef.reln @x4)) (HasType @x6 (FStar.Monotonic.RRef.m_rref @x3 @x4 @x5)) (HasType @x7 @x1) (HasType @x8 @x1)) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x3) @x4) @x5) @x6) @x7) @x8) Tm_type)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x3) @x4) @x5) @x6) @x7) @x8))))) :pattern ((HasTypeZ @x0 (Tm_arrow_3054 @x1 @x2))))) :named interpretation_Tm_arrow_3054))
(declare-fun FStar.Monotonic.RRef.m_fresh@tok () Term)
(assert (! (= 3056 (Term_constr_id FStar.Monotonic.RRef.m_fresh@tok)) :named fresh_token_FStar.Monotonic.RRef.m_fresh@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.Monotonic.RRef.m_fresh@tok @x0) @x1) @x2) @x3) @x4) @x5) (FStar.Monotonic.RRef.m_fresh @x0 @x1 @x2 @x3 @x4 @x5)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.Monotonic.RRef.m_fresh@tok @x0) @x1) @x2) @x3) @x4) @x5)))) :named token_correspondence_FStar.Monotonic.RRef.m_fresh))
(assert (! (HasType FStar.Monotonic.RRef.m_fresh@tok (Tm_arrow_3054 FStar.HyperHeap.t FStar.HyperHeap.rid)) :named function_token_typing_FStar.Monotonic.RRef.m_fresh))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (implies (and (HasType @x0 FStar.HyperHeap.rid) (HasType @x1 Tm_type) (HasType @x2 (FStar.Monotonic.RRef.reln @x1)) (HasType @x3 (FStar.Monotonic.RRef.m_rref @x0 @x1 @x2)) (HasType @x4 FStar.HyperHeap.t) (HasType @x5 FStar.HyperHeap.t)) (HasType (FStar.Monotonic.RRef.m_fresh @x0 @x1 @x2 @x3 @x4 @x5) Tm_type)) :pattern ((FStar.Monotonic.RRef.m_fresh @x0 @x1 @x2 @x3 @x4 @x5)))) :named typing_FStar.Monotonic.RRef.m_fresh))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (= (FStar.Monotonic.RRef.m_fresh @x0 @x1 @x2 @x3 @x4 @x5) (FStar.HyperHeap.fresh_rref @x1 @x0 (FStar.Monotonic.RRef.as_rref @x0 @x1 @x2 @x3) @x4 @x5)) :pattern ((FStar.Monotonic.RRef.m_fresh @x0 @x1 @x2 @x3 @x4 @x5)))) :named equation_FStar.Monotonic.RRef.m_fresh))
(declare-fun FStar.Monotonic.RRef.m_sel (Term Term Term Term Term) Term)
(declare-fun Tm_arrow_3058 (Term Term) Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (HasType (Tm_arrow_3058 @x0 @x1) Tm_type) :pattern ((HasType (Tm_arrow_3058 @x0 @x1) Tm_type)))) :named kinding_Tm_arrow_3058))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_3058 @x2 @x3)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_3058 @x2 @x3))))) :named pre_typing_Tm_arrow_3058))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_3058 @x1 @x2)) (forall ((@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term)) (! (implies (and (HasType @x3 @x2) (HasType @x4 Tm_type) (HasType @x5 (FStar.Monotonic.RRef.reln @x4)) (HasType @x6 @x1) (HasType @x7 (FStar.Monotonic.RRef.m_rref @x3 @x4 @x5))) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x3) @x4) @x5) @x6) @x7) @x4)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x3) @x4) @x5) @x6) @x7))))) :pattern ((HasTypeZ @x0 (Tm_arrow_3058 @x1 @x2))))) :named interpretation_Tm_arrow_3058))
(declare-fun FStar.Monotonic.RRef.m_sel@tok () Term)
(assert (! (= 3060 (Term_constr_id FStar.Monotonic.RRef.m_sel@tok)) :named fresh_token_FStar.Monotonic.RRef.m_sel@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.Monotonic.RRef.m_sel@tok @x0) @x1) @x2) @x3) @x4) (FStar.Monotonic.RRef.m_sel @x0 @x1 @x2 @x3 @x4)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.Monotonic.RRef.m_sel@tok @x0) @x1) @x2) @x3) @x4)))) :named token_correspondence_FStar.Monotonic.RRef.m_sel))
(assert (! (HasType FStar.Monotonic.RRef.m_sel@tok (Tm_arrow_3058 FStar.HyperHeap.t FStar.HyperHeap.rid)) :named function_token_typing_FStar.Monotonic.RRef.m_sel))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x0 FStar.HyperHeap.rid) (HasType @x1 Tm_type) (HasType @x2 (FStar.Monotonic.RRef.reln @x1)) (HasType @x3 FStar.HyperHeap.t) (HasType @x4 (FStar.Monotonic.RRef.m_rref @x0 @x1 @x2))) (HasType (FStar.Monotonic.RRef.m_sel @x0 @x1 @x2 @x3 @x4) @x1)) :pattern ((FStar.Monotonic.RRef.m_sel @x0 @x1 @x2 @x3 @x4)))) :named typing_FStar.Monotonic.RRef.m_sel))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (= (FStar.Monotonic.RRef.m_sel @x0 @x1 @x2 @x3 @x4) (FStar.HyperHeap.sel @x1 @x0 @x3 (FStar.Monotonic.RRef.as_rref @x0 @x1 @x2 @x4))) :pattern ((FStar.Monotonic.RRef.m_sel @x0 @x1 @x2 @x3 @x4)))) :named equation_FStar.Monotonic.RRef.m_sel))
(declare-fun FStar.Monotonic.RRef.m_upd (Term Term Term Term Term Term) Term)
(declare-fun Tm_arrow_3062 (Term Term) Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (HasType (Tm_arrow_3062 @x0 @x1) Tm_type) :pattern ((HasType (Tm_arrow_3062 @x0 @x1) Tm_type)))) :named kinding_Tm_arrow_3062))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_3062 @x2 @x3)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_3062 @x2 @x3))))) :named pre_typing_Tm_arrow_3062))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_3062 @x1 @x2)) (forall ((@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term) (@x8 Term)) (! (implies (and (HasType @x3 @x2) (HasType @x4 Tm_type) (HasType @x5 (FStar.Monotonic.RRef.reln @x4)) (HasType @x6 @x1) (HasType @x7 (FStar.Monotonic.RRef.m_rref @x3 @x4 @x5)) (HasType @x8 @x4)) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x3) @x4) @x5) @x6) @x7) @x8) @x1)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x3) @x4) @x5) @x6) @x7) @x8))))) :pattern ((HasTypeZ @x0 (Tm_arrow_3062 @x1 @x2))))) :named interpretation_Tm_arrow_3062))
(declare-fun FStar.Monotonic.RRef.m_upd@tok () Term)
(assert (! (= 3064 (Term_constr_id FStar.Monotonic.RRef.m_upd@tok)) :named fresh_token_FStar.Monotonic.RRef.m_upd@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.Monotonic.RRef.m_upd@tok @x0) @x1) @x2) @x3) @x4) @x5) (FStar.Monotonic.RRef.m_upd @x0 @x1 @x2 @x3 @x4 @x5)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.Monotonic.RRef.m_upd@tok @x0) @x1) @x2) @x3) @x4) @x5)))) :named token_correspondence_FStar.Monotonic.RRef.m_upd))
(assert (! (HasType FStar.Monotonic.RRef.m_upd@tok (Tm_arrow_3062 FStar.HyperHeap.t FStar.HyperHeap.rid)) :named function_token_typing_FStar.Monotonic.RRef.m_upd))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (implies (and (HasType @x0 FStar.HyperHeap.rid) (HasType @x1 Tm_type) (HasType @x2 (FStar.Monotonic.RRef.reln @x1)) (HasType @x3 FStar.HyperHeap.t) (HasType @x4 (FStar.Monotonic.RRef.m_rref @x0 @x1 @x2)) (HasType @x5 @x1)) (HasType (FStar.Monotonic.RRef.m_upd @x0 @x1 @x2 @x3 @x4 @x5) FStar.HyperHeap.t)) :pattern ((FStar.Monotonic.RRef.m_upd @x0 @x1 @x2 @x3 @x4 @x5)))) :named typing_FStar.Monotonic.RRef.m_upd))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (= (FStar.Monotonic.RRef.m_upd @x0 @x1 @x2 @x3 @x4 @x5) (FStar.HyperHeap.upd @x1 @x0 @x3 (FStar.Monotonic.RRef.as_rref @x0 @x1 @x2 @x4) @x5)) :pattern ((FStar.Monotonic.RRef.m_upd @x0 @x1 @x2 @x3 @x4 @x5)))) :named equation_FStar.Monotonic.RRef.m_upd))
(declare-fun FStar.Monotonic.RRef.m_alloc (Term Term Term Term) Term)
(declare-fun FStar.Monotonic.RRef.m_alloc@tok () Term)
(declare-fun FStar.Monotonic.RRef.m_read (Term Term Term Term) Term)
(declare-fun FStar.Monotonic.RRef.m_read@tok () Term)
(declare-fun FStar.Monotonic.RRef.m_write (Term Term Term Term Term) Term)
(declare-fun FStar.Monotonic.RRef.m_write@tok () Term)
(declare-fun FStar.Monotonic.RRef.stable_on_t (Term Term Term Term Term) Term)
(declare-fun Tm_arrow_3068 (Term Term) Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (HasType (Tm_arrow_3068 @x0 @x1) Tm_type) :pattern ((HasType (Tm_arrow_3068 @x0 @x1) Tm_type)))) :named kinding_Tm_arrow_3068))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_3068 @x2 @x3)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_3068 @x2 @x3))))) :named pre_typing_Tm_arrow_3068))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_3068 @x1 @x2)) (forall ((@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term) (@x7 Term)) (! (implies (and (HasType @x3 @x2) (HasType @x4 Tm_type) (HasType @x5 (FStar.Monotonic.RRef.reln @x4)) (HasType @x6 (FStar.Monotonic.RRef.m_rref @x3 @x4 @x5)) (HasType @x7 (Tm_arrow_239 @x1))) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x3) @x4) @x5) @x6) @x7) Tm_type)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x3) @x4) @x5) @x6) @x7))))) :pattern ((HasTypeZ @x0 (Tm_arrow_3068 @x1 @x2))))) :named interpretation_Tm_arrow_3068))
(declare-fun FStar.Monotonic.RRef.stable_on_t@tok () Term)
(assert (! (= 3070 (Term_constr_id FStar.Monotonic.RRef.stable_on_t@tok)) :named fresh_token_FStar.Monotonic.RRef.stable_on_t@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.Monotonic.RRef.stable_on_t@tok @x0) @x1) @x2) @x3) @x4) (FStar.Monotonic.RRef.stable_on_t @x0 @x1 @x2 @x3 @x4)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.Monotonic.RRef.stable_on_t@tok @x0) @x1) @x2) @x3) @x4)))) :named token_correspondence_FStar.Monotonic.RRef.stable_on_t))
(assert (! (HasType FStar.Monotonic.RRef.stable_on_t@tok (Tm_arrow_3068 FStar.HyperHeap.t FStar.HyperHeap.rid)) :named function_token_typing_FStar.Monotonic.RRef.stable_on_t))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x0 FStar.HyperHeap.rid) (HasType @x1 Tm_type) (HasType @x2 (FStar.Monotonic.RRef.reln @x1)) (HasType @x3 (FStar.Monotonic.RRef.m_rref @x0 @x1 @x2)) (HasType @x4 (Tm_arrow_239 FStar.HyperHeap.t))) (HasType (FStar.Monotonic.RRef.stable_on_t @x0 @x1 @x2 @x3 @x4) Tm_type)) :pattern ((FStar.Monotonic.RRef.stable_on_t @x0 @x1 @x2 @x3 @x4)))) :named typing_FStar.Monotonic.RRef.stable_on_t))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (= (Valid (FStar.Monotonic.RRef.stable_on_t @x0 @x1 @x2 @x3 @x4)) (forall ((@x5 Term) (@x6 Term)) (implies (and (HasType @x5 FStar.HyperHeap.t) (HasType @x6 FStar.HyperHeap.t) (Valid (ApplyTT @x4 @x5)) (Valid (ApplyTT (ApplyTT @x2 (FStar.Monotonic.RRef.m_sel @x0 @x1 @x2 @x5 @x3)) (FStar.Monotonic.RRef.m_sel @x0 @x1 @x2 @x6 @x3)))) (Valid (ApplyTT @x4 @x6))))) :pattern ((Valid (FStar.Monotonic.RRef.stable_on_t @x0 @x1 @x2 @x3 @x4))))) :named equation_FStar.Monotonic.RRef.stable_on_t))
(declare-fun FStar.Monotonic.RRef.witnessed (Term) Term)
(declare-fun Tm_arrow_3075 (Term) Term)
(assert (! (forall ((@x0 Term)) (! (HasType (Tm_arrow_3075 @x0) Tm_type) :pattern ((HasType (Tm_arrow_3075 @x0) Tm_type)))) :named kinding_Tm_arrow_3075))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_3075 @x2)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_3075 @x2))))) :named pre_typing_Tm_arrow_3075))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_3075 @x1)) (forall ((@x2 Term)) (! (implies (HasType @x2 (Tm_arrow_239 @x1)) (HasType (ApplyTT @x0 @x2) Tm_type)) :pattern ((ApplyTT @x0 @x2))))) :pattern ((HasTypeZ @x0 (Tm_arrow_3075 @x1))))) :named interpretation_Tm_arrow_3075))
(declare-fun FStar.Monotonic.RRef.witnessed@tok () Term)
(assert (! (= 3077 (Term_constr_id FStar.Monotonic.RRef.witnessed@tok)) :named fresh_token_FStar.Monotonic.RRef.witnessed@tok))
(assert (! (forall ((@x0 Term)) (! (= (ApplyTT FStar.Monotonic.RRef.witnessed@tok @x0) (FStar.Monotonic.RRef.witnessed @x0)) :pattern ((ApplyTT FStar.Monotonic.RRef.witnessed@tok @x0)))) :named token_correspondence_FStar.Monotonic.RRef.witnessed))
(assert (! (HasType FStar.Monotonic.RRef.witnessed@tok (Tm_arrow_3075 FStar.HyperHeap.t)) :named function_token_typing_FStar.Monotonic.RRef.witnessed))
(assert (! (forall ((@x0 Term)) (! (implies (HasType @x0 (Tm_arrow_239 FStar.HyperHeap.t)) (HasType (FStar.Monotonic.RRef.witnessed @x0) Tm_type)) :pattern ((FStar.Monotonic.RRef.witnessed @x0)))) :named typing_FStar.Monotonic.RRef.witnessed))
(declare-fun FStar.Monotonic.RRef.witness (Term Term Term Term Term) Term)
(declare-fun FStar.Monotonic.RRef.witness@tok () Term)
(declare-fun FStar.Monotonic.RRef.weaken_witness (Term Term) Term)
(declare-fun FStar.Monotonic.RRef.weaken_witness@tok () Term)
(declare-fun FStar.Monotonic.RRef.testify (Term) Term)
(declare-fun FStar.Monotonic.RRef.testify@tok () Term)
(declare-fun FStar.Monotonic.RRef.testify_forall (Term Term Term) Term)
(declare-fun FStar.Monotonic.RRef.testify_forall@tok () Term)
(declare-fun FStar.Monotonic.RRef.m_recall (Term Term Term Term) Term)
(declare-fun FStar.Monotonic.RRef.m_recall@tok () Term)
(declare-fun FStar.Monotonic.RRef.rid_exists (Term Term) Term)
(declare-fun FStar.Monotonic.RRef.rid_exists@tok () Term)
(assert (! (= 3079 (Term_constr_id FStar.Monotonic.RRef.rid_exists@tok)) :named fresh_token_FStar.Monotonic.RRef.rid_exists@tok))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (ApplyTT (ApplyTT FStar.Monotonic.RRef.rid_exists@tok @x0) @x1) (FStar.Monotonic.RRef.rid_exists @x0 @x1)) :pattern ((ApplyTT (ApplyTT FStar.Monotonic.RRef.rid_exists@tok @x0) @x1)))) :named token_correspondence_FStar.Monotonic.RRef.rid_exists))
(assert (! (HasType FStar.Monotonic.RRef.rid_exists@tok (Tm_arrow_577 FStar.HyperHeap.t FStar.HyperHeap.rid)) :named function_token_typing_FStar.Monotonic.RRef.rid_exists))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (implies (and (HasType @x0 FStar.HyperHeap.rid) (HasType @x1 FStar.HyperHeap.t)) (HasType (FStar.Monotonic.RRef.rid_exists @x0 @x1) Tm_type)) :pattern ((FStar.Monotonic.RRef.rid_exists @x0 @x1)))) :named typing_FStar.Monotonic.RRef.rid_exists))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (= (FStar.Monotonic.RRef.rid_exists @x0 @x1) (Prims.b2t (FStar.Map.contains FStar.HyperHeap.rid FStar.Heap.heap @x1 @x0))) :pattern ((FStar.Monotonic.RRef.rid_exists @x0 @x1)))) :named equation_FStar.Monotonic.RRef.rid_exists))
(declare-fun FStar.Monotonic.RRef.ex_rid () Term)
(assert (! (HasType FStar.Monotonic.RRef.ex_rid Tm_type) :named function_token_typing_FStar.Monotonic.RRef.ex_rid))
(assert (! (HasType FStar.Monotonic.RRef.ex_rid Tm_type) :named typing_FStar.Monotonic.RRef.ex_rid))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (HasType (ApplyTT FStar.Monotonic.RRef.rid_exists@tok @x1) (Tm_arrow_239 @x0)) :pattern ((HasType (ApplyTT FStar.Monotonic.RRef.rid_exists@tok @x1) (Tm_arrow_239 @x0))))) :named @partial_app_typing__3081))
(declare-fun Tm_refine_3083 (Term) Term)
(assert (! (forall ((@x0 Term)) (! (HasType (Tm_refine_3083 @x0) Tm_type) :pattern ((HasType (Tm_refine_3083 @x0) Tm_type)))) :named refinement_kinding_Tm_refine_3083))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (iff (HasTypeFuel @u0 @x1 (Tm_refine_3083 @x2)) (and (HasTypeFuel @u0 @x1 @x2) (Valid (FStar.Monotonic.RRef.witnessed (ApplyTT FStar.Monotonic.RRef.rid_exists@tok @x1))))) :pattern ((HasTypeFuel @u0 @x1 (Tm_refine_3083 @x2))))) :named refinement_interpretation_Tm_refine_3083))
(assert (! (forall ((@x0 Term)) (! (iff (Valid (Prims.hasEq (Tm_refine_3083 @x0))) (Valid (Prims.hasEq @x0))) :pattern ((Valid (Prims.hasEq (Tm_refine_3083 @x0)))))) :named haseqTm_refine_3083))
(assert (! (= FStar.Monotonic.RRef.ex_rid (Tm_refine_3083 FStar.HyperHeap.rid)) :named equation_FStar.Monotonic.RRef.ex_rid))
(declare-fun FStar.Monotonic.RRef.ex_rid_of_rid (Term) Term)
(declare-fun FStar.Monotonic.RRef.ex_rid_of_rid@tok () Term)
(push)
(declare-fun FStar.All.all_pre () Term)
(assert (! (HasType FStar.All.all_pre Tm_type) :named function_token_typing_FStar.All.all_pre))
(assert (! (HasType FStar.All.all_pre Tm_type) :named typing_FStar.All.all_pre))
(assert (! (= FStar.All.all_pre (Prims.all_pre_h FStar.HyperHeap.t)) :named equation_FStar.All.all_pre))
(declare-fun FStar.All.all_post (Term) Term)
(declare-fun FStar.All.all_post@tok () Term)
(assert (! (= 3085 (Term_constr_id FStar.All.all_post@tok)) :named fresh_token_FStar.All.all_post@tok))
(assert (! (forall ((@x0 Term)) (! (= (ApplyTT FStar.All.all_post@tok @x0) (FStar.All.all_post @x0)) :pattern ((ApplyTT FStar.All.all_post@tok @x0)))) :named token_correspondence_FStar.All.all_post))
(assert (! (HasType FStar.All.all_post@tok Tm_arrow_105) :named function_token_typing_FStar.All.all_post))
(assert (! (forall ((@x0 Term)) (! (implies (HasType @x0 Tm_type) (HasType (FStar.All.all_post @x0) Tm_type)) :pattern ((FStar.All.all_post @x0)))) :named typing_FStar.All.all_post))
(assert (! (forall ((@x0 Term)) (! (= (FStar.All.all_post @x0) (Prims.all_post_h FStar.HyperHeap.t @x0)) :pattern ((FStar.All.all_post @x0)))) :named equation_FStar.All.all_post))
(declare-fun FStar.All.all_wp (Term) Term)
(declare-fun FStar.All.all_wp@tok () Term)
(assert (! (= 3087 (Term_constr_id FStar.All.all_wp@tok)) :named fresh_token_FStar.All.all_wp@tok))
(assert (! (forall ((@x0 Term)) (! (= (ApplyTT FStar.All.all_wp@tok @x0) (FStar.All.all_wp @x0)) :pattern ((ApplyTT FStar.All.all_wp@tok @x0)))) :named token_correspondence_FStar.All.all_wp))
(assert (! (HasType FStar.All.all_wp@tok Tm_arrow_105) :named function_token_typing_FStar.All.all_wp))
(assert (! (forall ((@x0 Term)) (! (implies (HasType @x0 Tm_type) (HasType (FStar.All.all_wp @x0) Tm_type)) :pattern ((FStar.All.all_wp @x0)))) :named typing_FStar.All.all_wp))
(assert (! (forall ((@x0 Term)) (! (= (FStar.All.all_wp @x0) (Prims.all_wp_h FStar.HyperHeap.t @x0)) :pattern ((FStar.All.all_wp @x0)))) :named equation_FStar.All.all_wp))
(push)
(declare-fun Exp_abs_3090 (Term Term) Term)
(declare-fun Tm_arrow_3093 (Term Term) Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (HasType (Tm_arrow_3093 @x0 @x1) Tm_type) :pattern ((HasType (Tm_arrow_3093 @x0 @x1) Tm_type)))) :named kinding_Tm_arrow_3093))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_3093 @x2 @x3)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_3093 @x2 @x3))))) :named pre_typing_Tm_arrow_3093))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_3093 @x1 @x2)) (forall ((@x3 Term)) (! (implies (HasType @x3 @x2) (HasType (ApplyTT @x0 @x3) (Tm_arrow_239 @x1))) :pattern ((ApplyTT @x0 @x3))))) :pattern ((HasTypeZ @x0 (Tm_arrow_3093 @x1 @x2))))) :named interpretation_Tm_arrow_3093))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (HasType (Exp_abs_3090 @x0 @x1) (Tm_arrow_3093 FStar.HyperHeap.t @x1)) :pattern ((Exp_abs_3090 @x0 @x1)))) :named typing_Exp_abs_3090))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (Exp_abs_3090 @x1 @x2) @x0) (ApplyTT @x1 (Prims.V @x2 @x0))) :pattern ((ApplyTT (Exp_abs_3090 @x1 @x2) @x0)))) :named interpretation_Exp_abs_3090))
(push)
(assert (= MaxFuel (SFuel (SFuel ZFuel))))
(assert (= MaxIFuel (SFuel ZFuel)))
(assert (! (not (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (implies (and (HasType @x2 (FStar.All.all_post @x0)) (HasType @x1 (FStar.ST.st_wp @x0)) (HasType @x0 Tm_type)) (and (forall ((@x3 Term)) (implies (and (= @x3 (Exp_abs_3090 @x2 @x0)) (HasType @x3 (Tm_arrow_577 FStar.HyperHeap.t @x0))) (forall ((@x4 Term)) true))) (forall ((@x3 Term)) (implies (HasType @x3 @x0) (forall ((@x4 Term)) (implies (and (= @x4 @x3) (HasType @x4 @x0)) (forall ((@x5 Term)) (implies (and (HasType @x5 (Prims.result @x0)) (= @x5 (Prims.V @x0 @x3))) (forall ((@x6 Term)) (implies (and (= @x6 @x5) (HasType @x6 (Prims.result @x0))) (forall ((@x7 Term)) true))))))))))))) :named @query_3095))
(set-option :timeout 5000)
(check-sat)
(echo "Done!")
(pop)
(pop)
(declare-fun FStar.All.lift_state_all (Term Term Term) Term)
(declare-fun Tm_arrow_3097 (Term) Term)
(assert (! (forall ((@x0 Term)) (! (HasType (Tm_arrow_3097 @x0) Tm_type) :pattern ((HasType (Tm_arrow_3097 @x0) Tm_type)))) :named kinding_Tm_arrow_3097))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_3097 @x2)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_3097 @x2))))) :named pre_typing_Tm_arrow_3097))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_3097 @x1)) (forall ((@x2 Term) (@x3 Term) (@x4 Term)) (! (implies (and (HasType @x2 Tm_type) (HasType @x3 (FStar.ST.st_wp @x2)) (HasType @x4 (FStar.All.all_post @x2))) (HasType (ApplyTT (ApplyTT (ApplyTT @x0 @x2) @x3) @x4) (Prims.st_pre_h @x1))) :pattern ((ApplyTT (ApplyTT (ApplyTT @x0 @x2) @x3) @x4))))) :pattern ((HasTypeZ @x0 (Tm_arrow_3097 @x1))))) :named interpretation_Tm_arrow_3097))
(declare-fun FStar.All.lift_state_all@tok () Term)
(assert (! (= 3099 (Term_constr_id FStar.All.lift_state_all@tok)) :named fresh_token_FStar.All.lift_state_all@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT FStar.All.lift_state_all@tok @x0) @x1) @x2) (FStar.All.lift_state_all @x0 @x1 @x2)) :pattern ((ApplyTT (ApplyTT (ApplyTT FStar.All.lift_state_all@tok @x0) @x1) @x2)))) :named token_correspondence_FStar.All.lift_state_all))
(assert (! (HasType FStar.All.lift_state_all@tok (Tm_arrow_3097 FStar.HyperHeap.t)) :named function_token_typing_FStar.All.lift_state_all))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 (FStar.ST.st_wp @x0)) (HasType @x2 (FStar.All.all_post @x0))) (HasType (FStar.All.lift_state_all @x0 @x1 @x2) (Prims.st_pre_h FStar.HyperHeap.t))) :pattern ((FStar.All.lift_state_all @x0 @x1 @x2)))) :named typing_FStar.All.lift_state_all))
(declare-fun Exp_abs_3100 (Term Term) Term)
(declare-fun Tm_arrow_3103 (Term Term) Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (HasType (Tm_arrow_3103 @x0 @x1) Tm_type) :pattern ((HasType (Tm_arrow_3103 @x0 @x1) Tm_type)))) :named kinding_Tm_arrow_3103))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_3103 @x2 @x3)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_3103 @x2 @x3))))) :named pre_typing_Tm_arrow_3103))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_3103 @x1 @x2)) (forall ((@x3 Term)) (! (implies (HasType @x3 @x2) (HasType (ApplyTT @x0 @x3) (Tm_arrow_239 @x1))) :pattern ((ApplyTT @x0 @x3))))) :pattern ((HasTypeZ @x0 (Tm_arrow_3103 @x1 @x2))))) :named interpretation_Tm_arrow_3103))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (HasType (Exp_abs_3100 @x0 @x1) (Tm_arrow_3103 FStar.HyperHeap.t @x1)) :pattern ((Exp_abs_3100 @x0 @x1)))) :named typing_Exp_abs_3100))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (ApplyTT (Exp_abs_3100 @x1 @x2) @x0) (ApplyTT @x1 (Prims.V @x2 @x0))) :pattern ((ApplyTT (Exp_abs_3100 @x1 @x2) @x0)))) :named interpretation_Exp_abs_3100))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (= (FStar.All.lift_state_all @x0 @x1 @x2) (ApplyTT @x1 (Exp_abs_3100 @x2 @x0))) :pattern ((FStar.All.lift_state_all @x0 @x1 @x2)))) :named equation_FStar.All.lift_state_all))
(push)
(push)
(assert (= MaxFuel (SFuel (SFuel ZFuel))))
(assert (= MaxIFuel (SFuel ZFuel)))
(assert (! (not (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (implies (and (HasType @x3 FStar.HyperHeap.t) (HasType @x2 (FStar.All.all_post @x0)) (HasType @x1 (Prims.ex_wp @x0)) (HasType @x0 Tm_type)) (forall ((@x4 Term)) true)))) :named @query_3105))
(set-option :timeout 5000)
(check-sat)
(echo "Done!")
(pop)
(pop)
(declare-fun FStar.All.lift_exn_all (Term Term Term Term) Term)
(declare-fun Tm_arrow_3107 (Term Term) Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (HasType (Tm_arrow_3107 @x0 @x1) Tm_type) :pattern ((HasType (Tm_arrow_3107 @x0 @x1) Tm_type)))) :named kinding_Tm_arrow_3107))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_3107 @x2 @x3)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_3107 @x2 @x3))))) :named pre_typing_Tm_arrow_3107))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_3107 @x1 @x2)) (forall ((@x3 Term) (@x4 Term) (@x5 Term) (@x6 Term)) (! (implies (and (HasType @x3 Tm_type) (HasType @x4 (Prims.ex_wp @x3)) (HasType @x5 (FStar.All.all_post @x3)) (HasType @x6 @x2)) (HasType (ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x3) @x4) @x5) @x6) @x1)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT @x0 @x3) @x4) @x5) @x6))))) :pattern ((HasTypeZ @x0 (Tm_arrow_3107 @x1 @x2))))) :named interpretation_Tm_arrow_3107))
(declare-fun FStar.All.lift_exn_all@tok () Term)
(assert (! (= 3109 (Term_constr_id FStar.All.lift_exn_all@tok)) :named fresh_token_FStar.All.lift_exn_all@tok))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.All.lift_exn_all@tok @x0) @x1) @x2) @x3) (FStar.All.lift_exn_all @x0 @x1 @x2 @x3)) :pattern ((ApplyTT (ApplyTT (ApplyTT (ApplyTT FStar.All.lift_exn_all@tok @x0) @x1) @x2) @x3)))) :named token_correspondence_FStar.All.lift_exn_all))
(assert (! (HasType FStar.All.lift_exn_all@tok (Tm_arrow_3107 Prims.ex_pre FStar.HyperHeap.t)) :named function_token_typing_FStar.All.lift_exn_all))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (and (HasType @x0 Tm_type) (HasType @x1 (Prims.ex_wp @x0)) (HasType @x2 (FStar.All.all_post @x0)) (HasType @x3 FStar.HyperHeap.t)) (HasType (FStar.All.lift_exn_all @x0 @x1 @x2 @x3) Prims.ex_pre)) :pattern ((FStar.All.lift_exn_all @x0 @x1 @x2 @x3)))) :named typing_FStar.All.lift_exn_all))
(declare-fun Exp_abs_3110 (Term Term Term) Term)
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (HasType (Exp_abs_3110 @x0 @x1 @x2) (Tm_arrow_587 @x2)) :pattern ((Exp_abs_3110 @x0 @x1 @x2)))) :named typing_Exp_abs_3110))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (ApplyTT (Exp_abs_3110 @x1 @x2 @x3) @x0) (ApplyTT (ApplyTT @x2 @x0) @x1)) :pattern ((ApplyTT (Exp_abs_3110 @x1 @x2 @x3) @x0)))) :named interpretation_Exp_abs_3110))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (= (FStar.All.lift_exn_all @x0 @x1 @x2 @x3) (ApplyTT @x1 (Exp_abs_3110 @x3 @x2 @x0))) :pattern ((FStar.All.lift_exn_all @x0 @x1 @x2 @x3)))) :named equation_FStar.All.lift_exn_all))
(push)
(declare-fun Tm_arrow_3113 (Term Term) Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (HasType (Tm_arrow_3113 @x0 @x1) Tm_type) :pattern ((HasType (Tm_arrow_3113 @x0 @x1) Tm_type)))) :named kinding_Tm_arrow_3113))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_3113 @x2 @x3)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_3113 @x2 @x3))))) :named pre_typing_Tm_arrow_3113))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_3113 @x1 @x2)) (forall ((@x3 Term)) (! (implies (HasType @x3 @x2) (HasType (ApplyTT @x0 @x3) (FStar.All.all_post @x1))) :pattern ((ApplyTT @x0 @x3))))) :pattern ((HasTypeZ @x0 (Tm_arrow_3113 @x1 @x2))))) :named interpretation_Tm_arrow_3113))
(declare-fun Exp_abs_3116 (Term Term Term Term Term) Term)
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (HasType (Exp_abs_3116 @x0 @x1 @x2 @x3 @x4) (Tm_arrow_239 @x4)) :pattern ((Exp_abs_3116 @x0 @x1 @x2 @x3 @x4)))) :named typing_Exp_abs_3116))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (= (ApplyTT (Exp_abs_3116 @x1 @x2 @x3 @x4 @x5) @x0) (Prims.l_imp (ApplyTT (ApplyTT (ApplyTT @x4 @x3) @x2) @x0) (ApplyTT (ApplyTT @x1 @x2) @x0))) :pattern ((ApplyTT (Exp_abs_3116 @x1 @x2 @x3 @x4 @x5) @x0)))) :named interpretation_Exp_abs_3116))
(declare-fun Exp_abs_3119 (Term Term Term Term Term) Term)
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (HasType (Exp_abs_3119 @x0 @x1 @x2 @x3 @x4) (Tm_arrow_587 @x4)) :pattern ((Exp_abs_3119 @x0 @x1 @x2 @x3 @x4)))) :named typing_Exp_abs_3119))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (= (ApplyTT (Exp_abs_3119 @x1 @x2 @x3 @x4 @x5) @x0) (Prims.l_Forall @x4 (Exp_abs_3116 @x3 @x0 @x2 @x1 @x4))) :pattern ((ApplyTT (Exp_abs_3119 @x1 @x2 @x3 @x4 @x5) @x0)))) :named interpretation_Exp_abs_3119))
(declare-fun Exp_abs_3122 (Term Term Term Term) Term)
(declare-fun Tm_arrow_3124 (Term Term) Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (HasType (Tm_arrow_3124 @x0 @x1) Tm_type) :pattern ((HasType (Tm_arrow_3124 @x0 @x1) Tm_type)))) :named kinding_Tm_arrow_3124))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_3124 @x2 @x3)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_3124 @x2 @x3))))) :named pre_typing_Tm_arrow_3124))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_3124 @x1 @x2)) (forall ((@x3 Term) (@x4 Term)) (! (implies (and (HasType @x3 (FStar.All.all_post @x2)) (HasType @x4 @x1)) (HasType (ApplyTT (ApplyTT @x0 @x3) @x4) Tm_type)) :pattern ((ApplyTT (ApplyTT @x0 @x3) @x4))))) :pattern ((HasTypeZ @x0 (Tm_arrow_3124 @x1 @x2))))) :named interpretation_Tm_arrow_3124))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term)) (! (HasType (Exp_abs_3122 @x0 @x1 @x2 @x3) (Tm_arrow_3124 @x2 @x3)) :pattern ((Exp_abs_3122 @x0 @x1 @x2 @x3)))) :named typing_Exp_abs_3122))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term) (@x5 Term)) (! (= (ApplyTT (ApplyTT (Exp_abs_3122 @x2 @x3 @x4 @x5) @x0) @x1) (Prims.l_and (ApplyTT @x3 @x1) (Prims.l_Forall (Prims.result @x5) (Exp_abs_3119 @x2 @x1 @x0 @x4 @x5)))) :pattern ((ApplyTT (ApplyTT (Exp_abs_3122 @x2 @x3 @x4 @x5) @x0) @x1)))) :named interpretation_Exp_abs_3122))
(push)
(assert (= MaxFuel (SFuel (SFuel ZFuel))))
(assert (= MaxIFuel (SFuel ZFuel)))
(assert (! (not (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (implies (and (HasType @x2 (Tm_arrow_3113 @x0 FStar.HyperHeap.t)) (HasType @x1 FStar.All.all_pre) (HasType @x0 Tm_type)) (and (forall ((@x3 Term)) (implies (and (= @x3 (Exp_abs_3122 @x2 @x1 FStar.HyperHeap.t @x0)) (HasType @x3 (Tm_arrow_605 @x0 FStar.HyperHeap.t))) (forall ((@x4 Term)) true))) (forall ((@x3 Term) (@x4 Term)) (implies (and (HasType @x4 FStar.HyperHeap.t) (HasType @x3 (FStar.All.all_post @x0))) (and (forall ((@x5 Term)) true) (implies (Valid (ApplyTT @x1 @x4)) (and (forall ((@x5 Term)) (implies (and (= @x5 (Exp_abs_3119 @x2 @x4 @x3 FStar.HyperHeap.t @x0)) (HasType @x5 (Tm_arrow_587 @x0))) (forall ((@x6 Term)) true))) (forall ((@x5 Term)) (implies (HasType @x5 (Prims.result @x0)) (and (forall ((@x6 Term)) (implies (and (= @x6 (Exp_abs_3116 @x3 @x5 @x4 @x2 FStar.HyperHeap.t)) (HasType @x6 (Tm_arrow_239 FStar.HyperHeap.t))) (forall ((@x7 Term)) true))) (forall ((@x6 Term)) (implies (HasType @x6 FStar.HyperHeap.t) (and (forall ((@x7 Term)) true) (forall ((@x7 Term)) (implies (and (= @x7 @x5) (HasType @x7 (Prims.result @x0))) (forall ((@x8 Term)) (implies (and (= @x8 @x6) (HasType @x8 FStar.HyperHeap.t)) (forall ((@x9 Term)) true)))))))))))))))))))) :named @query_3126))
(set-option :timeout 5000)
(check-sat)
(echo "Done!")
(pop)
(pop)
(declare-fun FStar.All.pipe_right (Term Term Term Term) Term)
(declare-fun FStar.All.pipe_right@tok () Term)
(declare-fun FStar.All.pipe_left (Term Term Term Term) Term)
(declare-fun FStar.All.pipe_left@tok () Term)
(push)
(declare-fun Tm_arrow_3128 (Term Term) Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (HasType (Tm_arrow_3128 @x0 @x1) Tm_type) :pattern ((HasType (Tm_arrow_3128 @x0 @x1) Tm_type)))) :named kinding_Tm_arrow_3128))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_3128 @x2 @x3)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_3128 @x2 @x3))))) :named pre_typing_Tm_arrow_3128))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_3128 @x1 @x2)) (forall ((@x3 Term)) (! (implies (HasType @x3 @x2) (HasType (ApplyTT @x0 @x3) (FStar.All.all_post @x1))) :pattern ((ApplyTT @x0 @x3))))) :pattern ((HasTypeZ @x0 (Tm_arrow_3128 @x1 @x2))))) :named interpretation_Tm_arrow_3128))
(declare-fun Exp_abs_3130 (Term Term) Term)
(declare-fun Tm_arrow_3132 (Term Term) Term)
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (HasType (Tm_arrow_3132 @x0 @x1) Tm_type) :pattern ((HasType (Tm_arrow_3132 @x0 @x1) Tm_type)))) :named kinding_Tm_arrow_3132))
(assert (! (forall ((@u0 Fuel) (@x1 Term) (@x2 Term) (@x3 Term)) (! (implies (HasTypeFuel @u0 @x1 (Tm_arrow_3132 @x2 @x3)) (is-Tm_arrow (PreType @x1))) :pattern ((HasTypeFuel @u0 @x1 (Tm_arrow_3132 @x2 @x3))))) :named pre_typing_Tm_arrow_3132))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term)) (! (iff (HasTypeZ @x0 (Tm_arrow_3132 @x1 @x2)) (forall ((@x3 Term) (@x4 Term) (@x5 Term)) (! (implies (and (HasType @x3 @x2) (HasType @x4 (Prims.result @x1)) (HasType @x5 @x2)) (HasType (ApplyTT (ApplyTT (ApplyTT @x0 @x3) @x4) @x5) Tm_type)) :pattern ((ApplyTT (ApplyTT (ApplyTT @x0 @x3) @x4) @x5))))) :pattern ((HasTypeZ @x0 (Tm_arrow_3132 @x1 @x2))))) :named interpretation_Tm_arrow_3132))
(assert (! (forall ((@x0 Term) (@x1 Term)) (! (HasType (Exp_abs_3130 @x0 @x1) (Tm_arrow_3132 @x0 @x1)) :pattern ((Exp_abs_3130 @x0 @x1)))) :named typing_Exp_abs_3130))
(assert (! (forall ((@x0 Term) (@x1 Term) (@x2 Term) (@x3 Term) (@x4 Term)) (! (= (ApplyTT (ApplyTT (ApplyTT (Exp_abs_3130 @x3 @x4) @x0) @x1) @x2) (Prims.l_and (Prims.b2t (Prims.is_Err @x3 @x1)) (Prims.eq2 @x4 @x0 @x2))) :pattern ((ApplyTT (ApplyTT (ApplyTT (Exp_abs_3130 @x3 @x4) @x0) @x1) @x2)))) :named interpretation_Exp_abs_3130))
(push)
(assert (= MaxFuel (SFuel (SFuel ZFuel))))
(assert (= MaxIFuel (SFuel ZFuel)))
(assert (! (not (forall ((@x0 Term)) (implies (HasType @x0 Tm_type) (and (forall ((@x1 Term)) (implies (and (= @x1 (Exp_abs_3130 @x0 FStar.HyperHeap.t)) (HasType @x1 (Tm_arrow_3128 @x0 FStar.HyperHeap.t))) (forall ((@x2 Term)) true))) (forall ((@x1 Term) (@x2 Term) (@x3 Term)) (implies (and (HasType @x3 FStar.HyperHeap.t) (HasType @x2 (Prims.result @x0)) (HasType @x1 FStar.HyperHeap.t)) (and (forall ((@x4 Term)) true) (implies (BoxBool_proj_0 (Prims.is_Err @x0 @x2)) (forall ((@x4 Term)) (implies (and (= @x4 @x1) (HasType @x4 FStar.HyperHeap.t)) (forall ((@x5 Term)) (implies (and (= @x5 @x3) (HasType @x5 FStar.HyperHeap.t)) (forall ((@x6 Term)) true))))))))))))) :named @query_3134))
(set-option :timeout 5000)
(check-sat)
(echo "Done!")
(pop)
